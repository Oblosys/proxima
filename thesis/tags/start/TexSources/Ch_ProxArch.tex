\chapter{Architecture of the Proxima Editor}
\label{chap:proxArch}

%\fromHere  % VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
%\toHere     % ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

% Multiple presentations? Will this be hard to implement?

% ref to reqs and how the architecture helps?

% Partial? is that really when high -> low + extra???
% Partial: compare with window that shows only part of the source?

% UNCLEAR:
% Insert of new tokens is tricky: 
% if preceding ws is stored, insert type decl before needs copy of ws from 1st decl token
% if following ws is stored, then insert after is tricky.

% \par in figures?

% SOMEWHERE: presentation may support duplicates in future, otherwise tree views need enriched 
% document structures.

%TODO: mention that font query in arranger is also ui dependent.

%TODO: find out where edit gesture/operation should be mentioned

%plaatje Proxima + style (parsing) sheet + computation (reduction) sheet -> editor


* mention Bootstrapping problem, descr. of levels layers and edit model. second is easier to give with in a formal story. however, design reasons for first are hard to comprehend without idea. So first informal arch and edit model and later the formal stuff

{\em *** Version: \today~***}


A generic editor is a large system with an architecture that consists of many components for performing many different tasks. However, in this chapter, we focus on those components of the architecture that are involved in the process of presenting the internal document to the user, and translating the edit gestures given by the user to edit operations on the document structure. Of course, other functionality, such as IO handling, macro processing, or a search facility is very important for the usability of the final editor, but its implementation is mainly straightforward and merely requires a substantial amount of engineering. \note{maybe a bit too strong?} The presentation and handling of edit gestures, on the other hand, is of greater importance, because it determines for which applications the editor can be used, and how powerful the editing behavior will be.

The core components of the Proxima architecture are a number of layers that only communicate with their direct neighbors. The layered structure is based on the staged nature of the presentation process. Instead of mapping it directly onto its rendering, a document is first mapped onto an intermediate data structure. The intermediate data structure is mapped onto another intermediate data structure, until a final intermediate data structure is mapped onto the rendering. The intermediate data structures are the data {\em levels}, and the components that take care of the mapping are the {\em layers}.  Figure~\ref{proxlayers} schematically shows the levels and layers of Proxima. Only two levels are visible at each layer: an upper and a lower level.

\begin{figure}
\begin{small}
\begin{center}
\par                 %??? why a \par?
\begin{small}
\begin{tabular}{c}
{Document}\vspace{1ex}\\
\framebox[5cm][c]{Evaluation layer}\vspace{1ex}\\
{Enriched document}\vspace{1ex}\\
\framebox[5cm][c]{Presentation layer}\vspace{1ex}\\
{Abstract presentation}\vspace{1ex}\\
\framebox[5cm][c]{Arrangement layer}\vspace{1ex}\\
{Arrangement}\vspace{1ex}\\
\framebox[5cm][c]{Rendering layer}\vspace{1ex}\\
{Rendering}
\end{tabular}
\end{small}\caption{ The levels and layers of Proxima (draft)}\label{proxlayers} 
\end{center}
\end{small}
\end{figure}

%sheets?

There are a number of reasons why the Proxima architecture is layered:

\begin{description}

\item[Staged presentation process.]
The presentation process is naturally staged. The process consists of repeatedly mapping  structures that have a different meaning on a higher level onto the same set of lower level structures. For example, a table of contents, once its structure has been computed, can be presented in the same way as a chapter structure. Similarly, a line that comes from a formatted paragraph is rendered in the same way as a line that was explicitly specified in the presentation. Mappings like these form stages in the presentation process that can be performed by separate layers.

\item[Specification of presentation and edit behavior.]
A layered architecture provides natural hooks for the editor designer to specify presentation and edit behavior. A separate evaluation layer, for example, makes it possible to separate computation and presentation, thus allowing different style sheets to be used for a document together with its derived structures. At the same time, layers offer more control over backward mappings, for example specifications of how edit operations in derived structures should be translated to edit operations on the document.

\item[Local state.] \note{maybe this name is not right: "Extra state"?}
An important aspect of the Proxima editor is the concept of local state, which is inherently connected to a layered architecture. Each level in the presentation process may contain information that is not present in the surrounding upper or lower levels. Applications of local state include keeping track of the focus and storing whitespace for tokens. 

\item[Keeping bidirectional mappings.]
Because Proxima supports editing on all levels, a mapping between each pair of levels needs to be maintained. Maintaining such mappings is easier in a layered architecture. Furthermore, the lower layers can maintain the mappings automatically.

\item[Efficiency.]
Some steps in the presentation process, especially in the higher layers, may be time consuming because global computations need to be performed. In a layered architecture, it is possible to perform the higher layer computations not at every keystroke, but only once in a while. For example, in a program editor, parsing the program may be delayed until the user enters a whitespace character or performs a navigation operation. Type checking the program may be delayed until after a certain period of inactivity, or when specifically requested by the user.
\end{description}

The remainder of this chapter contains an informal description of the levels and layers in the Proxima architecture. A formal description is presented in Chapter~\ref{chap:layeredArchs}.

\section{The levels of Proxima}

A data level in Proxima is not just an intermediate value in the presentation computation, but an entity in its own right. Together, the data levels constitute the state of the editor. The six data levels of Proxima are:

\begin{description}
\item[Document:] The edited document, the type of which is described by a DTD or an EBNF grammar.

\item[Enriched Document:] The document enriched with computed information.

\item[Presentation:] A logical description of the presentation of the document, consisting of rows and columns of presentation elements with attributes. The presentation also supports elements to be specified to be formatted based on the available space (line breaking).

\item[Layout:]  Similar to the presentation, but with explicit whitespace.

\item[Arrangement:] Similar to the layout, but with absolute size and position information. At this level, line breaking have been performed.

\item[Rendering:] A collection of user interface commmands for drawing the absolutely positioned and sized arrangement.
\end{description}

\subsection{Document} \label {sect:docLevel}

A document is the internal tree data structure that is edited by the user. The type of the document is described by a context free grammar, with special constructs for lists and optional values (similar to EBNF). Haskell data types, EBNF, DTDs and XML Schemas are all restricted forms of context free grammars suitable for describing the document type. In this thesis, we make use of simple Haskell data types without higher-order types, except for the list and the maybe type.

The exact type formalism is important for document to document transformations (ie. document edit operations), because it should be possible to guarantee type safety of such transformations. However, for the time being, the only supported document edit operations are simple tree based operations, such as cut and paste, and basic operations on lists and optionals, such as selecting a segment of a list. Therefore, using a context free grammar formalism for describing document structure is powerful enough.
 
Because the type of the document will vary for different applications of the editor, we can only give an example for a specific application. The example document consists of a list of declarations, each of which is an identifier declaration or a comment. An identifier declaration contains a string that represents the declared identifier, as well as an expression that may contain conditional expressions, integers, and booleans. The third field of the declaration is a string that may contain additional information about the declaration. It is used to illustrate the local state concept in the Proxima editor. A comment consists of a list of strings. The types {\tt String}, {\tt Int}, and {\tt Bool} are primitive types. Although not very suitable for practical purposes, the chosen document type will allow us to illustrate the different aspects of the Proxima data levels and layers.

\noindent
\ttfamily
\begin{tabbing}
data Document = Root$_{Doc}$ [Decl$_{Doc}$]\\
data Decl$_{Doc}$ \= = Decl$_{Doc}$ String Exp$_{Doc}$ String\\
                            \> | Comment$_{Doc}$ [String]\\
data Exp$_{Doc}$ \= =  IfExp $_{Doc}$ Exp$_{Doc}$ Exp$_{Doc}$ Exp$_{Doc}$\\
                 \> | IntExp$_{Doc}$ Int\\
                 \> | BoolExp$_{Doc}$ Bool\\
\end{tabbing}
\rmfamily

An example document of this type, as well as examples of the lower levels, is provided with the explanation of the presentation process in Section~\ref{sect:presprocess}.

\subsection{Enriched Document} \label{sect:enrLevel}

An enriched document is a copy of the document, to which derived information has been added. In the word processor example, the enriched document contains a table of contents, and each section or subsection element has a field that contains its number. Such derived information is not present in the document level.

Besides containing extra information, the enriched document, or a subtree of it, may also be a reordered version of the document. For example, the enriched document may contain a sorted list of values, which is not sorted in the document.

As an example of an enriched document, we take the sample document of the previous section and a type declaration alternative to the $Decl$ type. The type declaration is computed for each declaration. The type of an expression may be integer, boolean, or erroneous (eg. {\tt if True then 0 else False}). It is also possible to add the type as a field to the $Decl$ alternative, however, separate type declarations make it easier to show how edit operations on the enriched document are handled in Section~\ref{sect:reducer}.

\noindent
\ttfamily
\begin{tabbing}
data EnrichedDocument = Root$_{Enr}$ [Decl$_{Enr}$]\\
data Decl$_{Enr}$ \= = TypeDecl$_{Enr}$ String Type$_{Enr}$\\
                           \> | Decl$_{Enr}$ String Exp$_{Enr}$ String\\
                           \> | Comment$_{Enr}$ [String]\\
data Exp$_{Enr}$ \= =  IfExp $_{Enr}$ Exp$_{Enr}$ Exp$_{Enr}$ Exp$_{Enr}$\\
                 \> | IntExp$_{Enr}$ Int\\
                 \> | BoolExp$_{Enr}$ Bool\\
\\
data Type$_{Enr}$ = IntType$_{Enr}$ | BoolType$_{Enr}$ | ErrorType$_{Enr}$
\end{tabbing}
\rmfamily

\subsection{Presentation} \label{sect:presLevel}

%what is presentation
A presentation is an abstract description of what the document will look like to the user. It consists of strings, images, and simple graphical elements (lines, rectangles, etc.) that are grouped in rows, columns and matrices. Elements have attributes for colors, line styles, fonts, and alignment. Attribution can be influenced using a {\em with} element, which contains a rule that specifies how the attribution is affected.

There are three ways of positioning elements in the presentation. Firstly, the position can be specified relative to other elements in the presentation, by placing a list of elements next to each other in a {\em row}, or above each other in a {\em column}. Elements are aligned according to reference lines (eg. the baseline for a string), and stretchable elements may be used to influence the positioning. Besides rows and columns, a {\em matrix} construct presents a list of lists of elements aligned both horizontally as well as vertically, and an {\em overlay} presents a list of elements in front of each other (eg. for presenting a squiggly \makebox(0,0)[lt]{\epsfig{file=Pics/squiggly.bmp.eps, width=0.042in}\epsfig{file=Pics/squiggly.bmp.eps, width=0.042in}\epsfig{file=Pics/squiggly.bmp.eps, width=0.042in}\epsfig{file=Pics/squiggly.bmp.eps, width=0.042in}\epsfig{file=Pics/squiggly.bmp.eps, width=0.042in}}line). 
%mention that alignment is modified easily?

The second way of positioning presentation elements is by using a {\em formatter} element, that positions a list of children based on the available space. Currently, Proxima only supports horizontal formatting, suitable for line breaking in a paragraph. Vertical formatting is not fundamentaly different, but has not been implemented yet. Furthermore, support for a page model also requires extensions to the lower levels, which have not been realized yet.

Finally, a presentation can consist of a list of tokens, which may be identifiers, operators, integers, strings, etc. If textual editing on a presentation is desired (eg. for a source editor), a parser is invoked on the presentation after it has been edited. A presentation that needs to be parsed may be specified using tokens, which make it possible to use a separate layer for scanning. A token contains information about the whitespace (line breaks and spaces) preceding it in the presentation. In some cases, a presentation may need to be parsed without using the Proxima scanner. For example, when explicit whitespace information is stored in the document. In that case, dummy tokens that are not processed by the scanner may be used for the presentation.

In some cases, a presentation that needs to be parsed contains parts that we do not want to be parsed. For example, non-textual presentations, such as images. Such presentations can be included in the token list presentation with a {\em structural token}. A structural token contains a presentation, and is treated specially by the parser. Although the child presentation is not parsed, it may be an arbitrary presentation, and hence contain a token list presentation itself, that will be parsed.

Unlike the document and the enriched document, the presentation has a fixed type. It is discussed in more detail in Chapter~\ref{chap:xprez}. Here, we present a slightly simplified subset of the type. The details regarding the attribution (eg. color, font, and reference lines) of presentation elements have been left out, by leaving the type \verb|AttributionRule| abstract. 

\noindent
\ttfamily
\begin{tabbing}
data Presentation \= = Empty$_{Pres}$\\
                  \> | String$_{Pres}$ String \\
                  \> | Tokens$_{Pres}$ [Token]\\
                  \> | Row$_{Pres}$ [Presentation]\\
                  \> | Column$_{Pres}$ [Presentation]\\
                  \> | Overlay$_{Pres}$ [Presentation]\\
                  \> | Matrix$_{Pres}$ [Presentation]\\
                  \> | Formatter$_{Pres}$ [Presentation]\\
                  \> | With$_{Pres}$ AttributionRule Presentation\\
\\
data Token \= = UCaseToken Whitespace String\\
           \> | LCaseToken Whitespace String\\
           \> | IdentToken Whitespace String\\
           \> | OpToken Whitespace String\\
           \> | IntToken Whitespace Int\\
           \> | StructuralToken Whitespace Presentation\\
           \> \dots \\
\\
type Whitespace = (LineBreaks, Spaces)\\
type LineBreaks = Int\\
type Spaces = Int\\
\\
data AttributionRule = \dots\\
\end{tabbing}
\rmfamily
\note{refnr in row/col?} \note{Hoe doen we tokens?} \note{verschillende types Token vs Presentation?}
\note{mention Structural tokens?}

\subsection{Layout}

The layout level is the same as the presentation level, but without the tokens. Whitespace information from the tokens is represented in the layout level by strings containing spaces and by starting a new row for each line break. Formatters are still present, because the exact size and position information required to remove them is not known at the layout level.

The similarity between the layout and the presentation level is clearly visible in the types: the {\tt Layout} type is the {\tt Presentation} type without the {\tt Tokens} alternative.

\noindent
\ttfamily
\begin{tabbing}
data Layout \= = Empty$_{Lay}$\\
            \> | String$_{Lay}$ String \\
            \> | Row$_{Lay}$ [Layout]\\
            \> | Column$_{Lay}$ [Layout]\\
            \> | Overlay$_{Lay}$ [Layout]\\
            \> | Matrix$_{Lay}$ [Layout]\\
            \> | Formatter$_{Lay}$ [Layout]\\
            \> | With$_{Lay}$ AttributionRule Layout\\
\\
data AttributionRule = \dots\\
\end{tabbing}
\rmfamily

\subsection{Arrangement}

%what is arrangement  : fixed position + size. also formatters are replaced by columns of rows
At the arrangement level, each element gets its position and size. The position is expressed in actual coordinates. These may be different from the pixel coordinates in the final rendering because the rendering may be scaled. Formatters have been resolved at this point, and are represented by columns of rows.

% A page model is not yet part of the arrangement.

% why a tree
The arrangement is structured as a tree and positions are relative to the parent element. Relative positioning makes it easier to reposition a subtree in the arrangement, because it removes the need to update the position of each element in the moved subtree.

A with node does not have a geometry field, because it only influences the attribution of the tree, but does not form an actual part of the arrangement. 
% debugging?
\note{geometry for Empty?} 
\ttfamily
\begin{tabbing}
*** two options: position in  each child, or positions in parent ***\\
\\
data Arrangement \= = Empty$_{Arr}$ Geometry\\
                 \> | String$_{Arr}$ Geometry String\\
                 \> | Row$_{Arr}$ Geometry [Arrangement]\\
                 \> | Column$_{Arr}$ Geometry [Arrangement]\\
                 \> | Overlay$_{Arr}$ Geometry [Arrangement]\\
                 \> | Matrix$_{Arr}$ Geometry [Arrangement]\\
                 \> | With$_{Arr}$ AttributionRule Arrangement\\
\\
type Geometry = (Position, Size)\\
data AttributionRule = \dots\\
\\
*** of ***\\
\\
data Arrangement \= = Empty$_{Arr}$\\
                 \> | String$_{Arr}$ Size String\\
                 \> | Row$_{Arr}$ Size [Arrangement] [Position]\\
                 \> | Column$_{Arr}$ Size [Arrangement] [Position]\\
                 \> | Overlay$_{Arr}$ Size [Arrangement] [Position]\\
                 \> | Matrix$_{Arr}$ Size [Arrangement] [Position]\\
                 \> | With$_{Arr}$ AttributionRule Arrangement\\
\\
type Position \= = (Int, Int)\\
type Size      \> = (Int, Int)\\
data AttributionRule = \dots\\
\end{tabbing}
\rmfamily

\note {have to make a choice: 2nd one makes moving arrs in a compound arr easier, good for incrementality, but has not been implemented/tested}

\subsection{Rendering}

A rendering is a set of user interface drawing commands that are actually drawn on the screen. Positions are expressed in pixel coordinates. In contrast to the other levels, a rendering has no explicit tree structure. \note{maybe it should be a tree though}

Because the rendering is highly dependent on the GUI library that is used, we only give an abstract type.
\note{Haskell syntax? (type vs. data)}

\noindent
\ttfamily
\begin{tabbing}
type Rendering = [RenderingCommand]\\
data RenderingCommand = \dots
\end{tabbing}
\rmfamily

\section{The layers of Proxima}

Between each pair of data levels is a {\em layer} that takes care of mapping the upper level onto the lower level (downward mapping, or presentation) and that translates edit operations on the lower level to edit operations on the upper level (upward mapping, or translation). 

In the actual architecture, the downward mapping is not a mapping between the upper and lower levels, but between edit operations on the levels, similar to the upward mapping. Hence, the upward and the downward mappings are symmetrical, as both are concerned with edit operations. The layer has access to the upper and lower levels surrounding it, and may update the upper level.  The exact types of the mappings in a layer are presented in Chapter~\ref{chap:layeredArchs}. Figure~\ref{singleLayer} contains a more detailed picture of a single layer. The update on the higher level is denoted with the $\leadsto$ symbol.

\note{Mention where update takes place?}

\begin{figure}
\begin{small}
\begin{center}
\par
\begin{small}
\begin{tabular}{ccc}
$\delta_{High}$ & $\leadsto$ \hspace{3.5em} upper level \hspace{5em} & $\delta_{High}$\\
$\downarrow$ & $\downarrow ~~~~~ \downarrow$ & $\uparrow$ \\
\multicolumn{3}{c}{ \framebox[7cm][c]{presentation component / ~~translation component}\vspace{1ex}}\\
$\downarrow$ & $\uparrow ~~~~~ \uparrow$ & $\uparrow$\\
$\delta_{Low}$ & {lower level} & $\delta_{Low}$
\end{tabular}
\end{small}\caption{ A single proxima layer}\label{singleLayer} 
\end{center}
\end{small}
\end{figure}

%Three kinds of arrows are visible in the picture: downward, upward, and horizontal arrows pointing to the %right. The downward arrows represent the presentation process and the upward arrows represent the %translation of edit operations. The horizontal arrows  and the horizontal arrows 


 
%A mapping between edit operations is at least as expressive as a mapping between values, because any %mapping on values can be represented by a mapping 
%$f :: Data_{High} \rightarrow Data_{Low}$ can be expressed as a mapping on edit operations
%$f' ::  \delta_{Data_{High}} \rightarrow \delta_{Data_{Low}}$ with $f' edit_{High} = set (f %(edit_{High}high))$



%thing is parameterized!!!
A layer has two separate components, one for the downward mapping (presentation) and one for the upward mapping (translation). Because each layer is between two levels and the Proxima system consists of six data levels, there are five layers:

\begin{itemize}
\item Evaluation layer: Evaluator/Reducer
%The evaluator computes all derived values and structures, and may reorder parts of the document. Its %counterpart, the reducer, maps edit operations on derived structures onto edit operations on the %document.

\item Presentation layer: Presenter/Parser
%The presenter computes the presentation of the enriched document. The parser A logical description of the %presentation of the document, consisting of rows and columns of attributed presentation elements. %\note{mention formatters here?}
\item Layout layer: Layouter/Scanner
%The layouter adds explicit whitespace to tokens in the presentation, whereas the scanner removes the %whitespace and recognizes tokens.
\item Arrangement layer: Arranger/Unarranger
\item Rendering layer: Renderer/Gesture Interpreter
\end{itemize}

The downward mappings together form a logical whole (the presentation process), just like the upward mappings (the translation process). Therefore, rather than discussing the components pairwise from layer to layer, we give a description of all the components involved in the presentation process, followed by the components of the translation process.

\section{Presentation Process}
\label{sect:presprocess}
The presentation process is the stepwise mapping of a document onto its final rendering. Although the mapping is actually a mapping between edit operations on each of the levels, we will present it here as a mapping between edit levels. The reason for this is that the fact that the mapping is on edit operations rather than on levels is important mainly for reasons of incrementality, and regarding it as a mapping on levels makes the presentation process easier to explain.

In order to illustrate the different stages in the presentation process, we follow the presentation of an simple document. After the description of each layer component, the intermediate result of the presentation of the document is given.

The document type of the example is the expression list document type from Section~\ref{sect:docLevel}. The sample document consists of two items: a comment and an expression. For sake of clarity, we will denote strings on each level with {\tt "\dots"} instead of {\tt String$_{level}$ "\dots"}. 

Document:
\small \ttfamily
\begin{tabbing}
Root$_{Doc}$ \= [ Comment$_{Doc}$ ["This", "is", "a", "simple", "expression"] \\
       \> , Decl$_{Doc}$ \= "simple1" \\
       \>                        \>(IfExp$_{Doc}$ (BoolExp$_{Doc}$ True) (IntExp$_{Doc}$ 1) (IntExp$_{Doc}$ 0))\\
       \>                        \> "info"\\
       \> ] 
\end{tabbing}
\rmfamily \normalsize

\subsection{Evaluation layer: Evaluator} \label{sect:evaluator}

%what is evaluator
The first step in the presentation process is the computation of the derived information in the document. The component that takes care of this is the evaluator. The evaluator is parameterized with a {\em computation sheet}, which is a declarative specification of the derived values. The computation sheet is specified using the attribute grammar formalism.

Besides basic values, such as section numbers or the outcome of a computation in a spread sheet, the evaluator may also derive tree structures, such as a table of contents. The derived structures may be partial, duplicated, or reordered versions of the document. \note{probably more is possible}

%.computing values, type errors , page numbers, table of contents
\bigskip {\bf Example:} For each declaration, the evaluator computes a type declaration in the enriched document. In the example this means that a type declaration for \verb|"simple1"| with type {\tt IntType} is included in the item list, yielding:

Enriched document:
\small \ttfamily
\begin{tabbing}
Root$_{Enr}$ \= [ Comment$_{Enr}$ [ "This", "is", "a", "simple", "expression" ]\\
       \> , TypeDecl$_{Enr}$ "simple1" IntType$_{Enr}$\\
       \> , Decl$_{Enr}$ \= "simple1"\\
       \>                       \> (IfExp$_{Enr}$ (BoolExp$_{Enr}$ True) (IntExp$_{Enr}$ 1) (IntExp$_{Enr}$ 0)) \\
       \>                        \> "info"\\
       \> ] 
\end{tabbing}
\rmfamily \normalsize

\subsection{Presentation layer: Presenter} \label{sect:presenter}

%what is presenter
The enriched document is mapped onto the presentation by the presenter. Similar to the evaluator, the presenter is parameterized with a {\em presentation sheet} that specifies the presentation. The presentation sheet is an attribute grammar that defines the presentation as a synthesized attribute for each element in the enriched document.

Tokens form a special case in the presentation process, because a token contains its own whitespace, which is not represented in the document or enriched document levels. Therefore, the presenter keeps track of which tokens the enriched document is mapped onto. If a enriched document structure is re-presented, the old tokens (and corresponding white\-space) are reused. 

If an enriched document element that is presented with tokens, is newly created or has not been presented before, a default value for the whitespace of its tokens is chosen. This default may come from a pretty print algorithm. A default value may be used also in case a structure has been edited in such a way that reusing the old tokens does not make sense.

The mechanism of reusing presentation tokens is also used to handle ambiguities in token representations. For example when a user has entered the text "001" which is stored in the document as the integer 1, the mapping between the enriched document and the presentation ensures that on re-presentation, the integer is presented as "001" instead of "1"

% strongly related to evaluator
The evaluator and the presenter both make use of the attribute grammar formalism and are closely related. The separation between evaluating and presenting is not strict. On the one hand, the entire presentation can be regarded as a derived structure, and on the other hand the presentation sheet can reorder elements in the presentation and introduce structures, which is more appropropriately done in the evaluation sheet. 

The editor designer must make a careful decision on where to specify document evaluation and presentation. Whenever it is conceivable that a derived structure may have different presentation styles, the computation of the structure and presenting it is best separated. A good example of such a structure is a table of contents, whose presentation must match the presentation of the document. Another case in which separation is beneficial is when edit operations on the derived structure have to be supported, as the separation makes it easier to specify the translation of the edit operations. \note{bad paragraph}

\bigskip {\bf Example:} The example presentation of the enriched document is basic: a comment is put in a formatted paragraph and a (type) declaration is presented in a textual infix representation using tokens. The third string field of the declaration \verb|"info"| is not included in the presentation in order to have an example of a partially presented structure. The reason for this becomes apparent in Section~\ref{sect:parser} on parsing. The pair of numbers in each token represents the whitespace ({\em nr. of line breaks}, {\em nr. of spaces}) preceding it. 

The \verb|With| nodes specify the font for the presentation of the declarations. For sake of simplicity, the exact details of the attribution rule are not shown: the bracketed declaration \verb|{fontFamily = "|{\em name}\verb|", fontSize = |{\em size}\verb|}| specifies the font family and size for the child of the with node. \note{need an end token} \note{mention that this is a simple whitespace repr. that does not allow lines containing only spaces?}

Presentation:
\small \ttfamily
\begin{tabbing}
Col$_{Pres}$ \= [ With$_{Pres}$ \{ fontFamily = "Times New Roman", fontSize = 12 \}\\
       \>  ~~~ (Formatter$_{Pres}$ [ "This", "is", "a", "simple", "expression" ])\\
       \>, With$_{Pres}$ \{ fontFamily = "Courier New", fontSize = 12 \}\\
       \>  ~~~ \= (Tokens$_{Pres}$ \= [ LCaseToken$_{Pres}$ (1,0) "simple1",  OpToken$_{Pres}$ (0,1) "::"\\  
       \>          \>              \> , UCaseToken$_{Pres}$ (0,1) "Int"\\
       \>          \>              \> ])\\
       \>, With$_{Pres}$ \{ fontFamily = "Courier New,  fontSize = 12 \}\\
       \>  ~~~ \= (Tokens$_{Pres}$ \= [ LCaseToken$_{Pres}$ (1,0) "simple1", OpToken$_{Pres}$ (0,1) "="\\
       \>          \>              \> , LCaseToken$_{Pres}$ (1,2) "if", UCaseToken$_{Pres}$ (0,1) "True"\\
       \>          \>              \> , LCaseToken$_{Pres}$ (0,1) "then", IntToken$_{Pres}$ (0,1) "1"\\
       \>          \>              \> , LowercaseToken$_{Pres}$ (1,10) "else", IntToken$_{Pres}$ (0,1) "0"\\
       \>          \>              \> ])\\
             \> ]
\end{tabbing}
\rmfamily \normalsize


\subsection{Layout layer: Layouter (better name?)} \label{sect:layouter}

%what is layouter
The layouter removes the tokens in the presentation level, yielding the layout level. Each list of tokens is mapped on a column that contains rows of strings. Each token is represented as a string \note{Structural tokens are not strings} and spaces are represented as strings of spaces. A line break causes a new row in the layout. \note{mention a layout sheet?}

%The layout layer may be parameterized with a layout sheet, in whi
%
%Layout sheet (how to display tokens, or tokens with parse errors)

%what does it do


\bigskip {\bf Example:} The tokens that are present in the presentation level are replaced by strings in the layout level (the \textvisiblespace~character denotes a space). The formatter is not affected. The line break before the type declaration is represented by an empty string. 

Layout:
\small \ttfamily
\begin{tabbing}
Col$_{Lay}$ \= [  With$_{Lay}$ \{ fontFamily = "Times New Roman", fontSize = 12 \}\\
                    \>  ~~~ Formatter$_{Lay}$ [ "This", "is", "a", "simple", "expression" ]\\
                    \> , With$_{Lay}$ \{ fontFamily = "Courier New,  fontSize = 12 \}\\
                    \>  ~~~ \= (Col$_{Lay}$ \= [ "" \\
                    \>          \>        \> , Row$_{Lay}$ [ "simple1", "\textvisiblespace", "::",
                                                                              "\textvisiblespace", "Int" ]\\
                    \>          \>        \> ])\\
                    \> , With$_{Lay}$ \{ fontFamily = "Courier New,  fontSize = 12 \}\\
                    \>  ~~~ \= (Col$_{Lay}$ \= [ Row$_{Lay}$ [ "simple1", "\textvisiblespace", "=" ]\\
                    \>          \>        \> , Row$_{Lay}$  [ "\textvisiblespace\textvisiblespace", 
                                                                              "if", "\textvisiblespace", "True", "\textvisiblespace", 
                                                                              "then", "\textvisiblespace", "1" ]\\
                    \>          \>        \> , Row$_{Lay}$ [ "\textvisiblespace\textvisiblespace\textvisiblespace
                                                                              \textvisiblespace\textvisiblespace\textvisiblespace
                                                                              \textvisiblespace\textvisiblespace\textvisiblespace                                                                                    \textvisiblespace ", "else", "\textvisiblespace", "0" ]\\
                    \>          \>        \> ])\\
                    \> ]
\end{tabbing}
\rmfamily \normalsize

\subsection{Arrangement layer: Arranger} \label{sect:arranger}

The arranger computes the exact sizes and positions for all elements in the layout level, yielding the arrangement. Fonts are queried to determine the size of strings, and child elements of compound elements such as rows and columns are aligned and positioned.

The arrangement layer also processes formatters by mapping them onto columns of rows in the arrangement. First, the amount of available space for a formatter is computed, and then the child elements are distributed along rows using a (possibly optimal) line breaking algorithm.
% no sheet

\bigskip {\bf Example:} The formatter, which is the first element in the top-level column of the example layout, is replaced by a column of rows in the arrangement. Furthermore, each element in the arrangement tree contains has an exact size and a position relative to its parent, which are denoted with superscripts: {\em element}$^{(x,y)(width\times height)}$. 

Note that the with elements are not removed, because the font information is required to render the arrangement.
%(149,156)
%
%[149-166,174-180,189-193,201-228,149-191]
%[17,6,4,27,42]
%
%
%6   (0,6) This (25,6)  is (40,6) a (52,6) simple
%18  (0,18) expression
%30
%42  (0,) simple1 (35,) :: (55,) Int
%54  (0,) simple1 (35,) = 
%66         (10,) if   (25,) True   (50,)  then (75,) 1
%78                                       (50,)  else  (75,) 0
%\note{show the sizes and positions, but maybe not for strings}

Arrangement:
%With$_{Lay}$ \{ FontFamily = "Times New Roman" \}\\
                    %\>  ~~~ Formatter$_{Lay}$ [ "This", "is", "a", "simple", "expression" ]\\
%                    \> , With$_{Lay}$ \{ FontFamily = "Courier New" \}\\
                    %\>  ~~~ \=
\small \ttfamily
\begin{tabbing}
Col$_{Arr}^{(0,0)(80\times84)}$ \\
~~ \= [ With$_{Arr}$ \{ fontFamily = "Times New Roman", fontSize = 12 \}\\
      \> ~~~ (Col$_{Arr}^{(0,0)(80\times24)}$ \\
      \> ~~~~~~ \= [ Row$_{Arr}^{(0,0)(80\times12)}$ \= [ "This"$^{(0,0)(17\times12)}$, "is"$^{(25,0)(6\times12)}$, "a"$^{(41,0)(4\times12)}$ \\
      \>       \>                                                      \>, "simple"$^{(53,0)(27\times12)}$]\\
      \>       \> , Row$_{Arr}^{(0,12)(80\times12)}$  [ "expression"$^{(0,0)(42\times12)}$]\\
      \>       \> ])\\
                    
      \> , With$_{Arr}$ \{ fontFamily = "Courier New,  fontSize = 12 \}\\
      \> ~~~ (Col$_{Arr}^{(0,24)(75\times24)}$\\
      \> ~~~~~~ \= [ ""$^{(0,0)(0\times12)}$\\
      \>      \> , Row$_{Arr}^{(0,12)(75\times12)}$ \= [ "simple1"$^{(0,0)(35\times12)}$, "\textvisiblespace"$^{(35,0)(5\times12)}$, "::"$^{(40,0)(10\times12)}$\\
      \>      \>                                                      \> , "\textvisiblespace"$^{(50,0)(5\times12)}$, "Int"$^{(55,0)(15\times12)}$ ]\\

      \>      \>  ])\\
                    
      \> , With$_{Arr}$ \{ fontFamily = "Courier New,  fontSize = 12 \}\\
      \> ~~~ (Col$_{Arr}^{(0,24)(80\times36)}$\\
      \> ~~~~~~ \= [  Row$_{Arr}^{(0,24)(50\times12)}$ [ "simple1"$^{(0,0)(35\times12)}$, "\textvisiblespace"$^{(35,0)(5\times12)}$, "="$^{(40,0)(5\times12)}$ ]\\
      \>      \> , Row$_{Arr}^{(0,36)(80\times12)}$ [ \dots~]\\
      \>      \> , Row$_{Arr}^{(0,48)(80\times12)}$ [ \dots~]\\
      \>      \> ])\\
       \> ]

%                    \>                       \> , Row$_{Arr}^{(0,24)(80\times12)}$ \=  [ 
                    %"\textvisiblespace\textvisiblespace"$^{(0,0)(10\times12)}$, 
                                                                              %"if"$^{(10,0)(10\times12)}$, 
%                                                                              "\textvisiblespace"$^{(20,0)(5\times12)}$\\
                    %\>                       \>              \>, "True"$^{(25,0)(20\times12)}$, 
%                    "\textvisiblespace"$^{(45,0)(5\times12)}$, 
                                                                              %"then"$^{(50,0)(20\times12)}$\\
                    %\>                       \>              \>, "\textvisiblespace"$^{(70,0)(5\times12)}$, 
%                    "1"$^{(75,0)(5\times12)}$ ]\\
%
                    %\>                       \> , Row$_{Arr}^{(0,36)(80\times12)}$ \= [ 
%                    "\textvisiblespace\textvisiblespace\textvisiblespace
                                                                             %\textvisiblespace\textvisiblespace\textvisiblespace
                                                                             %\textvisiblespace\textvisiblespace\textvisiblespace
                                                                             %\textvisiblespace "$^{(0,0)(50\times12)}$, 
%                                                                             "else"$^{(50,0)(20\times12)}$\\
                     %\>                     \>              \>, "\textvisiblespace"$^{(70,0)(5\times12)}$, 
%                     "0"$^{(75,0)(5\times12)}$ ]\\
\end{tabbing}
\rmfamily \normalsize

\subsection{Renderering layer: Renderer} \label{sect:renderer}

The renderer maps each element of the arrangement onto a set of drawing commands for the user interface. All positions and size have already been computed by the arranger, and the renderer only scales these positions and sizes according to the current scaling factor of the view.

%rendering sheet: how to render things, eg. corners of lines smooth or not. Maybe not very realistic.

\bigskip {\bf Example:} The result of applying the renderer to the example arrangement is a set of rendering commands which display the comment and the declaration when executed. Note that the comment is rendered in a different font than the declaration. The fonts are specified in the presentation, layout, and arrangement levels, but have been 

Rendering:

\framebox{
\parbox{1.15in}{
This is a simple
\hbox{expression}
\ttfamily
\begin{tabbing} % only in a tabbing are ~'s at start of line are shown correctly! 
simple1~::~Int\\
simple1 = \\
~~if True then~1\\
~~~~~~~~~~else~0\\
\end{tabbing}
\rmfamily
}}


\section{Translation Process}

The translation process of edit operations is layered in the same way as the presentation process. However, there are important differences between the two.

For the translation process, edit operations are the main focus, and therefore we do not regard a translation mapping as a mapping between levels, like we did for the presentation process.

Another difference is that in the translation process, layers may be skipped. For example, a document edit operation is passed on by the lower layers, until it reaches the evaluation layer, where it is performed on the document level.

The translation of edit operations can take place either directly, or indirectly by applying the edit operation to a lower level, using a mapping between levels to compute the corresponding upper level and computing the upper level edit operation by taking the difference between the new and the previous upper level.

An example of the direct translation is when a mouse click on an absolute position in the arrangement is mapped onto a mouse click operation on a tree path in the layout level. An example of an indirect translation is the insertion of a character in the presentation level. Rather than mapping this edit operation immediately on an enriched document edit operation, the character is inserted in the presentation, the presentation is parsed, and the edit operation is distilled from the newly parsed enriched document.

On the lowest two layers (rendering and arrangement), only direct translation takes place, whereas on the higher levels also indirect translation is possible. The reason for this is that the rendering and the arrangement level cannot be edited by the user, and an indirect translation only takes place when a lower level is edited and the edited level is then mapped onto the new upper level. The lowest level that may be edited by the user is the layout level. However, the architecture does not fundamentally prohibit editing the lower levels, and a future version of Proxima may support editing on the arrangement, by allowing a user to change the absolute positions of arrangement elements. Editing the rendering seems to be rather far fetched, since the rendering is a set of GUI-specific commands.

Because the translation of edit operations does not go through all stages like the presentation does, and because of the variation in edit operations, it is not possible to give a running example of the translation process. A number of separate examples are therefore provided together with the descriptions of the translation components.

\subsection{Renderering layer: Gesture Interpreter} \label{sect:gestureInterpreter}

The gesture interpreter has two tasks. It maps edit gestures onto edit operations for the designated levels, and it translates edit operations on the rendering onto edit operations on the arrangement, which means that absolute positions in pixel coordinates are translated descaled to arrangement level coordinates. \note{explain more that gesture interpreter is a bit weird because it creates wrapped upper level edit ops?}

\bigskip {\bf Example:} 
We will give two example translations by the gesture interpreter: a mouse click and a key press. 

The mouse edit operation is a single left click at pixel coordinates (84,57) in a rendering that has been scaled to 150\%.
Because of the scaling factor, the coordinates are divided by 1.5 to get the arrangement coordinates.

\ttfamily
MouseClick$_{Ren}$ Left 1 (84,57)) $\mapsto$ MouseClick$_{Arr}$ (56, 38) Left 1\\
\rmfamily

The second example is a key press of the letter 'a', which is mapped onto an insert event. However, a textual insert event is targeted at the layout level instead of the arrangement level, since the arrangement level cannot be edited textually. The insert operation is therefore not of the arrangement edit type, and needs to be wrapped. The arrangement layer unwraps the insert operation and passes it on to the layout layer.

\ttfamily
KeyPress$_{Ren}$ 'a' $\mapsto$ Wrap$_{Arr}$ (Insert$_{Lay}$ 'a')
\rmfamily

\subsection{Arrangement layer: Unarranger}

The main task of the unarranger is mapping locations in arrangement level edit operations on locations in layout level edit operations. A location that is specified in absolute coordinates is first converted to a location in the arrangement tree, which is specified as a tree path. Subsequently, the arrangement tree path is mapped onto a layout tree path. The arrangement tree is largely isomorphic to the layout tree, except for the formatter subtrees, as these are represented by rows and columns in the arrangement. Therefore, the mapping is mainly the identity function, except for paths in rows that originate from a formatter, which are mapped to paths in the originating formatter.

\bigskip {\bf Example:}
An mouse left click event at position (56,38) in the example arrangement from Section~\ref{sect:arranger} represents a click on the string "\verb|Int|" in the layout (Section~\ref{sect:layouter}). To be precise, it is a click on the left side of the letter '\verb|I|'. If we represent a path in the arrangement tree by list of integers and a 0 denotes the first child, then this position is represented by \verb|[1,0,1,4,0]|. \note{explain more?} Hence:

\ttfamily
unarrange (MouseClick$_{Arr}$ (56,38) Left 1) = MouseClick$_{Lay}$ [1,0,1,4,0] Left 1
\rmfamily

\subsection{Layout layer: Scanner} \label{sect:scanner}

The scanner is the first layer in which the level to level mapping is important, since the layout level may be edited by the user. Edit operations targeted at the layout level are performed on the layout level, after which the level is scanned, yielding the new presentation. A presentation edit operation is computed from the new presentation.

The scanner operates only on the subtrees in the layout layer that originate from a token list on the presentation level, while leaving other parts of the tree unaffected. A subtree, which is a column of rows, is scanned by inspecting it row by row, and recognizing the tokens that are represented by the strings in each row. For each token, the whitespace preceding it is recorded. Whitespace in the layout level is represented either by explicit whitespace characters in the strings, or by row transitions (line breaks). \note{structural tokens?} \note{scanner sheet? (has consequences for presentation type)} 

Scanning is a rather localized process, so rather than re-scanning an entire token list, only the edited part of the layout level is scanned and used to compute the appropriate presentation edit commands. \note{note the exception for comments?}

\bigskip {\bf Example:}
Consider the example layout level from Section~\ref{sect:layouter}, and assume that the edit operation on the layout is the insertion of a space between the characters 'e' and '1' in the identifer \verb|"simple1"| of the type declaration. Of course, inserting a space here is not allowed here, since our example declarations do not have parameters.\note{give the grammar somewhere?} A parse error will therefore occur on the presentation layer, but this has no consequences for the example on the layout layer.

In order to compute the edit operation on the presentation, we first apply the layout edit operation to the layout level, yielding:

\small \ttfamily
\begin{tabbing}
\dots \\
Col$_{Lay}$ \= [ "" \\
                  \> , Row$_{Lay}$ [ "simple 1", "\textvisiblespace", "::", "\textvisiblespace", "Int" ]\\
                  \> ]\\
\dots
\end{tabbing}
\rmfamily \normalsize

Now, the scanner is invoked on the updated parts of the layout (including the whitespace parts that precede the updated part,) which gives rise to the following list of tokens.

\small \ttfamily
\begin{tabbing}
[ LCaseToken$_{Pres}$ (1,0) "simple", IntToken (1,0) 1\\
, OpToken$_{Pres}$ (0,1) "::", UCaseToken$_{Pres}$ (0,1) "Int"\\
]\\
\end{tabbing}
\rmfamily \normalsize
 
From the new token list and the old presentation, an edit operation on the presentation level can be derived:

\small \ttfamily
\begin{tabbing}
\rmfamily {\em insert$_{Lay}$} \ttfamily ' ' \\
$\mapsto$\\
\rmfamily {\em replace$_{Pres}$} \ttfamily [ LCaseToken$_{Pres}$ (1,0) "simple1" ]\\  
\rmfamily {\em by} \ttfamily [ LCaseToken$_{Pres}$ (1,0) "simple", IntToken (1,0) 1 ] 
\end{tabbing}
\rmfamily \normalsize

We use an informal notation for both the {\em insert} and the {\em replace} edit operations to improve readability. The actual insert operation also contains a reference to the target location of the inserted character, and the replace operation contains the locations of the token lists, rather than the lists themselves. 

\subsection{Presentation layer: Parser} \label{sect:parser}
        
It is difficult to directly map edit operations on the presentation to edit operations on the enriched document, therefore we take the indirect approach: the edit operations are applied to the presentation, which is then parsed. The edit operations on the enriched document are computed from the new enriched document.

Similar to the scanner, the parser component of the presentation layer makes a distinction between token lists and the rest of the presentation. Only the token lists are actually parsed, the other parts of the presentation may not be edited at presentation level and are therefore recursively mapped onto their originating enriched document structures. Because parsed presentations may contain parts that are not parse, and vice versa, the two processes alternate. \note{it could also be possible to parse something that is not a token list}

Each part of the presentation that is not parsed is mapped directly onto the enriched document element of which it is the presentation. Because the presentation is specified with an attribute grammar, for each subtree in the presentation, the element in the enriched document that gave rise to it can be determined.\note{is this entirely right?} If the originating enriched document element has children that are also presented, these children are determined via the same process. A child that does appear in the presentation is reused from the previous enriched document level, or if is not possible, it is initialized to a default value. If a child has a token list presentation, the parser process takes over.

Parsing takes place by invoking a parser, which is specified in the parsing sheet, on the list of tokens. Parse errors are represented in the document with special error nodes that may appear anywhere in the document tree. \note{error corr. parser, with errors in local state?} Because the enriched document may contain information that is not presented, the parser tries to reuse the enriched document nodes from the previous time the enriched document was presented. If a node cannot be reused, the extra information is initialized to a default value. If a structural node is encountered, the previously described mapping process is invoked again.

Even though it is possible to specify a presentation for which it is not possible to automatically determine the originating enriched document elements, this is not a big problem in the editor. In such a case, automatic handling of presentation editing is simply not supported, and the editor designer will have to take care of handling it, or prohibit it altogether. \note{what about formatters, these should probably also have tokens}

\bigskip {\bf Example:}  
For the example translation at the parser component, we consider a delete operation on a number of succesive tokens in the presentation. Due to the simplicity of the example presentation, each declaration or type declaration is presented with a separate token list. Hence, presentation edit operations are always local to a single declaration or type declaration and cannot span several declarations. Therefore, the resulting edit behavior for the example is somewhat restrictive. However, in an actual source editor, the the token lists may be concatenated.

The presentation level for the example is the same as in Section~\ref{sect:presenter}. The part that is affected by the edit operation is: 

\small \ttfamily
\begin{tabbing}
\dots\\
Tokens$_{Pres}$ \= [ LCaseToken$_{Pres}$ (1,0) "simple1", OpToken$_{Pres}$ (0,1) "="\\
                         \> , LCaseToken$_{Pres}$ (1,2) "if", UCaseToken$_{Pres}$ (0,1) "True"\\
                         \> , LCaseToken$_{Pres}$ (0,1) "then", IntToken$_{Pres}$ (0,1) "1"\\
                         \> , LowercaseToken$_{Pres}$ (1,10) "else", IntToken$_{Pres}$ (0,1) "0"\\
                         \> ]\\
\dots                                                  
\end{tabbing}
\rmfamily \normalsize

The delete operation removes the \verb|"if"|,  \verb|"True"|,  \verb|"then"|,  \verb|"1"|, and  \verb|"else"| tokens, giving rise to a new presentation level.

\small \ttfamily
\begin{tabbing}
\dots\\
Tokens$_{Pres}$ \= [ LCaseToken$_{Pres}$ (1,0) "simple1", OpToken$_{Pres}$ (0,1) "="\\
                         \> ,  IntToken$_{Pres}$ (0,1) "0"\\
                         \> ]\\
\dots                                                  
\end{tabbing}
\rmfamily \normalsize

Now, a parser is invoked on the new list of tokens. The result is not an entire enriched document, but only an updated declaration for \verb|simple1|. For the resulting declaration, the previously presented declaration is reused. This is why the declaration contains the string \verb|"info"|, even though it is not present at the presentation level. The string is part of the local state of the enriched document level.

\small \ttfamily
\begin{tabbing}
Decl$_{Enr}$ \= "simple1" (IntExp$_{Enr}$ 0) "info"
\end{tabbing}
\rmfamily \normalsize

The edit operation is extracted from the new enriched document part and the previous enriched document, yielding:

\small \ttfamily
\begin{tabbing}
\rmfamily {\em delete}$_{Pres}$\ttfamily  "if" \dots~"else"\\
$\mapsto$\\
 \rmfamily {\em replace$_{Enr}$} \ttfamily (IfExp$_{Enr}$ (BoolExp$_{Enr}$ True) (IntExp$_{Enr}$ 1) (IntExp$_{Enr}$ 0))\\
 \rmfamily {\em by} \ttfamily (IntExp$_{Enr}$ 0) 
\end{tabbing}
\rmfamily \normalsize

It should ne noted that the second \ttfamily (IntExp$_{Enr}$ 0)\rmfamily in the replacement operation is exactly the same as the one in the else part of the if expression. In this case, the expression is uniquely determined by its presentation, and hence parsing it gives an exact copy, but even if this were not the case, both expressions would be the same, due to the reuse strategy of the parser. For example, if the int expression has an extra field that is not presented, the replacement int expression gets the same value for that field, since the first int expression is reused by the parser. This is analogous to the \verb|"info"| string for the declaration.

After it is edited, an enriched document may be inconsistent with regard to the document and the evaluator. For example, if the declaration is edited in such a way that its type no longer matches the one in its type declaration. The consistency is guaranteed again when the reducer and evaluator have been invoked.

\subsection{Evaluation layer: Reducer} \label{sect:reducer}

The reducer takes care of mapping edit operations in derived structures on edit operation on the document. The specification of the mapping is in the {\em reduction sheet}, which in many cases may be automatically derived from the evaluation sheet. Automatic reduction behaviour is typically possible for parts of the enriched document that are duplicated, reordered, or partial versions of parts of the document. 

The reducer resolves duplicates in the enriched document by taking the duplicate that was edited. In case of a conflict, either the edit operation may be blocked, or a choice between the two may be made. Reordering and partiality \note{word: partiality?} is handled by maintaining a mapping between each enriched document element and the document element from which it originated.

For many derived structures, a reverse mapping does not make much sense. For example, it is hard to give a clear semantics of editing a chapter number directly, however, when two chapters in a table of contents are swapped, swapping the two actual chapters in the document could be a logical operation in some editors. In the cases for which the reverse mapping makes sense, it be specified in the reduction sheet. In the other cases, editing derived structures can be forbidden.

Besides regarding the reduction as the reverse of the evaluation, it is also possible to use reduction as an extension of the parser. For example, when a program source contains definitions of infix operators with a user-specified associativity and precedence. Parsing such operators in one pass requires a sophisticated parser, whereas the two pass solution is straightforward.

Another application of reduction is the handling of rendundancy in a document presentation. For example, when a document type for expressions does not have a construct for explicitly representing parentheses, redundant parentheses that are entered by a user can be removed by the reducer, to be added again by the evaluator. \note{also mention ambiguity? eg. 1:2:3:[] vs [1,2,3]?}

\bigskip {\bf Example:} 

For the reducer example, assume that the editor supports editing on an identifier in a type declaration, leading to an update on the indentifier in the corresponding declaration. Although this may not be desirable behavior in an actual source editor, it provides a good example of editing on derived values.

The enriched document edit operation that is translated is an update on the identifier in the type declaration of the enriched document from Section~\ref{sect:evaluator}. The identifier is changed from \verb|"simple1"| to \verb|"simple"|. Thus, we get the following updated enriched document.

\small \ttfamily
\begin{tabbing}
Root$_{Enr}$ \= [ Comment$_{Enr}$ [ "This", "is", "a", "simple", "expression" ]\\
       \> , TypeDecl$_{Enr}$ "simple" IntType$_{Enr}$\\
       \> , Decl$_{Enr}$ \= "simple1"\\
       \>                       \> (IfExp$_{Enr}$ (BoolExp$_{Enr}$ True) (IntExp$_{Enr}$ 1) (IntExp$_{Enr}$ 0)) \\
       \>                       \> "info"\\
       \> ] 
\end{tabbing}
\rmfamily \normalsize

The reducer processes the enriched document and maps both the type declaration and the declaration onto a document level declaration. The type declaration is mapped onto a document level declaration with string \verb|"simple"| and expression (\verb|if True then 1 else 0|). The declaration on the other hand, is mapped on a document declaration that contains the same expression but has string \verb|"simple1"|. The two conflicting declarations are resolved in favor of the updated fields. In this case, it means that the string \verb|"simple"| is chosen. The result is a new document.

\small \ttfamily
\begin{tabbing}
Root$_{Doc}$ \= [ Comment$_{Doc}$ ["This", "is", "a", "simple", "expression"] \\
       \> , Decl$_{Doc}$ \= "simple" \\
       \>                        \>(IfExp$_{Doc}$ (BoolExp$_{Doc}$ True) (IntExp$_{Doc}$ 1) (IntExp$_{Doc}$ 0))\\
       \>                       \> "info"\\
       \> ] 
\end{tabbing}
\rmfamily \normalsize

And the document level edit operation is:

\small \ttfamily
\begin{tabbing}
\rmfamily {\em replace$_{Enr}$} \ttfamily "simple1" \rmfamily {\em by} \ttfamily  "simple" $\mapsto$ \rmfamily {\em replace$_{Doc}$} \ttfamily  "simple1" \rmfamily {\em by} \ttfamily  "simple"
\end{tabbing}
\rmfamily \normalsize

\section{Local state on each level}

Each level in the Proxima editor is part of the total editor state, rather than just an intermediate value in a computation. One reason for this is to support incrementality, but a more fundamental reason is that the presentation and translation mappings are not complete. More specifically, a level does not always contain enough information to compute the level below it and vice versa. By storing both layers, together with information on how elements in each layer depend on each other, it is possible to compute the lower level from an updated upper level and vice versa.

An example of a partial presentation mapping can be found between the enriched document and the presentation. An enriched document element that is presented with tokens, does not contain the layout information that is present in the tokens. Therefore, if the element is re-presented, it must reuse the tokens from its previous presentation. In order to be able to reuse the tokens, the element must keep track of which parts of the presentation it is mapped on.

The translation of edit operations also has to deal with partial mappings. Take for example an enriched document subtree that contains only the titles of the chapters, sections, and subsections of a document. This structure does not contain enough information to construct the document. Therefore, if a title in the enriched document is edited, and we want to be able to perform the title update in the document, each enriched document node needs to keep track of the document node from which it originated. 

In short, the presentation function that is given by the editor designer, specifies a mapping between the two levels $high$ and a $low$:  $present :: high \rightarrow low$. However, because the lower level may contain extra information, the mapping that needs to be maintained by the editor is 
$present :: high+extra_{high} \rightarrow low+extra_{low}$. Similarly, for the translation, the specified mapping function is 
$translate :: low \rightarrow high$, whereas the editor needs the mapping 
$translate :: low+extra_{low} \rightarrow high+extra_{high}$. 

The problem with partial mappings, ie. that when mapping one level onto another, information from a previous mapping must be reused, appears in several layers of the Proxima editor. In the lower layers, the mappings can be maintained by the system, because the lower layers operate between levels that have fixed types, and the presentation and translation mappings at these layers are less customizable by the editor designer. For the higher levels, however, the editor designer in some cases needs to specify how the mappings should be maintained. The formalisms for the sheets on these levels offer special support for making this more easy. Furthermore, for frequently appearing patterns in the presentation process, special functionality is present for automatic maintenance of the mappings. Chapter~\ref{chap:singleLayer} deals more extensively with the problem.

\section{Motivation for the layer structure}

The choice of layers for the Proxima editor is not an exact one. On the one extreme, the entire edit process can be put in one big layer, whereas on the other extreme a separate layer can be defined for every small step in the process. The choice of layers in Proxima is a balance between these extremes. This section contains the motivation for the layer structure as it is.

The separation of document evaluation from the presentation serves two purposes. Firstly, the separation makes it possible to have different presentations for a document together with its derived structures. And secondly, it facilitates the specification of edit behavior on derived structures. When parsing and reduction are mixed, such behavior is harder to specify.

The reasons for a separate layout layer are automatic whitespace handling for token presentations and efficiency, since first scanning and then parsing is more efficient than parsing on character basis. A downside is that different languages require slightly different scanning methods, and a generic scanner that is able to handle all exotic cases is hard to construct. Moreover, in some cases, an editor designer may be interested in dealing with whitespace at enriched document or document level. However, in these cases, the scanner layer may be bypassed altogether, allowing the editor designer to parse on a character basis and explicitly deal with whitespace.

Below the layout level are the arrangement level and the rendering level. The separation between these two levels and the higher levels is obvious, since the position and size computations are similar for different elements in the layout, and keeping the computations in a separate layer prevents cluttering the higher layers. The reason why the arrangement and rendering are split is to keep the part of the architecture that deals with the GUI-specific issues as small as possible. Furthermore, the arrangement contains exact information on the location and size of each item that is to be rendered, which is useful for resolving pointing issues and performing incremental updates. 

The arrangement process itself also consists of steps, since formatters are mapped on arrangement rows and columns which are then arranged similar to other rows and columns. However, these steps are very closely intertwined, and separating the arrangement into different layers does not offer enough advantages. 

Besides the current layers, several other layers are imaginable. For example, a post-arrangement layer could process the arrangement in order to handle footnotes and formatting of paragraphs that contain text in languages with different reading directions. Similarly, an extra evaluation layer is conceivable when computations over computed structures need to be specified. When yet other computations are desired on the resulting computed structures, even multiple evaluation layers may be required. This brings up the issue of using higher-order attribute grammars for the evaluation layer. In fact, the whole presentation process can be specified with a higher-order attribute grammar. However, when using higher-order attribute grammars, it is not straightforward anymore to handle local state at intermediate levels, nor is it clear how to translate the edit operations on lower levels. In Proxima, these problems are dealt with by the layered architecture. Before it is possible to do presentation, or even just evaluation, with higher-order attribute grammers in Proxima, more research is necessary.

\note{make a Conclusions section?}
% multiple eval is handy