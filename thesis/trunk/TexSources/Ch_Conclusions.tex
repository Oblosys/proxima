\chapter{Conclusions and further research} \label{chap:conclusions}

In this thesis, we have introduced the presentation-oriented structure editor Proxima. Proxima provides an intuitive and user-friendly way of editing for complex document presentations which may contain derived structures.


%What we did.
In Chapter~\ref{chap:requirements} we investigated a number of use cases for a generic editor, and formulated a set of functional requirements based on these use cases. We have provided an evaluation of existing generic editors with regard to the requirements. It turns out that none of the existing systems is able to handle all of the use cases. In our opinion, the reason for this is that these editors either lack the power to support the complex presentations of the use cases, or have an edit model that is overly restrictive. The chapter ended with a brief description of the Proxima editor, which has been designed to meet the requirements and will be able to handle all of the use cases.

%\todo{figure out reqs and levels in intro and requirements chapters}
Proxima has a layered architecture that makes it possible to support both pre\-sen\-tation-oriented and document-oriented editing. An overview of the layers and data levels of the architecture has been provided in Chapter~\ref{chap:proxArch}, followed by a specification in chapters~\ref{chap:informalSpec} and~\ref{chap:formalSpec}. 

\bc We explored the possibilities of using Haskell for describing Proxima's layered architecture in Chapter~\ref{chap:archCombs}. The result is a combinator library that can be used to describe the architecture of layered systems in general. A Haskell module containing the Proxima architecture description expressed with these combinators forms part of the prototype implementation. \ec

In Chapter~\ref{chap:presenting} we introduced the declarative presentation formalism {\Xprez}. The language is a Haskell combinator library for creating graphical presentations with an advanced alignment model. Using Haskell's abstraction facilities, complex presentations may be defined in a concise way.

A prototype for Proxima  has been implemented and was discussed Chapter~\ref{chap:prototype}. To instantiate an editor, a basic Haskell document type definition must be provided together with a presentation sheet and a parsing sheet. The presentation sheet is an attribute grammar, and the parsing sheet is a combinator parser. A number of example editors have been instantiated with the prototype.


\section{Further research}

The formal specification has provided a wildcard representation for extra-state equivalence classes. However, the specified reuse function is rather basic and only allows reusing extra state after simple edit operations. The specification should be improved with a more advanced reuse function, a sketch of which was provided. 
Furthermore, the specification for an editor supporting duplicates in the presentation was only informal. A more formal definition of the notion of duplication as well as of the mechanism of ignoring duplicates is needed to establish a formal specification for the editor that supports duplicates. 

In Proxima, functions for both the presentation and the interpretation direction need to be specified. The inverse of the presentation sheet is the parsing sheet, and the inverse of the evaluation sheet is the reduction sheet. Because specifying these inverses by hand is a possible source of errors, a bidirectional presentation formalism, which automatically generates an inverse function, is desirable. 

The evaluation layer of Proxima is an ideal place for such  a bidirectional presentation (or rather evaluation) formalism. Thus, the reduction sheet will be automatically generated from the evaluation sheet. For the presentation layer the situation is somewhat more complicated because it does not seem realistic to assume that an efficient parser can always be generated automatically from the presentation sheet. On the other hand, many parts of the presentation are straightforward and could be inverted automatically. In the prototype, for example, it is already clear how the structure recognizers in the parsing sheet can be derived from the presentation sheet. For the more difficult parts of the presentation, the presentation sheet could contain special directives for parsing, or even an explicit specification of the appropriate part of the parser.


\bc Obtaining an efficient parser from the presentation sheet may not be a realistic .. yet. Hence, the applicability of a bidirectional presentation formalism on the presentation layer will require It is not immediately obvious that an efficient parser can always be obtained from a presentation sheet, and hence the applicability to the presentation layer is not . \ec

Chapter~\ref{chap:prototype} already provided an overview of the future research concerning the Proxima prototype. We recapitulate a few main issues here. The most important area of research is support for incrementality, consisting both of built-in incremental behavior for the lower layers, as well as the application of techniques for incremental attribute evaluation to the attribute-grammar compiler. A second important area concerns the evaluation layer for which we need to establish the formalisms for the sheets, as well as provide an implementation. Furthermore, we need extensions to the attribute grammar formalism and the {\Xprez} presentation language.  And finally, libraries of useful functions must be compiled, to facilitate the specification of common editor behavior.
% to capture common patterns in presentation sheets



\section{Final remarks}

% 
The approach taken for Proxima is different from most other generic editing projects. Most of these projects take as the starting point a specification formalism that guarantees a correct and efficient editor for a limited range of applications. Proxima, on the other hand, provides a general architecture with presentation and computation formalisms that are powerful enough to build serious editor applications. In the initial stages of the Proxima project, it is left to the editor designer to  guarantee safety and efficiency of the implemented editor. Support for automatic interpretation and incrementality  will be added at a later stage.

Because both the presentation and the interpretation need to be specified, it is possible to specify an editor for which the parser does not match the presentation. Furthermore, because the presentation formalism allows arbitrary computations, it is possible to specify a presentation that is too slow for editing, or even crashes.  Nevertheless, the safety of an editor built with Proxima is already much easier to guarantee than if a similar editor had been built by hand. Further, in practice, it turns out to be rather straightforward to avoid inconsistencies between the presentation and interpretation functions.

An advantage of our approach is that even in an early stage, complex editors can be specified (albeit with a little more effort). And, moreover, it is possible to specify editors for which automatic interpretation is not yet an option. A related advantage is that by building and experimenting with editors, it becomes clear which parts of the generic system should get the highest development or research priorities.

Even without the language support and libraries for common presentation patterns, it is already straightforward to specify a complex editor in Proxima. Thus, the Proxima prototype shows that it is possible to combine a powerful presentation formalism with a mode\-less integration of document-oriented and presentation-oriented editing. The resulting editors are powerful, yet easy to use.


\bc

Even without the language support and libraries for common presentation patterns, it is already straightforward to specify a complex editor in Proxima. Thus, the Proxima prototype shows that it is possible to combine a powerful presentation formalism with a mode-less integration of document-oriented and presentation-oriented editing. The resulting editors are powerful, yet easy to use.
\ec


\bc
\toHere
Although it is unlikely that generic editors will provide a replacement for the big standard editors,  However, because of the rapid development and  specialized document types . Furthermore, because mixing is so easy, may even lead to editors that one would not come up with without a generic system. Together with the popularity of XML, and the associated with a non-restrictive presentation-oriented edit model, structure editors may be able to get rid of their rather negative image.
\ec


%Why proxima is useful (check with introduction) ?
%*not a replacement of big ones (word, powerpoint, etc)
%*Rapid development
%*Good support for editing own datatypes.
%*Mixing different editors easy



%Interesting problems?? table formatting, generalized paste, etc.



\bc
Commentaar Johan op 8 & 9.

In 8.4.2

Over dynamic loading: neem je hier aan dat je een Haskell compiler nog
eens op de achtergrond aanroept? Anders zie ik niet direkt dat dat zo
eenvoudig is.


8.4.3


developing extensions to the formalism... Bedoel je hier het Prez of het
AG formalisme? Ik dacht het eerste, maar de laatste zin van deze paragraaf
verwart mij een beetje

#An desirable aspect := a desirable aspect
In dezelfde paragraag nog invertable functions noemen?

To identify the different forms of extra state... Heb je het al eens over
die different forms gehad? Misschien kan je daar naar refereren, of nog
een vb geven?

#layer needs provide := layer needs to provide

#the instantiation of more := the development of more

#researched extensively := investigated extensively

#The instantiated editors := The example editors (een paar keer)

#as well as allow us assign ... := and allow us to assign ... as well

Ik had in dit hoofdstuk (of in het volgende) eigenlijk ook nog een soort
evaluatie van de requirements in hoofdstuk 2 verwacht, waarin je
beschrijft hoe Proxima aan al die requirements voldoet, en hoe je dat voor
elkaar gekregen hebt. Daarmee zou de cirkel mooi rond zijn.

In 9

#2e zin: The editor := Proxima
#laatste zin voor 9.1: instantiated with := developed using

In 9.1

#Because having to specify := Because specifying

Volgens mij is het ook niet altijd mogelijk de reduction sheet uit de
evaluation sheet af te leiden (net zoals parser vs presentation).

In 9.2

Ik vind het begin van 9.2 een ietsepietsje negatief over andere editors.
Misschien iets positiever formuleren? (Overigens Roland Backhouse heeft
toegezegd in de leescommissie deel te nemen, dus check nog even je
referenties naar Mathspad. Verder heeft ook Takeichi ja gezegd, dus
misschien ook daar een ref naar opnemen, voor zover je die nog niet had.
en niet in negatieve termen, uiteraard.)

stages of the project... welk project?

#presentation direction ... interpretation directions ... verwijder de
#`direction(s)'

with a little more effort ... more than what?

Waarom staat 9.2 niet voor Future research? Ik begrijp de plek niet helemaal.

Loop nog eens spell over je hele document.
\ec