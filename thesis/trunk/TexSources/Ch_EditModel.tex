\chapter{Proxima Edit Model}
\label{chap:editModel}

{\em *** Version: \today~***}

\bc


mention navigation in basic edit op discussion and don't say incorrect things about focus.
Check Johans comments
Check these comments:


Big questions:
Is there a difference between:

from(>) to (<)
col [row [row  [a,>b,c] ] 
     ,row [d<, e,f ] 
     ]
     
and 

col {#0} [row {#1} [aa, row {1,3} [a,b,c] ] 
              ,row {0,1} [d, e,f ] 
              ]

using the distr. notion, we need descendant-has-focus property as well. And we cannot distinguish a single
range from a multiple range, if it spans several levels. Is this a problem?

--

mouse handling?
edit evts die meer input nodig hebben?
alles al (lazy) opslaan, of edit cycle maken?

fall back on lower level?
macros?

\ec


% what is chapter about
This chapter explains the edit model of the Proxima editor. We focus on how an edit gesture from the user is interpreted to yield edit operations on the data levels of Proxima. Because Proxima is a generic editor, it is only possible to give a general description of the edit model, since different instances have different edit behavior. Much of the edit functionality for an actual instance of the editor is described in the sheets that specifiy the instance (evaluation/reduction sheet, presentation/parsing sheet, and scanner sheet). 

% structural view
Almost all structure editors can provide a structural view that shows the underlying document structure, which may not be apparent in the presentation. For example, in a word processor, it may be hard to distinguish between a heading and a single line of text with a larger font size. In Proxima, such a structural view is defined in the same way as any other presentation. A structural view is a presentation in which each element is presented with its type name, all elements of the document are presented, and in which the structure of the document is made explicit. The exact details may vary for different structural presentations. For example, a structural presentation can be a tree presentation of the document, in which the layout of the tree nodes shows the structure, but it can also be an XML source presentation that uses text to show the structure. A default structural presentation will be available for each element type, but other than that no built-in primitive support for structural presentations is necessary.

Although the user only sees a presentation, it is possible to target edit operations at other levels besides the presentation. For example, in a Haskell editor, one may type in a function definition (presentation-oriented editing), but also navigate over the abstract syntax tree (document-oriented editing) of the edited program. One way to do this is by switching to a structural presentation before performing the edit operation. However, in practice it turns out that higher level edit operations are useful also in a non-structural presentation. For example, in a word processor it is useful to be able to move sections around without having to switch views. Similarly, in a source editor it is desirable to be able to select entire declarations, sub-expressions, etc.\ while remaining in the regular source text view. Therefore, Proxima offers editing on all editable levels at any time. We explicitly mention the term editable, because not every level has sensible edit operations; only the document and enriched document may be edited directly, as well as the layout level, which is in fact the level at which presentation-oriented editing takes place.

\bc
\section{Presentation oriented editing}
a whole section?

\subsection{Ceci n'est pas un document}

also navigation here? ( If document works. then doc. Otherwise presentation. Always  possible to override.)

[62] from Pan paper point vs extended cursor problem

if selection is not structural, assume the structural that results from a click with the mouse.

weird behavior of left right arrow vs up/down? 
\ec


%																
%																
%																
\section{Editing at different levels} \label{sect:editDifferentLevels}

Before we explain how the layered architecture of Proxima affects its edit model, we give a description of the edit process, which basically consists of repeatedly going through the following 5 phases:

\begin{enumerate}
\item Compute a rendering, or {\it presentation}, of the document (and intermediate levels)
\item Show the presentation to the user
\item Receive an edit gesture from the user
\item Interpret the edit gesture as an update on the document (and intermediate levels)
\item Update the document
\end{enumerate}

Figure~\ref{simpleeditprocess} contains a schematic representation of the edit process. Each of the boxes represents one complete edit cycle. The emphasis in the figure is put on the presentation and interpretation phases (phases 1 and 4). Phases 2 and 3 are represented by the dotted arrows at the bottom of the figure, and phase 5 is represented by the dotted arrows at the top.

\begin{figure}
\begin{small}
\begin{center}
\begin{center}
\begin{scriptsize}
\xymatrix{
 & \data{$doc$}\ar[d] & \data{$upd$} \ar@{.>}[r]^{update} & \data{$doc$}\ar[d] & \data{$upd$} \ar@{.>}[r]^{update} & \data{$doc$}\ar[d] & \data{$upd$}  & \\
 & \component{$present$}\ar[d] & \component{$interpret$}\ar[u] & \component{$present$}\ar[d] & \component{$interpret$}\ar[u]& \component{$present$}\ar[d] & \component{$interpret$}\ar[u] \\
 & \data{$pres$} \ar@{.>}[r]_{~~User~Edit~~} &  \data{$gest$}\ar[u] & \data{$pres$} \ar@{.>}[r]_{~~User~Edit~~}
   &  \data{$gest$}\ar[u] & \data{$pres$} \ar@{.>}[r]_{~~User~Edit~~} &  \data{$gest$}\ar[u] &
\bc
 \save"2,2"."3,2"*!=<6.105em,12.2ex>[F.]\frm{}\restore
 \save"2,2"."3,3"*!=<14.47em,12.2ex>[F]\frm{}\restore
 \save"2,4"."3,4"*!=<6.105em,12.2ex>[F.]\frm{}\restore
 \save"2,4"."3,5"*!=<14.47em,12.2ex>[F]\frm{}\restore
 \save"2,6"."3,6"*!=<6.105em,12.2ex>[F.]\frm{}\restore
 \save"2,6"."3,7"*!=<14.47em,12.2ex>[F]\frm{}\restore
\ec
}
\end{scriptsize}
\end{center}\caption{Three cycles in the edit process. (draft)}\label{simpleeditprocess} 
\end{center}
\end{small}
\end{figure}

The presentation and interpretation phases are not atomic actions, but consist of several steps, each of which is handled by a single layer. Therefore, we need to refine Figure~\ref{simpleeditprocess}. 

Figure~\ref{simplelayers} shows a more detailed view of a single edit cycle, in which the layered character of Proxima becomes apparent. The edit gesture, which originates from the user, is first processed by the gesture interpreter in the renderer layer, then by the unaranger, and so on until the reducer is reached. The resulting document edit operation is then applied to the document, after which the updated document is subsequently presented onto lower data levels and finally onto a new rendering. In the actual architecture, the downward mapping is on edit operations rather than on levels, causing a symmetrical picture. However, since it is more intuitive to see the presentation as a mapping on levels, we regard it as such in this chapter. Chapter~\ref{chap:singleLayer} and~\ref{chap:layeredArchs} discuss the mappings in full detail.

\begin{figure}
\begin{small}
\begin{center}
\begin{center}
\begin{scriptsize}
\begin{verbatim}
          EditDoc     --update-->   Doc       																																	  
             ^                       v
         (Reducer)                 (Eval)     																																	  
          Edit Enr                 Enr Doc    																																	  
         (Parser)                (Presenter)  																																	  
                                           																																	  
            ...                    ...       																																	  
   (Gesture Interpreter)         (Renderer)   																																	  
             ^                      v
       Edit Gesture              Rendering    																																	  
             ^                      |         																																	  
user edit ---|                      -->     user edit
\end{verbatim}
\end{scriptsize}
\end{center}\caption{The layered edit cycle. (draft)} \label{simplelayers} 
\end{center}
\end{small}
\end{figure}


% targeting different levels

\bc Edit operations may be targeted at different levels in the Proxima architecture. When an edit gesture is received from the user, it is interpreted as an edit operation on one of the data levels, and from there to updates on all higher levels up to the document. Subsequently, the document is presented again and also the lower levels, including the rendering, are updated. \ec

Chapter~\ref{chap:proxarch} already mentioned that the interpretation of edit operations in proxima does not in fact start with an edit operation on the rendering that is mapped to an edit operation on the arrangement, and so on to an edit operation on the document. Instead, the lowest level that can be edited directly is the layout level. If it is edited, for example by typing a keyword, the levels above are updated by subsequently tokenizing, parsing and reducing the updated level.

%also higher
Apart from editing the layout level, resulting in indirect edit operations on the higher levels, it is also possible to directly target these higher levels, after which indirect edit operations on levels above is computed, similar to what happens when the layout is edited. For example, moving a section entry in a table of contents is a direct edit operation on the enriched document level. An indirect document edit operation that moves the corresponding section (rather than just the entry) is computed from it by the reducer. Because the levels below the targeted level are skipped during interpretation in this case, these levels are not updated until the document is presented again. 

Currently, besides the layout level, only the enriched document and document levels can be edited directly. The presentation level does not need to be edited directly due to its high similarity to the layout level. The only difference between the two is that the presentation contains lists of tokens that are represented by strings and explicit whitespace in the layout level. Hence the only reason for supporting direct presentation-level editing is for manipulating tokens as lists, which can be done at layout level as well.

Summarizing, the following three levels can be directly edited in Proxima:

\begin{description}
\item[Document] Structure-oriented edit operations, such as moving section in wordprocessor document; deleting a declaration in Haskell source; or moving the focus to a certain subtree of the document.
\item[Enriched Document] Also structure-oriented, but on derived structures such as a table of contents.
\item[Layout] Mainly text-oriented editing. For example: typing keywords (eg.\ "\verb|if|", "\verb|then|", or "\verb|else|"); moving the focus one character to the right; etc.
\end{description}

\bc
% pres oriented and structural
Although various levels may be targeted, edit operations can be divided roughly in two categories: {\em presentation-oriented edit operations} and {\em structural edit operations}. Presentation-oriented edit operations are targeted at the structure of the presentation, whereas structural edit operations are tree based edit operations on the structure of the document. \note{examples?} Presentation-oriented editing includes all textual editing. However, because a presentation is not necessarily purely textual, also non-textual presentation oriented-edit operations exist. Structural edit operations are performed at the document and the enriched document levels, and presentation-oriented edit operations are performed at the layout level. Contrary to what the name might suggest, presentation-oriented editing is not done at the presentation level itself. In order to be able to edit the whitespace of a presentation textually (by inserting spaces, tabs and newlines), presentation-oriented editing is performed at the layout level rather than the presentation level. 
% not document-oriented because these are just the rough categories
\ec

\bc
Rest does have focus edit (navigation). pres, layout, arrangement are more similar than doc  and enr.
doc. vs pres.
\ec

The layered nature of Proxima has consequences for the focus model as well. A document-oriented edit operation requires a document level focus, whereas an operation on the layout level requires a layout focus. Therefore, each level from the layout up to the document has its own focus. During presentation and interpretation, a layer also maps the focus on one level onto the focus on another level. Section~\ref{sect:focus} contains a more detailed description of the focus model and the way focus is presented and interpreted.

% edit ops at higher levels
A final issue regarding the edit model and the Proxima layers is that not every layer needs to be involved on each cycle of the edit process. Firstly, higher layers may be skipped when the edit operation takes place on extra state that is not present in the higher levels. And secondly, it is possible that the interpretation and presentation process does not pass through the higher layers for every edit operation, but only after a sequence of edit operations or after an explicit request from the user. Section~\ref{sect:bypassingLayers}, explains this process of bypassing layers in more detail.

The following subsections provide a short description of the edit functionality at each level. 
 
 
%																
\subsection{Rendering}

The rendering level is not edited directly and therefore has no focus or edit functionality. A direct edit operation on the rendering would consist of moving around bitmaps, after which the updated rendering needs to be interpreted to yield a new arrangement. The semantics of such edit behavior are unclear and supporting it will probably be difficult, and since direct rendering editing is not required by any of the use cases that drive the design of Proxima (Section~\ref{sect:usecases}), it is not supported.
  

%																
\subsection{Arrangement}\label{sect:editArr} 

The arrangement level is structurally very similar to the presentation level, except that line breaking has been performed and elements have absolute positions. Edit operations targeted at the arrangement are edit operations concerned with lines and absolute positions, such as navigating to the end of the line that contains the focus, or selecting all elements in a rectangular area.

Currently, Proxima does not support direct editing on the arrangement level. It is not possible to update the arrangement level and compute an edit operation on the presentation level. Edit operations targeted at the arrangement only involve the focus. A consequence is that although rectangular areas may be selected and deleted (the deletion takes place at a higher level), it is not possible to insert a rectangular area. Such edit behavior, often referred to as column editing in text editors, is not a big requirement for Proxima. In text editors, column editing is used to edit a text that is organized in columns, but since Proxima is a structure editor, a document whose data needs to be presented in columns can use a presentation level matrix, whose elements can be selected columnwise at presentation level.

\bc
If the presentation language is extended with a construct for absolutely positioning elements, the positions are typically edited at the arrangement level. An example is a  file manager window in which files are represented by icons that may be freely moved in  the window. Icon positions can be stored in the arrangement extra state. However, at the  moment, absolute positions in the presentation are not yet allowed. 
?????????? not true, position can be stored at pres level in percentages.
\ec

 
%																
\subsection{Layout}

The layout level is where all presentation-oriented editing takes place. This includes the typing in program text in a source editor, but also text entry in the tax form editor or the word processor. Besides text insertion and deletion, also cut, copy and paste operations are supported.
 
%																
\subsection{Presentation}

As mentioned before, the presentation level is not directly editable. All information in the presentation level is also present in the layout level, and can therefore be edited at that level. The only reason for directly editing the presentation level would be when a user wishes to manipulate tokens without paying attention to their whitespace. Such behavior seems appropriate only in an editor with automatic whitespace handling, but in that case editing may just as well be performed at the layout level, since the whitespace will be ignored. 
 
 
%																
\subsection{Enriched document and document}

Because the enriched document is a tree, similar to the document, the edit functionality on both levels is the same. The only difference between the two is that if the enriched document is edited, a subsequent interpretation takes place to compute the document update. Because of the similarities, both levels are discussed together.
% mention isomorphic parts?

The edit operations at the document level are basic tree operations, such as cut, copy and paste on subtrees. If an list element has a parent that is also a list (eg.\ a list of subsections in a list of sections), split and join operations can be applied. Besides the standard edit operations, an editor designer may specify other generic transformations, or domain specific transformations.

%placeholders
Child elements that are not of optional or list type are required and hence cannot be left out of the parent element. In order to still be able to manipulate an element without its children, Proxima employs the concept of a placeholder (eg.~\cite{syngen}). A placeholder of a type $T$ is a dummy value that can be used in any place where an element of type $T$ is required. A built-in presentation is available for placeholders, but it can be overridden in a presentation sheet. If a document contains a placeholder it is not valid. The placeholders are typically present only during the construction\note{don't use the word constructing} of a document (or part of it), or as an intermediate situation during a document modification that consists of several steps. Lists and optional types do not require placeholders: for a list type, the empty list is the placeholder, and for an optional it is the empty alternative.

\bc
what about extra children that are not allowed? in XML that's a rather natural situation doesn't fit our model since we don't have rose trees
\ec

%																
%																
%																
\section{Modeless editing}

\bc
not the same as VI, command mode. nothing is said about that. menus and dialogues are kind % of command mode. ref to humane stuff?
Mention in chapter one?
\ec

% also if doc is not parsable, structure edit is important
One of the requirements for the Proxima editor is the possibility of modeless editing; it must be possible to freely mix edit gestures targeted at different levels without having to switch to a different editor mode. Because the structure of the presentation is often closely related to the structure of the document, many structural edit operations are also presentation edit operations, and therefore it does not matter at what level the edit operation is performed. However, in some cases it makes a difference whether an edit operation is interpreted as a structural edit operation, or as a presentation edit operation.

%The reverse is not true because if part of an element's presentation is edited, 
%this does not constitute a document edit operation.

One example concerns a date element that appears in several places in a document, but with different presentations. In one place, it is presented in the US format (month/day/year), whereas somewhere else it is presented in the European style (day/month/year). However, at document level, both are represented by the same type of date element. Now, if for example the date January the twelfth in the year 1900 is copied from a US date field ("1/12/1900") to a European one, two interpretations are possible. Interpreted as a presentation copy, the resulting date looks similar to the source date (ie. "1/12/1900"), but it now refers to the first of December. Interpreted as a document edit operation, on the other hand, the copied date gets a different appearance ("12/1/1900"), but it refers to the same date as its source.

A second example is if the element \verb|1| is deleted from the Haskell list \verb|[1,2]|. This can be interpreted as a presentation deletion of the character \verb|1|, leading to \verb|[,2]|. \note{explain that this one fails during parse?} On the other hand, it can also be interpreted as the structural deletion of the first element of the list, since the comma can be argued to belong more to the presentation of the list than to the presentation of the element. Interpreted structurally, the result of the edit operation is \verb|[2]|. 

Ambiguity arises when parsing an element's presentation at the destination of a paste operation results in a different element (as in the date example), or when the presentation of a parent element depends on its children, as is the case in the Haskell example since the number of commas depends on the number of elements in the list. \note{don't know exactly when. Should we try to say this?}
% counter example, different repr in doc but appearance important? not very
% likely

% maybe when both are succesful do  highest, and if only high is successful then
% unclear.

In case of ambiguity, an edit operation is performed by default on the highest possible level. For the date example, the appearance of the date changes but the meaning is preserved. In the Haskell example, the delete operation takes place at the document level and the comma is removed as well. However, the ideal choice of the target level may vary for different editor instances, because the usability of the editor is not only determined by the consistency of the underlying edit model, but also by the habits of a user. It is not unthinkable that a user finds it strange or annoying when a comma automatically disappears in a source editor. 

There are several alternative ways to handle ambiguities. Firstly, backspace and delete operations, which are mainly used for deleting characters, could always be interpreted as presentation edit operations, while cut, copy, and paste may be document operations that automatically insert and remove commas. Secondly, a document delete operation may cause the creation of a volatile placeholder, which disappears when the focus is changed. When a list element is deleted, a comma remains, but changes color. If the user starts to type, the comma changes back to the text color, whereas if the user changes the focus, the comma disappears completely. Finally, a source editor may simply give priority to presentation editing over document editing. 

Practical experience with several editor instances is required to decide what is the best choice of the target level in case of ambiguity. In any case, a user can always override the automatic choice made by the editor, possibly after first performing an undo.

\note{Mention other copy/paste algorithms, including Lamberts generalized paste}
%Besides the mentioned forms of handling copy and paste. The generalized paste algorithm %\cite{MeertensGeneralizedPaste} \cite{roisin97cutPaste}

% Word processing?
% Popup menus, buttons, etc?


%																
%																
%																
\section{Focus model} \label{sect:focus}
\bc
FOCUS IS NOT ENTIRELY RIGHT! elts can be  in focus, lists can't. Find out whether this is a problem or not.
\ec


\bc
is this linked to consistency between levels?
The ambiguity is mainly a focus question, as it is not clear how what exactly is in focus, the lower or higher level structures. Focus is as high in the level structure as possible.

What about the clipboard?
different high than in tree.

In fact, the ambiguity examples from the previous section are problems with the ambiguity of the focus
\ec

\bc modeless & levels. Focus on diff. levels. When edit op on one level needs that focus, interpret it. Problem Doc focus not always visible in pres, and pres not always sensible on doc. ES further complicates it
\ec


\bc Old
Because Proxima is a modeless editor, the concept of focus exists simultaneously on several levels.  Similar to the way in which the presentation and interpretation processes maintain a mapping between each pair of adjacent levels, a mapping between the foci on adjacent levels is maintained. 
\ec

The property of modelesness has several consequences for the focus model. Since edit operations on different levels may be mixed, a navigation operation on one level can be followed by an edit operation on a different level. For example, after textually selecting an subexpression in an equation editor (eg.\ "2*(3+4)"), a document level transformation may be applied (eg.\ a distribution transformation, yielding "2*3+2*4"). This means that the layout level focus (the textual selection) must be mapped onto a document level focus, before the transformation can be performed. A similar thing happens when a lower level edit operation is performed after a higher level navigation operation. Therefore, it must be possible to map focus on one level onto focus on another level without user intervention.

Proxima handles focus by keeping a separate focus on each level. Whenever an edit operation on a certain level changes the focus on that level, the focus for the rest of the levels is recomputed. For levels above the edited level, the focus is interpreted, whereas for levels below, it is presented.

This section explains the issues that come into play when maintaining the focus on different levels. Since only a prototype focus model has been implemented, the model is still preliminary and requires further research as well as practical experience from building and using editor instances. 

 
%																
\subsection{Focus on one level}

\begin{figure}
\begin{small}
\begin{center}
\begin{verbatim}
* denotes focus

  A*        A     |      A*
 / \       / \    |     / \
B*  C*    B*  C*  |    B   C*
                  |
correct           | not possible (because B is not in focus)
\end{verbatim}
\caption{Non-list node focus examples (draft)}\label{correctIncorrect focus} 
\end{center}
\end{small}
\end{figure}

Focus is modeled as a property of each node in a level, which stored in the node itself. This distributed representation of focus is chosen in order to be able to restore focus, after a level is structurally updated during interpretation or presentation. If focus is kept track of outside the data level tree structure, then after restructuring the tree, it is difficult, if not impossible to update the focus accordingly. However, if focus is a property local to the nodes, then even after restructuring, the old focus may be retrieved. Hence, if a global transformation on the document would reorder 

In Proxima, the issue of focus is especially important because of the presence of derived values in the presentation, and the possibility of mixing edit operations on different levels. Derived values may cause the presentation to structurally change while editing it, for example because a type signature is inserted in front of a typed function definition. Furthermore, parsing an edited presentation may cause some parts to be transformed slightly (eg.\ \verb|->| may change to $\rightarrow$). In such cases, the presentation focus, or more precisely the layout focus, may not change.

The focus model makes a distinction between list nodes and non-list nodes. For a non-list node, focus is modeled as a boolean property specifying that the node and its children are in focus (see Figure~\ref{correctIncorrectFocus}). As a consequence, it is not possible for a parent node alone (ie. without its children) to have focus, but it is possible for the children of a parent to have focus, without the parent being in focus (the second example in Figure~\ref{correctIncorrectFocus}).

For a list, the focus is not a boolean property, but rather a set of ranges of children that are in focus. The entire list element is in focus if the set contains one range that spans all elements, and the list element is not in focus if the set of ranges is empty. The set may also contain empty ranges that correspond to insertion points in the list. Figure~\ref{listFocus} shows a list element with three ranges that are in focus. The first range spans elements \verb|B| and \verb|C| (but not \verb|A|), the second range is an empty range between elements D and E, and the third range contains only element F. Note that although \verb|B|, \verb|C| and \verb|F| have focus, since they are part of a range that is in focus in the parent, it is not the case that elements in unfocused ranges may not have focus. For example, \verb|A| has focus, even though it is not part of a focused range. 

\begin{figure}
\begin{small}
\begin{center}
\begin{verbatim}
          >-------<  >-<  >---<          
      [   ,   ,   ,   ,   ,   ]
        |   |   |   |   |   |
        A*  B*  C*  D   E   F*

\end{verbatim}
\caption{List with three focused ranges of length 2, 0, and 1(draft)}\label{listFocus} 
\end{center}
\end{small}
\end{figure}

%optional elements?

The focus properties of all elements on a data level together constitute the focus on that level. Because only a subtree or a range in a list of subtrees can be in focus (as opposed to single parent element without its children), the focus can also be regarded as a set of subtrees and ranges of subtrees. One of these subtrees or ranges is the main focus, which is used for edit operations that are not clearly defined on a multiple focus, such as insertion.

An implementation of the focus model also needs to support for each node a property that states whether a descendent of that node has focus, regardless the focus of the node itself. This is necessary in order to be able to access focused subtrees without having to traverse the entire data level. Focused subtrees can be located by starting at the root of the level and following the paths of nodes that have descendents in focus.  In case a level has been edited, changed parts need to be traversed in order to find any nodes with focus or focus in descendents, after which the old focus can be restored, if desired.


%																
\subsection{Navigation}
\note{add examples and pictures?}

Just as any other edit operation, a navigation operation may be targeted at various levels in Proxima. However, unlike the other edit operations, a user explicitly specifies the level on which navigation takes place. Pressing arrow keys and clicking with the mouse results in navigation on the layout level, whereas a modifier key (shift, control, or alt) can be used to navigate on the document and enriched document levels. \bc More exotic navigation operations such as selecting rectangular areas in the arrangement navigation are available through menus. \ec Furthermore, a presentation element may bind a mouse click to an edit operation, and hence also to a navigation operation. Clicking in a presentation may therefore cause the focus not to be moved to the clicked element, but somewhere else. For example, a mouse click on a type error in a Haskell editor may move the focus to the location of the error in the source.

Currently, only those levels that are directly editable (document, enriched document and layout) support navigation. Even though the presentation, arrangement and rendering levels have a focus, it is not directly editable and can only be changed by navigating on one of the other levels. However, a future version of Proxima may support arrangement navigation in order to allow column selections (see also Section~\ref{sect:editArr}).

Because of the different characteristics of each level, different kinds of navigation operations are used. On the document and enriched document levels, navigation is mainly tree oriented: absolute, by focusing on a specific subtree, or relative to the current focus, by moving up and down to parent and child elements, or left and right to sibling elements. The layout level consists mainly of rows and columns that have lists of children, and of strings, which are lists of characters. Focus on the layout level therefore consists mainly of ranges in lists. Relatively moving the layout focus means changing it to an adjacent empty range, and has to take into account whether the parent is a row or a column. Tree navigation is not a common operation on the layout level.

\note{mention widening of focus? (shift-arrows \& shift-click)}

Formatter elements of the presentation level, which are used for line breaking (see Section~\ref{presLevel}), are a special case in navigation. In a formatted paragraph, horizontal navigation is targeted at the presentation level; a focus move to the left or the right always goes to an adjacent element in the presentation level, whereas on the layout level, it may jump to a different line. On the other hand, vertical navigation is interpreted at arrangement level; the focus moves to an adjacent line and the horizontal position is maintained as close as possible. This operation cannot be performed at the layout level due to absence of position and line information. 
%\note{mention that nested formatters make it trickier, but still possible?}
 
 
%																
\subsection{Presenting and interpreting the focus}

\bc
Stress that presentation as focus is not always nec. For presentation editing, it is nice, but sometimes doc
focus will have a presentation of its own (actual pres, not focus). For example. Tree, where in between two nodes a line is shown where paste would be. This is not just a presentation focus, but a presentation element.
\ec 

Higher levels can contain information that is not present in lower levels (eg.\ part of a document that is not presented), and lower levels can contain information not present in higher levels (eg.\ whitespace), or in other words, a mapping between the focus from one level onto another can be partial and therefore does not always have an inverse. Therefore, it is not possible to keep track of the focus at a fixed level. If focus is kept track of in the higher levels, focus on whitespace cannot be modeled, and analogously, if focus is kept track of in a lower level, then focus in non-presented parts of the document cannot be modeled. Hence, we keep track of the focus simultaneously at all levels. 

When the focus changes on one level, it is updated on the other levels in the same way as the data levels are updated; it is {\em presented} and {\em interpreted}. The presentation of a focus is the computation of a lower level focus from a higher level focus and hence can be seen as having a downward direction, whereas the interpretation of a focus is the reverse computation of an higher level focus from a lower level one. Because each level has a focus, each layer maintains a focus mapping, hence the higher and lower levels mentioned in this section may denote any pair of adjacent levels. By presentation in this context we mean the mapping from a level to an adjacent lower level. It can denote any of the downward mappings in the presentation proces (Section~\ref{sect:presprocess}): evaluation, presentation, layout, arrangement, or rendering.

The difference between presentation and interpretation of the focus on the one hand, and presentation and interpretation of the data levels on the other hand, is that the latter form a cycle, whereas the former do not. After a focus update, focus on the levels above is computed by interpreting, and on the levels below by presenting, but both are only one way processes. Unlike a data level, a interpreted focus is not presented again, and the presented focus is not interpreted. Figure~\ref{focusUpdates} shows a sequence of focus updates on respectively the enriched document, layout, and document levels, and the resulting updates on the other levels. After each update, first the focus on higher levels is recomputed, and then the focus on lower levels. The reason for this order is that the process follows the cycle of presentation and interpretation on data levels, as explained in Section~\ref{sect:editDifferentLevels}.


We use a simplified presentation and interpretation for focus because of  the partial nature and possible lack of inverse of the focus mapping, or in other words, because focus on one level cannot always be represented by focus on another level. For example, when an if expression is partly selected in the layout level ("{\tt \frame{if c then}\verb| 1 else 2|}"), the corresponding \verb|If| node in the enriched document level is not in focus. However, when the enriched document focus is presented, it should not cause the layout focus on half of the expression to disappear. In order to handle the situation, focus would have to be considered as extra state and be reused when it cannot be computed. However, such a complex model of focus requires more research and implementation. Therefore, Proxima uses a simplified model. \note{can't seem to think of any cases in which this model does not work well} 
\note{Mention weird effects in some cases when mixing navigation on different levels? (happens also with other model)}
\note{It's a bit more complicated, focus is ES after all (will fix this later)}

\begin{figure}
\begin{small}
\begin{center}
\begin{verbatim}
Doc: --          /------           /----- update -------
Enr: --- update --------          /------         \-----
Pre: --            \----- update --------          \----
Lay: --             \---             \---           \---
Arr: --              \--              \--            \--
Ren: --               \-               \-             \-

Legend:     ---: focus     /: interpretation     \: presentation
\end{verbatim}
\caption{Focus updates on different levels}\label{focusUpdates} 
\end{center}
\end{small}
\end{figure}


% extra mapping info is used
Between each pair of adjacent levels, Proxima keeps track of exactly which element is mapped onto which during presentation and interpretation.  One higher level element may be mapped onto several lower level elements, or none if the element is part of the higher level's extra state. On the other hand, a lower level element may be mapped onto at most one higher level element (or zero if it is part of the lower level's extra state). The information about the mappings is used when presenting and interpreting the focus. Note that when saying that an element is mapped onto elements in another level, we regard the elements separate from their children. Thus, an element can be mapped onto another element without being mapped onto its children, or only on some of its children. Figure~\ref{elementmapping} shows an element A, which is mapped onto \verb|A1|, \verb|A2|, and \verb|A3|, even though \verb|A1| is the only root. \verb|A| is not mapped onto \verb|B1| and \verb|C1|, since \verb|B1| and \verb|C1| come from respectively \verb|B| and \verb|C|.  

\note{somewhere: forward ref to single layer}
\begin{figure}
\begin{small}
\begin{center}
\begin{verbatim}
document         enriched document

   ...................> A1
  A                  / /  \  \ 
 / \                / |    |  \ 
B   C              A2 |    |   A3
.                     B1   C1  
...................../ \  / \
                     ---  ---
\end{verbatim}
\caption{Element A is mapped onto A1, A2 and A3(draft)}\label{unpresentableFocus} 
\end{center}
\end{small}
\end{figure}

Basically, if a higher level element is in higher level focus, then all lower level elements in its presentatation are in lower level focus. Vice versa, a higher level element is in higher level focus, if all lower level elements of which it is the interpretation, are in lower level focus. 

\bc
The asymmetry is caused by the fact that one higher level element may be presented on several lower level elements, whereas one lower level may only be interpreted***sentence not right*** to a single higher level element.
\ec

\bc MAYBE WE CAN REUSE THIS ONE?
Because of the subtree restriction on focus, an element can only be in focus if all its children are in focus as well. \note{mention homomorphic?} A consequence is that if a presentation of a higher level element \verb|A| contains a descendent which is the presentation of a higher level element that is not a descendent of \verb|A|. Figure~\ref{unpresentableFocus} shows an example. The \verb|C| node is in document focus, and is mapped onto \verb|C'|. However, \verb|C'| contains \verb|B'| which has no enriched document focus since it is the presentation of document node \verb|B| that has no document focus. Therefore \verb|C'| does not have enriched document focus in this case. Although an editor designer can override automatic focus computations for such special cases, it may be desirable to have a more relaxed focus model, in which a node can be in focus even when its children are not. This \note{mention that more research is req'd?}
% token press don't suffer from this because they are not trees

\begin{figure}
\begin{small}
\begin{center}
\begin{verbatim}
document         enriched document

  A                  A'
 / \                 |
B   C*...............C'
.  / \              /|\
. D*  E*          D' E' B'
.                    .
......................    
\end{verbatim}
\caption{Document focus that does not show in enriched document (draft)}\label{unpresentableFocus} 
\end{center}
\end{small}
\end{figure}
\ec

% switching
\bc When doing doc nav and then layout nav, lose info. maybe fix with full, but desired edit behavior is not exactly clear yet.
\ec

%list focus
List elements form a special case in the focus presentation and interpretation process. If the elements of a list on one level are mapped onto elements of a list of equal length on another level, while preserving the order, then the focus ranges can simply be copied. If the the list is mapped onto a list that has different lenght or is reordered, then the editor designer must provide a function that maps ranges in one list onto ranges in the other. If a list is mapped onto a structure that is not a list, or vice versa, then focus handling is left to the editor designer. If no mapping is provided, then the focus cannot be interpreted as a focus for the other level. For example, when the presentation focus is only on a "then" token in an if expression, there is no corresponding enriched document focus.


%																
\subsection{Extra state focus}

The proposed focus interpretation mapping is not ideal for handling focus in extra state. Because extra state in a lower level often represents non-essential information, it can be useful when focus on the extra state is not considered when computing the higher level focus. However, a lower level element can only have focus if all its children, including extra state children are in focus. As an example, consider Figure~\ref{extraStateFocus}: the enriched document element \verb|Int 173|, with a presentation \verb|IntToken (0,2) 173| and corresponding layout level \verb|"|\textvisiblespace\textvisiblespace\verb|173"|. If the \verb|'2'| and only part of the preceding whitespace is in layout focus ({\tt \textvisiblespace\framebox{\textvisiblespace 173}}), then the presentation focus will include the \verb|173| child of the token, but not the whitespace child \verb|(0,2)|, since its layout is not entirely in focus. Therefore, the \verb|IntToken| parent cannot be in focus either, which in turn means that the \verb|Int| element is not in enriched document focus. 

\begin{figure}
\begin{small}
\begin{center}
\begin{verbatim}
enriched document     presentation      layout

   Int*                IntToken     
    |                    /  \    
   173*               (0,2)  173*       "  173"
                                          ****
\end{verbatim}
\caption{Focus in extra state (draft)}\label{extraStateFocusunpresentableFocus} 
\end{center}
\end{small}
\end{figure}

% solution
For this whitespace example, the problem can be solved by ignoring the whitespace of a token during interpretation of the focus, and regarding a token to have focus, also if only its right child has focus. However, in general, a more complicated method is required, which will not be discussed here \note{or do we need to? It requires another picture and maybe the problem will never be an issue}, since it must be determined whether it is actually necessary to have a focus interpretation method that ignores extra state. \note{mention other direction? Problem won't appear due to 1:n property of presentation, but this is bit tricky to explain}

\bc
solution is to ignore ES, but must be done during interpretation, eg:
  N       nn cc nn esc
C ESC 

now if nn cc nn has focus, N does not have focus and C has. however impossible to say from this whether N has non-ES focus. since cc gives same. Hence, during interpretation, give N a NES if children have focus, or are ES, and all its presentation has focus.
\ec

\bc
way back does not seem to know the problem because never two non ancestor related nodes can influence one pres (1:n prop). So only if (Node Child ESChild), then both children must be in focus, but easy, just navigate focus to parent (which is not possible in interpretation dir, because no shared parent)
\ec

\bc OBSOLETE: we have a better solution
In order to disregard the extra state focus, the relaxed focus model that was mentioned before may provide a solution. If each element can have focus regardless of its children, we can define an element to have {\em non-extra focus} if both it is in focus itself, and its non-extra state children (with regard to the considered direction: presentation or interpretation) recursively have non-extra focus. However, further research is required to establish the exact details of this focus model, as well as its necessity.
\ec

%																
\subsection{Focus ambiguity}

Besides ambiguity concerning the level at which an edit operation is targeted, there can also be  ambiguity regarding the element that is in focus on a single level. If a parent element does not have any presentation elements of its own, then there is no difference at the lower level between the selection of its children alone or the selection of the children together with the parent. An example is the following fictitious element (\verb|Italic (Word "bla")|) of a word processor editor. It is presented as {\it bla}. If the focus is in front of the first letter, it is not clear whether it is inside the italic region or not. 

Focus ambiguities can be partially solved by letting the focus depend on the direction from which the focus was navigated. For the example, this means that if the focus came from the right (between the 'b' and the 'l' characters), it is inside the italic region, whereas if it came from the left, it is outside. However, as soon as more than two levels of ambiguity exist, for example with (\verb|Bold (Italic (Word "bla"))|), this strategy is no longer sufficient. In such a case, the user needs to use a more structural view if the desired navigation is not possible in the regular view.


A related kind of ambiguity arises when the enriched document type

\small \ttfamily
\begin{tabbing}
data Exp$_{\Enr}$ = IdentExp$_{\Enr}$ Ident$_{\Enr}$ | \dots \\
data Ident$_{\Enr}$ = Ident$_{\Enr}$ String
\end{tabbing}
\rmfamily \normalsize

has a presentation such that the expression \verb|IdentExp (Ident "x")| is presented only as the lower case token \verb|"x"|. If the token is in presentation focus, it is unclear whether the enriched document focus is on the string, the identifier, or the expression. The problem can be approached by either merging the possible edit operations for each of the possibilities, or by specifying in the presentation sheet which alternative should get the focus. The Cornell Synthesizer Generator (see Section~\ref{sect:synDirEditors}) employs the latter solution and denotes the element that receives the focus as a {\em resting place}. For Proxima, no final choice has been made, since the merging solution still requires further research.

\bc
resting place correct?

is this also the comma thing? Or can we make it so?
What does this have to do with the focus interpretation mapping? Shouldn't that select all possible foci?

can we use some kind of post-processing phase that finds ambiguities left and right, after level focus is established?

what about moving in row [row [row [1,2,3]]] , ambiguities must be skipped. 
\ec

Until now, we assume that an edit operation works on the element that is in focus. However, in some cases, it is useful if ancestors of the currently focused element can be edited. For example, when the focus is somewhere in a chapter, but not on the entire chapter, it is still useful to be able to perform chapter specific edit commands and transformations for that chapter. Similarly, we want to be able to select or move a declaration by clicking somewhere in its presentation. Therefore, apart from the edit operations on the currently focused element, Proxima also gives access to the edit operations on its ancestors. 
% maybe with popups or something similar.


%																
%																
%																
\section{Bypassing higher layers} \label{sect:bypassingLayers}

During editing, it is possible to temporarily skip updates on higher levels. The main reason for this is efficiency, but in some cases it also increases the usability of the editor. An example of the efficiency reason is that when a user is typing program text, the invocation of the parser can be postponed until the user inserts a whitespace character or performs a navigation. However, even when a higher layer is not computationally expensive, it may be desirable not to invoke it on every edit action because the constantly changing presentation may be confusing for a user. For example, when a field in a tax form editor is changed by typing a number, it may distracting to see the computated fields updated on every key press.

When one or more higher layers have been skipped, the data levels may not be consistent with regard to the presentation and interpretation mappings. The level of consistency of a presentation is shown to the user. However, this does not mean that the editor has different modes, because it is always possible to enforce that all layers are invoked. If a higher level edit operation is issued, the intermediate layers are first invoked in order to guarantee consistency. Because it must be possible to complete the entire interpretation process, no layer may fail if a problem is encountered; a layer must always produce a higher level. Therefore, an error correcting parser is used at the presentation level. Even if the layout contains a parse error, the parser still returns an enriched document in which incorrect parts are marked. The parser can be tuned to help keep an error as local as possible in the tree.

\note {explain better why this is not a mode switch?} \note{also talk about scanner and evaluator?}

*** Should there be a conlusions section? ***

*** Should we say more about: ***
\begin{itemize}
\item Multiple document views/presentations?
\item Local/extra state and the structure watching behavior following from it?
\item The fact that focus for duplicate presentations is not investigated yet?
\end{itemize}


\bc
what if evaluation is impossible?

Figure out when to parse when to evaluate. And how to signal that old evaluation results are no longer valid. Helium is a good example. During editing, we do want to see type info.

\section{Multiple document views/presentations}
 
Single presentations may already have several views, multiple views should be trivial, is  this true?

Splitting is possible at several layers.

\section{Generalized paste}    % only if we have time

Copy/Paste on pres and doc level. (Generalized paste)

\section{?Editing partial presentations}
\note{Partial is a bit weird}

Structure watching for free.

A partial presentation is parsed as the whole thing. Duplications also here?

big parts not implemented. So no hard evidence. Anyhow Proxima allows many different  things. 
\ec