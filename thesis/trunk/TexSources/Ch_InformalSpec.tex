\chapter{Specifying a layered editor}
\label{chap:informalSpec}
\note{chapter title?}


\newcommand{\spc}{\textvisiblespace}

\newcommand{\fn}[1]{{\ensuremath{\mathsf {#1}}}}

%\renewcommand{\present}{\ensuremath{\mathit{present}}}
\renewcommand{\present}{\fn{present}}
%\newcommand{\interpret}{\ensuremath{\mathit{interpret}}}
\renewcommand{\interpret}{\fn{interpret}}
\renewcommand{\core}{\fn{core}}
\newcommand{\default}{\fn{default}}
\newcommand{\valid}{\fn{valid}}
\newcommand{\close}{~\text{``close to''}~}


% not used, so we redefine these commands
\renewcommand{\H}{_{\, \mathrm H}}  % old \H seems to put '' above the next character
\renewcommand{\L}{_{\, \mathrm L}} % was an L with a dash in the middle
\newcommand{\M}{_{\, \mathrm M}}
\newcommand{\HH}{_{\, \mathrm {HH}}} 
\newcommand{\HL}{_{\, \mathrm {HL}}} 
\newcommand{\LH}{_{\, \mathrm {LH}}} 
\newcommand{\LL}{_{\, \mathrm {LL}}} 
\newcommand{\CH}{_{\, \mathrm {CH}}} 
\newcommand{\CL}{_{\, \mathrm {CL}}} 
\newcommand{\C}{_{\, \mathrm C}} 
\newcommand{\Eqclass}[2]{{#1}\!/_{{#2}}}
\newcommand{\eqclass}[2]{[{#1}]_{{#2}}}  % maybe pad [] with \' spaces?
\newcommand{\Eqcl}[2]{\Eqclass{#1}{_{\!\!{#2}}}}
\newcommand{\eqcl}[2]{\eqclass{#1}{\!_{#2}}}
\newcommand{\eqstar}{\ensuremath{\simeq}}
%\newcommand{\eqstar}{\ensuremath{\stackrel{*}{\simeq}}}
\newcommand{\Eqstarcl}[2]{{#1}/_{\!\eqstar {\mathrm {#2}}}}
\newcommand{\eqstarcl}[2]{[{#1}]_{\!\eqstar {\mathrm {#2}}}}
\newcommand{\eqhole}{[\hole]} % \eqcl{\hole}{} gets wrong spacing

\newcommand{\eqr}{\ensuremath{\simeq}}
\newcommand{\reuz}{\ensuremath{\triangleright}}
\newcommand{\reuze}[1]{\ensuremath{\,\reuz_{_{\!\!#1}}\,}} % rm prevents {\sc $\reuzestar$} from changing the *
\newcommand{\reuzestar}{\ensuremath{\,\overlay{\protect\raisebox{0.3em}{\rm \:\:\scriptsize *}}{\reuz}\,}}
%\newcommand{\reuzestar}{\ensuremath{\stackrel{ * }{\reuz}}}
\newcommand{\rel}{\ensuremath{\sim}}
\newcommand{\law}[1]{{\sc {#1}}}


\newcommand{\is}{\widehat{=}} % instead of {\stackrel{\wedge}{=}}
\newcommand{\gts}{\text{\tt :=}}
\renewcommand{\gets}{~\gts~}
\newcommand{\smi}{\text{\tt ;}}
\newcommand{\semi}{\smi~}
\newcommand{\assert}[1]{\{ \ensuremath{#1} \}}
\newcommand{\hoare}[3]{{\assert{#1}\:{#2}\;\assert{#3}}} % #2 is italic, so space looks bigger

\newsavebox{\wpbox}
\sbox{\wpbox}{$\wp$}
\newcommand{\powerset}{\usebox{\wpbox}}
\renewcommand{\wp}[2]{\fn{wp}(#1,~#2)}







{\em *** Version: \today~ ***}

%reorganizing Chapter 5

\bc
Introduction

Proxima is levels with layers in between.
Here we specify the types of the levels, and what functions between them.

The defs hold for all layers and levels, although some special cases.

Renderer is implemented as tree, but
\ec




\bc

?? mention that in the process of refinement, only the last step makes sense? Direct/indirect edit ops etc. from previous chapters is not made here, and breaks invariants. Will (hopefully) be fixed in next chapter.


Duplications somewhere else? Only in evaluator.
mapping toc, two arrows, one to each group
be clear on when mapping is required. Only if lower has ls. back only if partial pres?



TODO
check super & subscripts in figures and text: h/high h,intr or h_intr, etc.

SOMEWHERE: mappings important for extra state, but also for editing on several levels. (is this really true?)

MAPPING INFO INCONSISTENCY: figure out how to express that two cycles are needed to restore it.
                                                  %is probably related to edit ops starting at higher level
ALSO ALL IS ON TREES, for other things, eg, sum of leafs, it does not work, do it yourself
EXTRA STATE, also tree ordering? precedence op tree -> non ordered op tree?
SOMEWHERE, explain why this is all necessary, refer to Editing Chapter


***EXTRA STATE is based on invariant mapping, however, implemented mapping is from level to level
***EXTRA STATE is only possible when inc. because lev, cannot be derived, or maybe only store extra?

** SOMEWHERE. pres is typically just for viewing: no big problem when destroyed
** intr is more essential. bigger problem when destroyed.
** guarantee no loss, so only limited edit func. on toc.

interpretation is bit strange as edit ops can be on higher level
* could this also be the case with presentation?


!what about sheets? 

SOMEWHERE: FOCUS more formally (if included then add forward refs to edit model chapter)


IMPL: mapping downward, how to store in doc? Now datatype changes when pres is modified

\ec


%* explain edit steps? Before fitting it all together, we first build one layer

In the layered architecture of Proxima (see Chapter~\ref{chap:proxArch}), each layer maintain an invariant between adjacent levels. When either the higher or the lower level is changed, the other adjacent level is updated apropriately. The process of updating the levels is largely symmetrical for both directions.

This chapter discusses the invariant that is maintained between adjacent levels from the perspective of a single layer. Furthermore, it specifies the additional information necessary for computing the updates that restore the invariants. The invariants given in this chapter hold for any layer in the Proxima system, although some layers are simpler than the generic layer presented here.



Intro. here an informal description of the concepts and terminology of the formal spec in next chapter. Not Proxima specific. any pres oriented layered editor. Examples are from Proxima.

editingg process (mention levels and layers? .
Also the concept of extra state and which cases  bla, and finally duplicates




% based on a mapping between levels
% add sheets, add extra and add incrementality

\note{somewhere: Stress that mappings are not needed when for subtrees for which the lower level is not editable}
\note{somewhere: Stress that it's only an architecture. Safety, impl. etc is left to layer. Future research (Pierce?)}
%rather than safe toy, complete arch for many ed's Safety and patterns need to be researched

\bc
Where say that mapping back is only when we need automatic editing: is it only important for duplicates? It seems to be important for 2:1 presentations as well.  In some complicated cases, the mapping back cannot be spec'd if mapping back is does not work, it means that lower edit cannot be handled, and is forbidden. However, we always have the higher-level edit left.
\ec




%																
%																
%																
\section{The presentation invariant}
*** mention that levels are trees.

% during editing one of the levels is changed, other changes along. in this section first give updates for entire editor
%, then refine it for layers
An editor maintains a relation between a document and its presentation. We denote the document by $level\H \tp Level\H$, and the presentation by $level\L \tp Level\L$. The relation that is maintained is $\Present \tp  \Level_{H} \rel \Level_{L}$. 

The invariant that the editor should maintain during editing is is that the lower level is a correct presentation of the higher level:

\begin{math}
\text{\bf Presentation invariant:~~~} \level_{L} \Present~\level_{H}\\
\end{math}

The precondition of an edit step is that the presentation invariant holds. The user then modifies the presentation, and most likely breaks the invariant. In order to restore the invariant, the editor updates the document level by interpreting the modified presentation. However, because often a user update does not result in a comletely valid presentation, the document update may not yet restore the presentation invariant. For example, a program fragment may have been entered without proper syntax-coloring, or a chapter title may have been modified in the chapter itself but not in the table of contents. Therefore, to restore the presentation invariant, the updated document is presented again.

Figure~\ref{singleLayerEdit} schematically shows the edit process for one edit step.  Note that the final higher level is $level''\H$ rather than $level'\H$ to enable a consistent notation for final values. Furthermore, in the multi-layered editor, which is introduced in the next section, $level'\H$ will denote an intermediate value for the higher level $level'H$.

The final values $level''\H$ and $level''\L$ satisfy the presentation invariant and are and are the initial values $level\H$ and $level\L$ for the next edit step. In the rest of this chapter, as well as in the next, we use the same notation for the different stages of the data levels.

\begin{figure}[h]
  \hfill
  \begin{minipage}[b]{.45\textwidth}
    \begin{center}   
      \epsfig{file=pics/eps/LayerSimple.eps, height=1.4in} %width = 60mm}
      \caption{Single edit step.} \label{singleLayerEdit}
    \end{center}
  \end{minipage}
  \hfill
  \begin{minipage}[b]{.45\textwidth}
    \begin{center}  
      \epsfig{file=pics/eps/LayerExample.eps, height=1.4in} %width = 60mm}
      \caption{Edit step example.} \label{singleLayerEditExample}
    \end{center}
  \end{minipage}
  \hfill
\end{figure}

%
%\begin{figure}
%\xpr{
%level\H 		&   			&		 & 			& level''\H\\
%~~~\downarrow &   		&		&~\nearrow~&~~~\downarrow \\
%level\L 		&~\leadsto~ & level'\L 	& 			& level''\L\\
%}
%\caption{Single edit step schematically.(draft)} \label{singleLayerEdit}
%\end{figure}

%\begin{figure}
%\xpr{
%Plus~1~x 		&   			&		 & 			& Lam~x~(Plus~1~x)\\
%~~~\downarrow &   		&		&~\nearrow~&~~~\downarrow \\
%1+x 		&~\leadsto~ & {\tt \backslash x~->~} 1 + x 	& 			& \lambda~x~\to~1+x\\
%}
%\caption{Single edit step example.(draft)} \label{singleLayerEditExample}
%\end{figure}

Figure~\ref{singleLayerEditExample} shows the values of the higher and lower levels for an actual example. The document is an expression that is presented in a graphical way, using an italic style for identifiers and mathematical symbols for operators. The presentation of a sum in modified by entering or pasting the text "\verb|\x->|" at the beginning. After the document update, the presentation invariant clearly does not hold. It is restored by re-presenting the document.

Instead of updating the lower level (presentation-oriented editing), a user may also perform an update on the higher level (document-oriented editing). However, because after a document update, the presentation invariant can be restored by simply presenting the updated document, we do not consider document-oriented editing in much detail.


\bc
$\Present$ and $\Interpret$ are not actual functions that can be evaluated, but abstract concepts used to express a property of two levels. The functions are used to specify the behavior of a layer.
Strictly speaking, $\Present$ and $\Interpret$ are not even functions but relations, since a higher level may have several correct presentations, and a lower level may have several correct interpretations. However, this occurs only if a level has extra state, as will be explained in Section~\ref{sect:extraState}. \ec

\bc Because we only look at one layer in this chapter (ie. the layer between $\Level_{H}$ and $\Level_{L}$), we need two more functions to refer to the behavior of the layers below this layer, as well as the layers above. For lower layers, the function 
$\Edit :: \Level_{L} \rightarrow \Level_{L}$ denotes an update on $\Level_{L}$ by the lower layers. For representing updates on the higher level, we use 
$\Transform :: \Level_{H} \rightarrow \Level_{H}$. In the next chapter, when layers are connected, $\Edit$ and $\Transform$ become superfluous.\ec


\head{A layered editor}

% why layers?
In order to describe the layered architecture of Proxima (see Chapter~{chap:proxArch}), we refine the simple editor by splitting the presentation relation. A  $Present$ relation that is split into $n$ components $Present_{0 \dots n-1}$ gives rise to $n+1$ data levels: $level_{0 \dots n}$. Lower levels have increasing numbers, hence $Level_{0}$ is the document level and $Level_{n}$ is the presentation level.

From the perspective of a single layer, we only need to consider a single $Present$ relation and two data levels: $Level\H$ and $Level\L$. Figure~\ref{layerEditProcess} shows the updates during an edit step from the perspective of a single layer. It is similar to the simple editor without layers, except at the top. Instead of directly computing $level''\H$, the layer first computes an intermediate $level'\H$. This $level'\H$ is then processed by the layers above, yielding $level''\H$. At the top of the layered structure, $level'\H$ is copied to $level''\H$. \note{mention: user \rarr lower layers?}

\note{mention doc edit on intermediate levels?}
\note{All intermediate results also go horizontally!}

% can we express when this happens with a condition? pres .. /= pres .. oid?
\bc
The reason why $\level'_{H}$ is not immediately presented, is that it first has to be processed by the higher layers, just as $\level'_{L}$ is processed by this layer. The final value $\level''_{H}$ may be equal to $\level'_{H}$, but certainly does not have to be. Take an enriched document that contains a list of numbers together with the sum of the numbers. When one of the numbers is edited at the presentation level, the new enriched document that results from parsing ($\level'_{H}$) is a list of numbers together with a sum value that is most likely to be incorrect. In order to compute the a sum value, the enriched document needs to be passed on to the reducer and evaluator, resulting in a final enriched document ($\level''_{H}$) that reflects a correct sum.
\ec
\begin{figure}
\begin{small}
\begin{center}
\begin{center}
\epsfig{file=pics/eps/LayerSingle.eps, height=1.4in}
\end{center}\caption{An edit step at one layer.}\label{layerEditProcess} 
\end{center}
\end{small}
\end{figure}
% original layered picture was not very clear.

% why two:
\bc
We use two invariants instead of one, to make it possible to describe the intermediate state in which changes have not been fully propagated upwards and been taken into full account. Consider an editor in which an enriched document node for a product expression (\verb|Product (Int 1) (Int 2)|) is presented as a list of presentation level tokens, colored according to the syntax. The integer values are presented in black, and the operator in green. If we denote the colors between braces, the presentation is \verb|["1" {black}, "*" {green}, "2" {black}]|. Because the presentation level is a correct presentation of the document level, the presentation invariant is satisfied. But now consider a list of tokens typed by the user, which do not have the correct coloring: \verb|["1" {black}, "*" {black}, "2" {black}]|. If we use a single invariant, then expressing that \verb|Product (Int 1) (Int 2)| is an appropriate interpretation of the uncolored tokens list, also implies that the uncolored tokens are a correct presentation of the product expression. It is no longer possible to express that the colored presentation is a correct presentation of the product, whereas the uncolored presentation is not. \note{are we saying that with one invariant, pres is inverse of intr?} \ec



\bc

OTHER EXAMPLE?: Apart from the syntax coloring example, the problem also arises when for example a textual arrow 
\verb|"->"| is presented as a $\rightarrow$. 

Vice versa? Fix by remembering extra?
 layer shortcutting can now be expressed by only letting the lower pres invariants hold

 -explain that in incremental, present and interpret cannot be used instead of Present and Interpret
 -how does this relate to inc with diff etc. maybe that can be expressed nicely with Present
 (or even present, then Present will be superfluous.)

* does   intr.pres = id hold for a layer? pres.intr never needs to hold due to syntax coloring, normalization etc., but also because Chess board is not a presentation of ChessBoard   
* intr.pres = id? then each pres has unique doc. Is this true? Can't doc variants be presented as same thing?
   present( interpret uncolored ) = colored, so present.interpret /= id
   interpret ( present ) = id? if so, what if two docs are presented on the same pres?
 it seems true, interpret.present cycles should not alter the doc. In case of ambiguity, the system should
 take care of conservative behavior. On an edit, the doc may change, but that's not a (interpret.present) cycle

****** When this is figured out, update sheet paragraph
\ec




%																
%																
%																
\section{Extra state} \label{sect:extraState}

%SOMEWHERE: when es is hard. If no parent with a presentation is parent then 
% tricky. Hence invisible elements with extra state may lose it during editing.

\note{specify conditions for safety? like in Pierce's lenses stuff?}
\note{mention Pierce paper?}

In some cases, a lower level contains information that cannot be computed by presenting its adjacent higher level. Similarly, a higher level may contain information that cannot be computed by interpreting the lower level. The information in a level that cannot be computed by presenting, or interpreting an adjacent level, is referred to as {\em extra state} (also see sections~\ref{sect:editingExtraState}~and~\ref{sect:archExtraState}). 

Examples of extra state are the parts of a document that are not presented, or properties of a presentation that are not stored in the document. Because extra state cannot be computed by the mapping function, its previous value is reused, if possible. 

** can go wrong when edited. 
***
\bl
\o if es is absence of an inverse, hard to say much about it.
\o therefore look at specific kind of presentation mappings, for which es is more clearly defined. and give bla
\el
%In this section, we discuss the two give an informal definition of extra state and also sketch how extra state can be reused.
%refine the definitions of the data levels in order to give a more precise definition of this extra state. Furthermore, we specify %what information needs to be kept track of in order to handle extra state.


%This section gives a more precise definition of extra state and specifies how  Furthermore, 
%This section explains : welke info. wanneer gaat het mis. 



%																
\subsection{The Presentation mapping}\label{mappingsInLayer}

% mapping is relation levelH levelL but each two levels express a mapping between nodes.

\bl
\o mapping between trees, specific. also 1:n element level mappig.
\o other mappings possible, but do not allow es handling
\o when there is no es, or when presentation is not editable, no problem.
\el
In the rest of this section, order to discuss extra state, we restrict the presentation relation somewhat. We assume it to be a

We assume presentation relation to establishes a mapping between two levels, which we assume to be tree structures. ****

On presentation, elements in one data level are mapped onto elements in another level. If the presentation relation is a mapping between tree data structures, it can also establish a mapping between the nodes. 

Figure~\ref{nodeMapping} shows an example of such a mapping between two levels. The dotted arrows denote to which lower-level nodes a higher-level node is mapped and vice versa. To reduce the number of arrows in the figure, the lower-level nodes are grouped. Note that a mapping between two nodes only relates the nodes and not the subtrees rooted at these nodes.

In the remainder of this section, we regard $Present$ to be a mapping between trees, which establishes a $1:n$ relation between the higher and lower-level nodes. 

Because the mapping between elements is ??$1:n$, the presentation of a higher-level node may consist of several lower-level nodes, whereas the interpretation of a lower-level node may consist of at most one higher-level node. Note, however, that the concerns only the element mapping; the $Present$ relation between the two levels is still $n:m$.

The restriction to $1:n$ relations** why. logical. doc elt is presented. (mention fold/ag?) Reverse does not happen very often. only some cases. Only for es reuse. pres still possible, just no es. n:m not implemented More experience needed.

What about focus?, is that the reason?
Parser makes it hard to do n:m reuse. For eval layer might be possible already.

** consequences see es section.


\begin{figure}
\begin{center}
\begin{center}
\epsfig{file=pics/eps/mapping.eps, width=2in}
\end{center}
\caption{A mapping between the nodes of two levels.}\label{nodeMapping} 
\end{center}
\end{figure}



%																
%\subsection{The presentation mapping}

\begin{figure}
\begin{center}
\begin{center}
\epsfig{file=pics/eps/presentationEh.eps, width=80mm}
%\begin{verbatim}
%                  ..
%                    \
%..                   EL0
%  \                 ELEL.
%   EH       ->     EL..EL.
%  / \             EL....EL. 
% C...C           EL......EL.
%                EL/\EL.EL/\EL.
%                 /__\   /__\
%                    
%\end{verbatim}
\end{center}
\caption{The presentation of element $E_H$. (make arrows double)}\label{elementPresentation} 
\end{center}
\end{figure}

$\Present$ relates each element of the higher level to zero or more lower-level elements, forming zero or more subtrees with holes. \note{is there a name for 'tree with holes'? eg. 'tree segment'?} Figure~\ref{elementPresentation} schematically shows the presentation of a node ($E_H$) in the higher level. $E_H$ has $n$ children ($C_{H,0\dots n-1}$). The presentation of $E_H$ is a number of trees (although usually just one) that may consist of several nodes. In the figure, the first tree is shown in more detail. It consists of $m$ nodes ($E_{L,0\dots m-1}$), is rooted at $E_{L,0}$. 

The $C_{L,0}$, \dots, $C_{L,l-1}$ subtrees in the lower-level tree are not part of the presentation of $E_H$. Typically, these are the presentations of the children of $E_H$, but in general they can be (part of) the presentation of any element in the higher level. 

Elements that are not related to any element in the other level are part of the level's extra state. This is discussed in more detail in Section~\ref{sect:extraState}.

\begin{figure}
\begin{center}
\begin{center}
\epsfig{file=pics/eps/presentParenSum.eps}
%
%  ( )       Tk   ( 1+2 )
%   +      Tk ...
%  1 2       .....  
%
\end{center}
\caption{The presentation of a parenthesized sum.}\label{presentExample} 
\end{center}
\end{figure}


%removed story about whitespace extra state
Figure~\ref{presentExample} provides a more concrete example of a presentation, taken from a source editor (see Section~\ref{sect:sourceeditor}). A parenthesized sum in the enriched document is presented as a list of tokens, which are represented by strings.  The figure shows only part of the enriched document and its presentation. To the editing user, the expression will appear as "{\tt (1+2)}". The example is somewhat simplified, because it does not contain whitespace, which is part of the presentation extra state and will be discussed in Section~\ref{subsect:extraState}.

\bc  why is this one commented?
In the example, the resulting presentation is a single tree, but this is not always the case. For example, the evaluation layer in a word processor (see Section~\ref{sect:wordprocessor}), maps each chapter onto an entry in the table of contents, as well as onto the presentation of the chapter itself. Hence, the presentation (in this case the evaluation) of a chapter consists of two separate enriched document trees.
\ec






%																
\subsection{Extra state elements} \label{sect:extraState}

\bl
\o es are the ones without an incoming arrow.
\el

\bc
during is not okay+ levels benoemen, want er wordt vaak heen en weer gesprongen.

% One layer: two kinds of extra
Since a presentation of an element may consist of zero or more elements, and an interpretation consists of at most one, it is possible that an element is not mapped onto any elements in the target level. In that case, the target level simply does not contain the information needed to compute the element**iets specifieker**, and hence it ** what ** is part of the former level's extra state. Because whether or not a node is extra state depends on which mapping we consider, we distinguish two kinds of extra state: presentation extra state and interpretation extra state. The {\em presentation extra state} consists of elements that during presentation cannot be computed from the higher level (the shaded elements at the top level of Figure~\ref{layerExtraState}), and the {\em interpretation extra state} consists of elements that during interpretation cannot be computed from the lower level (the shaded elements at the bottom layer of the figure).
\ec


% example pres extra
Figure~\ref{layerExtraState} shows two examples of extra state, one occurring on presentation, and the other on interpretation. On the left-hand side, an enriched document node is presented as a token. The shaded whitespace node (0,1) is not specified by the presentation mapping, and hence is part of the lower level {\em presentation extra state}. On presentation, tokens are reused, causing the whitespace information to stay the same. In order to do this, we need to know exactly on which presentation elements an enriched document node was mapped when it was previously presented. In case a token has no previous whitespace, for example because it is the presentation of an enriched document part that has not been presented before, a default value is used.

\begin{figure}
\begin{center}
\begin{center}
\epsfig{file=pics/eps/presIntrESExamples.eps, width=125mm}
\end{center}
\caption{Two examples of extra state.} \label{layerExtraState} 
\end{center}
\end{figure}

% example intr extra

The right-hand side of Figure~\ref{layerExtraState}\note{don't use Extra and \Core already in this figure} shows an example of {\em interpretation extra state}: a word processor with an editable table of contents view. A document level chapter is presented only partially on the enriched document level, since the content of the chapter is left out. For sake of simplicity, we assume that the enriched document only contains the table of contents and not the chapters themselves. This way, we only have to consider the extra state here and not the duplication (titles appearing in the table of contents as well as in the chapters). Section~\ref{mappingsInLayer} discussed how to handle duplications in general, and the same method can be used for the table of contents.

On reduction, the table of contents is mapped back onto a complete document, including the shaded content parts that are not in the enriched document. The title of a chapter comes from the entry in the enriched document, whereas the content is reused from the chapter of which the entry is the presentation. 

\note{mention that intr ES is more important then pres ES here?}


% even with pres, there can still be extra state
Even if an element $E_H$ is mapped onto one or more elements in the lower level, it can still be part of the extra state if these lower-level elements do not constitute enough information to compute $E_H$. Consider for example a presentation of a Haskell source, in which al integers are presented with the string \verb|{Int}|. The integer nodes do have a presentation, but since it does not contain enough information for the backward mapping, the integer nodes are in interpretation extra state. \note {Is this also the case for focus?} \note{Don't know much about this kind of ES yet}
%%%

An important point to note is that extra state with regard to a certain mapping is extra state for the {\em result} type of the mapping. Hence, presentation extra state for a presentation mapping between $\Level_{H}$ and $\Level_{L}$ is in $\Level_{L}$. Vice versa, interpretation extra state is in $\Level_{H}$.

\bc Although the term presentation extra state of $\Level_i$ may suggest that this concerns state that is used during the presentation of $\Level_i$, this is not the case. The extra state of $\Level_i$ refers to the extra state with regard to the presentation of the level above ($\Level_{i-1}$) on level $\Level_i$. The only extra state that is involved in the presentation of $\Level_i$ is that of its lower neighbor: $\Level_{i+1}$
\ec


%																
\subsection{One level has two kinds of extra state} \label{sect:oneLevelDoubleES}

% One level: two kinds of extra
Figure~\ref{layerExtraState} only shows one layer, but since each data level except the document and the rendering is in between two layers, each level between the document and the rendering has two kinds of extra state. Figure~\ref{levelExtraState} shows a data level between two layers. At the medium level, a shaded left or right half denotes that an element is extra state. Elements with a shaded left half are presentation extra state for the higher layer, and elements with a shaded right half are interpretation extra state for the lower layer. Extra state in one direction is independent of extra state in the other direction, hence an element in the figure can have zero, one, or two shaded halves.

\begin{figure}
\begin{center}
\begin{center}
\epsfig{file=pics/eps/3levelES.eps, width=125mm}
\end{center}
\caption{Presentation and interpretation extra state in one level.}\label{levelExtraState} 
\end{center}
\end{figure}

% example one level independence of es
The whitespace extra state in tokens shows that extra state in one direction is independent of extra state in the other direction. Whitespace is presentation extra state of the presentation level, since it cannot be computed when presenting the enriched document. On the other hand, when scanning, whitespace in tokens is computed from strings and line breaks in the layout level. Hence, whitespace is not interpretation extra state of the presentation level.

\note{also example of one level with both kinds of extra state? Will be somewhat contrived}


\bc
When the scanner layer interprets the layout level, spaces and row transitions between a token's string and the preceding token's string are encoded as whitespace information in the token. Since it can be computed during interpretation, the whitespace is not part of the interpretation extra state. On the other hand, when the enriched document is presented on tokens in the presentation level, the whitespace information cannot be computed, and hence it is part of the presentation extra state of the presentation level.
\ec

\subsection{Reusing extra state}

\bl
\o reuse. when computing lower or higher, take es from previous.
\el

********* Mapping info:
\bl
\o can go wrong. + -> *
\el
\bl
\o responsibility of keeping mapping information is in layer.
\o more sophisticated, more reuse.
\el

When a level is updated and subsequently presented or interpreted, yielding a target level that contains extra state, the extra state from the previous value for the target level must be reused. However, the new value of the target level together with its previous value do not always provide sufficient information for reusing the extra state. For example, when a list of integers that is presented as a list of tokens with whitespace has been reordered, the tokens in the whitespace must be reordered correspondingly.  In order to do so, the layer needs to keep track of additional information about the mapping.

For each target level node that is not extra state, we keep track of its origin in the source level. Thus, when presenting a higher level ($\Level_{H}$), each node in the presentation ($\Level_{L}$) contains a reference to the higher-level whose presentation it is part of. Similarly, when interpreting a lower level, each resulting $\Level_{H}$ node has references to the lower-level nodes of which it is the interpretation. 

\subsection{Limitations of extra state (name ?)}

Problem withfor n:m stuff:

%%% stuff on 1:n vs  n:m
\bc
A consequence of the difference between the presentation and the interpretation mappings is that even when a lower-level element depends on several higher-level elements, only one is responsible for its presentation. For example, when an element \verb|Word Color String|, representing a colored string, is presented as a string in the specified color. Now the string in the presentation is presentation of \verb|Color| as well as of \verb|String|. However, only one of the two can be the interpretation of the . In order to edit the color
\ec

Is IntExp interpretation ES (Then ES is not always a subtree, but can be a segment as well: Paren -- IntExp(es) -- Int )? Then reusing is not as easy anymore.\\
Or can interpretation map onto 2 nodes after all?\\
Or do we just ignore elts with no pres and rebuild them when interpreting?\\
Need more experience

%%
%*Isn't this too restrictive?
%* doesn't this make the presentation more simple? interpretation is hard because several elements need to be 
%regarded.
%if we propagate a value downward as an attribute, it already happens.
%\fromHere  % VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV




\subsection{Conclusions}

trees and element 1:n. possible to handle es.

may be broken. free editing and parsing. easy to make es recovery impossible.

may need extra safety for protecting intr es. some ops can be handled other may cause loss.

not complete. Any mapping that cannot be inverted has es. Not possible to give general solution. But also not necessary. this one we can handle. with another one for order in lists. Many editors can be spec'd.






%																
%																
%																
\section{Duplicates in presentation}

\note{mention duplicates in interpretation?}
\note{mention that this can also be used for multiple views?}
%* not just because multiple trees: elements may depend on several trees. without duplication.

Duplication occurs when a higher-level structure is presented on more than one lower-level structure. An example of duplication is a chapter title that appears both in the derived table of contents as well as in the document. But also multiple windows showing the presentation of the single document involve duplications.

The problem with duplicate values is that if only one of the duplicates is edited, a conflict may arise during interpretation, and the editor needs to choose which value to use for computing the higher level. We tackle the problem by giving priority to the changed duplicate. In case both duplicates have been edited and yield different higher-level results, the editor can either prohibit the edit operation, or make a default choice for one of the duplicates.

It is hard to give a precise definition of duplication. The "\verb|(|" and "\verb|)|" tokens in Figure~\ref{presentExample} are both in the presentation of the \verb|Paren| node, but it is not immediately obvious to consider these tokens as duplicates. Consider for example a presentation \verb|(1+2)*(3+4)| in which the middle two parentheses are deleted. If parentheses are regarded as duplicates, this results in the deletion of both pairs of parentheses, yielding \verb|1+2*3+4|. However, it may be more logical to get the result \verb|(1+2*3+4)|.


\bc
If a higher-level element The presentation of a higher-level element may consist of several lower-level elements, as shown in in Figure~\ref{presentExample}. In this case, both the "\verb|(|" and "\verb|)|" tokens are in the presentation of the \verb|Paren| node. However, it is also possible that a higher-level element is duplicated in the presentation, in which case interpretation of the lower level may yield conflicting values for the higher-level element. An example of such a duplication is the title of a chapter that appears in the table of contents as well as in the presentation of the chapter itself. When the lower level is interpreted, several alternatives for one element may arise, and a choice has to be made.

Note that having several lower-level elements does not automatically mean that an element is duplicated. Furthermore, the interpretation of duplicates only needs to be dealt with if the duplicate structure is edited on the lower level. If a duplicate only needs to support document editing and no presentation editing, no extra work needs to be done.
\ec

In Proxima, the only layers potentially giving rise to duplicates are the evaluation and the presentation layers. The presentation mappings for the other layers are largely predefined and do not duplicate any structures. 
\bc To avoid having to deal with duplicates when parsing, duplicating is currently only allowed at the evaluation layer. This restriction may be lifted in a future version, but for now, if a presentation contains duplicates, the evaluation sheet specifies how the involved structures are duplicated, and the reduction sheet specifies how updates on duplicate structures are handled.
\ec

\begin{figure}
\begin{center}
\begin{center}
\epsfig{file=pics/eps/interpretToc.eps}
%
%  Chap              Toc
%  "first.."     TokChap      Chap
%                   "first.."     "first.." 
%
\end{center}
\caption{The presentation of a word processor document with a table of contents.}\label{duplicatesExample} 
\end{center}
\end{figure}

% example

Figure~\ref{duplicatesExample} shows an example of a duplicated structure in the form of a table of contents for a word processor. On the left-hand side of the figure is a document that contains two chapters, of which only the titles are shown. The enriched document contains both a table of contents subtree (\verb|Toc|), as well as a copy of the chapters. The table of contents subtree follows the structure of the original document, but only contains the title of each chapter rather than the chapter itself. To keep the figure simple, the table of contents only contains chapters and not sections and subsections, but in a real editor the table of contents may reflect the entire document structure. 

The evaluator maps a chapter in the document on a chapter in the enriched document, as well as on a chapter entry in the table of contents tree, in the latter case leaving out everything but the title. The presenter simply presents both the table of contents tree as well as the chapter tree, and does not duplicate any structures. The table of contents example is somewhat complex, because it does not only involve a duplicated presentation, but also extra state, since in the table of contents, a chapter is shown without its content. However, the extra state is orthogonal to presence of duplicates and can be handled as sketched in  Section~\ref{sect:extraState}.

When a user performs an update on the presentation, this results in an updated enriched document. Updates can be either in the table of contents, or in the chapters themselves. If the update is not in the table of contents, the document is computed from the chapters in the enriched document, while ignoring the table of contents altogether. On the other hand, if the table of contents tree is modified, the chapters in the enriched document tree are ignored on interpretation, and the document is obtained from the table of contents tree only. In this case, the chapter content is treated as interpretation extra state. 

By treating the table of contents as a partial duplicate of the chapters, it is easy to support structural updates on the table of contents, such as swapping two titles. The reuse process for extra state takes care of swapping the chapter content correspondingly. The editor designer only needs to specify what happens when a new title is inserted, or when an entry is moved to a different level (eg. a section to a subsection). Furthermore, it may be desirable to issue a warning when deleting an table of contents entry.

\note{mention that we need change management as well as incremental updates for this to work?}
\bc
For duplicate structures, the enriched document contains several alternatives, which may have different interpretations. In the table of contents example, the alternatives for a chapter title are the title in the table of contents and the title in the chapter. Three situations are possible. Firstly, if none of the alternatives have been edited, all interpretations are equal, and any one can be chosen. Secondly, if one alternative has been edited, the choice is in favor of the edited element. Hence, if a chapter title is edited in the table of contents, the resulting reduced document contains the updated title. Finally, if a title has been edited in the chapter as well as in the table of contents, the editor may give preference to the chapter title. In this case the edit operation may be forbidden, or either one of the values may be chosen.
%skipping eval layers becomes tricky now. but it's not mentioned here anyway
\ec

% not true, and also more implementation than specification
\bc
Specifying duplications in the evaluation and reduction sheets is not ideal, since the enriched document type now depends on whether or not the presentation contains duplicates. Hence, if a presentation contains several views on a structure, the necessary duplications for these views need to be specified in the evaluation layer. A special facility for specifying common duplicate presentations, such as tree views on a structure, in the presentation layer is desirable. A possible approach for such functionality is a special parser that can resolve duplicate conflicts during parsing. With such a parser, the entire process of handling duplicates takes place in the presentation layer, and the evaluation layer is not affected. \note{parse (dirty arrangement) $\rightarrow$ dirty presentation? May be tricky as well}
\ec









%%% OLD MAPPING INFO STUFF


%Example Decl, Decl Type Exp., Tree view
%So always Info Pres and Intr. bla core extra:

\bc
% equations:      
\toHere
talk about isomorphism, instead of viewing
\fromHere
More specifically a data level ($\Level_{i}$) can be viewed in two ways, depending on the direction of the mapping function of which it is the result. When coming from the higher layer, the level can be considered as the product of a core part ($\Core_{\Pres,i}$) and the presentation extra state ($\Extra_{\Pres,i}$), whereas when coming from the lower layer, it is the product of a core part together with interpretation extra state (ie. $\Core_{\Intr,i} \times \Extra_{\Intr,i}$). The document and rendering level form special cases. The document ($\Level_0$) is never the result of a presentation, and therefore has no presentation extra state, whereas the rendering ($\Level_n$), which is never the result of an interpretation, has no interpretation extra state.

The specification of the data level types reads:

% Note that pres es for level i is important for pres of level i-1
% and intr es for level i is important for intr of levl i+1
\begin{small}
\refstepcounter{specification} \label{spec:levelMultiFirst}
\(\begin{array}{lcll}
\Level_{0} & = & \Core_{\Intr,0} \times \Extra_{\Intr,0}      & \text{\{Document\}}\\
\Level_{n} & = & \Core_{\Pres,n} \times \Extra_{\Pres,n}      & \text{\{Rendering\}}\\
\lefteqn{\forall i:1 \le i \le n-1:}  \\
\Level_{i}  & \simeq & \Core_{\Pres,i} \times \Extra_{\Pres,i}     & \text{\{Viewed from higher layer\}}\\
                & \simeq & \Core_{\Intr,i} \times \Extra_{\Intr,i} &  \text{\{Viewed from lower layer\}}\\
\end{array}\)\end{small}
\begin{center}(Specification \thespecification: Level types with extra state (Multiple layers, First attempt))\end{center}\vspace{1em}

% could say Extra_{\Pres,0} = Extra_{\Int,n} = ()


Note that the representation of a level type as a product is only used to show that the type consists of two kinds of information. In an implementation, a level type does not need to be a product of the core and the extra state. It is likely that a level type is a tree that contains the core elements as well as the extra state elements.

We can use a simplified version of this specification in this chapter, because here we focus on a single layer only. Thus, we can drop several subscripts and for each adjacent level ($\Level_{H}$ and $\Level_{L}$) only consider one of the views from Specification~\ref{spec:levelMultiFirst}, thereby improving readability of the layer specification that will be presented further on. 

From the perspective of a single layer with its adjacent data levels, we only need to consider the upper level interpretation extra state, and lower-level presentation extra state. The higher-level presentation extra state and the lower-level interpretation extra state level are handled by other layers. Hence, $\Level_{H}$ and $\Level_{L}$ no longer need two views. Furthermore, the document and rendering levels are no longer special cases, since by definition the document cannot be a lower level and the rendering cannot be a higher level. The simplified equations are:

\begin{small}\( \begin{array}{lcll}
\Level_{H} & = & \Core_{\Intr, H} \times \Extra_{\Intr, H}\\
\Level_{L} & = & \Core_{\Pres, L} \times \Extra_{\Pres, L}\\
\end{array}\)\end{small}

Finally, because each level now only has one kind of extra state, we can drop the $\Pres$ and $\Intr$ subscripts, yielding:

\begin{small}
\refstepcounter{specification} \label{spec:levelSingleFirst}
\( \begin{array}{lcll}
\Level_{H} & = & \Core_{H} \times \Extra_{H}\\
\Level_{L} & = & \Core_{L} \times \Extra_{L}\\
\end{array}\)\end{small}
\begin{center}(Specification \thespecification: Level types with extra state (Single layer, First attempt))\end{center}
\ec



\bc
%																
\subsection{Mapping information} \label{sect:mappingInformation}

*** This section will probably be removed. Mapping info is the arrows, how it is maintained is left to the implementation.
\ec

\bc     copied to previous section
When a level is updated and subsequently presented or interpreted, yielding a target level that contains extra state, the extra state from the previous value for the target level must be reused. However, the new value of the target level together with its previous value do not always provide sufficient information for reusing the extra state. For example, when a list of integers that is presented as a list of tokens with whitespace has been reordered, the tokens in the whitespace must be reordered correspondingly.  In order to do so, the layer needs to keep track of additional information about the mapping.

For each target level node that is not extra state, we keep track of its origin in the source level. Thus, when presenting a higher level ($\Level_{H}$), each node in the presentation ($\Level_{L}$) contains a reference to the higher-level whose presentation it is part of. Similarly, when interpreting a lower level, each resulting $\Level_{H}$ node has references to the lower-level nodes of which it is the interpretation. 
\ec
\bc
*** rename Info to Map?

We introduce two types for this mapping information: $\Info\idwn_{H}$ denotes the {\em interpretation mapping information} in the higher level (pointing to the lower level), and $\Info\iup_{L}$ denotes the {\em presentation mapping information} in the lower level (pointing to the higher level). Similar to the $\Core$ and $\Extra$ types, the $\Info$ types are only conceptual and do not necessarily correspond to types in an implementation. Figure~\ref{coreExtraInfoExamples} shows the two examples from Figure~\ref{layerExtraState} with explicit mapping information arrows. \note{Figure is not entirely right yet, non shaded can be high or low.}

\begin{figure}
\begin{center}
\begin{center}
\epsfig{file=pics/eps/coreExtraInfoExamples.eps, width=125mm}
\end{center}
\caption{Two extra state examples with explicit mapping information.}\label{coreExtraInfoExamples} 
\end{center}
\end{figure}

Because the mapping information is part of a level, we define the level type to be a product of $\Info$ and 
$\Extra \times \Core$. Except for the top and bottom levels, all levels contain presentation and interpretation information. The top level is never the result of a presentation mapping, and hence has no presentation information ($\Info\iup$), whereas the bottom level has no interpretation information ($\Info\idwn$). The new definition of $\Level_i$ is:

\begin{small}
\refstepcounter{specification} \label{spec:levelMultiFinal}
\begin{align*}% \label{sse}
\end{align*} 
\(\begin{array}{lcll}
\Level_{0} & = & \Core_{\Intr,0} \times \Extra_{\Intr,0} \times \Info\idwn_{0} \\
\Level_{n} & = & \Core_{\Pres,n} \times \Extra_{\Pres,n} \times  \Info\iup_{n}\\
\lefteqn{\forall i:1 \le i \le n-1:}  \\
\Level_{i} & = & \Core_{\Pres,i} \times \Extra_{\Pres,i}  \times \Info\iup_{i} & \text{\{Viewed from upper layer\}}\\  
               & = & \Core_{\Intr,i} \times \Extra_{\Intr,i} \times \Info\idwn_{i} & \text{\{Viewed from lower layer\}}
\end{array}\)\end{small}
\begin{center}(Specification \thespecification: Level types (Multiple layers, Final))\end{center}\vspace{1em}

*** do we have $\Info\idwn_i = \Info\iup_{i+1}$?

Note that for the middle levels, for which two kinds of mapping information exist, each alternative of the definition contains only one kind. This is because the downward mapping information $\Info\idwn_{i}$ cannot be computed by the higher layers presentation mapping, and hence is part of its extra state: $\Extra_{\Pres,i}$. Analogously, viewed from the lower layer, $\Info\iup_{i}$ is part of $\Extra_{\Intr,i}$. Rather than further complicating the definition by splitting the extra state type in a mapping information part and a regular extra state part (eg. $\Extra_{\Pres,i} = \Extra_{\mathit{Regular},\Pres,i} \times \Info\idwn_{i}$), we choose to make explicit only the mapping information relevant for the direction from which the level is viewed.
\ec

\bc
Again, the notation can be simplified by taking a single layer perspective. Note that we leave the arrows in the  mapping information types, even though they are redundant now.

\begin{small}
\refstepcounter{specification} \label{spec:levelSingleFinal}
\(\begin{array}{lcll} \label{spec:extraStateSL}
\Level_{H} & = & \Core_{H} \times \Extra_{H} \times \Info\idwn_{H}\\
\Level_{L} & = & \Core_{L} \times \Extra_{L} \times \Info\iup_{L}\\
\end{array}\)\end{small}
\begin{center}(Specification \thespecification: Level types (Single layer, Final))\end{center}\vspace{1em}
\ec

\bc
% example in picture 
Figure~\ref{mappingInfo} shows two examples of the $\Info$ argument. The left-hand side shows the situation at the presentation layer of a Haskell source editor during presentation.  The enriched document element \verb|If|  was presented on the three tokens in the presentation level. The downward arrows represent $\Info_{\Pres,H}$, whereas the upward arrows are the interpretation information $\Info_{\Intr, L}$. The dotted arrows represent $\Info_{\Intr,H}$ (upward) and $\Info_{\Pres,L}$ (downward), which are not used in this layer. The whitespace nodes in the presentation level are presentation extra state, that has to be reused on presentation. \note{more detail on reuse?}

The right-hand side of the figure shows the evaluation layer of a word processor during interpretation. The document is a \verb|Chapter| element containing two \verb|Section| children, which is mapped onto a table of contents structure in the evaluation level. Again, downward arrows are $\Info_{\Pres,H}$ and upward arrows are $\Info_{\Intr,L}$. \note{mention there is no $\Info_{\Intr,H}$?} In this case, the document contains interpretation extra state, since the contents of the chapter and sections cannot be computed from the enriched document.  \note{more detail on reuse?}

\begin{figure}
\begin{center}
\begin{center}
\begin{footnotesize}
\begin{verbatim}
Enriched Document:                       Document:                                                                                            
                                                                                            
                  If                         Chapter "chapter 1" {"this is bla bla bla..."} 
            / /   | |   \\                      v       v                                     
           v v    v v    vv              Sect "1" {"..."}     Sect "2" {"..."}                
       ^           ^           ^           |   /                    \   |                            
      /    ^       |   ^        \  ^       v  v          ^  ^        v  v                          
    Token /      Token |      Token \                    |  |                             
 {WS} "if"    {WS} "then"  {WS} "else"      ChapterTocEntry "chapter 1"                     
                                          ^              ^                 ^   ^              
Presentation:                            SectionTocEntry "1"  SectionTocEntry "2"           
                                                                                            
                                         Enriched Document:                                 

----------                                                                        
legend   ^ is pres info       v is intr info     {node} is extra state            
                                                                                  
\end{verbatim}  
\end{footnotesize}                                                                  
\end{center}                                                                      
\caption{Mapping information.}\label{info}                          
\end{center}                                                                      
\end{figure}

%??? 
%Mapping is to the node for reusing. Mapping to path is for associating doc edits with presentation parts.
%If things are moved, the paths are no longer meaningful (nodes are). Before doc op, always fix paths by parsing.


%What about keeping list [ID->Info?] that switches and is not part of level.
We choose to make the mapping information part of the $\Level$ type. The reason for this is that both adjacent layers may update a level, and therefore also affect the mapping information on the level. \note{need an example? ** Johan: ja **} With the mapping information in the level types, $\present$ and $\interpret$ do not need additional arguments anymore.
\ec


