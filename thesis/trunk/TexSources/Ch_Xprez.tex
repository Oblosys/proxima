% this might be useful: \def\figpath{Figures/traversal/}

\bc
TODO:


CHECK hansen function based formatting (Bib from Rui)
Check out  Yahu & wxHaskell for alternative ways of handling attributes/properties. Can these handle synthesized attrs as well?

change case for titles and headings

Check first chapter if transformation/target language separation is removed here
\ec





%with this def:  \def\ch{chap:presenting}        we can use chapter specific labels like \label{\ch:labelname}

\chapter{Presenting structured documents with {\sc Xprez}} \label{chap:presenting}

{\sc Xprez} is not latex!! Latex is too complex. {\sc Xprez} is target. Latex needs attributes and lot of computations. Proxima can build an editor for latex, but not just using {\sc Xprez}. E.g.\ fontsize etc will be visible in document level.


\bc
The popularity of the document standard XML has led to an increasing demand for XML editors. The Proxima project is concerned with the design of a generic presentation-oriented XML editor with support for derived values in documents. A presentation is a view on a document, according to a style sheet. In a presentation oriented editor the user only sees a presentation of a document. WYSIWYG editing is possible using a WYSIWYG presentation, whereas the underlying document structure can be viewed and edited with a presentation that shows the actual tags and tree structure of the document. Because Proxima will support derived values, constructs such as chapter numbers and references are not hard-coded in the editor, but can be specified entirely by the user. Also, computations in a document, where one field contains the result of a calculation over several input fields can be modeled with derived values. In order to specify document presentations, a powerful presentation language is required. For this reason, we have developed the declarative XML presentation language {\sc Xprez}.
\ec


\bl
\o Presentation level in Proxima is Xprez
\o Simple version is Section~\ref{sect:presLevel}
\o Compare it to other pres langs and explain language
\o just enriched/pres level now?
\el

There exist a number of style sheet or presentation languages for XML, for example CSS~\cite{css2}, CCSS~\cite{badros99ccss}, PSL~\cite{marden98psl}, XSL~\cite{xsl10}, and P~\cite{quint97thot}, but they lack either the expressiveness or the abstraction mechanisms to specify the presentations for the use cases from Chapter~\ref{chap:requirements}. Pretty-printing combinators \cite{oppen80prettyPrinting,swierstra98combinators,hughes1995prettyPrinting,kahl99galleyCombs,brand96generationOfFormatters} do offer expressiveness, abstraction mechanisms and first-class presentations, but these libraries are mainly text-oriented.

%, and all require a program for traversing the document tree and generating the presentation. 

\bc
In a comparative study of a number of existing languages, we determined the following list of requirements for a presentation language:

\begin{itemize}
\item Complicated presentations should be possible, but at the same time simple presentations should be easy to specify.
\item The language should be declarative. Thus, the order in which presentation rules are specified is not important.
\item Domain-specific syntax should be available for presentation-specific constructs. 
\item It should support a flow (\`a la XSL) and a box (\`a la \TeX) model with alignment.
\item Presentations should be first-class values. Thus presentations can be manipulated, passed as arguments to functions, etc.
\item It should have a powerful abstraction mechanism. Thus, similar presentations can be specified with one, appropriately parameterized, function.
\end{itemize}
\ec

{\sc Xprez} has been implemented in the functional language Haskell. It does not yet have a domain-specific syntax, but other than that it meets the requirements. Although the language is not yet fully developed, it is already powerful enough to describe a \TeX -like presentation with a style sheet of about 300 lines. Below are two screenshots of an example document presented using this style sheet. The style sheet handles section numbering, ligatures (e.g.\ the ``fi'' in Scientific), and several mathematical constructs.

\begin{center}
\epsfig{file=pics/eps/xlatex1.png.eps, width=2in} \qquad
\epsfig{file=pics/eps/xlatex2.png.eps, width=2in}
\end{center}

%Contributions of this paper:

\bc
The contributions of this paper are:

\begin{itemize}
\item An evaluation of the strengths and weaknesses of existing presentation languages, resulting in a list of requirements for a presentation language.
\item A proposal for the declarative presentation language {\sc Xprez} that supports both the flow and the box model, has presentations as first-class objects, and has a powerful abstraction mechanism.
\end{itemize}
\ec


\todo{}
Section~\ref{sect:targetlangs} discusses existing presentation languages and states a number of requirements for a presentation language. followed by the introduction of the target language of {\sc Xprez} in Section~\ref{sect:xpreztarget}.  Section~\ref{sect:conclusions} concludes.


%																
%																
%																
\section{Presentation languages} \label{sect:targetlangs}

\todo{change title}

In this section, we discuss five presentation languages: CSS~2.0, CCSS, XSL, PSL and P. 
\cite{sgml86} and \cite{dsssl96}

%Paper organisation move this to introduction
Two kinds of languages are involved in the presentation process: a presentation target language, and a presentation specification or transformation language. The presentation target language describes the building blocks of the presentation that is displayed on the screen or sent to a printer, whereas the transformation language specifies how an XML document is mapped onto the target language to create this presentation. The Extensible Stylesheet Language (XSL) gives a clear example of the distinction, as it has been split into a transformation language (XSL Transformations or XSLT) and a target language (XSL Formatting Objects). XSLT documents specify transformations that map a source document tree to a tree of Formatting Objects, which can then be rendered. 


Presentation lang is trans + target. Most formalisms have both. Here focus on target. Trans is AG but has not been that well developed for Prox. (Example in next chapter?)

Maybe not say Xprez has a target language, but that Xprez is a target language?



The elementary building blocks of most presentation target languages are basic presentations of strings and simple graphical objects such as lines, boxes and circles. The building blocks can be composed according to a severaln models:

\begin{description}
\item[Flow model]
When a flow model is used, presentations are placed next to each other or above each other, depending on the current flow direction. If the remaining space in the current direction is too small to fit the presentation, a new flow presentation is started. In this way, lists of words can be divided into lines and lists of lines can be divided into pages. The generated list of flows may then be manipulated further, for example, by extending each page in a list of pages with a header and a footer.
\item[Box model]
The box model allows each presentation to define its position relative to sibling or parent presentations. The positions can be set either directly by specifying them relative to positions of other presentations, or by declaring constraints. If constraints are used, the style sheet does not so much specify the exact calculation of a property, but rather gives constraints that should hold for the property. The actual computation of the property value is left to a constraint solver. 
\item[Matrix model]
The matrix model can be used to align a tree of cells, usually a list of rows that each contain a list of cells, along the rows as well as the columns. This is difficult to specify just using rules for each row and cell, as the width of the n-th cell has to be related to the n-th cells in the other rows instead of to properties of its parent or sibling cells. Matrices can be used to create box presentations, but the extent to which this is possible depends on the expressivity of the matrix model; for example, whether or not cells may overlap.
\item[Absolute positioning]
A very low level way of formatting is specifying the absolute coordinates in the resulting presentation.
\end{description}


%																
\subsection{Existing presentation languages} \label{sect:existingtarget}

\todo{DSSSL? Lambert mentioned it at the transformation lang section} % Does DSSSL have a target component?

Of the five \todo{?}presentation languages we examined, only XSL regards its target language as a language in its own right, with a separate syntax. The other languages only describe how properties of the elements of the target presentation tree can be set, but do not treat a presentations as an actual value in the language.

\head{CSS~2.0:} Cascading Style Sheets, level~2~\cite{css2} is an example of a simple presentation language. Its target language is almost invisible to the style sheet designer. The presentation of a document is a tree that is almost isomorphic to the document tree, with the document content in the leaves. It is not entirely isomorphic, because content can be left out and simple text content can be added. 
\toHere

The nodes of the tree specify presentation properties such as font size or color, either absolutely or as a percentage. However, aribitrary expressions *** . The kind of a property determines to what property a percentage refers. For instance, a percentage value for the {\em font-size} property refers to the font size of the parent element, but a percentage for the {\em line-height} property refers to the font size of the element itself. It is not possible to let a property value depend on arbitrary properties of the parent or siblings in the presentation tree.

\fromHere

CSS~2.0 supports a flow layout and absolute positioning. There is also a table format, but it is of limited use because the transformation language is rather weak. Consequently, if the data in the document does not have exactly the same structure as a CSS~2.0 table, it cannot be presented as one.

\head{CCSS:} Constraint Cascading Style Sheets~\cite{badros99ccss} is an extension of the CSS~2.0 standard that is based on constraints. The target language of CCSS closely resembles the CSS~2.0 target language, but child properties are specified using constraints instead of percentages of the parent's property values. Another difference is that the constraints may refer to global constraint variables and to left-siblings in the presentation tree as well as to the parent node. 

\head{XSL FO:} On the other side of the spectrum is the XSL stylesheet language for XML. The design of the target language, XSL Formatting Objects, was based on the*** flow objects of the DSSSL presentation language for SGML. consists of a large collection of elements that can be used to specify page models, presentation properties, and more complicated presentation aspects, such as hyphenation and counters. A presentation is a tree that consists of these formatting objects. 

XSL formatting objects offer  strong control over the flow model, but no box model is supported. There is a table model, but using it to do a box layout is difficult, because that requires the style sheet to take care of computing the alignment, and XSLT does not support a strong computational formalism.

\head{PSL:} The Proteus Stylesheet Language~\cite{marden98psl} is an attempt to combine the simplicity of CSS~2.0 with the power of XSL. Its target language is again close to the CSS target language. PSL extends the CSS target language with a box model and graphical symbols. The value of a property can be expressed as a mathematical expression that refers to properties of nodes in the presentation tree. This mechanism is called {\em property propagation}. 

PSL supports a constraint-based box model. A presentation can specify its properties for position and size relative to properties of other presentations in the tree. The other presentations can be addressed using a number of primitive functions for accessing siblings, parents, ancestors of a specific type, etc.

\head{P:} The last language we consider is the presentation language P of the Thot editor toolkit~\cite{quint97thot}. It has a target language that consists entirely of boxes. Instead of having a large number of different presentation boxes, similar to XSL Formatting Objects, P has only three kinds of boxes with a large number of properties. In contrast to PSL, the box layout in P is not constraint based. Hence, the style sheet designer needs to take the order of computation of the layout properties into account. P does support horizontal and vertical reference lines for automatic alignment of boxes. Matrices are not primitive objects in P.

\head{Discussion:} The languages discussed above are all declarative and domain-specific languages that vary in expressive power. The simple languages CSS~2.0, CCSS, and PSL allow simple presentations to be specified in a simple way, but cannot be used to specify more complex presentations, such as mathematical formulas. In contrast, XSL and P do allow complex presentations to be specified, but due to the lack of abstraction, simple presentations also have rather elaborate specifications, especially in P. 

Only P and PSL support a box model, but both models are of a rather object-oriented and imperative nature. A box can specify its own position properties relative to its parent or siblings, but it is not possible to state at parent level that two child presentations should have their top and bottom aligned, or that two presentations should have the same width. As a consequence, the conceptually simple change of presenting the children of a node next to each other instead of above each other requires changing the presentations for all child elements. Moreover, if the choice for vertical or horizontal layout depends on an attribute of the parent, then all children require code in their presentation rules for accessing this parent attribute, if possible, and letting their presentation depend on its value. If, however, presentations are first-class objects in the target language, then the parent presentation rule can specify the layout of the children.

Letting a child presentation specify its own layout makes it more difficult to understand a presentation. For example, a reverse order presentation of a list of children is obtained by aligning each right side with the previous child's left side. If, on the other hand, child presentations are first-class, and abstraction mechanisms can be used to define combinators on them, reversing can be specified by a simple reverse combinator. Another advantage of this approach is that the concepts of reversing and direction of layout are orthogonal now. Changing the layout from a horizontal list to a vertical list can be achieved by applying a different combinator to the reversed children, while the order of the children is controlled by applying the reverse combinator or not. In the P and PSL model, these concepts are intertwined.

\fromHere

\head{ Requirements}

Based on the previous discussion, we can conclude that a presentation target language, and in particular the target language for Proxima, should meet the following requirements: 

\begin{description}
\item[Proportional effort]
It must be possible to specify complex presentations, but the specification of simple presentations should still be easy.
\item[Declarative]
In a declarative language, understanding a composite presentation is easier, because the computation of a presentation does not generate side effects. Another advantage is that the designer need not worry about the order of computation of presentations and properties.
\item[Domain-specific]
The language should have syntax for presentation-specific constructs such as an {\bf em} (the height of the letter m in the current font and size) and different measuring units such as pixels and inches.
\item[Flow and Box model with alignment]
The language supports a flow model for textual parts of a presentation, and a box model for displaying mathematical formulas and other more graphical presentations such as trees. Automatic alignment can be used to specify composite presentations without having to position each child presentation explicitly.
\item[First-class presentations]
A first-class presentation can be named and manipulated at the level of its parent, which in many cases is the natural place for such manipultation. At the same time, it is also possible to specify properties at child presentation level when this is more appropriate. \todo{clear enough?}
\item[Powerful abstraction mechanism]
User-defined functions and var\-i\-ables help to reduce code duplication, facilitate code reuse, and increase transparency, because complex pieces of code may be replaced by functions with well-chosen names.
\end{description}

%																
%																
%																
\section{The {\sc Xprez} target language} \label{sect:xpreztarget}

With the requirements from the previous subsection in mind, we have developed the declarative presentation language {\sc Xprez}. 

%																
\subsection{{\sc Xprez} presentation model}

{\sc Xprez} is a box language, similar to P and the document formatting languages \TeX ~and Lout~\cite{kingston93lout}. A presentation is a value of the abstract type \texttt{Xprez}, and is either a simple box containing a text or a graphical object, or a composite box that contains a list of child presentation boxes. Thus, a presentation is a tree, in which the leaves are simple presentations and the nodes are composite presentations. We construct \texttt{Xprez} values in the functional language Haskell, using a number of primitive functions that are described in Section~\ref{sect:primitives}.

\begin{figure}
\begin{small}
\begin{center}
\begin{small}
\begin{verbatim}
data Inh = Inh {fontFamily :: String, fontSize :: Int,
                textColor, lineColor, fillColor, backgroundColor :: Color} 
data Syn = Syn {hRef, vRef, minWidth, minHeight :: Int,
                hStretch, vStretch :: Bool}
\end{verbatim}
\end{small}
\caption{The {\sc Xprez} properties}\label{xprezproperties} 
\end{center}
\end{small}
\end{figure}


A presentation box (from now on called presentation) has a number of properties that describe its size and its appearance: 

\begin{center}
\epsfig{file=pics/eps/PresentationBox.eps, width=2in}
\end{center}

\toHere

Figure~\ref{xprezproperties} shows the definition of the two records \texttt{Inh} and \texttt{Syn} (as explained below) with the type of each of the properties. The \texttt{hRef} and \texttt{vRef} properties specify the horizontal and vertical reference lines that are used for aligning boxes when combined in composite presentations. \todo{note h is vertical line} The boolean properties \texttt{hStretch} and \texttt{vStretch} specify whether or not the presentation is allowed to stretch in horizontal or vertical direction. The rest of the properties are \texttt{fontFamily}, \texttt{fontSize}, \texttt{textColor}, \texttt{lineColor}, \texttt{fillColor}, and \texttt{backgroundColor}, which should be self-explanatory. In the future, this set will be extended with other properties such as more line-style and font attributes, and user-defined properties will be supported. The presentation tree is transformed into an attribute grammar in which the font, style, and color properties are inherited attributes that go down in the tree, and alignment and stretch properties are synthesized attributes that go up in the tree. In the Haskell types, this division is visible in the fact that the properties are modeled using two records: \texttt{Inh} for inherited properties, and \texttt{Syn} for synthesized properties.


%																
\subsection{{\sc Xprez} primitives} \label{sect:primitives}

Simple presentations can be created with the first five combinators in Figure~\ref{xprezprim}. The \texttt{empty} combinator is a neutral element that is not visible and takes up no space. A piece of text can be presented with \texttt{text}, and a rectangle with \texttt{rect}, which takes the width and height as arguments. The \texttt{poly} combinator takes a list of relative coordinates between (0,0) and (1,1) and produces a line figure that connects these points. A \texttt{poly} presentation stretches in horizontal and vertical direction. Finally, \texttt{img} can be used to display bitmap images. The argument is a string that contains the path to the bitmap file. By default, the reference lines of simple presentations are 0\todo{expl more}, except for the vertical reference line of a text presentation, which is the baseline of the current font.

\begin{figure}
\begin{small}
\begin{center}
\begin{small}
\begin{verbatim}
empty             :: Xprez
text              :: String -> Xprez             -- simple text
rect              :: Int -> Int -> Xprez         -- rectangle
img               :: String -> Xprez             -- image (jpg, png, ...)
poly              :: [ (Float, Float) ] -> Xprez -- poly line
row, col, overlay :: [ Xprez ] -> Xprez          -- row, column, overlay
rowR, colR        :: Int -> [ Xprez ] -> Xprez   -- row, col w/ reference
matrix            :: [[ Xprez ]] -> Xprez
format            :: [ Xprez ] -> Xprez
\end{verbatim}
\end{small}
\caption{The {\sc Xprez} primitives} \label{xprezprim} 
\end{center}
\end{small}
\end{figure}

There are several kinds of composite presentations, the simplest being rows and columns (combinators \texttt{row} and \texttt{col}), which are duals. In a row, each child presentation is placed immediately to the right of its predecessor, with their vertical reference lines aligned. Horizontal reference lines have no effect on the positioning in a row.

\begin{center}
\epsfig{file=pics/eps/row.eps, width=3.2in}
\end{center}

The bounding box of a row is the smallest rectangle that encloses all its children. The vertical reference line is equal to the aligned reference lines of the children, whereas the horizontal reference line is taken from one of the children (by default the first one). The \texttt{rowR} combinator takes an extra argument of type \texttt{Int} that specifies which child carries the horizontal reference line for the row. \texttt{}By default, a row stretches in horizontal direction if one of its children does, and it stretches in vertical direction if all children stretch vertically. However, by setting the stretch properties, these defaults can be overridden. 

The \texttt{matrix} combinator can be used to describe a table layout, in which elements are aligned with elements to their left and right as well as with elements above and below them. 

Because \texttt{row}, \texttt{column} and \texttt{matrix} do not allow their children to overlap, a special combinator is required to create overlapping presentations. The \texttt{overlay} combinator places its children in front of each other, while aligning both the horizontal and vertical reference lines. It can be used to create underlined text, for example. Because alignment takes place on both reference lines and hence all child reference lines overlap, no special \texttt{overlayR} combinator is needed. 

The last composite combinator in Figure~\ref{xprezprim} is \texttt{format}. It takes list of presentations as argument and splits this list into rows based on the available horizontal space. The resulting rows are placed in a column. The \texttt{format} combinator can be used to display a paragraph of words, or any other kind of presentations for that matter, on a number of lines. 

\fromHere

Here is an example {\sc Xprez} presentation that illustrates alignment and stretching in a row:

\begin{small}
\begin{verbatim}
let cross     = poly [(0,0),(1,0),(1,1),(0,1),(0,0),(1,1),(0,1),(1,0)]
    greycross = cross `withbgColor` grey
in  row [ text "Big" `withFontSize` 200
        , colR 2 [ cross, cross, text "small", greycross, greycross ] ] 
\end{verbatim}
\end{small}

\toHere
The code produces the following image (the dashed line has been added to show vertical reference line of the presentation):

\begin{center}
\epsfig{file=pics/eps/align.png.eps, width=1in}
\end{center}

The second element in the row is a column that takes the vertical reference line from its third child (the numbering starts at 0). Therefore, the word ``Big'' is aligned with the word ``small''. The \texttt{cross} object is a line figure in the form of a rectangle with a cross, and the \texttt{greycross} is a \texttt{cross} with a grey background. 
 \todo{these?}
 
Because these presentations stretch in vertical direction, so does the containing column. The two stretching objects above the reference object (\texttt{text "small"}) are each assigned equal amounts of the remaining space above the vertical reference line, and likewise, the objects underneath the reference object are assigned the remaining space below the reference line. If, on the other hand, the reference object itself is allowed to stretch, then the total amount of available space is added and distributed equally over all stretching objects. In this case, there will no longer be any alignment of the reference object. 


%																
\subsection{Property modification}

The properties of a presentation can be modified using the \texttt{with\symbol{95}}\footnote{The name has an underscore because the keyword {\tt with} is already defined in Haskell} combinator:

\begin{small}
\begin{verbatim}
with_ :: Xprez -> ((Inh, Syn) -> (Inh, Syn)) -> Xprez
\end{verbatim}
\end{small}

In the specification of a property value, the original values of properties can be used, e.g.\ the font size can be set to the old font size increased with 2 points. Therefore, the second argument of \texttt{with\symbol{95}} is a function that takes the original values of the inherited attributes that come from the parent and the synthesized attributes that come from child presentation as arguments, and returns the new values (i.e.\ the inherited attributes that go to the child and the synthesized attributes that go to the parent).

The inherited and synthesized property values are Haskell records, which have special syntax for accessing and updating fields. If \texttt{inh} is a value of type \texttt{Inh}, then the expression \texttt{fontSize inh} denotes the value of the \texttt{fontSize} field in \texttt{inh}, and \texttt{inh $\{$ fontSize = 10 $\}$} denotes a value of type \texttt{Inh} in which all fields have the same values as in \texttt{inh}, except for the \texttt{fontSize} field, which is now 10. Below is the definition for the \texttt{withFontSize} combinator: 

\begin{small}
\begin{verbatim}
withFontSize :: Xprez -> Int -> Xprez
withFontSize xp fs = xp `with_` \(inh, syn) -> (inh {fontSize = fs}, syn)
\end{verbatim}
\end{small}

Constructing functions comes with some syntactic overhead, but by using a libary of combinators for the most frequent uses, most of the explicit calls to the \texttt{with\symbol{95}} combinator can be avoided. However, a problem with this derived combinator is that is that the \texttt{fs} value is of type \texttt{Int}, and therefore cannot depend on the original font size value. A different combinator that takes a function of type \texttt{Int -> Int} as argument, which is used in the fraction example below, solves this problem:

\begin{small}
\begin{verbatim}
withFontSize_ :: Xprez -> (Int -> Int) -> Xprez
withFontSize_ xp ffs = 
  xp `with_` \(inh, syn) -> (inh { fontSize = ffs (fontSize inh) }, syn)
\end{verbatim}
\end{small}


With \texttt{p `withFontSize\symbol{95}` (\symbol{92}fs -> 2*fs)} we can now specify the doubling of the font size for a presentation \texttt{p}, but again, this requires a function in the presentation code, although it is easier to write than the functions required by \texttt{with\symbol{95}}. A more natural solution is the declaration of a special data type \texttt{Length}, with operations such as addition and multiplication, but which also has primitive values that represent current font properties. In Haskell, type classes can be used to accomplish this. Using type classes, it will be possible to write: \texttt{vSpace (2*ex)}, which denotes a horizontal space of twice the height of the letter x in the current font. A future version of {\sc Xprez} will support special syntax for \texttt{with\symbol{95}}, allowing \texttt{text "a" with $\{$ child.fontSize = parent.fontSize * 2 $\}$} to be written without explicit functions.\todo{mention this stuff?}

The font-size combinators show how abstraction is used to meet the {\em proportional effort} requirement. For simple changes of the font size, the simple \texttt{withFontSize} combinator can be used, and only if more control is desired, it is necessary to use the more complicated \texttt{withFontSize\symbol{95}} or \texttt{with\symbol{95}} combinators.



\fromHere

%																
\subsection{Advanced examples}

Because a presentation in {\sc Xprez} is a first-class value, it is possible manipulate a child presentation (e.g.\ change its position or modify the font size) at the level of its parent.  This is illustrated in the presentation for a mathematical fraction: 

\begin{small}
\begin{verbatim}
frac e1 e2 = let numerator   = hAlignCenter (pad (shrink e1) )
                 bar         = hLine
                 denominator = hAlignCenter (pad (shrink e2) )
             in  colR 2 [ numerator, vSpace 2, bar
                        , vSpace 2, denominator ] `withHStretch` False

pad xp = row [ hSpace 2, xp, hSpace 2 ]

shrink e = e `withFontSize_` (\fs -> (70 `percent` fs) `max` 10)
\end{verbatim}
\end{small}

The non-primitive library function \texttt{hAlignCenter} centers its argument horizontally, and the \texttt{shrink} function reduces the font size to 70\%, with a minimum of 10. The result of \texttt{(text "x" `frac` text "2") `frac` text "1 + y"} is:

\begin{center}
\epsfig{file=pics/eps/frac.png.eps, width=0.5in}
\end{center}

The \texttt{pad} and \texttt{shrink} functions illustrate the {\em first-class} and {\em abstraction} requirements. Because a presentation is a first-class value, the presentations of the numerator and the denominator can be resized and positioned in the presentation of the fraction itself. Furthermore, we can abstract over positioning and resizing by using the functions \texttt{pad} and \texttt{shrink}. 

In contrast, child presentations in both P or PSL cannot be addressed at parent level. Hence, the numerator, the denominator, and even the fraction bar, each have to specify their own size and relative position. As a result, it is difficult to reuse parts of a presentation in another presentation, since all parts refer to each other. Furthermore,  the manipulations on the appearance are harder to read, because no abstraction can be used. 


The second example is a pair of combinators that can be used to create tree browser presentations:

\begin{center}
\epsfig{file=pics/eps/tree.png.eps, width=1in}
\end{center}

\toHere

The image has been created with the \texttt{mkTreeLeaf} and \texttt{mkTreeNode} combinators, shown in Figure~\ref{treeCombinators}. Both combinators take an \texttt{Xprez} argument that is the presentation of the label, and the tree node also takes a list of child presentations (which should be either nodes or leaves for a correct tree, but can actually be any value of type \texttt{Xprez}). Labels are not restricted to text, but can also be images, or composite {\sc Xprez} presentations, like the label that contains the case expression in the last leaf of the example tree. 

The tree example is given here to show that a rather complex and graphical presentation can be specified with relatively little effort. However, in order to make this presentation a fully operational tree browser that can react to mouse clicks, we need to model the presentation state and edit operations on this state. This is not possible in the current version of {\sc Xprez} but will be possible in the Proxima editor system.
\begin{figure}
\begin{small}
\begin{center}
\begin{footnotesize}
\begin{verbatim}
mkTreeLeaf :: Bool -> Xprez -> Xprez
mkTreeLeaf isLast label = 
  row [ leafHandle isLast, hLine `withWidth` 5, leafImg
      , hLine `withWidth` 5, refHalf label ] 

mkTreeNode :: Bool -> Bool -> Xprez -> [Xprez] -> Xprez
mkTreeNode isExp isLast label children =
  rowR 1 [ hSpace 4, nodeHandle isExp isLast, hLine `withWidth` 5
         , col $ [ row [ col [nodeImg , if isExp then vLine else empty]
                       , hLine `withWidth` 5, refHalf label ] ]
                 ++ (if isExp then children else [] ) ]

nodeHandle isExp isLast 
 = colR 1 ([ Line, handleImg isExp]++ if isLast then [] else [vLine])

leafHandle isLast 
  = colR 1 ([vLine, empty]++ if isLast then [] else [vLine])

handleImg isExp = if isExp then minusImg else plusImg

nodeImg = img "folder.bmp" `withRef` (7,7)
leafImg = img "help.bmp"   `withRef` (7,6)
plusImg = img "plus.bmp"   `withRef` (4,4)
minusImg = img "minus.bmp" `withRef` (4,4)
\end{verbatim}
\end{footnotesize}
\caption{{\sc Xprez} treebrowser combinators}\label{treeCombinators} 
\end{center}
\end{small}
\end{figure}



%																
\subsection{Future work}

{\sc Xprez} meets the requirements listed at the bottom of Section~\ref{sect:existingtarget}, except for domain-specific syntax, for which a special parser will have to be added to the system. Furthermore, there are a number of things that are still lacking in the current model and that are being investigated. Firstly, there is no page model yet, and hence no page related concepts such as footnotes and page references are possible. Probably, an abstraction similar to the {\em galley} from Lout~\cite{kingston93lout} can be used for this. Secondly, there is no primitive notion of padding, which will allow spacing in columns and rows to be specified more naturally. Both of these concepts are related to the need for a more powerful \texttt{format} primitive that can handle both horizontal and vertical formatting while offering more control over the generated rows and columns. Finally, the \texttt{with\symbol{95}} combinator only gives access to the properties of a parent and its child. It is not possible to access properties of siblings, or presentations elsewhere in the tree, but it is also not yet clear whether such access is really necessary in a presentation language. Nevertheless, the set of combinators we have presented is powerful enough to cover much of the \TeX~math typesetting as described in \cite{heckmann97functionalTex}, including superscripts and subscripts. We also expect that defining a presentation sheet for the MathML~\cite{mathml20} language will be rather straightforward in {\sc Xprez}.


%																
%																
%																
\section{Conclusions} \label{sect:conclusions}

\note{paper-style conclusions must be changed to chapter conclusions}
Current style sheet languages lack either the expressiveness or the abstraction mechanisms to specify complex presentations in a readable way. The declarative presentation language {\sc Xprez}, introduced in this paper, combines a flow and box model with a powerful abstraction mechanism and first-class presentations. The language is well suited for specifying a wide range of presentations, from tree browsers to WYSIWYG presentations of mathematical formulas, using concise and readable style sheets.


% research: develop a more algebraic description, so we can show stretching and alignment without giving the entire AG.

% page model

\bc
A Haskell implementation has been developed for both the target and transformation parts of {\sc Xprez}. It has been used to generate all screen shots in this paper. The user interface of this implementation is still in a premature stage, and the dependency on a number of different tools make it difficult to install. However, these are minor problems which require a fair amount of programming, but pose no major theoretical difficulties. For more information about the system, contact the authors, or visit: \url|http://www.cs.uu.nl/research/projects/proxima/|
\ec
\todo{mention Xander van Wiggen for his Renderer?}

\bc
\head{Acknowledgements}

The authors thank Xander van Wiggen for implementing the {\sc Xprez} renderer, and Dave Clarke and Doaitse Swierstra for their helpful comments on this paper.
\ec




\bc
Referee comments: 
The PADL 2002 Program Committee: PADL 2002 Decision,  Fri, 12 Oct 2001 15:27:12 -0400 (EDT) 
Harald Sondergaard: Your PPDP01 paper #16,  Mon, 7 May 2001 19:51:05 +1000 (EST) 
\ec









