\chapter{Introduction}
\label{chap:introduction}

{\em *** Version: \today~ ***}



\begin{figure} % use XY pic?
\hfill
\begin{minipage}[b]{.45\textwidth}
\begin{tabular}{c}
\begin{tabular}{|c|}
\hline 
Document \\
(Internal representation)\\
\hline 
\end{tabular}\\
$\downarrow$ $\uparrow$\\
\begin{tabular}{|c|}
\hline
Presentation \\
(Image, visible to the user)\\
\hline
\end{tabular}\\
$\downarrow$ $\uparrow$\\
User
\end{tabular}\caption{Editing (Draft)}\label{editprocess} 
\end{minipage}
\hfill
\begin{minipage}[b]{.45\textwidth}
\framebox{
\begin{minipage}[b]{5cm}
\normalsize 
\begin{center}
Ceci n'est pas un document\\
[2mm]
\tiny Martijn M. Schrage\\
[2mm]
24 April 2004\\
[4mm]
\end{center}
\scriptsize Contents\\
\tiny
\begin{tabular}{l}
1.~bla bla\\
~1.1~bla ............. 1\\
~1.2~bla bla ........ 2\\
\dots
\end{tabular}
\end{minipage}
}
\caption{A presentation}\label{editprocess} 
\end{minipage}
\hfill
\end{figure}



*** Pictures are still drafts because they might be replaced by screen-shots of the prototype.\\

\bc
Editing is concerned with the creation and maintenance of documents.  
Most documents have some form of structure. 

In this chapter, we give a rather informal definition of editing (editor?**), and look at why no str eds. From a number of use cases, we state a number of requirements that are important in the design of a generic structure editor. Other structure editors are evaluated on these requirements, and . We end with a discussion why no structure editor has yet .  give fun. req. and evaluate related work according to them. End with a discussion why no editor meets all requirements, and how proxima will.
\ec

%								
%								
%								

\bl
\o introduce terminology about structured documents and editing
\el



\section{Preliminaries}

\subsection{Structured documents and XML}


%\section{Structured documents}
%Basics of XML and DTD's  Schema. CSS. XSL
%XML is EBNF 
%Documents are trees

A {\em structured document} is document with a logical structure that conforms tAn example of a structured document is a program source, which conforms to its abstract syntax definition. However, structured documents are not necessarily. 

Document is not file, but internal data.


Although graphs can also be considered as structured documents, we do not . Computations over graphs are much more complicated that over trees, parsing is hard. And l
 

http://homepages.inf.ed.ac.uk/wadler/papers/xml-essence/xml-essence.pdf

The eXtensible Markup Language XML~\cite{xml11} is a format fo, XML a descendent of  SGML~\cite{sgml86} (Standardized General Markup Language) XHTML~\cite{xhtml}. 


 tree structured docs. The grammar of an xml document may be specified in a Document Type Definition (DTD), or a Schema. 
more exist

There exists a growing number of standards for XML subsets, also referred to as dialects. 

%XML is not a meta language.
\bl
\o thematical markup language MathML~\cite{mathml20}.  DocBook standard~\cite{walsh02docbook}. XHTML 
\el

In this thesis, we do not commit ourselves to a specific formalism to describe the document structure. assume structured documents to be describ. 

\bl
\o a specific formalism, we consider tree structured data, cfg
\o context free grammar trees. Suitable for most apps.  graphs are too difficult, parsing performing computations.
\el

% format for examples
We use Haskell~\cite{peytonJones03haskell} terms for representing example document fragments. For example, a document representing the expression $1 \times (2 + 3)$ can be denoted by $Product (Int 1) (Sum (Int 2) (Int 3))$. An XML representation this could be:

\verb|<Product><Int val=1><Sum><Int val=1><Int val=1></Sum></Product>|

\verb|<P>Some text with <b>bold</b> and <i>italic</i> words|
$Para [Text "Some text with", Bold (Text )]$


%Difference XML is markup. CFG is tree, everything is part of tree. Markup is more document with tags. leads to differences. 
things like expressions are awkward to model in XML. On the other hand, mixed... text with bold and bla tags are harder to describe in a cfg, ...
\subsection{Editing}
\label{sect:editing}


%what is an editor
While the term {\em editor} is usually only associated with text editors such as Emacs~\cite{stallman81emacs}, we will use it in a much broader sense. We regard as an editor any application that shows an image of an internal data structure to a user and allows the user to modify this structure. ??remove \rarr The internal data structure is referred to as the {\em document} and the image is the {\em presentation}. 
% add that notion of document is req'd? (is it?)

%boundaries of editor concept
Naturally, word processors, image editors, and XML editors are regarded as editors in this view, but there are also some less obvious examples. Take for example the preferences pane that is part of most window-based applications. The check boxes, selection lists, and text fields can be seen as a presentation of the preferences of the application. 

\bl
\o figure~\ref{} shows an image of a presentation of a document. schematical? editor
\o document is some internal data structure, invisible to the user. Emphasize that it is not the file! XML ascii, is just a textual presentation of the document.
\o from doc, presentation is computed. image.
\o presentation is computed by presentation mapping.
\o may be parameterized by a {\em presentation sheet}
\el

SHEET parameter to the presentation function. by modifying the sheet, user may influence the appearence of the document without having to modify the editor itself. popular for HTML and XML: Cascading Style Sheets or CSS~\cite{css2}.

%what is the edit process
Figure~\ref{editprocess} schematically shows the edit process. The editor shows a presentation of the internal document together with the current focus of attention to the user. The focus of attention, or {\em focus}, is a shared name for the selection as well the cursor (which is an empty selection). The user provides the editor with {\em edit gestures}, such as key presses or mouse movements, which are mapped onto updates on the document. The document is then re-presented and shown to the user. This process is repeated until the user quits the editor. Chapter~\ref{chap:formalSpec} contains a more formal specification of the edit process.


\bc
When regarded as an editor, more sophisticated input fields that incorporate parsers, may be used. Furthermore, normal undo/redo functionality is possible, instead of the course grained OK/Cancel model, which only allows accepting or ignoring all changes at once.
\ec

\bc
% misschien niet zo'n interessante para
With such a broad view of editors, it is possible to regard every application, and even an entire operating system as an editor. In essence, all a computer user does is give edit gestures with the mouse and the keyboard in response to the presentation on the computer monitor. In reaction to the edit gestures, the internal state of the computer changes, giving rise to a new presentation. 

% en nog een
There is no fundamental problem with this view, but we do not adopt it because a definition that is too broad does not help in finding appropriate abstractions for a generic structure editor. Therefore, we do not explicitly consider all applications to be editors, but adopt the view that many applications contain editors.
\ec

%what is structure editor
A {\em structure editor} is an editor that has knowledge of the structure of the document that is edited. More precisely, it offers edit operations that are not targeted at the presentation of the document, but rather at the document itself. Some structure editors exclusively offer edit operations targeted at the document structure ({\em document-oriented editing} or {\em structure editing}), whereas others also allow edit operations targeted at the presentation ({\em presentation-oriented editing}). Another possibility is that an editor offers structural navigation together with information on the structure but without any structure edit operations that modify the document.
examples

%text/structure   niet zo heel belangrijk.
We do not make a sharp distinction between text editing and structure editing. Instead, we regard all editing as structure editing, but with a varying level of structure. A text editor can be seen as a structure editor with a very simple structure model: a string or a list of strings. 

%what is generic?
An editor is a {\em generic editor} if it is not specifically built for a single document type but can be used to edit a whole class of document types. Instead of one single editor that works on arbitrary document types, genericity can also be achieved with an editor generator. The generator is an environment that generates an editor application based on a description of a specific document type. Although a generator is not as versatile as a single generic editor, we still do consider editor generators to be generic. 

%structure editor is not nec. generic
** but we will often use it as such "Proxima, a presentation-oriented structure editor"
The term structure editor is often associated with genericity, but non-generic structure editors are quite common. A few familiar examples are: equation editors, bookmark editors in web browsers, and outline editors.


maybe introduce XML Editor here? and forward ref?


%who is the user of a generic editor?
In the context of generic editing, the term {\em user} can refer to either an editor designer, who tailors the generic editor for a specific domain, or a user that is editing a document. Unless explicitly stated otherwise, we use the term user for the document editing user.

Because it is difficult to give a precise definition of a generic structure editor and because such a definition might be to restrictive, we will we will use a number of typical use cases to clarify what we mean be a generic structure editor. Section~\ref{sect:usecases} presents these use cases.

\subsection{Summary}
We conclude this section with a summary of the main terms that were introduced:

\begin{description}
\item[Document:] Internal data structure that represents the information that is edited.
\item[Presentation/View:] Visible representation of the document. 
\item[Presentation mapping/relation:] The relation between the document and its presentation.
\item[Presentation-oriented:] Edit operation targeted at the presentation: e.g. \
\item[Document-oriented/Structural:] Edit operation Targeted at the document: e.g. swap two chapters 
\item[Presentation sheet:] Parameter to the presentation mapping. 
\item[Presentation process:] Process of computing the presentation of a document.
\item[Interpretation process:] Process of computing a document from an (updated) presentation.
\item[Generic editor:] An editor that is suitable to handle different typ
\end{description} 

%								
\subsection{Classes of structure editors}

Three classes of structure editors are distinguished in literature: syntax-directed, syntax-recognizing, and hybrid editors. Syntax-directed editors mainly support edit operations targeted at the document structure, whereas syntax-recognizing editors support edit operations on the presentation of the document. A hybrid editor combines  syntax-directed with syntax-recognizing features, but the term is not used consistently in literature. 

\head{Syntax-directed Editors} 
% mention that structure editing is often source editing.
The first structure editors that were developed are the {\em syntax-directed editors}~\cite{reps84synGen,Bahlke86PSG,magnusson90orm}, also known as pure structure editors. Early syntax-directed editors show a plain text presentation of the document, usually a program source, but exclusively offer edit operations targeted at the internal document structure, and not at the presentation. The idea behind this was that if structural edit operations were available, a user would not need the textual edit operations anymore. Worse still, presentation-oriented edit operations would interfere with the user's structural model of the document and introduce errors, so they were prohibited altogether. Most XML editors and editors for preferences panes can be regarded as syntax-directed editors.

\begin{figure}
\begin{small}
\begin{center}
\begin{center}
\begin{small}
\noindent \xymatrix{
   \dataa{$Document$} \ar[dd]    &     \\
                                              & User  \ar[lu] \ar@{.>}[ld] \\
 \dataa{$Presentation$}  &   \\
}
\end{small}
\end{center}\caption{A syntax-directed editor}\label{synDirEdit} 
\end{center}
\end{small}
\end{figure}


Figure~\ref{synDirEdit} shows a schematic representation of a syntax-directed editor. The editor works by computing some presentation of the internal document structure, which is shown to the user together with a current focus of attention. The user provides an intended edit operation (edit gesture) on the document structure, from which a document update is computed. After the document is updated, a new presentation is computed, which is shown to the user.

If the editor supports clicking in the presentation to set the focus, the editor also needs to keep track of the origin in the document for each position in the presentation.

In the figure, the line between the user and the presentation is dotted because syntax-directed editors do not support edit operations on the presentation very well. Because the presentation is derived from the document, an edit operation on the presentation first needs to be mapped onto an edit operation on the document. Some syntax-directed editors offer a freely editable textual presentation of (part of) the document, and apply a parser to the edited text. Because this forces the user to work in a different mode of editing, this approach to editing is called {\em mode switching}.

A major problem with syntax-directed editors is the restrictiveness of the edit model (e.g.~\cite{vanter94practical,rubinNeal87design}). If a user wishes to change a while statement to an if statement, simply typing over the keyword is often not supported. The mode switching approach is not an ideal solution either. Often, a separate window showing a text-only presentation is opened and before the mode can be switched back, the edited text has to be valid. Furthermore, separate modes require a user to be constantly aware of the current mode of the editor. The resulting increased cognitive burden has been shown to be a source of errors~\cite{sellen90modes}.

% mention problems?
\head{Syntax-recognizing editors} 

At the other end of the spectrum are the {\em syntax-recognizing} structure editors~\cite{budinsky85sre, ballance92pan}. A syntax-recognizing editor keeps track of the textual presentation of the document. The user can freely edit the text, and the editor tries to recognize the document structure by means of a parser. Once the text has been (partially) recognized, structural information, navigation, and, for some editors, edit operations are available.

\begin{figure}
\begin{small}
\begin{center}
\begin{center}
\begin{small}
\noindent
\xymatrix{
   \dataa{$Document$}     &     \\
                                              & User  \ar[ld] \ar@{.>}[lu] \\
 \dataa{$Presentation$} \ar[uu] &   \\
}
\end{small}
\end{center}\caption{A syntax-recognizing editor}\label{synRecEdit} 
\end{center}
\end{small}
\end{figure}

Figure~\ref{synRecEdit} schematically shows a syntax-recognizing editor. The user's edit operations are targeted at the presentation, which can be edited freely. The document is derived by parsing the presentation; hence the reversed direction of the arrow, compared to Figure~\ref{synDirEdit}.

For each element in the document structure, the editor needs to keep track of what parts of the presentation it corresponds to, in order to show structural information in the presentation, as well as support structural navigation.  When a document structure has been recognized, additional information can be shown in the presentation, for example font and color changes, context sensitive menus, etc.

Similar to the syntax-directed editor, the picture of the syntax-recognizing editor also has a dotted arrow. In this case, because the document is derived from the presentation, structural edit operations on the document are difficult to support. A document edit operation has to be mapped onto an update on the presentation, such that parsing the updated presentation returns the intended updated document. Presentation information that is not stored in the document tree, such as whitespace and comments, has to be related to the document tree in some way, so that it can be put in the right place after a structural edit operation.

The main problem with syntax-recognizing editors lies in their limited applicability. Because the presentation needs to contain enough information to derive the document, interesting presentations that only show part of the document are hard to support. Furthermore, graphical presentations, as well as presentations containing computed values and structures do not fit the model, as these are difficult to parse. As a result, syntax-recognizing editors are mainly limited to text-oriented applications, such as program source editors.

% mention: good for program editing?
\head{Hybrid editors} 

The term hybrid editor is used for an editor that supports structural edit operations as well as presentation (often just textual) edit operations. 

In some publications (e.g.~\cite{teitelbaum81progSynth, minor90editing}), the term hybrid is used to refer to syntax-directed structure editors that support some form of presentation editing. As a consequence, most syntax-directed editors would qualify as hybrid editors, because most editors support some form of text parsing.

Others (e.g.~\cite{ballance92pan, koorn92gse}), however, advocate that hybrid should be reserved for editors that support full textual editing of the document, as well as structural edit functionality, even if structural modifications on the document are not supported. In this view, almost all syntax-recognizing editors would classify as hybrid editors. 

Because of the confusion, and because of the strictness of the syntax-directed versus syntax-recognizing classification, we rather regard the levels on which edit operations are supported together with the integration between edit operations on different levels. Syntax-directed editors mainly support document-level edit operations, whereas syntax-recognizing editors mainly support presentation-level edit operations.


%								
\subsection{Advantages of structure editors}

An editor that knows about the structure of the edited document can offer interesting functionality. Advantages include:

\begin{description}
\item[Different Views on the Document.] A structure editor may provide a user with several editable views on the document. The views can show the document with a different order, or with a varying amount of detail. 

\item[Graphical Views.] A view may contain color and fonts in order to clarify document structure, but also use layout alignment, and graphical elements such as lines and rectangles. Graphical views may also be used for WYSIWYG document editing.

\item[Derived Information in the Presentation.] The editor can analyze the document during editing and display information that is computed from the document structure. Examples are the results of static and type analyses in source editors, but also chapter numbers or an automatically generated table of contents.

\item[Structural Edit Operations.] Some operations, such as demoting a section with subsections to a subsection with subsubsections in a scientific article, are straightforward to specify at the structural level, but awkward at the presentation level.

\item[Structural Navigation.] Navigating over the document structure instead of its presentation can be very useful. In source editors, when the focus is on an identifier, a jump to its definition in the source may be performed. Furthermore, an outline view of the document can be shown in which a user can click to jump to the corresponding position in the document.

\item[Integration with Other Tools.] A structure editor allows fine control over integration with other tools, such as spell checkers, theorem provers, and program transformation systems. Furthermore, the editor may show the results coming from these tools at the appropriate position in the presentation, rather than showing a list of messages with line numbers. 

\end{description}

For document types with a textual presentation, such as program sources or XML documents, some of the advantages can be simulated with a text editor. Lexical analysis can be used on the edited text, and basic support for syntax coloring, auto-completion, and navigation can be provided. However, although simple and efficient, these solutions are  very basic and prone to errors, because, in general, much of the structure of a document cannot be recognized at a purely lexical level.

\bc
sometimes basic structural navigation.  Even though some of the document structure can be recognized at lexical level, in the general case, a full parse is needed. For example, when trying to specify a Haskell function definition as a line in which a '=' character is present, also lines containing strings or comments with '=' characters are identified as funcion definitions. In some cases the problems can be overcome, but in general this amounts to building a parser in a formalism that is too weak for that purpose. Therefore, we will not consider text editors in this overview of editors.
%*********************************
\ec

Despite the advantages, generic structure editors are not widespread at all. Several structure editors are used in small communities, but most development projects have been terminated, and in the last decade, very few publications on the subject have appeared. The rise of the XML standard has spawned a large number of generic editors, but when regarded as structure editors, XML editors do not show much variation and do not offer many of the possibilies that a structure editor could offer. Hence their applicability is limited, and using an XML editor to edit a java program source, for example, is not possible with the current generation of editors.

% pan article
As mentioned, users regard structure editors as being either overly restrictive, or not powerful enough. In the remainder of this chapter, we first give a set of possible applications of structure editing, and then explore a number of functional requirements that in our view are important for creating a flexible non-restrictive structure editor.

\section{Why Proxima}

%Why proxima

complex, but:
new stuff:

-extra state
-also editing on all? levels

Document standard XML getting popular, need editors.

interactive transformations, proof editors, rewrite systems
structural data complex presentations: math
programs with types and structural edit ops: IDEs

Proxima not about changing the world: struct editors, views, (THE?). editors have illogical/inconsistent features. Easiest to start all over with new model, however will frustrate users. Better to have a model that allow to express the familiar edit models. and merge them seamlessly.



\section{Outline of the Thesis}
* mention here or in chapter proxArch?:
Bootstrapping problem, descr. of levels layers and edit model. second is easier to give with in a formal story. however, design reasons for first are hard to comprehend without idea. So first informal arch and edit model and later the formal stuff

\begin{itemize}
\item 2 Example editors, requirements and evaluation of editors according to requirements
\item 3 Explain the Proxima Editor
\item 4 Informal introduction to the specification
\item 5 Formal specification of a layered editor
\item 6 Haskell combinators for implementing the formal description
\item 7 The presentation formalism {\sc Xprez}
\item 8 The proxima prototype
\item 9 Conclusions
\end{itemize}



