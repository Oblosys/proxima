\chapter{The Proxima Prototype} \label{chap:prototype}
% Reuse from Ch_EditModel

\bl
\o Architecture from Section~\ref{sect:proxArch} has been implemented (not completely) in Functional language Haskell
\o editor generator. compile for datatype and sheets, although sheets in future dynamic
\o Platform-independent, Windows, Linux,  Unix, Mac. 
\el

\bl
\o Evaluation layer still only tentatively
\o No effort in incremental, but simple fixes have been shown to make system run at acceptable speed.
\el

% switch with implementation of system?
\section{Implemented editors}

The prototype has been used to instantiate several example editors. 

Research vehicle, so many combined features in an incomplete editor.

Before we discuss the editors, we give a brief overview of the . that need to be to instantiate an editor with Proxima.

\subsection{Building an editor with Proxima}


\bl
\o doc type
\o pres ag
\o parser
\el

Evaluator is still basic.

\subsection{A Helium source editor}
subset of Helium~\cite{heeren03helium} similar to \ref{sect:sourceeditor}

Source with fraction, and types, and values (not useful, but similar to spread sheet)
folded function.

\head{structural editing}

1+2*3     ->     1+{Exp}
[ 1, >2<, 3 ]      [ 1, 3 >< ]    
    cut                            paste

\head{built-in XML/tree view}
incomplete    
\head{Jump to definition}
SCREENSHOT

\head{Beta reduction}
a few steps

\head{prettyprinter}

\todo{check manual}

\subsection{Slide editor}
Slide with Haskell and a type error
SCREENSHOT

two views
SCREENSHOT



\subsection{Chess board}

Integrated with Helium editor.

Chess board with computed possible moves

SCREENSHOT

attribute for square is possible move. `withMouseClick` cut piece paste here.

\section{Implementation}

\subsection{General}

Haskell is not generic: code generator for type decls. Flexible solution. GH other possibility.

Mappings. not everywhere actually only between arr and pres. and pres and enr. (doc is same as enr.)

\subsection{Architecture}

Implemented with combinators from Section

Each layer has a presentation and an interpretation module, defining present resp. interpret. 
Architecture module imports all and lifts the function pairs to layers Chapter~\ref{chap:archCombs}. 
%No hierarchical modules because of editor problem (all look the same). %? mention this at all?


\subsection{Evaluation}

\bl
\o Not really implemented
\o New type is a hassle. same type is not nice for doc type
\o Need support maybe in language. 
\el

\bl
\o Doc editing is done with code generation. (Only explicit tree editing, presentation-oriented doc editing is done by parsing edited presentation)
\el

\subsection{Presentation}

%If presenter/parser is explained in more detail here, then add a forward ref in chapter proxArch
\bl
\o Structural/Parsing in presentation
\o parser/recognizer combinators in parser
\o reuse combinator
\el


\begin{verbatim}
SEM Exp
  | PlusExp
      lhs.pres = loc (PlusExpNode @self @lhs.path) $ parsing $ presentFocus @lhs.focusD @lhs.path $
                   squiggleRanges @lhs.ranges @lhs.path $ addReductionPopupItems @reductionEdit $
                   row' [@exp1.pres , op (mkIDP @idP0 @lhs.pIdC 0) "+", @exp2.pres]

| DivExp      
      lhs.pres = loc (DivExpNode @self @lhs.path) $ structural $ presentFocus @lhs.focusD @lhs.path $
                   squiggleRanges @lhs.ranges @lhs.path $ addReductionPopupItems @reductionEdit $
                   frac @exp1.pres @exp2.pres

-- already in Xprez chapter?
frac e1 e2 = let numerator   = hAlignCenter (shrink e1)
                 bar         = hLine
                 denominator = hAlignCenter (shrink e2)
             in centerline $ row [ hSpace 2, colR 1 [ numerator, bar, denominator] `withHStretch` False
                                 , hSpace 2 ]
\end{verbatim}

parser:
\begin{verbatim}
..
     <??> (    (\tk e t-> reusePlusExp [tokenNode tk] Nothing (Just $ tokenIDP tk) (Just t) (Just e))
           <$> pKey "+" <*> parseExp 
          )
..

recognizeExp' = pStr $ 
         (\str e1 e2 -> reuseDivExp [tokenNode str] Nothing Nothing (Just e1) (Just e2))
     <$> pStructural DivExpNode
     <*> recognizeExp
     <*> recognizeExp

\end{verbatim}

\bl
\o Presentation transformation formalism is UUAG system.
\o pres attribute
\o generated attributes
\o Target is {\sc Xprez}
\o breaking not optimal, or is this more for Xprez chapter?
\el

\bl
\o Parsers and structure recognizers
\el

\bl
\o still a lot of code is added by hand. Need nice abstractions
\el

\subsection{Layout}

\bl
\o Layouter is simple. Just add whitespace
\el
\bl
\o Scanner processes presentation tree.
\o not parameterized
\el

\subsection{Arrangement}

\bl
\o AG implements Xprez. 
\o Unarranger is simple keep mappings for pointing. path translation. Formatters require little more work
\el

\subsection{Rendering}

\bl
\o Why wxHaskell~\cite{wxHaskell}. 
\o Elegant and fast. Enough low level hooks.
\o Piggy backs on vast wxWidgets library. low maintenance, more chance of continuity (unlike Fudgets, etc. when researcher proves his point and goes on with new project)
\o platform independent.  GTK+HS/GTK2HS No documentation yet
\o integrated in Haskell, much easier than external
\o very easy to change, very little dependence on GUI.
\o we want a Haskell GUI standard soon! 
\el

\bl
\o   The HTk, TclHaskell, FranTk and Yahu are based on Tcl/Tk. The Tcl/Tk backend are portable but slow. 
\o The Gtk+HS, iHaskell, Gtk2HS are based on GTK. Poor windows. Proxima is user-friendly and more appropriate for 90\%
of people using windows, than for vi users on Unix etc.
\el
\bl
\o Object I/O is Win32 specific.
\o External renderer was too slow and harder to communicate with. (already mentioned)
\el
\bc
Why wxHaskell.
Why ObjectIO. 
Easy and fast.
Tcl is slow, problem with diffing. 
OpenGL: Alas, there are no real documents describing HOpenGL yet. Incomplete and under construction. Maybe some day ok. However, might be optimized for 3-d rendering of graphical objects instead of heaps of text with a few lines and symbols + some nice menus.
GTK+HS/GTK2HS No documentation yet. Windows GTK does not appear stable (GIMP may crash at any time). Because the development platform (== my computer) is a Windows machine right now, this is not a wise choice.
Prent C renderer by Xander is incomplete, hard to update and not very portable. Also socket communication is expensive.
For now platform dependence is not a problem.
Porting to different Renderer is relatively easy, because of Layered implementation.
Future Proxima will perhaps use a standard Haskell GUI, or dedicated Renderer.
\ec

\bc Krasimir:

  * Gtk+HS
   * iHaskell
   * Gtk2HS
   * HTk
   * TclHaskell
   * Fudgets
   * FranTk
   * Object I/O
   * Yahu

None of them are capable for large scale development 
for some reason. The HTk, TclHaskell, FranTk and Yahu 
are based on Tcl/Tk. The Tcl/Tk backend are portable 
but slow. The Gtk+HS, iHaskell, Gtk2HS are based on
GTK. The backend is powerful and portable (GTK >= 2.0)
but I prefer to use just native libraries on 
different platforms. The Object I/O is Win32 specific.
I think that there are need of one portable and 
efficient library. It needs to have advantages of
existing library but must have single uniform
interface. I post this message to haskell@haskell.org 
because I think that development of nice libraries 
requires agreement of the entire Haskell Community on
basic design lines. I looking for peoples which are
interested in the development of "standard" GUI
library. \ec

\section{Future work and conclusions}


Straightforward or little research (but maybe a lot of work)

\bl
\o Parameterizable scanner.
\o Matrix.
\o Editing in formatter.
\o Standard stuff, file menu, search, keyboard macros, etc.
\o use dynamic module loading to change presentation dynamically. changing datatype dyn. is probably not an option
\o Extensions to Xprez presentation formalism. windows/frames/widgets/formatters/page model
\o error correcting parser
\el

Requiring further research:
\bl
\o Incrementality. easy tricks diffing. other ag stuff. maybe more complex explicit model: only requesting evaluation of what is needed.
\o formalism for declaring pres Extra state + language support
\o Libraries for easy editor building.
\o Focus handling
\o Full evaluator layer.
\o Graph support.
\o Storing presentation extra state.
\o formalism/combinator library for edit commands
\el

\bl
\o find more things and establish priorities by instantiating more editors
\el

\bl
\o conclusions?
\el