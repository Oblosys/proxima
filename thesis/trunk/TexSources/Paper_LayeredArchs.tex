%\chapter{Layered editor Architectures}
%\section{Modelling a presentation system}
%\subsection{One stage presentation}
%rename to >>Single<< stage presentation?
%\subsection{Layered presentation}
%\subsection{Layered presentation with local state}
%\section{Modelling an editor}
%\subsection{One stage editor}
%\subsection{Layered editor}
%\subsection{Layered editor with local state}
%\section{Incrementality}
%\subsection{One stage incremental editor}
%\subsection{Layered incremental editor}
%\subsection{Layered incremental editor with local state}
%\section{Conclusions}
%%\addtocounter{page}{35}

% import generated tex file here?


\chapter{Layered Editor Architectures}
\label{chap:layeredArchs}


 


 

We propose to use the functional programming language Haskell as an architecture description language (ADL), and demonstrate its aptness using the architecture of interactive systems as an example. A typical computer user uses many interactive systems such as a text editor, an e-mail program, a spreadsheet program, etc. Using such a system, a user creates a document in an incremental way, by editing through some view of the document. Many interactive systems pass through several phases (or layers, stages) when presenting a document to a user. For example, in a spreadsheet program, a document containing formulae is first mapped to a sheet containing just text and numbers, and is then transformed into a bitmap, which is shown to the user. This paper develops an architecture for interactive systems, by starting with a simple architecture and refining it stepwise to a layered architecture that can deal with incremental changes. The components in the architecture are related by means of invariants.

The architecture description itself is a Haskell program, in which both the data and the functionality are left unspecified. The advantage of describing the architecture as a Haskell program is that the Haskell type checker verifies that all functions and data types mentioned in the description of the architecture are introduced somewhere in the architecture, and that all arguments of functions are explicit and type correct: it is for example impossible to hide state except by using the functional programming concept of monads. Another advantage of using Haskell as an architecture description language is that the type and the invariants satisfied by a function are a very precise description of the desired functionality. This will make it easier to distinguish and implement different components of an architecture.

This paper is organised as follows: Section \ref{problem} describes our view on interactive systems; In Section~\ref{presenting}, we will give an architecture model for presentation systems. From the invariants for the presentation systems, we will construct the invariants for editors in Section~\ref{editing}, which will be further refined for editors that support incremental changes to the document. Section \ref{impl} formalizes the architecture in Haskell; Section \ref{related} discusses related work; Section \ref{conc} describes future work and concludes.
\section{The edit process}
\label{problem}

{\bf }
\subsection{What are editors}


{\bf }Many systems that at first sight are not identified as editors, are nevertheless used to edit existing information. Text editors and HTML editors are well-known examples of editors, but also spread-sheets, e-mail agents, or even the preferences screens that are present in most applications with graphical user interfaces can be regarded as editors. 

The common characteristic of editors is that they provide the user with one or more visible representations (which we will call {\em renderings} or {\em presentations}) of an internal data structure (which we will call the {\em document}), wait for some kind of input from the user or some other external agent, and update the document according to the received input. After the document has been updated, the process is repeated. The editor updates the representations to reflect the changes in the document and waits for new input. This cyclic process is the {\em editing} process, and we will call the user input an {\em edit gesture}. Furthermore, because the computation of the rendering from the document can be regarded as a separate process, we will refer to it as the {\em presentation process}. Summarizing, we have the following definitions.
 \begin{description}
 
 \item[Document:]
 The internal data structure that represents the data that is being
          edited by the user.
 \item[Rendering or presentation: ]
 A bitmap, showing a representation of the document, that can be
          viewed by the user.
 \item[Edit gesture:]
A proposed edit operation coming from a user or some external
          agent. An edit gesture can be a mouse click or a key press, but also the
          selection of an edit command from a menu.
 \item[Presentation process:]
The computation of a rendering from a document.
 \item[Edit process:]
The cyclic process of showing a rendering of a document to a user,
          receiving the edit gestures, updating the document accordingly, and recomputing
          the rendering.
 \end{description}






A user can only see a rendering of the document. Even if a structure view on the document is present that reveals the exact structure of the internal document, this is still just a rendering that represents the structure.
\subsection{Edit gestures}

\begin{figure}
\begin{small}
\begin{center}
\begin{tabular}{ll}
type & value \\
{\tt document :: Root String String} & {\tt document = Root "Hello" "World!"} \\
{\tt rendering :: Bitmap} & rendering =
\begin{tabular}{|l|}
\hline
\{Hello\}\{World\}\\
\{5\}\{6\}\\
\hline
\end{tabular}
\end{tabular}\caption{A simple editor}\label{simpleexample} 
\end{center}
\end{small}
\end{figure}


In order to examine different kinds of edit gestures, we will take a close look at a hypothetical editor, the document and rendering of which are shown in Figure~\ref{simpleexample}. The example editor is an editor of a simple tree structure that contains two string values. The top of the figure shows the document, which consists of a node containing the strings "Hello" and "World" and the bottom is the rendering of the document that is shown to the user. The rendering consists of two lines; on the top line, both strings are shown, surrounded by braces, and the bottom line contains the lengths of the strings, surrounded by braces as well. 

The two numbers in the rendering are examples of {\em derived values}. In a real editor, more interesting derived values will be present, such as chapter numbers and a table of contents, and in the case of a spreadsheet, all computed cells.

The example document can be edited in several ways, of which we will discuss three examples here: {\em document-oriented editing}, {\em presentation-oriented editing}, and {\em derived value-oriented editing}. Even though the edit gestures are conceptually different, all of them result in updates on the document (if they succeed), which in turn causes the rendering to change.

{\bf Document-oriented editing:} The first kind of editing occurs when the gesture is targeted directly at the structure of the document. In our example editor, a user may right click on one of the two strings, and a menu of edit operations pops up, which contains for example a command, called "swap children", which swaps the two strings, producing the new document \texttt{Root "World" "Hello!"}. Besides using a popup-menu, structural edit operations can also be offered by selection from a main menu bar after positioning the cursor, or pressing some keyboard short-cut. Of course, in this example, the structure is very simple, so the structural edit gestures are not very interesting. If the document is a more complex tree structure, however, for example a paper with sections, subsections and paragraphs, then there exists a multitude of possible edit gestures. Since these structural edit gestures directly correspond to edit operations on the document and their use requires the user to have a clear understanding of the structure of the document, we will refer to them as {\em document edit gestures}. 

{\bf Presentation-oriented editing: }If the cursor is positioned between the character '!' and the closing brace, and the user presses the '!' key, a '!' character is inserted after the word "world!" in the document, changing it to \texttt{Root "Hello" "World!!"}. The rendering will change accordingly to show the updated string, and the '6' will change to '7'. Unlike the previous edit gestures, this gesture is not as much concerned with the structure of the document, but rather with how the document is presented in the rendering. Instead of directly editing the document, the user changes the rendering and the document is updated in such a way, that the new rendering reflects this change. This is more clear if we envisage a rendering in which all lower-case characters in the document are mapped to upper-case characters and vice versa. Inserting an 'a' as a document edit gesture would result in an 'A' appearing in the rendering, whereas if the {\bf insert 'a'} gesture is presentation oriented, the result would be the insertion of 'A' in the document, so that an 'a' would appear in the rendering. For now, we will call these edit gestures {\em presentation edit gestures}. They are not called rendering edit gestures, as this would suggest that the user is performing edit gestures on the actual bitmap. However, even though inserting a bitmap of a letter 'a' in order to insert an 'a' in the document is rather absurd, the concept of rendering edit gestures is not that far fetched if we regard a graphical editor in which bitmaps can be manipulated directly. 

The difference between both classes of edit gestures becomes apparent in editors that allow free editing of a textual presentation of the document, and then use a parser to compute the updated document. The keywords and separators that are typed in by the user, are edit gestures on the presentation of the document, and not on the document itself, since keywords and separators may not even be present in the document (the expression "if $<$exp0$>$ then $<$exp1$>$ else $<$exp2$>$ fi" can be modeled by a tree node \texttt{If exp0 exp1 exp3}).

{\bf Derived value-oriented editing: }The sample editor can support yet another kind of edit gesture by allowing the user to edit the numbers that represent the string lengths. For example, when a user right clicks on the '5' the editor might offer a number of menu items, such as an {\bf increase number} item. Selecting this item could result in adding a space to the \texttt{"Hello"} string, thus increasing its length by one. In this case, editing the derived value may not seem very useful, but there are many cases in which it is. If the rendering of a document contains a tree browser view representing the structure of the document, then it may be desirable that moving nodes in the tree browser results in changes to the structure of the document.

\bigskip All of the example edit gestures result in updates on the document, and could therefore be regarded as document updates, but there is a difference in the directness with which the gesture is mapped to a document update. The document edit gesture directly corresponds to an update on the document, whereas a presentation edit gesture is mapped to an update more indirectly. It is even possible that a presentation edit gesture is mapped to an update on a derived value, which in turn is mapped to a document update. As an example, consider textual editing of the numbers representing the lengths. If the '5' is changed to a '15' by typing a '1', this is a presentation edit gesture, as the presentation of the length is edited. A possible semantics of the edit gesture is the insertion of 10 spaces in the \texttt{"Hello"} string.

In the next sections we will show that the presentation process is typically a staged computation, and that the different kinds of edit gestures correspond to edit gestures targeted at the different intermediate levels of the rendering computation. Furthermore, we will show that the mapping from gestures to document updates is staged as well. 

\bigskip {\bf Editing local state:} In addition to gestures that update the document, it is also possible to have edit gestures that do not change the basic document at all. Consider again a rendering that contains a tree browser view of the document structure. Because the nodes in the tree browser can be expanded and collapsed, the tree browser view needs to keep track of the expansion states. The states could be accommodated in the document, but that is not where it conceptually belongs, because this causes the type of the document to depend on the way in which it may be viewed. Furthermore, if several views on the document are open simultaneously, each one requires a separate expansion state; this suggests that such information belongs to the view itself rather than to the basic document. We will refer to this kind of state information as local state, because it is local to the view. We will show that local state can appear in any of the intermediate values in the presentation process. Note that we speak of local state editing instead of local state-oriented editing, since the editing is not just targeted at the local state but also results in updates on the local state, unlike the previous gestures, which were targeted at different levels, but all resulted in updates on the document.

Not all editors support the various edit gestures that were discussed in this section. In fact, we have no knowledge of an editor that supports derived values, local state, and presentation editing as well as document editing.  The Proxima project is concerned with the design of a generic XML editor which does support these aspects. In the next sections, we will formally describe the layered architecture model that we have developed.
\section{Modelling a presentation system}
\label{presenting}



Presentation systems are applications that provide a user with some kind of view on a data structure. Examples are pdf-viewers, image viewers, and web browsers, although the latter also have functionality for accessing non-local documents. Because all editors are in essence presentation systems with extra functionality for editing the presented data, we will first develop a number of invariants that model the architecture of a presentation system.

In this section, as well as in the following two, we will follow the same line of reasoning while constructing the invariants: First, we consider a simple case, in which the rendering of a document is computed in one single step. Secondly, the functions mapping the document to the rendering and the functions that map the edit gestures on the rendering to document updates are split in a number of subfunctions, each handling a specific step in the mapping process. And finally, we will extend the invariant to support the local state that was mentioned in the previous section. In some cases, a first attempt is given for the invariant, which is refined afterwards. 


\subsection{One stage presentation}


Suppose that there is a function $present :: Document \rightarrow Rendering$ that maps a $document$ of type $Document$ to a $rendering$ of type $Rendering$. We formally define the relation between the document and the rendering with the invariant:\begin{small}\begin{align*} %\label{ssp}
present & :: Document \rightarrow Rendering \\
\end{align*}
\begin{math}
rendering = present~document
\hfill \text{\{Compute Rendering\}}
\end{math}\end{small}

{\centering (Invariant 1: One stage presentation, 1st attempt)\\}\vspace{1em}

We will now refine this invariant slightly. During the computation of the rendering, information can be computed that will make it possible to map positions in the rendering back to positions in the document. In the next section, where we will model an editor, this mapping information will be required, so we will extend the current equation to explicitly define this information. It will be denoted by the variable $mapping$ which has type $Mapping$. We do not make any assumptions about the type $Mapping$ at this point; it may be a table, a function or whatever data that is necessary to keep track of the mapping between the positions in the rendering and the positions in the document. The mapping information is not used here yet, it is only introduced here in order to make the development of the invariants in the next section easier. 

Because the presentation function now computes the rendering as well as the mapping information, it returns a tuple:\begin{small}\begin{align*} % \label{sspupdate}
present & :: Document \rightarrow (Rendering, Mapping) \\
\end{align*}
\begin{math}
(rendering, mapping) = present~document
\hfill \text{\{Compute Rendering\}}
\end{math}\end{small}

{\centering (Invariant 2: One stage presentation, Final)\\}\vspace{1em}
\subsection{Layered presentation}


The invariant~2 gives us a correct but rather coarse way of modeling the presentation process. It might suffice for very simple text editors in which the document consists of a list of characters and there exists a straightforward mapping between the document and the rendering, as each of the characters directly corresponds to a specific part of the rendering. But in a WYSIWYG structure editor, the representation will be a bitmap that is not as obviously related to the document. The rendering might contain structures that are computed from the document, such as a table of contents, or chapter and section numbers. Furthermore, some parts of the document might not even be visible, and others will not directly appear in the rendering, but rather influence the way in which other parts are rendered (a {\bf bold} tag for example). We will refine the invariant to allow for a close modeling of complex presentation processes as well.
\begin{figure}
\begin{small}
\begin{center}
\begin{footnotesize}\begin{tabular}{rll}
& type & value \\
1) & {\tt Document = Root$_{doc}$ String} & {\tt Root$_{doc}$ "Hello World"} \\
2) & {\tt EnrichedDoc = Root$_{enr}$ String Int} & {\tt  Root$_{enr}$ "Hello World" 11}\\
3) & {\tt AbsPres = Row [AbsPres]} &   \verb|Col [ Row [ String "{", String "Hello World"|\\
 &                                   & \verb|          , String "}"]| \\
 & {\tt ~~~~~~~~~~~~~| Col [AbsPres]} & \verb|    , Row [String "{", String "11", String "}"]]| \\ 
 & {\tt ~~~~~~~~~~~~~| String String} & \\
4) & {\tt Arrangement = [ArrangementElt]} & \verb|[ {txt = "{", x = 0, y=0, color=Black, fontSize=10}| \\
 &                                        & \verb|, {txt = "Hello World", x = 110, y=0, ... }| \\
 &                                        & \verb|, ... ]|\\
 & {\tt ArrangementElt = \{txt :: String,}& \\
 & {\tt ~~~~~~~~~~~~~~~~~~x, y :: Int,} & \\
 & {\tt ~~~~~~~~~~~~~~~~~~color :: Color} & \\
 & {\tt ~~~~~~~~~~~~~~~~~~fontSize :: Int\}}& \\
5) &{\tt Rendering = Bitmap} & 
\begin{tabular}{|l|}
\hline
\{Hello World\}\\
\{11\}\\
\hline
\end{tabular}
\end{tabular}\end{footnotesize}\caption{Five data levels}\label{datalevelexamples} 
\end{center}
\end{small}
\end{figure}


In order to examine the different ways in which a document can be edited, we will take a close look at a hypothetical editor, the document and rendering of which are shown in Figure~\ref{simpleexample}. The example editor is an editor of a simple tree structure that contains two string values. The top of the figure shows the document, which consists of a node containing the strings "Hello" and "World!" and the bottom is the rendering of the document that is shown to the user. The rendering consists of two lines. On the top line both strings are shown, surrounded by braces, whereas the bottom line contains the lengths of the strings, surrounded by braces as well. 

The computation of a more complex rendering is performed in several steps. As an example, consider the data types and values in Figure~\ref{datalevelexamples}. The figure describes the data types that occur in a staged computation of the rendering of a very simple document type. The document is not directly mapped to the rendering, but first mapped to an intermediate data structure. The intermediate data structure is mapped to another intermediate data structure, and this process is continued until the the last intermediate value is mapped to the rendering. On the left side of the figure are the types of the document, the rendering and the intermediate values, and on the right side example values. 

The top level {\em Document}~(1) is a tree with one node, tagged \texttt{Root}$_{doc}$, that contains a single child of type {\em String}. The document is mapped to an {\em Enriched Document}~(2) of type {\em EnrichedDoc}, which has a type similar to that of the document, but which is extended with a derived value. In this case there is just one derived value of type {\em Int}, which is the length of the document string. Enriched documents can capture many kinds of derived values. However, information like page references cannot be captured, as these depend on information that is only present at a later stage in the presentation process. 

From the enriched document, the {\em Abstract Presentation}~(3) of type {\em AbsPres} is computed. It is a tree that describes the logical layout of the enriched document. In the example, an abstract presentation is either a row or a column of abstract presentations, or it is a string, but in a real setting, this will be a more complex type, supporting paragraph formatting, font attributes, etc. Typically, the function that computes the abstract presentation is described by a style sheet, which specifies how each of the nodes in the enriched document tree is presented. The mapping function in the example maps the string and the integer of the enriched document on an abstract presentation that is a column of two rows, the top one of which contains the string surrounded by braces, and the bottom one a string representation of the integer. The advantage of a staged computation is visible here, as the presentation function need not distinguish a derived value from a document value: both are treated as values of the enriched document tree, and are handled in the same way. The same advantage is present in later stages of the computation as well. The data on a given level can be computed from the level right above it, disregarding how that data was actually constructed. 

In the {\em Arrangement}~(4), the logical layout has been mapped to an absolute layout. For each of the components in the abstract presentation, an absolute position, color, font, etc. has been calculated. An {\em ArrangementElt}, or arrangement element is a record that consists of a string, an absolute position and a fontsize. An arrangement function in a real editor will compute more attributes and perform layout functions, such as line and page breaking. Furthermore, a real arrangement type will include more arrangement elements, such as lines and rectangles, and more attributes (line width, background color, etc.).

The bottommost data type in the figure is the {\em Rendering}~(5), which is the the result of the presentation function. It is a bitmap, the type of which is left further unspecified here.

We will first give the invariant for the layered editor without the mapping information. The fact that the computation is staged can be modeled in the invariant by splitting $present$ in several functions: $present_{n-1} \cdot present_{n-2} \dots present_{0}$. If we denote the intermediate types in the computation with $Data_i$, where $Data_0 = Document$ and $Data_n = Rendering$, then the type of each function $present_i$ is $present_i :: Data_i \rightarrow Data_{i+1}$. The presentation invariant becomes:\begin{small}\begin{align*} % \label{lp}
present_i & :: Data_i \rightarrow Data_{i+1} \\
\end{align*}
\begin{math}
rendering = (\bigodot_{i=n-1}^{0} present_i)~document
\hfill \text{\{Compute Rendering\}}
\end{math}\end{small}

{\centering (Invariant 3: Layered presentation, 1st attempt)\\}\vspace{1em} 

We will refer to the types $Data_i$ as the {\em data levels} of the editor, and to the functions that operate between these levels, as the {\em layers} of the editor. For now, layer$_i$ only comprises the function $present_i$, but as we extend the model, more functions will be incorporated in the layer. Figure~\ref{levelsandlayers} shows $n$ data levels and the $n-1$ layers between the levels. Note that the topmost level in the picture is level$_0$. We will refer to levels with a smaller index (which are higher in the figure) as higher levels, hence level$_0$ is the highest level and level$_n$ is the lowest level. The levels are ordered in this way to reflect that a data level higher in the architecture has a higher level of abstraction. 
\begin{figure}
\begin{small}
\begin{center}
\begin{center}
\begin{small}
\bigskip \noindent
\xymatrix{
\data{Level$_0$ (Document level)} \\
\component{Layer$_0$} \\
\data{Level$_1$} \\
\cdots \\
\data{Level$_{n-1}$} \\
\component{Layer$_{n-1}$} \\
\data{Level$_n$ (Rendering level)}
}
\end{small}
\end{center}\caption{Levels and layers}\label{levelsandlayers} 
\end{center}
\end{small}
\end{figure}


The invariant still has to be completed by adding the mapping information. Because the function $present$ is split in $n$ subfunctions, each of which will produce mapping information, $mapping$ will be split as well, giving rise to $mapping_i$. The indices of the $mapping_i$ are between $0$ and $n-1$ instead of between $1$ and $n$, because the mapping information is associated with the layer, rather than with the resulting data level. Hence, $present_0$ produces a value of $Data_1$ and a value of $Mapping_0$. However, if we change the type of $present_i$ to $present_i :: Data_i \rightarrow (Data_{i+1}, Mapping_{i})$, we can no longer use function composition to combine the $present_i$ functions, because the result of $present_i$ is a tuple of $Data_{i+1}$ and $Mapping_{i}$ whereas the argument of $present_{i+1}$ is a value of type $Data_{i+1}$. If we change the type of $present_i$ to $(Data_i, Mapping_{i-1}) \rightarrow (Data_{i+1}, Mapping_i)$ then composition works again but we need a different type for $present_0$, or have to start the presentation computation with a tuple of the document and a dummy mapping value $(Document, ())$. Worse still, the type now suggests that the result of $present_i$ depends not only on $Data_i$, but also on $Mapping_i$, which is not the case. We will therefore use the type $present_i :: Data_i \rightarrow (Data_{i+1}, Mapping_i)$ and write the invariant as a recurrence scheme rather than a composition. The computation will be: $(data_i, mapping_i) = (pres_{i-1} \cdot fst \cdot pres_{i-2} \ldots fst \cdot pres_{0})~document$, which can be written more formally as follows: \begin{small}\begin{align*} % \label{lpupdate}
present_i & :: Data_i \rightarrow (Data_{i+1}, Mapping_{i}) \\
\end{align*}
\begin{math}
\forall 0 \le i \le n-1: \\
data_0 = document \\
(data_{i+1}, mapping_{i}) = present_i~data_i\\
rendering = data_n \hfill \text{\{Compute Rendering\}}
\end{math}\end{small}

{\centering (Invariant 4: Layered presentation, Final)\\}\vspace{1em} 

Since we now have a uniform definition for each data level $data_i$ in terms of the function $present_i$ and the level above ($data_{i-1}$), the variables $document$ and $rendering$ no longer appear directly in the equation. For sake of clarity, equations for $document$ and $rendering$ are still present in this invariant, but from now on, in the layered case, we will refer in the invariant to $data_0$ and $data_n$ instead of $document$ and $rendering$.
\subsection{Layered presentation with local state}


According to the invariant~4, the rendering only depends on the document and the functions $present_i$. However, this is too simple a view of the situation. We will argue below that in many editors parameterizing $present_i$ with two parameters is desirable. One will be static and remain unchanged during the edit process, whereas the other will be subject to user edit operations. Even though at the moment we are modeling a presentation system, we will model the dynamic state as well, although we will not give an edit model for it until in the next section.

{\bf Static local state:} First, we will explain the need for static parameters. If $present_i$ has no extra parameters then $data_{i+1}$ only depends on $data_i$, which means that the mapping is entirely fixed. In some cases, however, we want to be able to influence the appearance of the document without changing the document, or having to recompile the entire system. For example, information that specifies how the document is presented can be put in the document itself, but a more elegant solution is to have a separate style sheet that specifies the presentation and pass that style sheet as an argument to the appropriate subfunction $present_i$. The languages XSL\cite{xsl} and CSS-2\cite{css} are good examples of such style sheets. It should be noted that even though the editor or presentation system regards the style sheets as entities different from the document, the document and the style sheet can still be stored in the same file on an actual file system (as can be the case for CSS style sheets). Another use for sheets is found in presentation systems that support user specified derived values. The specification of the computation of these values can be put in a computation sheet which is an argument of the $present$ subfunction that takes care of adding the derived values. We will model the static parameters by adding a parameter $sheet_{i}$ of type $Sheet_i$ to each function $present_i$.

{\bf Dynamic local state:} Apart from a static parameter to the mapping functions, we also introduce a dynamic parameter to the mapping function. The dynamic parameter is used to model state in the presentation system that conceptually does not belong to the document. 

An example of dynamic state is the expansion state of a tree browser, which was mentioned in Section~\ref{problem}. The expansion state is not part of the document, but comes into play at the layer that takes care of building the tree browser view. This layer accesses the local state to determine whether a node should be presented in its expanded state, in which case subtrees for its children are present in the presentation. A second example of local dynamic state is the cursor position of the editor or presentation system. Frequently, a presentation of a document contains elements that do not appear directly in the document, for example an automatically computed table of contents. However, since the table of contents appears in the presentation along with the document, it is only natural that we can move the cursor over it in the same way we can move it over the rest of the presentation. Allowing this means that the cursor can be at positions that do not make sense at document level, which will make it difficult to manage it at this level. The problem can be solved by keeping track of the cursor in the local state of a lower level in the presentation process. Yet other examples of local state are the current selection (related to the cursor), magnification of the view, etc.

We will model the dynamic state by an extra parameter $state_i$ of type $State_i$ to $present_i$. This does not preclude that in an actual implementation the state will somehow be accomodated in the document, but that fact will not be visible in the grammar of the document.

{\bf Modelling local state: }The difference between static and dynamic state is that the latter can be changed during the editing process. It would even make sense to be able to edit dynamic state in a presentation system, since presentation systems can support selections and tree browsers. However, since the model for presentation systems that we are discussing is only used as an introduction to the model for an editor, we will postpone the local state editing until the next section, where we will give an edit model for the document as well as for the local states. 

The two extra parameters of $present_i$ are supplied before the $Data_i$ parameter, so that if both parameters are supplied, the result is a function $present_i~sheet_i~state_i :: Data_i \rightarrow Data_{i+1}$, similar to the $present_i$ in invariant~4. The order of the two parameters is based on the frequency of changes to the parameter. The parameter that changes least often is put first. With the two extra parameters, the invariant becomes:\begin{small}\begin{align*} % \label{llp}
present_i & :: Sheet_i \rightarrow State_i \rightarrow Data_i \rightarrow (Data_{i+1}, Mapping_{i})\\
\end{align*}
\begin{math}
\forall 0 \le i \le n-1: \\
(data_{i+1}, mapping_{i}) = present_i~sheet_i~state_i~data_i
\hfill \text{\{Compute Rendering\}}
\end{math}\end{small}

{\centering (Invariant 5: Layered presentation with local state)\\}\vspace{1em}

At first glance, it may not make sense to also have local dynamic state at the top level, since the document itself is a kind of top level local state already. We could choose to model the document as the top level local dynamic state, but there are two objections to this. First of all, doing so will break the elegance of the equation, since the first stage will then be a special case because $present_0$ will have type $Sheet_0 \rightarrow Data_0 \rightarrow Data_1$ instead of $Sheet_0 \rightarrow State_0 \rightarrow Data_0 \rightarrow Data_1$. Having a different type for $present_0$ can be avoided by defining $data_0$ to be some kind of dummy parameter, which is supplied to $present_0$ together with the document, but then the presentation function is not a function from $Document$ to $Rendering$ anymore. 

Secondly, it is possible that in some editors, $present_0$ will depend on certain editable parameters that do not fit in the document. For example, if the editor is very simple and has a one stage mapping, then any local state present, such as the cursor position and selection information, should be accomodated in $state_0$.
\section{Modelling an editor}
\label{editing}

Since we are modeling an editor, the document at the top level, as well as the local states, will evolve during the editing process. We will now construct invariants that model an editor by following the same refinement steps as in the previous section. First we will consider a one stage case and formalize the edit model; then we add layers to the model and finally we add local state.

Before we can formalize the concept of an editor, we need a few definitions. In our model, the user can perform actions that may result in updates on the document. These actions are the {\em edit gestures} that were introduced in Section~\ref{problem}. Examples of edit gestures are mouse clicks and key presses, but also selections made in pop-up menus or in the main menu bar. The semantics of accepting an edit gesture may be an update on the document or one of the local states. Not all edit gestures, however, will always be accepted. The user can try to edit a part of the document which is not editable, in which case the editor will not perform any updates at all.
      

The editor translates the edit gesture to an {\em edit intention} on the appropriate data level, after which it is mapped to an actual update, or {\em edit operation}, on the document or one of the local states. The word intention is used to emphasize the fact that the edit intention, which is a proposed edit operation might not actually succeed, or might result in a slightly different edit operation. As an example of the latter, consider a program editor that represents program sources by trees at the document level, but shows to the user a textual presentation that is editable by typing in the constructs of the source language. If the editor has syntax coloring, and the user types in a string, then the edit intentions of inserting characters will result in edit operations that not only insert the characters, but also change the color once a keyword has been recognized. 

Summarizing, we have the definitions:
 \begin{description}
 
 \item[Edit intention]
A proposed update at a certain data level.
 \item[Edit operation ]
An actual update on the document or one of the local states.
 \end{description}

\subsection{One stage editor}
\label{subsectsingleedit}
\begin{figure}
\begin{small}
\begin{center}
\begin{center}
\begin{small}
\bigskip \noindent
\xymatrix{
 \data{$document$} \ar[dd] \ar[rr] & & \component{update} \ar[r] & \data{$document'$} \ar[dd] & \\
& & \data{$e_{Document}$} \ar[u] & & \\
\component{$present$} \ar[dd] \ar[r] & \data{$mapping$} \ar[r] & \component{$translate$} \ar[u] & \component{$present$} \ar[dd] \ar[r] & \data{$mapping'$} \\
& & \data{$gesture$} \ar[u] \ar@{.>}[d] & & \\
\data{$rendering$} \ar@{.>}[rr]  & & \component{EDIT} \ar@{.>}[r] & \data{$rendering'$} &
}
\end{small}
\end{center}\caption{ The edit process}\label{editprocess} 
\end{center}
\end{small}
\end{figure}


We will model the editing process by giving the invariant for a single edit step. Figure~\ref{editprocess} shows what happens during such an edit step. The rectangles in the figure represent data values, whereas the rounded rectangles represent functions. Arrows are used to represent parameters (going to rounded rectangles) and results (coming from rounded rectangles). Because the figure is only a sketch of the computation, it does not show arrows for all parameters that are present in the final invariant. On the left side of the figure are the original document, rendering, and mapping information. We will assume $rendering$ and $mapping$ to be the result of applying the function $present$ to $document$; this is the precondition of the edit step. On the right side of the figure are the new values: $document'$, $rendering'$ and $mapping'$ for which we have the postcondition that $rendering'$ and $mapping'$ are the result of applying $present$ to $document'$, which will be the precondition for the next edit step. The meaning of the edit gesture is denoted by the dotted arrows, that relate the edit gesture and the original rendering to the updated rendering using the abstract function $EDIT$. By $EDIT~rendering~gesture$, we mean the rendering that is expected when $gesture$ is given to the editor in the state that is characterized by $rendering$. However, as $EDIT$ is not an implementable function, the actual updated rendering is computed following a different path. First, the gesture is translated to an edit operation on the document. Then, the operation is performed on the document by function $update$, giving rise to the updated document, which is presented in order to get $rendering'$. The figure sketches that given the presentation function $present$ and expected edit behavior denoted by $EDIT$, we need a function $translate$ that computes an edit operation $e_{Document}$ from a gesture such that if applied to the document, it yields an updated document whose rendering is the expected result of performing the edit gesture.
        

We construct the invariant in two steps. In the previous section the extra step was used for introducing the mapping information, but here we will use it to introduce two extra parameters to the translate function. The mapping information is already included in the first attempt. The $mapping$ parameter is placed before the $gesture$ parameter, so that $translate~mapping :: Gesture \rightarrow Edit_{Document}$.

The first three equations in the invariant state the precondition, the correctness of the updated rendering, and the postcondition. The other equations denote the computation of the document update and the updated document. The computation of the updated rendering coincides with the postcondition. \begin{small}\begin{align*}% \label{sse}
update & :: Edit_\alpha \rightarrow \alpha \rightarrow \alpha \\
present & :: Document \rightarrow (Rendering, Mapping) \\
translate & :: Mapping \rightarrow Gesture \rightarrow Edit_{Document} \\
\end{align*} 
\begin{math}
(rendering, mapping) = present~document
\hfill \text{\{Precondition\}} \\
EDIT~gesture~rendering = rendering'
\hfill \text{\{Correctness\}} \\
(rendering', mapping') = present~document'
\hfill \text{\{Postcondition + Compute Rendering'\}} \\
document' = update~e_{Document}~document
\hfill \text{\{Update Document\}} \\
e_{Document} = translate~mapping~gesture 
\hfill \text{\{Compute Doc Update\}}
\end{math}\end{small}

{\centering (Invariant 6: One stage editor, 1st attempt)\\}\vspace{1em}

Here the function $update$ takes as arguments an edit operation on a data type $\alpha$ and a value of data type $\alpha$, and returns the result of performing the edit operation on the value. Let $Edit_\alpha$ be the type of edit operations on type $\alpha$, then $update$ has type: $edit :: Edit_\alpha \rightarrow \alpha \rightarrow \alpha$. Function $update$ is assumed to work for every data type for which edit operations are defined, so for the document, we have: $edit :: Edit_{Document} \rightarrow Document \rightarrow Document$, for the rendering: $edit :: Edit_{Rendering} \rightarrow Rendering \rightarrow Rendering$, etc. 

For $translate$, we have the following type: $translate :: Edit_{Rendering} \rightarrow Edit_{Document}$, which means that an update on the document has to be computed from an update on the rendering. However, in some cases it might be difficult to compute this update without having access to the old rendering. Consider a program editor in which a user adds the letter 'k' after an already present word "brea", and thus changes an identifier {\em brea} to the keyword {\bf break}. The desired result in this case is that the subtree in the document tree that represents the identifier is replaced by a subtree (or a node) that represents the break keyword. Although it is possible for an editor to forbid such changes, we do want to be able to model editors that offer this freedom, so the model should be able to handle it. The problem in this case is how to compute the tree update changing the identifier into the keyword, from the gesture of inserting a 'k' at the current cursor position. It is possible to map the cursor position on a position in the document tree, insert the 'k', and then recognize that the identifier is now a keyword, but for complex grammars, such changes may lead to a complete reorganization of the tree, which is difficult to compute.

In cases in which it is difficult to compute the document update directly from $e_{Rendering}$, the update could be calculated with the computation sketched in Figure~\ref{computeintentions}. The figure shows how a function with type $Edit_{Rendering} \rightarrow Edit_{Document}$ can be created when a parser function with type $Rendering \rightarrow Document$ is available. In the figure, the edit intention is applied as an update to the old rendering, by a function $update$. The updated rendering is then parsed yielding a new document. Finally, the incremental update is computed by taking the difference of the updated document and the original. Of course, this is only a sketch, and the difference function does not exist in general, but for some editors, this will be a feasible solution. Therefore, we update the invariant by supplying the rendering and the document as parameters to $translate$.
\begin{figure}
\begin{small}
\begin{center}
\begin{center}
\begin{small}
\bigskip \noindent
\xymatrix{
 \data{$document$} \ar[r] & \component{diff} \ar[r] & \data{$e_{Document}$} \\
& \data{$document'$} \ar[u] & \\ 
& \component{$Parser$} \ar[u] & \\
& \data{$rendering'$} \ar[u] & \\
\data{$rendering$} \ar[r]  & \component{update} \ar[u] & \data{$e_{Rendering}$} \ar[l] 
}
\end{small}
\end{center}\caption{Computation of $e_{Document}$ }\label{computeintentions} 
\end{center}
\end{small}
\end{figure}


In the new invariant, the parameters $rendering$ and $document$ are added to the application of $translate$. There is no apparent order in the changing frequency of $mapping$, $rendering$, and $document$, so the order of the parameters is not important. We put $rendering$ in front of $document$ to reflect that the direction of the translation computation is from the rendering to the document.\begin{small}\begin{align*}
update & :: Edit_\alpha \rightarrow \alpha \rightarrow \alpha \\
present & :: Document \rightarrow (Rendering, Mapping) \\
translate & :: Mapping \rightarrow Rendering \rightarrow Document \rightarrow Gesture \rightarrow Edit_{Document} \\
\end{align*} 
\begin{math}
(rendering, mapping) = present~document 
\hfill \text{\{Precondition\}}\\
\hfill EDIT~gesture~rendering = rendering'
\hfill \text{\{Correctness\}} \\
(rendering', mapping') = present~document' 
\hfill \text{\{Postcondition + Compute Rendering'\}} \\
document' = update~e_{Document}~document
\hfill \text{\{Update Document\}} \\
e_{Document} = translate~mapping~rendering~document~gesture
\hfill \text{\{Compute Doc Update\}}
\end{math}\end{small}

{\centering (Invariant 7: One stage editor, Final)\\}\vspace{1em}
\subsection{Layered editor}


We now develop the invariants that describe an editor that is layered in the same way as the layered presentation system in the previous section. Similar to the one stage editor case, a first incomplete attempt is made, which is subsequently extended with extra parameters without which the translation process would not be possible.

Recall that $present$ is split in several $present_i$ because the computation of the rendering is a staged process. In the same way, we can split $translate$ in several $translate_i$. In order to understand the motivation for this split, consider again the example data levels in Figure~\ref{datalevelexamples}. A user can perform a backspace gesture right after "world" in ordere to delete the last letter. The result will be that the 'd' is removed from the rendering, but we also expect that the "11" changes to "10". Another possible edit gesture is a backspace right after the "11" in the rendering which changes it to "1". What happens in this case depends on the way the editor handles edit operations on derived values. A possible result could be that the string is truncated to the new length, and the new rendering shows the two lines "{H}" and "{1}". Whatever the exact results are, the example makes clear that the editor will behave quite differently for gestures on derived values and gestures on values coming directly from the document. However, even though the edit gestures result in different behavior, the mapping function $translate$ is largely the same for both.

At the levels below the abstract presentation, both edit intentions can be regarded in the same way, as updates on strings. And even though on the level of the enriched document, one intention is an update on a number and the other one an update on a string, there is still no need to distinguish that the update on the number is an update on a derived value. The update on the "11" can be handled the same way as an update on a number that would come directly from the document (which is not present in this example). Only at the upper layer we need to make the distinction between derived and document values, and to specify how derived value updates are translated to document updates. Of course, it is also possible that they are not translated to document updates, as the editor might simply not allow updates on derived values. By splitting the mapping function $translate$, dealing with the specifics of the translation from one level to another is left to a specific subfunction, and this subfunction need not concern itself with the translations on the other levels.

Function $translate$ can be split in layers by writing it as a composition, similar to our first attempt at a layered $present$ (invariant~3)in the previous section. The subscripts will be in reverse order compared to those of $present_i$ because the translation function goes from the rendering level ($data_n$) to the document level ($data_0$), whereas $present$ goes from document to rendering. By reversing the indices, $translate_i$ operates between the same data levels as $present_i$. Written as a composition, $translate$ becomes: $translate_0 \cdot translate_1 \dots translate_{n-1}$. Trying to determine the type of each $translate_i$ turns out to be rather tricky.

Each $translate_i$ maps edit intentions on level $i+1$ to edit intentions on level $i$, so the type $translate_i :: Edit_{Data_{i+1}} \rightarrow Edit_{Data_i}$ seems natural. However, now the type of the entire composition is $Edit_{Data_n} \rightarrow Edit_{Data_0}$, implying that the edit gesture, which is the argument to the translate function, is of type $Edit_{Data_n}$, which is not always the case. An edit gesture can be oriented towards any of the data levels, so using $Edit_{Data_n}$ to represent it is not appropriate. An edit gesture targeted at level $i$ should be passed on unchanged by $translate_n$ until $translate_{i}$, after which $translate_{i-1}$ maps it to an intention on level $i-1$ ($Edit_{Data_{i-1}}$). Subsequently, the intention is mapped on higher level intentions by $translate_{i-2}$ until $translate_0$. 
\begin{figure}
\begin{small}
\begin{center}
\begin{center}
\begin{small}
\bigskip \noindent
\xymatrix{
                                 & \data{$e_{Data_0}$} \\
 \data{$gesture$} \ar[ru] \ar@{}[u]^*{translate_0: \qquad} & \data{$e_{Data_1}$} \ar[u]  \\
\dots \ar[ru] \ar[u]             & \dots   \ar[u] \\
 \data{$gesture$} \ar[ru] \ar[u] & \data{$e_{Data_{n-2}}$} \ar[u] \\
\data{$gesture$} \ar[ru] \ar[u]^*{translate_{n-2}: \qquad}  & \data{$e_{Data_{n-1}}$} \ar[u] \\
\data{$gesture$} \ar[ru] \ar[u]^*{translate_{n-1}: \qquad } & 
}
\end{small}
\end{center}\caption{The gesture translation process }\label{translate} 
\end{center}
\end{small}
\end{figure}


Figure~\ref{translate} shows how the document update $e_{Data_0}$ is computed from the gesture. The computation will be a path in the figure, so the result of a $translate_i$ function will always be either an $e_{Data_i}$ or the gesture. The gesture enters the computation at the bottom right, as an argument of $translate_{n-1}$. The result of the computation is $e_{Data_0}$ at the top left. At each stage or layer $translate_i$ of the computation, the gesture is either passed on to the layer above ($translate_{i-1}$), or an edit intention $e_{data_{n-1}}$ is computed. After the edit intention has been computed, it is translated to higher level edit intentions by each successive subfunction of $translate$. We assume that an edit gesture will never be mapped back on a gesture again.

To represent the choice between $Gesture$ and $Edit_{Data_i}$ in the parameter and in the result of the subfunctions of $translate$, we will use a sum type: $Gesture+Edit_{Data_i}$. Values of the sum type can be denoted with injection functions $Inj_{Gesture}$ and $Inj_{Edit_{Data_i}}$. For example, if $gesture$ is of type $Gesture$, then $Inj_{Gesture} gesture$ is of type $Gesture + Edit_{Data_i}$. Using the sum type, the type of $translate_i$ becomes $Gesture+Edit_{Data_{i+1}} \rightarrow Gesture+Edit_{Data_i}$. 

At the bottom ($translate_{n-1}$) and the top ($translate_0$) of the translation process, there are two slightly special cases. The argument of the entire translation function is the gesture, so this has to be injected into the sum type with $Inj_{Gesture} Gesture$. As a consequence, $translate_{n-1}$, will never actually receive an argument of type $Edit_{Data_n}$ (appropriately injected into the sum type), even though the gesture may be targeted at $Data_n$. In Figure~\ref{translate} this fact is visible by the absence of an $e_{Data_n}$ data value. Of course, a gesture targeted at $Data_n$ is still possible, but it will be provided to $translate_{n-1}$ as an injected $Gesture$ instead of an injected $Edit_{Data_n}$.

At the top, a special case arises because we want the translation to produce a value of type $Edit_{Data_0}$. This is enforced by using an injection in the equation: $Inj_{Edit_{Data_0}} e_{Data_0} = (\bigodot_{i=0}^{n-1} translate_i \dots$, effectively projecting the $e_{Data_0}$ out of the result. But now, $translate_0$ cannot return a value of type $Gesture$ (injected into the sum type), so if $translate_0$ gets a gesture targeted at level $0$, instead of passing it on unchanged, it will have to map it to an edit intention $Edit_{Data_0}$. The fact that the computation can only produce an edit operation and not a gesture is visible in Figure~\ref{translate} by the fact that at the top level, there is only a value $e_{Data_0}$ and no $gesture$. In an actual implementation, instead of forcing $translate$ to produce a document update, it can also be allowed to return the gesture, in which case an error message could be shown, because no document update could be computed from the gesture.

Special cases for the top and bottom layer could be added, but this would break the symmetry of the translation layers.

We also provide the mapping information $mapping_i$ as an argument to the $translate_i$ functions, so we get the following invariant: 

\begin{small}\begin{align*} % \label{le}
update & :: Edit_\alpha \rightarrow \alpha \rightarrow \alpha \\
present_i & :: Data_i \rightarrow (Data_{i+1}, Mapping_{i}) \\
translate_i & :: Mapping_{i} \rightarrow Gesture+Edit_{Data_{i+1}} \rightarrow Gesture+Edit_{Data_i} \\
\end{align*} 
\begin{math}
\forall 0 \le i \le n-1:  \\
(data_{i+1}, mapping_{i}) = present_i~data_i
\hfill \text{\{Precondition\}} \\
EDIT~gesture~data_n = data_n'
\hfill \text{\{Correctness\}} \\
(data_{i+1}', mapping_{i}') = present_i~data_i'
\hfill \text{\{Postcondition + Compute Rendering'\}} \\
data_0' = update~e_{Data_0}~data_0                       
\hfill \text{\{Update Document\}}  \\
Inj_{Edit_{Data_0}}~e_{Data_0} = (\bigodot_{i=0}^{n-1} translate_i~mapping_i)~(Inj_{Gesture}~gesture) 
\hfill \text{\{Compute Doc update\}}
\end{math}\end{small}

{\centering (Invariant 8: Layered editor, 1st attempt)\\}\vspace{1em}



The first attempt still suffers from the same problems as the first attempt for the one stage editor (invariant~6). It is difficult, if not impossible, to compute an edit operation on a higher level from an edit operation on a lower level without access to the values of the higher and lower data level. Therefore, we will add parameters $data_{i+1}$ and $data_i$ to each of the $translate_i$ functions. \begin{small}\begin{align*} % \label{leupdate}
update & :: Edit_\alpha \rightarrow \alpha \rightarrow \alpha \\
present_i & :: Data_i \rightarrow (Data_{i+1}, Mapping_{i}) \\
translate_i & :: Mapping_{i} \rightarrow Data_{i+1} \rightarrow Data_{i} \rightarrow Gesture+Edit_{Data_{i+1}} \rightarrow Gesture+Edit_{Data_i} \\
\end{align*} 
\begin{math}
\forall 0 \le i \le n-1: \\
 (data_{i+1}, mapping_{i}) = present_i~data_i
\hfill \text{\{Precondition\}}\\
EDIT~gesture~data_n = data_n'
\hfill \text{\{Correctness\}} \\
(data_{i+1}', mapping_{i}') = present_i~data_i'
\hfill \text{\{Postcondition + Compute Rendering'\}} \\
data_0' = update~e_{Data_0}~data_0
\hfill \text{\{Update Document\}} \\
Inj_{Edit_{Data_0}}~e_{Data_0} = (\bigodot_{i=0}^{n-1} translate_i~mapping_i~data_{i+1}~data_i)~(Inj_{Gesture}~gesture)\\
~ \hfill \text{\{Compute Doc Update\}}
\end{math}\end{small}

{\centering (Invariant 9: Layered editor, Final)\\}\vspace{1em}
\subsection{Layered editor with local state}


In Section~\ref{presenting}, the final presentation invariant includes local state in each of the layers of the presentation function. We will now do a similar thing for the edit invariant, which will have a number of consequences. First, the local state influences the mapping between $Data_i$ and $Data_{i+1}$, so presumably it also affects the mapping back from edit intentions on $Data_{i+1}$ to edit intentions on $Data_i$. As a result, both parameters $sheet_i$ and $state_i$ are supplied to $translate_i$, as well as $data_{i+1}$ and $data_i$.

The second consequence of local state is that an edit intention might result in not just an update on the document, but also in an update on one or more of the dynamic local states, or even on both the document and the local states. We will encode this by calculating from the gesture not only the document update $e_{Data_0}$, but also a set of updates $direct_i :: Edit_{State_i}$ on each of the local states $state_i$. However, besides direct local state updates, there also exist indirect local state updates which result from gestures targeted at the document. Below we will give examples of direct and indirect updates. From the direct updates together with the document update, the actual local state updates $e_{State_i}$ are computed by a function $h$, which are then applied to the local states $state_i$ in order to obtain $state_i'$.
\begin{figure}
\begin{small}
\begin{center}
\begin{center}
\begin{small}
\bigskip \noindent
\xymatrix{
                                            & \data{$Inj_{Edit_{Data_0}}~e_{Data_0}$\\$(gesture_0)$} \ar[dr] 
 &                                      & \\
\component{$translate_0$} \ar[ur] \ar[r]    & \data{$direct_0$} \ar[r]  
 & \component{$h$} \ar[r] \ar[ddr] \ar@{.}[dddr] \ar[ddddr] & \data{$e_{State_0}$} \\
\data{$gesture_1$} \ar[u]                   &                        
 &                                      & \\
\component{$translate_{1}$} \ar[u] \ar[r]   & \data{$direct_{1}$} \ar[uur]
 &                                      & \data{$e_{State_1}$} \\
\cdots \ar[u]                               & \cdots \ar@{.}[uuur]
 &                                      & \cdots \\
\data{$translate_{n-1}$} \ar[u] \ar[r] & \data{$direct_{n-1}$} \ar[uuuur]
 &                                      & \data{$e_{State_{n-1}}$} \\
\data{$Inj_{Gesture}~gesture$\\$(gesture_n)$} \ar[u]      &
 &                                      &
}
\end{small}
\end{center}\caption{Computation of $e_{State_i}$ }\label{estatecomputation} 
\end{center}
\end{small}
\end{figure}


{\bf  Computing local state updates: }Figure~\ref{estatecomputation} contains a sketch of the computation of the $e_{State_i}$. The figure focusses on the local state updates, so the presentation function and the data values have been omitted. The dotted arrows on the left represent the arrows coming from the $direct_2$ until $direct_{n-2}$, and the dotted arrows on the right represent the arrows going to $e_{State_2}$ until $e_{State_{n-2}}$. Each $translate_i$ function now produces two results, a direct local state update, and the remainder of the gesture that is to be translated by higher level $translate_i$ functions. This remainder is denoted by $gesture_i$, but it should be noted that it can be either an edit intention, or the gesture. The type of $gesture_i$ is the type of the intermediate results of the $translate$ function from the previous section: $Edit_{Data_i}+Gesture$. The parameter of the translate computation is $gesture_0$, which is equal to the injection $Inj_{Gesture}~gesture$. The results of the translate computation are the $direct_i$ values in the middle, and the injection $Inj_{Edit_{Data_0}}~e_{Data_0}$ at the top $(gesture_0)$. The projection of $e_{Data_0}$ from $Inj_{Edit_{Data_0}}~e_{Data_0}$, before passing it as argument to $h$, has been omitted from the figure for sake of clarity.

The figure shows the extra computation step formed by $h$. Instead of directly computing $e_{State_i}$ from the gesture, it is computed by function $h$ from the $direct_i$ and $e_{document}$. The reason for the indirection is that local state updates may come directly from the gesture, but also may result indirectly from the document update. Examples of direct local state updates are a change on the magnification of the view, or a mouse click on a plus handle in a tree browser. But sometimes local state updates are the result of updates on higher level data values. Consider the tree browser example, where the editor shows a document, for example a paper, together with a tree browser that reflects the structure of the sections and sections of the document. If a user performs an edit gesture that results in swapping two sections in the document, we expect that the nodes in the tree browser will also swap, together with their expansion states. But even if the expansion states do not swap, some update on the local state in which the expansion state is accomodated will be necessary, for example collapsing the subtrees of the swapped nodes. Such an update on the local state is not directly computable from the gesture and will be computed by function $h$ from the document update.

Note that the computation of a direct local state update can follow the same path as the computation of the document update. The gesture can be targeted specifically at the local state, which means that the gesture is passed on untouched by lower level $translate_i$ functions until the level of the targeted local state is reached, but it is also possible that the gesture is targeted at a lower data level, after which it is translated to higher data levels, and finally to the local state update. An example of this would be a local state string that appears as text in the rendering. On the lower levels, gestures targeted at the string can be handled similarly to gestures targeted at strings that originate from the document. The only difference is that the former gestures result in local state updates, whereas the latter result in a document update.

{\bf Kinds of local state: }In our model, there is only one kind of dynamic local state, even though we could make a distinction between two kinds. The first kind is local state that can only be edited directly, for example the magnification of a view. This kind of local \pagebreak state will never be affected by edit operations on higher level data structures, making the extra computation step with the $h$ function unnecessary. Updates on this local state can be passed on untouched by $h$, meaning that $h (\dots, direct_i,\dots) = (\dots, direct_i, \dots)$. The second kind of local state is the local state that can be affected by edit operations on the higher levels. Typically, this kind of state has a {\em structure watching} relation with the document, which means that its structure depends on the structure of the document. An example of such structure watching local state is the tree browser expansion state. The structure of the expansion state tree follows the structure of the document tree.  It can be edited directly, by expanding a tree node with a mouse click, or indirectly by changing the document structure, which has consequences for the local state structure as well. This structure watching behavior can be modeled with function $h$.







{\bf Modelling local state updates: }In the invariant for a layered editor with local state, the translate computation can no longer be written as a composition because each $translate_i$ now produces two results. Instead, we will write it as a recurrence scheme similar to the one used for modeling $present$. The (injected) document update is defined as the result of the translate computation ($gesture_0$), and the argument of the translate computation ($gesture_n$) is equated to the (injected) $gesture$. 

Extra local state parameters are added to $present_i$ and $translate_i$. For $present_i$, the order of the parameters is the same as in invariant~5. Note that in the {\bf Postcondition + Compute Rendering'} equation, $present_i$ gets $state_i'$ instead of $state_i$. For translate, the $sheet_i$ and $state_i$ parameters are put in front of the other parameters of $translate_i$ due to their change frequency.

Taking into account all the changes, the invariant becomes:\begin{small}\begin{align*} % \label{lle}
update & :: Edit_\alpha \rightarrow \alpha \rightarrow \alpha \\
present_i & :: Sheet_i \rightarrow State_i \rightarrow Data_i \rightarrow (Data_{i+1}, Mapping_{i})\\
translate_i & :: Sheet_i \rightarrow State_i \rightarrow Mapping_i \rightarrow Data_{i+1} \rightarrow Data_{i} \\
&  \rightarrow Gesture+Edit_{Data_{i+1}} \rightarrow (Gesture+Edit_{Data_i},Edit_{State_{i}}) \\
h & :: Edit_{Data_0}+Edit_{State_0}+\dots+Edit_{State_{n-1}} \rightarrow (Edit_{State_{0}}, \dots, Edit_{State_{n-1}}) \\
\end{align*} 
\begin{math}
\forall 0 \le i \le n-1: \\
 (data_{i+1}, mapping_{i}) = present_i~sheet_i~state_i~data_i
\hfill \text{\{Precondition\}} \\
EDIT~gesture~data_n = data_n'
\hfill \text{\{Correctness\}} \\
(data_{i+1}', mapping_{i}') = present_i~sheet_i~state_i'~data_i'
\hfill \text{\{Postcondition + Compute Rendering'\}} \\
document' = update~e_{Data_0}~document
\hfill \text{\{Update Document\}} \\
Inj_{Edit_{Data_0}}~e_{Data_0} = gesture_0  \\
(gesture_i,direct_i) = translate_i~sheet_i~state_i~mapping_i~data_{i+1}~data_i~gesture_{i+1}\\
gesture_n = Inj_{Gesture}~gesture \hfill \text{\{Compute Doc Update\}} \\
state_i' = update~e_{State_i}~state_i
\hfill \text{\{Update State\}} \\
(e_{State_0}, \dots, e_{State_{n-1}}) = h~e_{Data_0}~(direct_0, \dots,  direct_{n-1})
\hfill \text{\{Compute State Update\}}
\end{math}\end{small}

{\centering (Invariant 10: Layered editor with local state, 1st attempt)\\}\vspace{1em}




\bigskip {\bf Staged $h$ function: }In the invariant~10, all local state updates are computed simultaneously, which does not fit very well with the layered characted of the editor architecture. Because all $direct_i$ and the $e_{Data_0}$ are required, the computation has to be performed in the top layer. But this means that even a direct local state update that does not influence the document has to be passed up all the way to the top layer, whereas it is more efficient to perform it on the local state directly. Moreover, the computation of a local state update $e_{State_i}$ will never require access to direct local state updates on levels below $i$. Therefore, we will add layers to function $h$, that allow direct local state updates to remain at the layer where they are computed. In order to still allow higher level updates  to influence lower local state updates, an argument of the abstract type $Intermediate_i$ is passed to the lower levels. In this argument, information can be encoded to allow for structure watching behavior of local states.
\begin{figure}
\begin{small}
\begin{center}
\begin{center}
\begin{small}
\bigskip \noindent
\xymatrix{
                                            & \data{$Inj_{Edit_{Data_0}}~e_{Data_0}$\\$(gesture_0)$} \ar[dr] 
 &                                      & \\
\component{$translate_0$} \ar[ur] \ar[r]    & \data{$direct_0$} \ar[r]  
 & \component{$h_0$} \ar[d]  \ar[r] & \data{$e_{State_0}$} \\
\data{$gesture_1$} \ar[u]                            &                        
 & \data{$intermediate_{0}$} \ar[d]     & \\
\component{$translate_{1}$} \ar[u] \ar[r]   & \data{$direct_{1}$} \ar[r]
 & \component{$h_{1}$} \ar[d] \ar[r]    & \data{$e_{State_1}$} \\
\cdots \ar[u]                               & \cdots
 & \cdots \ar[d]                        & \cdots \\
\component{$translate_{n-1}$} \ar[u] \ar[r] & \data{$direct_{n-1}$} \ar[r]
 & \component{$h_{n-1}$} \ar[d] \ar[r]  & \data{$e_{State_{n-1}}$} \\
\data{$Inj_{Gesture}~gesture$\\$(gesture_n)$} \ar[u]                     &
 &  \data{$intermediate_{n}$}           &
}
\end{small}
\end{center}\caption{Staged computation of $e_{State_i}$ }\label{stagedh} 
\end{center}
\end{small}
\end{figure}


Figure~\ref{stagedh} sketches the computation of the local state updates $e_{State_i}$ from the direct updates and the document update. Instead of going all the way up to the highest level, the direct update $direct_i$ is passed directly to $h_i$. Besides the $direct_i$, $h_i$ also has a parameter $intermediate_{i-1}$, which contains information necessary to realize the structure watching behavior.  Because we specify all $h_i$ the same way, there is a value $intermediate_n$, which is not actually used by any other functions and which will not be computed by an implementation.

The layered $h$ function makes it possible to handle direct local state updates in an efficient way. If the gesture results in a direct local state update on some level $i$, without affecting any higher local states, or the document, then only $data_{i+1}$ until $data_n$ need to be recomputed. This situation arises when the first element of result of $translate_i$ ($gesture_i$) is an empty edit operation. In that case, $data'_i$ will be equal to $data_i$, so $present_i$ could make use of $data'_i$ instead of $data_i$ for the computation of $data_{i+1}$, avoiding recomputation of the higher presentation levels. 

The new invariant is very similar to invariant~10, because only the {\bf Compute State Update} equation changes. It is replaced by a recurrence scheme that defines $e_{State_i}$ and $intermediate_i$, and an equation that defines $intermediate_0$ to be the document update $e_{Data_0}$.\begin{small}\begin{align*}% \label{lleupdate}
update & :: Edit_\alpha \rightarrow \alpha \rightarrow \alpha \\
present_i & :: Sheet_i \rightarrow State_i \rightarrow Data_i \rightarrow (Data_{i+1}, Mapping_{i})\\
translate_i & :: Sheet_i \rightarrow State_i \rightarrow Mapping_i \rightarrow Data_{i+1} \rightarrow Data_{i}\\ 
 & \rightarrow Gesture+Edit_{Data_{i+1}} \rightarrow (Gesture+Edit_{Data_i},Edit_{State_{i}}) \\
h_i & :: Intermediate_i \rightarrow Edit_{State_i} \rightarrow (Edit_{State_i}, Intermediate_{i+1}) \\
Intermediate_0 & = Edit_{Data_0} \\
\end{align*} 
\begin{math}
\forall 0 \le i \le n-1: \\
 (data_{i+1}, mapping_{i}) = present_i~sheet_i~state_i~data_i
\hfill \text{\{Precondition\}} \\
EDIT~gesture~data_n = data_n'
\hfill \text{\{Correctness\}} \\
(data_{i+1}', mapping_{i}') = present_i~sheet_i~state_i'~data_i'
\hfill \text{\{Postcondition + Compute Rendering'\}} \\
document' = update~e_{Data_0}~document
\hfill \text{\{Update Document\}} \\
Inj_{Edit_{Data_0}}~e_{Data_0} = gesture_0 \hfill \\
(gesture_i,direct_i) = translate_i~sheet_i~state_i~mapping_i~data_{i+1}~data_i~gesture_{i+1}\\
gesture_n = Inj_{Gesture}~gesture 
\hfill \text{\{Compute Doc Update\}} \\
state_i' = update~e_{State_i}~state_i
\hfill \text{\{Update State\}} \\
intermediate_0  = e_{Data_0} \\
(e_{State_i},intermediate_{i+1}) = h_i~intermediate_i~direct_i
\hfill \text{\{Compute State Update\}}
\end{math}\end{small}

{\centering (Invariant 11: Layered editor with local state, Final)\\}\vspace{1em}
\section{Incrementality}




{\bf Why incrementality: }The model we presented so far assumes that if an edit gesture is processed, all renderings are recalculated from scratch. This is a rather expensive process, considering that most edit gestures cause only small changes to the rendering. If a user types the text for a paragraph, the majority of all edit operations concern only the current line, and only now and then a line is inserted, which will not affect the rest of the document in most editors. Of course, some edit operations do have a more global effect. Editing in the middle of the paragraph for example may have an effect on the rest of the paragraph, or even on the entire paragraph if an optimal line breaking layout is used. An even more global edit operation is the creation of a new chapter, a this will cause a renumbering of all subsequent chapters (assuming the editor supports chapter numbers). Such global updates will be unavoidable in some cases, but by applying some restrictions to what renderings are allowed, many updates can be kept local. For example, it can be enforced that the rendering is divided in horizontal bands at top level. A band may contain a paragraph, a section header, a figure, etc. This way, if an update affects only one horizontal band, the others can simply be moved without recomputing them.

It should be noted that although the model is incremental, this does not imply that an editor designed according to the model has to be incremental. Non-incremental editors can still be modelled. Instead of computing an incremental update on a lower level, each layer in the editor can compute an update that replaces the data on the lower level with a new data value, effectively making the computation non-incremental. 

In this section, we will extend the model by explicitly keeping track of the data values for all of the stages in the presentation process. The function $present$ will be replaced by a function $inc$ which maps edit operations on higher levels to edit operations on lower levels. The $translate$ function is not affected by these changes.
\subsection{One stage incremental editor	}


{\bf explain incremental edit process} Before we remodel the invariant~7 from Section~\ref{subsectsingleedit}, we will first take a look at the incremental edit process. Figure~\ref{inceditprocess} shows the computations that occur during one edit step. Just as Figure~\ref{editprocess}, the figure is only intended as a sketch, and not all parameters are shown as arrows. The main differences with Figure~\ref{editprocess} are that instead of directly computing the updated values, edit operations are computed, and that because the funtion $present$ is gone, an abstract function $PRESENT$ is used. 

Instead of computing a new rendering and new mapping information when an edit gesture is processed, a function $inc$ computes updates on the rendering $e_{Rendering}$ and on the mapping information $e_{Mapping}$ from the document update $e_{Document}$. Furthermore, local copies of the rendering and the mapping information are kept, which are updated by applying the edit operations to the old values.

{\bf How to specify correctness} Because there no longer is a function $present$ that defines the mapping between the document and the rendering, we use an abstract function $PRESENT$. Function $inc$ realizes the mapping specified by $PRESENT$ in an incremental way. Given this incremental presentation function $inc$, the invariant will now specify $translate$. The result of $translate$, given a {\it document}, a {\it rendering}, a {\it mapping} and a {\it gesture}, is an $e_{Document}$ for which the $e_{Rendering}$ that is computed by $inc$, is such that $edit e_{Rendering} rendering = EDIT gesture rendering$. In other words, the gesture gives rise to a document update, whose corresponding rendering update is the desired effect of the edit gesture. 




\begin{figure}
\begin{small}
\begin{center}
\begin{center}
\begin{scriptsize}
\bigskip \noindent
\xymatrix{
 \data{$document$} \ar@{.>}[ddd] \ar[rr] & & \component{update} \ar[rrr] & & & \data{$document'$} \ar@{.>}[ddd] & \\
& &  \data{$e_{Document}$} \ar[u] \ar[r] & \component{$inc$} \ar[ddd] \ar[r] & \data{$e_{Mapping}$} \ar[d] & & \\ 
& \data{$mapping$} \ar[dr] \ar[rrr] & & &  \component{update} \ar[rr] & & \data{$mapping'$} \\
\abscomponent{$PRESENT$} \ar@{.>}[dd] \ar@{.>}[ur] & & \component{$translate$} \ar[uu] & & & \abscomponent{$PRESENT$} \ar@{.>}[dd] \ar@{.>}[ur] & \\
& & \data{$gesture$} \ar[u] \ar@{.>}[dd] &  \data{$e_{Rendering}$} \ar[d] & & & \\
\data{$rendering$} \ar@{.>}[drr] \ar[rrr] & & & \component{update} \ar[rr] & & \data{$rendering'$} & \\
& & \abscomponent{EDIT} \ar@{.>}[rrru] & &
}
\end{scriptsize}
\end{center}\caption{ The incremental edit process}\label{inceditprocess} 
\end{center}
\end{small}
\end{figure}


{\bf Changes to invariant: }We will present the invariant for the incremental one stage editor in two steps. In the first step, we will convert the non-incremental one stage invariant~(7) to a still incorrect invariant, to which a number of essential parameters will be added in the second step.

For now we will assume that because function $inc$ computes updates on the rendering and the mapping information from an update on the document, its type is $inc :: Edit_{Document} \rightarrow (Edit_{Rendering}, Edit_{Mapping})$. We will first give the new invariant and then explain the changes.\begin{small}\begin{align*} % \label{ssi}
PRESENT & :: Document \rightarrow (Rendering, Mapping) \\
update & :: Edit_\alpha \rightarrow \alpha \rightarrow \alpha \\
inc & :: Edit_{Document} \rightarrow (Edit_{Rendering}, Edit_{Mapping}) \\
translate & :: Mapping \rightarrow Rendering \rightarrow Document \rightarrow Edit_{Rendering} \rightarrow Edit_{Document} \\
\end{align*} 
\begin{math}
(rendering, mapping) = PRESENT~document
\hfill \text{\{Precondition\}}\\
EDIT~gesture~rendering = rendering' 
\hfill \text{\{Correctness\}} \\
(rendering', mapping') = PRESENT~document'
\hfill \text{\{Postcondition\}} \\
rendering' = update~e_{Rendering}~rendering
\hfill \text{\{Update Rendering\}} \\
mapping' = update~e_{Mapping} 
\hfill \text{\{Update Mapping\}} \\
(e_{Rendering}, e_{mapping}) = inc~e_{Document}
\hfill \text{\{Compute Rendering Update\}} \\
document' = update~e_{Document}~document
\hfill \text{\{Update Document\}} \\
e_{Document} = translate~mapping~rendering~document~gesture
\hfill \text{\{Compute Doc Update\}}
\end{math}\end{small}

{\centering (Invariant 12: One stage incremental editor, 1st attempt)\\}\vspace{1em}


The difference between invariant~7 and invariant~12 is that the {\bf Postcondition + Compute Rendering'} equation has been replaced by the {\bf Postcondition}, {\bf Update Rendering}, {\bf Update Mapping} and {\bf Compute Rendering Update} equations. The reason why the equation has split into four new equations is that the computation of the updated rendering no longer coincides with the postcondition, because $PRESENT$ is now abstract. Therefore the {\bf Postcondition} equation is separate. Furthermore, the computation of the rendering and mapping information now requires 3 equations, one for computing the updates ({\bf Compute Rendering Update}), and two more for updating the data ({\bf Update Rendering} and {\bf Update Mapping}).

{\bf }{\bf Extra parameters for $inc$: }In invariant~12, $inc$ realizes a mapping from updates on the documents to updates on the rendering and updates on the mapping information. For similar reasons as why $translate$ gets $rendering$ and $document$ as parameters, we will now also add $rendering$ and $document$ as parameters to $inc$. We will also supply the old mapping information as a parameter.

For example, if in a spread sheet, a cell that contains the sum of the values in a set of cells, is changed so it contains the product of a set of cells, then the update of the sum formula to the product formula will not hold enough information to compute the update on the rendering. In order to compute the new sum value, access to the set of cells is needed. Function $inc$ will therefore need the document as a parameter. 

The motivation for supplying also the rendering as a parameter to $inc$ can bee seen in Figure~\ref{computeops}. It shows how incremental updates on the rendering can be computed when only a non-incremental presentation function is present. The computation is similar to the one in Figure~\ref{computeintentions}. First the updates are applied to the old $document$, and the resulting $document'$ is mapped on a $rendering$ by a $Presenter$ function, which is the non-incremental $present$ in the invariants of the previous sections. Finally a difference is computed to get the updates on the rendering.

The old value $mapping$ is required for similar reasons as why we need $rendering$. If $present$ can only compute a new $mapping'$ instead of an edit operation $e_{Mapping}$, the old value is needed to compute the edit operation . 
\begin{figure}
\begin{small}
\begin{center}
\begin{center}
\begin{small}
\bigskip \noindent
\xymatrix{
\data{$e_{Document}$} \ar[r] & \component{update} \ar[d] & \data{$document$} \ar[l] \\
 & \data{$document'$} \ar[d] & \\ 
 & \component{$Presenter$} \ar[d] & \\
 & \data{$rendering'$} \ar[d] & \\
\data{$e_{Rendering}$} & \component{diff} \ar[l] & \data{$rendering$} \ar[l]  
}
\end{small}
\end{center}\caption{Computation of $e_{Rendering}$ }\label{computeops} 
\end{center}
\end{small}
\end{figure}




The addition of the three extra parameters $document$, $rendering$ and $mapping$ causes changes in the type of $inc$ and in the {\bf Compute Rendering Update} equation. Because there is no apparent order in the changing frequency of $document$, $rendering$, and $mapping$, the order of the parameters is not important. However, we put $document$ in front of $rendering$ to reflect that the direction of the computation is from the document to the rendering. \begin{small}\begin{align*} % \label{ssiupdate}
PRESENT & :: Document \rightarrow (Rendering, Mapping) \\
update & :: Edit_\alpha \rightarrow \alpha \rightarrow \alpha \\
inc & :: Document \rightarrow Rendering \rightarrow Mapping \rightarrow \\
 &       Edit_{Document} \rightarrow (Edit_{Rendering}, Edit_{Mapping}) \\
translate & :: Mapping \rightarrow Rendering \rightarrow Document \rightarrow Edit_{Rendering} \rightarrow Edit_{Document} \\
\end{align*} 
\begin{math}
(rendering, mapping) = PRESENT~document 
\hfill \text{\{Precondition\}}\\
EDIT~gesture~rendering = rendering'
\hfill \text{\{Correctness\}} \\
(rendering', mapping') = PRESENT~document'
\hfill \text{\{Postcondition\}} \\
rendering' = update~e_{Rendering}~rendering
\hfill \text{\{Update Rendering\}} \\
mapping' = update~e_{Mapping}                    
\hfill \text{\{Update Mapping\}} \\
(e_{Rendering}, e_{mapping}) = inc~document~rendering~mapping~e_{Document}\\
~ \hfill \text{\{Compute Rendering Update\}} \\
document' = update~e_{Document}~document
\hfill \text{\{Update Document\}} \\
e_{Document} = translate~mapping~rendering~document~gesture
\hfill \text{\{Compute Doc Update\}}
\end{math}\end{small}

{\centering (Invariant 13: One stage incremental editor, Final)\\}\vspace{1em}
\subsection{Layered incremental editor}


For the layered editor case, we can rework invariant~9 the same way we have changed invariant~7 into invariant~13, which means that we take the layered editor invariant and add the incrementality features to it. Another approach would be to take invariant~13 and add layers to it, but adding the layers requires changing all equations whereas adding incrementality leaves some equation unchanged.\begin{small}\begin{align*} % \label{li}
PRESENT_i & :: Data_i \rightarrow (Data_{i+1}, Mapping_{i}) \\
update & :: Edit_\alpha \rightarrow \alpha \rightarrow \alpha \\
inc_i & :: Data_i \rightarrow Data_{i+1} \rightarrow Mapping_i \rightarrow Edit_{Data_i} \rightarrow (Edit_{Data_{i+1}}, Edit_{Mapping_{i}}) \\
translate_i & :: Mapping_{i} \rightarrow Data_{i+1} \rightarrow Data_{i}  \rightarrow Gesture+Edit_{Data_{i+1}} \rightarrow Gesture+Edit_{Data_i} \\
\end{align*} 
\begin{math}
(data_{i+1}, mapping_i) = PRESENT_i~data_i 
\hfill \text{\{Precondition\}}\\
EDIT~gesture~data_n = data_n'
\hfill \text{\{Correctness\}} \\
(data_{i+1}', mapping_i') = PRESENT_i~data_i' 
\hfill \text{\{Postcondition\}}\\
data_i' = update~e_{Data_i}~data_i 
\hfill \text{\{Update\}} \\
mapping_i' = update~e_{Mapping_i}
\hfill \text{\{Update Mapping\}} \\
(e_{Data_{i+1}}, e_{Mapping_{i}}) = inc_i~data_i~data_{i+1}~mapping_i~e_{Data_i}
\hfill \text{\{Compute Updates\}} \\
Inj_{Edit_{Data_0}}~e_{Data_0} = 
   (\bigodot_{i=0}^{n-1} translate_i~mapping_i~data_{i+1}~data_i)~(Inj_{Gesture}~gesture) \\
~ \hfill \text{\{Compute Doc Update\}}
\end{math}\end{small}

{\centering (Invariant 14: Layered incremental editor)\\}\vspace{1em}

For the first three equations, the only changes are that $present$ is replaced by $PRESENT$, and that the third equation is named {\bf Postcondition}. The compute rendering' part of the equation is taken care of by three new equations. One for describing the updates on the data values, one for the updates on the mapping information values and one for computing these updates. Because the new {\bf Update} equation also covers the document update (let $i=0$), the {\bf Update Document} equation has disappeared.
\subsection{Layered incremental editor with local state}


The last change we will make to the model, is adding the local static and dynamic states for each of the data levels. Since the difference between the non-incremental invariants for the layered and the local state case (invariants~9 and~11) was rather small, we will construct the incremental local state case by extending the invariant~14 in a similar way. The reason why the extension is simple also for the incremental case is that whether or not the presentation part of the edit process is incremental, does not affect the computation of the local state updates.

The difference between invariants~9 and~11 is a rewrite of the {\bf Compute Doc Update} equation in order to compute the $direct_i$, the addition of the {\bf Update State} and {\bf Compute State Update} equations, and the addition of the state parameters $sheet_i$ and $state_i$ to the application of $present_i$ (in {\bf Postcondition + Compute Rendering'}).

In the incremental model, the computation of the direct local state updates $direct_i$, the final local state updates $e_{State_i}$ and the updating of the local states is the same as in the non-incremental model. Therefore, the {\bf Compute Doc Update},{\bf  Update State} and {\bf Compute State Update} have been taken directly from invariant~11. 

In the pre- and postcondition, $PRESENT$ gets the $Sheet_i$ and $State_i$ parameters similar to $present_i$ in invariant~11. In the computation of the rendering', $inc_i$ takes the place of $present_i$, so we will supply $inc_i$ with extra parameters in {\bf Compute Updates}. However, instead of giving $sheet_i$ and $state'_i$, we will give $sheet_i$, $state_i$, and $e_{State_i}$. The reason for this is that in order to determine an incremental update on $data_{i+1}$, instead of the updated local state, we need the edit operation on the local state, together with the old value.

When these changes are applied to invariant~14, we get the following final invariant:\begin{small}\begin{align*} % \label{lli}
PRESENT_i & :: Sheet_i \rightarrow State_i \rightarrow Data_i \rightarrow (Data_{i+1}, Mapping_i)\\
update & :: Edit_\alpha \rightarrow \alpha \rightarrow \alpha \\
inc_i & :: Sheet_i \rightarrow State_i \rightarrow Data_i \rightarrow Data_{i+1} \rightarrow Mapping_i \\
 & \rightarrow Edit_{Data_i} \rightarrow (Edit_{Data_{i+1}}, Edit_{Mapping_{i}}) \\
translate_i & :: Sheet_i \rightarrow State_i \rightarrow Mapping_i 
  \rightarrow Data_{i+1} \rightarrow Data_{i}\\
 & \rightarrow Gesture+Edit_{Data_{i+1}} \rightarrow (Gesture+Edit_{Data_i},Edit_{State_{i}}) \\
h_i & :: Intermediate_i \rightarrow Edit_{State_i} \rightarrow (Edit_{State_i}, Intermediate_{i+1}) \\
Intermediate_0 & = Edit_{Data_0} \\
\end{align*} 
\begin{math}
(data_{i+1},mapping_i) = PRESENT_i~sheet_i~state_i~data_i 
\hfill \text{\{Precondition\}} \\
EDIT~gesture~data_n = data_n'
\hfill \text{\{Correctness\}} \\
(data_{i+1}',mapping_i') = PRESENT_i~sheet_i~state_i'~data_i' 
\hfill \text{\{Postcondition\}} \\
data_i' = update~e_{Data_i}~data_i 
\hfill \text{\{Update\}} \\
mapping_i' = update~e_{Mapping_i}
\hfill \text{\{Update Mapping\}} \\
(e_{Data_{i+1}}, e_{Mapping_{i}}) = inc_i~sheet_i~state_i'~data_i~data_{i+1}~mapping_i~e_{Data_i}
\hfill \text{\{Compute Updates\}} \\
Inj_{Edit_{Data_0}}~e_{Data_0} = gesture_0 \hfill \\
(gesture_i,direct_i) = translate_i~sheet_i~state_i~mapping_i~data_{i+1}~data_i~gesture_{i+1}\\
gesture_n = Inj_{Gesture}~gesture
\hfill \text{\{Compute Doc Update\}} \\
state_i' = update~e_{State_i}~state_i
\hfill \text{\{Update State\}} \\
intermediate_0 = e_{Data_0}\\
(e_{State_i}, intermediate_{i+1}) = h_i~intermediate_i~direct_i
\hfill \text{\{Compute State Update\}} 
\end{math}\end{small}

{\centering (Invariant 15: Layered incremental editor with local state)\\}\vspace{1em}
