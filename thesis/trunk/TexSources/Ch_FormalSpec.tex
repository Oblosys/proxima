\chapter{Specifying a layered editor}
\label{chap:formalSpec}


\bc
Lambert:

*) altijd <=, waarom? en waarom ook bij X => Y. assume X, prove Y is a =>
ziet er vaak mooier uit en verloopt logischer. mixen met <= bewijzen geen probleeem.

\ec

{\em *** Version: \today~ ***}




%\bl
%\o how to layout the equations and put label at the right?
%\o Operators between identifiers look asymmetrical: 
%$\Level\H \times \Level_L$. Fix using \verb|\:|? 
%(e.g.\ \verb|\times\:| \rarr $\Level\H \times\, \Level_L$) solution: use \verb|\!|
%\el


%$\true \imp P$ vs. $\true \eq P$. Answer: usually $\eq$ only in some weird cases $\imp$

%\subsection{Problems}
%
%{\bf Asymmetry between $\interpret$ and $\present$:}
%
%\bl
%\o When two Documents present as the same presentation. They are equal up to extra state.
%\o When two Presentations interpret to the same document. They may be equal up to extra state, but 
%they may also be incorrect presentations.
%\el
%
%Example: 
%
%\begin{math}
%Document \tp (Int, Char) ~~~ Presentation \tp String\\
%\present (i,\_) = whitespace \cat english~i\\ 
%h \in {(7, 'a'),(7,'b'),(7,'c'),\dots} : \present~h = \{"seven", "\spc seven", "\spc\spc seven", \dots\}\\
%l \in {
% }
% \left\{ \begin{array}{l}
%            "seven", " seven", "  seven", \dots \\
%            "sevven", "\spc sevven", "\spc\spc sevven", \dots \\
%            \dots
%            \end{array}
%\right\} : \interpret~l = \{(7, 'a'),(7,'b'),(7,'c'),\dots\}\\
%\end{math}





% Even in pure structure editor there are pres. oriented bits. eg navigation (pointing problem)


In this chapter we give a formal specification of the layered architecture of the Proxima editor. We represent the presentation mapping $\Present$ by a function $\present$. Given $\present$, we state a number of requirements for a function $\interpret$, which is an inverse of $\present$ and maps an updated presentation back onto the document. Furthermore, we specify a computation for handling edit operations on the presentation. 

In the presence of extra state, $\Present$ is an actual relation, which cannot directly be represented by a function. Therefore, we introduce an equivalence class representation for extra state, which allows us to represent $\Present$ by a function between equivalence classes.

Because we make only few assumptions on the presentation mapping, the specification gives requirements for $\interpret$, rather than specifying how the inverse can be computed for a specific $\present$. The burden of defining an $\interpret$ that meets the requirements lies with the editor designer.

An automatically derived $\interpret$ is desirable, but this is not yet feasible for the complex presentation functions of the use cases from Chapter~\ref{chap:requirements}. Examples of presentation formalisms supporting an automatic inverse for basic functions can be found in \cite{meertens98maintainers}, \cite{muhu04inv}, and \cite{pierce03lenses}. 

%*** no longer edit ops, but levels. (pres-oriented) easier to spec. Change to edit ops is future work

In contrast to the architecture description of Chapter~\ref{sect:proxArch}, the specification . Hence $\present$ and 
$\interpret$ are functions between levels and not between edit operations.***

We develop the specification by starting with a simplified editor, and then step by step adding extra functionality. Section~\ref{sect:singleSimple} specifies a simple editor that consists of a single layer and does not support extra state. In Section~\ref{sect:singleExtra}, the specification is extended with a general model of extra state. Section~\ref{sect:wildcardEq} provides a more concrete specification of extra state for tree data structures. The last step is the addition of layers to the specification in Section~\ref{sect:combinedExtra}. Finally, Section~\ref{sect:duplicates} discusses informally how the specification can be adapted to handle duplications in the presentation.


%\note{Somewhere: Duplicates are allowed, but cannot be handled in a way that a user would expect?}



%																
%																
%																
\section{A single layer} \label{sect:singleSimple}

First we consider a simple abstract editor consisting of a single layer between two data levels. The higher level is the document level and the lower level is the presentation level. In this section, we assume that the presentation mapping $Present$ maps each document onto exactly one presentation, and thus can be represented by a function $\present$.

We assume that the total function $\present$ is given:

\xpr{
\present & \tp &  \Level\H \rightarrow \Level\L\\
}

Because not every value of type $\Level\L$ is the presentation of a document is, $\present$ need not be surjective.  \note{what if not total?}

Given $\present$, we will specify a total function $\interpret$, which maps a lower level back onto a higher level:

\xpr{
\interpret  & \tp & \Level\L \rightarrow \Level\H\\
}

\note{Say some things on totality of \interpret (easy to make total?)}

\head{The \law{InterPresent} property}

A minimal condition for a $\present$ and $\interpret$ pair to model an editor is that presentation of a higher level followed by interpretation should yield the original higher level. In other words, $\interpret$ is a left inverse of $\present$. We express this with the \law{InterPresent} property: 

\xprlab{
l \equ \present~h ~\imp~ h \equ \interpret~l  
}{InterPresent}

Or, equivalently, using function composition:

\xpr{
\interpret \oo \present \eq id_{\Level\H} 
}
\note{consequence, no normalization on document}

The \law{InterPresent} property implies injectivity of $\present$ and (together with totality of $\present$) surjectivity of $\interpret$. 


We do not require that $\interpret$ is a right inverse (i.e.\ $\present \oo \interpret = id_{\Level\L}$) in order to support ``imprecise'' editing. Imprecise editing means that although the user-updated lower level is not a completely valid presentation of a document, it does make clear what the user intended with the edit operation.

Take a presentation function that presents a return statement by using a bold style for the keyword: 
$\present~({\tt Return~True}) = {\tt "{\bf return}~True"}$. If we want to allow a user to enter a return statement without having to add the exact styles to the text, we must have $\interpret~({\tt "Return~True"}) = {\tt Return~True}$. 
Hence, $\present \oo \interpret$ is not the identity, since $\present \oo \interpret~({\tt "Return~True"}) \eq {\tt "{\bf return}~True"}$.
%A consequence of \law{InterPresent} is that a document may not be No normalization may occur on doc.
% Not nec. always normalized.


\law{InterPresent} is only a minimal condition requirement on $\present$ and $\interpret$. In order to model an editor, we also want to say something about the result of $\interpret$ on lower level values outside the range of $\present$. The next section provides such a requirement.


%\bl
%\o sequence of presenting and interpreting therefore converges
%\o name comes from compose \interpret and \present
%\el


\subsection{Editing}\label{sect:single_Editing}

A user may perform an edit operation on either the higher level (document) or the lower level (presentation). However, because after a document update, the presentation invariant can be restored by simply presenting the updated document, we only consider presentation-oriented editing here. When the lower level is edited, we need to interpret the updated lower level in order to find a new higher level, which subsequently may need to be presented again (as explained Section~\ref{sect:editProces}).

Let $level\L$ and $level\H$ denote the state of the layer at the beginning of an edit step. 

\xprlab{
\level_L & \equ & \present~\level\H
}

The user then updates the lower level:

\xpr{
& & \level\L \leadsto \level'\L 
}

after which the editor computes the final values for the data levels: $level''\L$ and $level''\H$, in order to restore the presentation invariant.

\bc The final higher level is denoted by $level''\H$ rather than $level'\H$ to have a consistent notation for final values. Furthermore, in the multi layered editor specification (see Section~\ref{sect:combinedExtra}) $level'\H$ will denote the intermediate value for the higher level $level'H$. Figure~\ref{singleLayerEdit} schematically shows the edit process for one edit step. In the rest of this chapter we use the same notation for the different stages of the data levels.

\begin{figure}
\xpr{
level\H 		&   			&		 & 			& level''\H\\
~~~\downarrow &   		&		&~\nearrow~&~~~\downarrow \\
level\L 		&~\leadsto~ & level'\L 	& 			& level''\L\\
}
\caption{Single edit step.(draft)} \label{singleLayerEdit}
\end{figure}


Most likely, after editing, the presentation invariant does not hold between $\level'\L$ and $\level\H$. Hence, we need to find a new higher level value $\level''\H$. However, because it is possible that $\level'\L$ is not a valid presentation of a higher level value, we also need to find a new lower level $\level''\L$ in order to restore the presentation invariant. Figure~\ref{} shows the values of the higher and lower levels for the example from the previous section.
\ec 
Besides the presentation invariant, we impose several other requirements on the new levels.

Firstly, if $\level'\L$ is a valid presentation of $\level\H$, we do not want $\level\H$ to change because of the edit operation, and thus $\level''\H = \level\H$. Because in this section presentation is injective, $\level'\L$ can only be a valid presentation of $\level\H$, if it is equal to $\level\L$, meaning that the user did not change the lower level. However, in the next section, when extra state is added to the model, the reason for this property becomes clear. Because the property states that the document stays inert under an edit operation, we refer to it as \law{Doc-Inert}.

Secondly, if a user edits the lower level in such a way that $\level'\L$ is a valid presentation of some higher level value $h$, then the editor should not perform any further updates on the lower level, and the final value $level''\L$ should be equal $\level'\L$. Analogous to the previous property, this property is referred to as \law{Pres-Inert}.

\bc
Besides \law{Pres-Inert}, we could also add a requirement that if there exists an $h$, such that $level'\L = \present~h$, then $level''\H = h$, since because of \law{Pres-Inert} and injectivity of $\present$, $h$ is the only possible value for $\level''\H$. However, since this requirement will no longer hold in the presence of extra state, we will omit it here as well.
\ec

Our final requirement specifies what happens when $\level'\L$ is not a valid presentation of any higher level. In this case, the editor could simply forbid the edit operation, but a more user-friendly solution is to regard the operation as an imprecise edit operation and perform the intended edit operation. This means that the editor chooses a $level''\H$ and $level''\L$ such that $level''\L$ is close to the $level'\L$ that came from the user (and, of course, $\level''\L = \present~\level''\H$ ).

Summarizing, if we let $Comp$ be a program fragment that assigns new values to the data levels, then the requirements on $Comp$, specified as Hoare triples, are:

\xprlab{\hoare{\true} {Comp} { \level''\L = \present~\level''\H }}{Postcondition}
\xprlab{\hoare{ \level'\L = \present~\level\H } {Comp} { \level''\H = \level\H }}{Doc-Inert}
\xprlab{\hoare{ \level'\L = \present~h } {Comp} {\level'\L = \level''\L}}{Pres-Inert}
\xprlab{\hoare{ \true } {Comp} {\level'\L \close \level''\L}}{Imprecise}

Note that \law{Pres-Inert} is a special case of \law{Imprecise}, in which ``close~to'' is equality. \note{Maybe mention precondition more explicitly?} 
\todo{say that \law{Imprecise} is weaker}
\head{Definition of $Comp$}


A straightforward definition of $Comp$ that meets all requirements is:

\xprlab{
Comp \is 	& \level''\H \gets \interpret~\level'\L \semi\\
				&\level''\L \gets  \present~\level''\H
}{$Comp$-Def}

\todo{other reqs with pc specify interpret together with bla, fix this in sections below}

\head{A little Hoare logic}

We can prove that $Comp$ meets the first three requirements using Hoare logic. We use the following law to relate Hoare triples to weakest precondition propositions:


\xprlab{
\hoare{P}{S} {Q} ~\eqv~ P \imp wp(S,Q)
}{\fn{wp}-Char}

Because the program only consists of assignments and a composition, we do not need to consider termination, and moreover, we only need two laws from the weakest precondition calculus. For assignments we have:

\xprlab{
\wp{~x \gets e~}{P} \eqv P[x/e]\\
}{\fn{wp}-$\gts$}

And a for composition we have:

\xprlab{
\wp{~S \semi T~}{P} \eqv \wp{S}{ \wp{T}{P} }\\
}{\fn{wp}-$\smi$}

In Section~\ref{sect:combinedExtraEditing} we need two more laws, which we introduce here as well for completeness. We need a law for weakening the postcondition.

\xprlab{
Q \imp Q' ~\imp~ \wp{S}{Q} \imp \wp{S}{Q'}\\
}{\fn{wp}-Mono}

\bc
\begin{proof}
assume $Q \imp Q'$
\begin{Prf}&
\true\\
\Eqv{reflexivity of $\imp$}&
wp(S,Q) \imp wp(S,Q)\\
\Eqv{\law{\fn{wp}-Char}}&
\hoare{wp(S,Q)}{S} {Q}\\
\Eqv{Weakening postcondition}&
\hoare{wp(S,Q)}{S} {Q'}\\
\Eqv{\law{\fn{wp}-Char}}&
wp(S,Q) \imp wp(S,Q')\\
\end{Prf}
\end{proof}
\ec

And a law for combining two postconditions.

\xprlab{
P \imp \wp{S}{Q} \land P \imp \wp{S}{Q'} ~\imp~ P \imp \wp{S}{Q \land Q'}\\
}{\fn{wp}-And}

\head{\law{Postcondition} requirement}

\note{Give this proof here? It's rather trivial.}

According to \law{\fn{wp}-Char}, $\hoare{\true} {Comp} { \level''\L = \present~\level''\H }$ is equivalent to:

$\true ~\imp~ \wp{Comp}{ \level''\L = \present~\level''\H }$

Unlike the other proofs in this section, we start the weakest precondition proofs with the antecedent of the implication and work toward the conclusion. This way, the order of the subsitutions in the proof steps corresponds to the evaluation order of the assignment statements in $Comp$.

\begin{Proof} 
\begin{Prf}&
	\true\\
\Eqv{\law{\fn{wp}-$\gts$}}&
	\wp{\level''\H \gets \interpret~\level'\L}{\true} \\
\Eqv{ reflexivity of $=$ }&
	\wp{\level''\H \gets \interpret~\level'\L}{\present~\level''\H = \present~\level''\H} \\
\Eqv{\law{\fn{wp}-$\gts$}}&
	\wp{\level''\H \gets \interpret~\level'\L}{ \wp{ \level''\L \gets \present~\level''\H}{ \level''\L = \present~\level''\H }} \\
\Eqv{\law{\fn{wp}-$\smi$}}&
	\wp{\level''\H \gets \interpret~\level'\L \semi \level''\L \gets \present~\level''\H}{ \level''\L = \present~\level''\H } \\
\Eqv{\law{$Comp$-Def}}&
	\wp{Comp}{ \level''\L = \present~\level''\H }\\
\end{Prf}
\end{Proof}

\head{\law{Doc-Inert} requirement}

In the proofs below, we will implicitly use the equivalence between the Hoare notation and the weakest precondition notation suggested by \law{\fn{wp}-Char}. Hence, \law{Doc-Inert} is:

%According to \law{\fn{wp}-Char}, $\hoare{ \level'\L = \present~\level\H } {Comp} { \level''\H = \level\H }$ is equivalent to:

$\level'\L = \present~\level\H ~\imp~ \wp{Comp}{ \level''\H = \level\H}$


\begin{proof} 
\begin{Prf}&
	\level'\L = \present~\level\H\\
\Imp{\law{InterPresent}}&
	\level\H = \interpret~\level'\L\\
\Eqv{\law{\fn{wp}-$\gts$}}&
	\wp{\level''\H \gets \interpret~\level'\L}{\level\H = \level''\H} \\
\Eqv{{\sc \fn{wp}-$\gts$}}&
	\wp{\level''\H \gets \interpret~\level'\L}{ \wp{ \level''\L \gets \present~\level''\H}{\level\H = \level''\H}} \\
\Eqv{\law{\fn{wp}-$\smi$}}&
	\wp{\level''\H \gets \interpret~\level'\L \semi \level''\L \gets \present~\level''\H}{\level\H = \level''\H} \\
\Eqv{\law{$Comp$-Def}}&
	\wp{Comp}{\level\H = \level''\H}\\
\end{Prf}
\end{proof}

\head{\law{Pres-Inert} requirement}

The proof of \law{Pres-Inert} is similar to the proof of \law{Doc-Inert}

%$\hoare{ \level'\L = \present~h } {Comp} {\level'\L = \level''\L}$, is equivalent to:

$\level'\L = \present~h ~\imp~\wp{Comp}{\level'\L = \level''\L}$ 

\begin{proof}

In the proof, we assume $\level'\L = \present~h$:

\begin{Prf}&
	\level'\L = \present~h \}\\
\Eqv{\law{InterPresent}}&
	\level'\L = \present~(\interpret~(\present~h))\\
\Imp{assumption} &
	\level'\L = \present~(\interpret~\level'\L)\\
\Eqv{\law{\fn{wp}-$\gts$}}&
	\wp{\level''\H \gets \interpret~\level'\L}{ \level'\L = \present~\level''\H}\\
\Eqv{\law{\fn{wp}-$\gts$}}&
	\wp{\level''\H \gets \interpret~\level'\L}{ \wp {\level''\L \gets \present~\level''\H}{\level'\L = \level''\L} }\\
\Eqv{\law{\fn{wp}-$\smi$}}&
	\wp{ \level''\H \gets \interpret~\level'\L \semi \level''\L \gets \present~\level''\H}{\level'\L = \level''\L }\\
\Eqv{\law{$Comp$-Def}}&
	\wp{Comp}{\level'\L = \level''\L}\\
\end{Prf}
\end{proof}



\head{\law{Imprecise} requirement}

If $\level'\L$ is not a valid presentation, only \law{Postcondition} and \law{Imprecise} are of importance:

\xpr{\hoare{ \true } {Comp} {\level'\L \close \level''\L}}

This requirement states that $\interpret$ returns a higher level such that its presentation resembles what the user intended with the edit operation. Since $\present$ is given, this requirement provides a specification of $\interpret$. \todo{even fixen} Because the intention of a user is a rather vague concept, we cannot give a formal specification of the ``close~to'' relation here. It is left to the editor designer to assign a meaning to it and provide an $\interpret$ function that meets the requirement.

%\note{Is ``close to'' what we want? For simple editors, maybe it is, but is "-$>$" close to \rarr?}
%\note{What about Chapter titles and fonts? Will these be handled correctly with ``close to'' req.?}



%																
%																
%																
\section{Extra state} \label{sect:singleExtra}

In this section, we extend the specification of the single layered editor with extra state (see Section~\ref{sect:extraState}). The document level may contain interpretation extra state, whereas the presentation may contain presentation extra state.

Because the presentation does not specify extra state, a single document may have several presentations that differ only in extra state. Similarly, a single presentation may be the presentation of several different documents. Hence, we cannot use a functional representation for $Present$.

Because two levels that only differ in extra state are in a sense equivalent, we model extra state using an equivalence relation on the data level. The elements of an equivalence class are equal except for their extra state.

The equivalence class model for extra state makes it possible to regard $Present$ as a function between equivalence classes, rather than a relation between data levels. As a result, the specification is largely similar to the specification of the previous section.

Because no assumptions are made about the types of the two levels, the model for extra state is  rather abstract. Section~\ref{sect:wildcardEq} provides a concrete representation of extra state in tree-structured data types.


%?Next section we give a concrete instance of these classes.

\bc
\bl
\o Simple example a declaration (identifier \& rhs) in a source editor is presented by leaving out the righthand side:
\o  \verb| (Decl "b" True) <-> "b  =  ..."|\note{or complex expression?}
\o Whitespace is presentation extra state: \verb| (Decl "b" True) -> "*b*=*..."|
\o Right-hand side is interpretation extra state: \verb|b = ... -> (Decl "b" *)|
\el
\ec



\subsection{Equivalence classes}

We start by introducing some notation for equivalence classes. A typed binary relation $R \tp T \rel T$ is an equivalence relation if it is reflexive, symmetric, and transitive.  The equivalence class for a value $x \tp T$ is denoted by $\eqclass{x}{R}$. Its definition is:

\xpr{
%( \eqclass{\hole}{R}) \tp S \to  \Eqclass{S}{R}\\
\eqclass{x}{R} = \setof{y}{x R y}
}

The factor set $\Eqcl{T}{R}$ is the set of all equivalence classes of $R$. It is a set of mutually exclusive and jointly exhaustive subsets of $T$ (if we regard $T$ as a set).

\xpr{
\Eqclass{T}{R} = \setof{\eqclass{x}{R}}{ x \tp T}
}

We have the following property for an equivalence relation $R$:

\xprlab{
x \in \eqcl{y}{R} ~\eqv~ \eqcl{x}{R} = \eqcl{y}{R}
}{$\eqhole$-Member}


%Proposition:
%\xpr{
%\eqclass{x}{R} = \eqclass{y}{R} ~\lor~ (\eqclass{x}{R} \cap \eqclass{y}{R}) = \emptyset
%}


\subsection{An equivalence class for extra state} \label{sect:eqclassForES}

If several lower level values are related to the same higher level value by the presentation relation, this means that when disregarding extra state, the lower level values are equal. Similarly, if two higher level values are related to the same lower value, the higher level values are equal up to extra state. We use an equivalence relation to express that two values are equal up to extra state. 

The two data levels give rise to two equivalence relations: $H$ and $L$.

\xpr{
H \tp Level\H \rel \Level\H~~~~~~\text{and}~~~~~~L \tp Level\L \rel \Level\L\\
}

Sections~\ref{sect:editingExtraState} and \ref{sect:extraState} provide examples of extra state, but in order to illustrate the equivalence class representation of extra state, we give two simple examples here as well. Both examples are set in an editor for a simple programming language, for which layout is not part of the syntax.

We use a partially presented declaration as an example of interpretation extra state. If we hide the right-hand side, \verb|Decl "f" (Sum 1 2)| is presented as \verb|f = ...|, which is also a presentation of \verb|Decl "f" (Product 3 4)|. Hence, we have
$(\verb|Decl "f" (Sum 1 2)|)~H~(\verb|Decl "f" (Product 3 4)|)$. More generally, a declaration is equivalent to every declaration that has the same left-hand side identifier.

Whitespace is an example of presentation extra state on the lower level. Consider the expression \verb|Sum 1 2|, which is presented as {\tt 1\spc+\spc 2}. The presentation is equivalent to the symbols \verb|1|,\verb|+|, and \verb|2| with any configuration of whitespace. Thus, for example, $({\tt 1\spc+\spc 2})~L~({\tt 1+2})$.

In order to specify that extra state should be reused after an update, without making any assumptions on the level type, we use the ``close~to'' notion from the previous section. We express that an updated value $x'$ contains reused extra state from $x$, by requiring that $x'$ is the element of its equivalence class that is as close as possible to $x$. 

As an example, consider an update on the presentation of \verb|Decl "f" (Sum 1 2)| from the example above:  $\verb|f = ...| \leadsto \verb|g = ...|$. The new higher level should have left-hand side \verb|"g"| and reuse the sum. This can be specified by requiring that from the equivalence class of declarations with left-hand side \verb|"g"|, we select the element that is as close as possible to \verb|Decl "f" (Sum 1 2)|. The obvious solution is \verb|Decl "g" (Sum 1 2)|.



\subsection{Presenting and interpreting}

In the presence of extra state, both the presentation and interpretation mappings may have several results for a single argument, and hence cannot directly be represented by functions anymore. Regarding the mappings as relations, we have:
% they are no longer functions, but binary relations:

\xpr{
Present &\tp& \Level\L \rel \Level\H\\
Interpret &\tp& \Level\H \rel \Level\L
}

The level order in the relation types is such that $l~Present~h$ looks similar to its functional counterpart $l = \present~h$. 

%Consequentially, we regard the right ..? as the domain of the relation, and the left .. as the range. 

%\bl
%\o relations are total
%\o say that range is not the set, but only the set for which relation holds
%\el


%\note{maybe say something more about what it means for a relation to be an equivalence class mapping. (Depends non “Combined layer'' section)}


%\note{mention the intuition behind this?  (because arg is also an eq. class, es from one function can never influence result of its dual)}
%Explain that es is classes.
%Present underspecifies lower eq. relation (only on valid). And \interpret is tricky.


\bc
\textdownarrow\textdownarrow\textdownarrow\textdownarrow

Something about what the equivalence classes are: Lower is underspecified: 
PER story

\xpr{
\eqcl{h}{H} = \setof{h'}{\exists l : l~\Present~h \land l~\Present~h'}
}

defines a class on $\Level\H$, since $\Present$ is total, so we have $\eqcl{h}{H}$ for each $h$ on $\Level\H$.

\xpr{
\eqcl{l}{L} = \setof{l'}{\exists h : l~\Present~h \land l'~\Present~h}
}
defines a class on ${\bf range}~\Present \subset \Level\H$, $\Present$ need not be surjective.

$\Interpret$:

\xpr{
\eqcl{h}{H} = \setof{h'}{\exists l : h~\Interpret~l \land h'~\Interpret~l}
}

defines class on $\Level\H$, since $\Interpret$ is total.

Last one is tricky, since also elements without presentation are included in eq. class.
\xpr{
\eqcl{l}{L} = \setof{l'}{\exists h : h~\Interpret~l \land h~\Interpret~l'}
}

Restrict it to range of $\Present$?
That means we would get:

\xpr{
\eqcl{l}{L} = \setof{l'}{\exists h : h~\Interpret~l \land h~\Interpret~l' \land  l'~\Present~h'}
}

\textuparrow\textuparrow\textuparrow\textuparrow
\ec

If we model the extra state on the higher and lower levels with two equivalence relations $H$ and $L$, we can express $Present$ and $Interpret$ as functions between equivalence classes:

\xpr{
\present &\tp& \Eqcl{\Level\H}{H} \rightarrow  \Eqcl{\Level\L}{L}\\
\interpret &\tp& \Eqcl{ \Level\L}{L} \rightarrow \Eqcl{\Level\H}{H}
}


%result is always an eq. class (follows from type)\note{fix $H$ and $L$, since these are the eq. relations, but used %here as sets}
%
%\xpr{
%L = \present~H \imp L = \eqcl{l}{L}\\
%H = \interpret~L \imp H = \eqcl{h}{H}
%}

The correspondence between functions $\present$ and $\interpret$, and relations $\Present$ and $\Interpret$ is made explicit by the two characterizations:

\xprlab{
l~Present~h ~\eqv~ \eqcl{l}{L} = \present~ \eqcl{h}{H}\\
}{\present-Char}
\xprlab{
h~Interpret~l ~\eqv~ \eqcl{h}{H} = \interpret~\eqcl{l}{L}
}{\interpret-Char}

In the remainder of this section, we exclusively make use the functional representation.

%\xpr{
%\present~H = \setof{l}{h \in H \land l \in Present~h}
%}



%\head{Presentation invariant}    Seems obsolete now.
%
%\bl
%\o Presentation invariant changes: Works on sets now.
%%\o (\verb|"b = ..."| as well as more spatious \verb|"b    =    ..."| are correct presentations of \verb|Decl "b" True|
%\el
%
%\xprlab{
%\level\L~\Present~\level\H\\
%\text{or, equivalently}\\
%\eqcl{\level\L}{L} = \present~\eqcl{\level\H}{H}
%}{Present}


\head{\law{InterPresent} property}

The \law{InterPresent} property changes slightly, since we use equivalence class notation to make explicit that the arguments and results are equivalence classes:

\xprlab{
%l~\Present~h \imp h~\Interpret~l\\
%or\\
\eqcl{l}{L} = \present~\eqcl{h}{H} \imp \eqcl{h}{H} = \interpret~\eqcl{l}{L}\\
}{InterPresent}

Or, equivalently:

\xpr{
\interpret \oo \present = id_{\Eqcl{\Level\H}{H}} 
}

Similar to the previous section, \law{InterPresent} states that $\interpret$ is a left inverse of $\present$ and implies injectivity of $\present$ as well as surjectivity of $\interpret$.

% Kleisli is not applicable anymore. Maybe useful somewhere below.
% old problem with Kleisli:
% l in (pres  `kleisli` int) l       is not True, because that alread holds if there is s single h in int l
% for which l in pres h, but we want for all h in int l that l in pres h



\subsection{Editing} \label{sect:singleExtra_Editing}

Similar to Section~\ref{sect:single_Editing}, we need to assign new values to the higher and the lower data levels when a user edits the lower level:

\xpr{
\eqcl{\level\L}{L} = \present~\eqcl{\level\H}{H}\\
\level\L \leadsto \level'\L 
}

The old requirements, rewritten with equivalence classes, are:

\xprlab{\hoare{\true} {Comp} { \eqcl{\level''\L}{L} = \present~\eqcl{\level''\H}{H} } }		{Postcondition}
\xprlab{\hoare{\eqcl{\level'\L}{L} = \present~\eqcl{\level\H}{H}} {Comp} { \level\H = \level''\H}}  {Doc-Inert}
\xprlab{\hoare{\eqcl{\level'\L}{L} = \present~\eqcl{h}{H}} {Comp} { \level'\L = \level''\L}}		{Pres-Inert}
\xprlab{\hoare{\true} {Comp} {\level'\L \close \level''\L}}	{Imprecise}

With extra state, the \law{Doc-Inert} requirement becomes interesting, since it is now possible to update the lower level without breaking the presentation invariant. For example, if whitespace is not stored in the document, and a user edits only whitespace, then the document should remain unchanged.

In addition to the four requirements of the previous section, we need to require that extra state on both levels is reused after an update. For interpretation extra state on the higher level, we require that from the equivalence class specified by \law{Postcondition}, the element  that is as close as possible to the original value $level\H$ is selected:

\xprlab{\hoare{\true} {Comp} {\level\H \close \level''\H}}	{Doc-Preserve}

\law{Doc-Preserve} is weaker than the other requirements. It specifies which element of the equivalence class determined by \law{Postcondition} is the final value of the lower level.

On the lower level, we need a similar requirement for presentation extra state, but here it coincides with \law{Imprecise}. Thus, \law{Imprecise} has a double function: it states that the resulting equivalence class of $\present$ must be close to the equivalence class of $level'\L$, as well as that the presentation extra state in $level''\L$ must resemble the extra state in $\level'\L$ as much as possible. \note{mention strength of \law{Imprecise}?}


% es part weaker than others, not nec. either not valid, only imprecise and postcondition. 
% pres of doc, then pres-inert holds, imprecise does not interfere.  Just valid, same thing.

%\note{do we have to say the \law{Imprecise} is stronger than \law{Preserve}?}
\head{Reusing extra state}

$Comp$ realizes a mapping between data levels, but both $\present$ and $\interpret$ are mappings between equivalence classes on these data levels. Hence, we need a way to get from values to equivalence classes and back. We use the $\eqhole$ function to denote the equivalence class of a value. For going from an equivalence class to a value, we introduce a new function~$\reuz$.

The resulting class of $\present$ or $\interpret$ contains all possible combinations for the extra state.
From this class, we need to select an element for which the extra state resembles the extra state of the previous value as much as possible. Intuitively,~$\reuz$ ``reuses'' the extra state from the previous value of a level. Because we need to reuse extra state on the results of $\present$ as well as $\interpret$, we need two $\reuz$ functions: one for each level.

In this section, we only give the type of~$\reuz$, together with a number of requirements. Section~\ref{sect:wildcardEq} provides a more concrete instance. The type of~$\reuz$ is:

\xprlab{
\reuz \tp  \Eqclass{X}{R} \to X \to X\\
}

In order to disambiguate different $\reuz$ functions, we add the relation as a subscript to the operator (e.g.\ $\reuze{H}$ and $\reuze{L}\!$). For the higher level we have $\reuze{H} \tp  \Eqclass{Level\H}{H} \to Level\H \to Level\H$, and for the lower level $\reuze{L} \tp  \Eqclass{Level\L}{L} \to Level\L \to Level\L$

We require several properties of~$\reuz$. First of all, the equivalence class of the result of~$\reuz$ must be equal to the  equivalence class argument: \note{reformulate: its eq. class must be equal to args eq.class?} 

%\xprlab{\eqclass{x}{R} \reuz y \in \eqclass{x}{R}}				{$\reuz$-Valid}
\xprlab{\eqclass{\eqclass{x}{R} \reuz y}{R} = \eqclass{x}{R}}	{$\reuz$-Valid}

Furthermore, if the value argument is in the equivalence class argument, then~$\reuz$ returns the value argument.

 
%\xprlab{y \in \eqclass{x}{R} \imp \eqclass{x}{R} \reuz y = y}			{$\reuz$-Idem} 
\xprlab{\eqclass{y}{R} = \eqclass{x}{R} ~\imp~ \eqclass{x}{R} \reuz y = y}	{$\reuz$-Idem} 

Finally, if the value argument is not in the equivalence class argument, then~$\reuz$ returns an element of that class that is as close as possible to the value argument.

\xprlab{\eqclass{x}{R} \reuz y \close y}		{$\reuz$-Close} 

Similar to the \law{Doc-Inert} and \law{Imprecise} requirements, \law{$\reuz$-Idem} is a special case of \law{$\reuz$-Close}, for which ``close~to'' is equality.

\head{Definition of $Comp$}

Using $\eqcl{\hole}{X}$ and ~$\reuz$ we can define $Comp$. The definition is split in $Up$ and $Dwn$ to make the proofs of the requirements more readable. %(will be split for composite layers anyway).

%\xprlab{
%\level''\H = \interpret~ \eqcl{\level'\L}{L}  ~\reuze{H}~   \level\H  \\ %(\level'\L,\level\H)\\ 
%\level''\L = \present~ \eqcl{\level''\H}{H}   ~\reuze{L}~   \level'\L % ^* (\level''\H, level'\L)
%}{Compute}
%\xprlab{
%Comp \is 	& \level''\H = \interpret~ \eqcl{\level'\L}{L}  ~\reuze{H}~   \level\H \semi\\
%				& \level''\L = \present~ \eqcl{\level''\H}{H}   ~\reuze{L}~   \level'\L
%}{$Comp$-Def}

\xprlab{
Comp \is 	& Up \semi Dwn}{$Comp$-Def}
\xprlab{
Up \is		& \level''\H \gets \interpret~ \eqcl{\level'\L}{L}  ~\reuze{H}~   \level\H}{$Up$-Def}
\xprlab{
Dwn \is		& \level''\L \gets \present~ \eqcl{\level''\H}{H}   ~\reuze{L}~   \level'\L}{$Dwn$-Def}

We prove that $Comp$ meets the requirements.

\head{\law{Postcondition} requirement}

%Because of \law{\fn{wp}-Char}, \law{Postcondition} is equivalent to:
The weakest precondition notation of \law{Postcondition} is:

$\true ~\imp~\wp{Comp}{\eqcl{\level''\L}{L} = \present~\eqcl{\level''\H}{H}}$

\begin{proof} 
\begin{Prf}&
	 \true  \\
\Eqv{\law{\fn{wp}-$\gts$}}&
	\wp{\level''\H \gets \interpret~ \eqcl{\level'\L}{L}  ~\reuze{H}~   \level\H}{  \true  }\\
\Eqv{\law{$Up$-Def}}&
	\wp{Up}{ \true }\\
\Eqv{ reflexivity of~$=$ }&
	\wp{Up}{ \present~ \eqcl{\level''\H}{H} = \present~\eqcl{\level''\H}{H}  }\\
\Eqv{ \law{$\reuz$-Valid} }&
	\wp{Up}{ \eqcl{\present~ \eqcl{\level''\H}{H}   ~\reuze{L}~   \level'\L}{L} = \present~\eqcl{\level''\H}{H}  }\\
\Eqv{\law{\fn{wp}-$\gts$}}&
	\wp{Up}{ \wp{\level''\L \gets \present~ \eqcl{\level''\H}{H}   ~\reuze{L}~   \level'\L}{ \eqcl{\level''\L}{L} = \present~\eqcl{\level''\H}{H} }}\\
\Eqv{\law{$Dwn$-Def}}&
	\wp{Up}{ \wp{Dwn }{ \eqcl{\level''\L}{L} = \present~\eqcl{\level''\H}{H} }}\\
\Eqv{\law{\fn{wp}-$\smi$}}&
	\wp{Up \semi Dwn}{ \eqcl{\level''\L}{L} = \present~\eqcl{\level''\H}{H} }\\
\Eqv{\law{$Comp$-Def}}&
	\wp{Comp}{\eqcl{\level''\L}{L} = \present~\eqcl{\level''\H}{H}}\\
\end{Prf}
\end{proof}

\head{\law{Doc-Inert} requirement}

%$\hoare{\eqcl{\level'\L}{L} = \present~\eqcl{\level\H}{H}} {Comp} { \level\H = \level''\H }$

$\eqcl{\level'\L}{L} = \present~\eqcl{\level\H}{H} ~\imp~ \wp{Comp}{\level\H = \level''\H}$

\begin{proof}

%\note{compress this thing a bit?}
\begin{Prf}&
	\eqcl{\level'\L}{L} = \present~\eqcl{\level\H}{H}\\
\Eqv{\law{InterPresent}}&
	\eqcl{\level\H}{H} = \interpret~\eqcl{\level'\L}{L} \\
\Imp{\law{$\reuz$-Idem}}&
	\level\H = \interpret~ \eqcl{\level'\L}{L}  ~\reuze{H}~   \level\H \\
\Eqv{\law{\fn{wp}-$\gts$}}&
	\wp{\level''\H \gets \interpret~ \eqcl{\level'\L}{L}  ~\reuze{H}~   \level\H}{ \level\H = \level''\H }\\
\Eqv{\law{$Up$-Def}}&
	\wp{Up}{ \level\H = \level''\H }\\
\Eqv{\law{\fn{wp}-$\gts$}}&
	\wp{Up}{ \wp{\level''\L \gets \present~ \eqcl{\level''\H}{H}   ~\reuze{L}~   \level'\L}{ \level\H = \level''\H }}\\
\Eqv{\law{$Dwn$-Def}}&
	\wp{Up}{ \wp{Dwn }{ \level\H = \level''\H }}\\
\Eqv{\law{\fn{wp}-$\smi$}}&
	\wp{Up \semi Dwn}{ \level\H = \level''\H }\\
\Eqv{\law{$Comp$-Def}}&
	\wp{Comp}{\level\H = \level''\H}\\
\end{Prf}
\end{proof}


\head{\law{Pres-Inert} requirement}

%$\hoare{\eqcl{\level'\L}{L} = \present~\eqcl{h}{H}} {Comp} { \level'\L = \level''\L}$
%We prove \law{Pres-Inert} by proving the equivalent:

$\eqcl{\level'\L}{L} = \present~\eqcl{h}{H} ~~\imp~~ \wp{Comp}{ \level'\L = \level''\L  }$

\begin{proof}

We assume $\eqcl{\level'\L}{L} = \present~\eqcl{h}{H}$.
	
\begin{Prf}&
	\true\\
\Eqv{reflexivity of $=$}&
	\eqcl{\level'\L}{L} = \eqcl{\level'\L}{L}\\
\Eqv{ \law{$\reuz$-Idem} }&
	\level'\L  = \eqcl{\level'\L}{L}~\reuz~  \level'\L\\
\Eqv{assumption}&
	\level'\L  = \present~\eqcl{h}{H}  ~\reuze{L}~  \level'\L\\
\Eqv{\law{$\reuz$-Valid}}&
	\level'\L  = \present~ \eqcl{(\eqcl{h}{H}  ~\reuze{H}~   \level\H)}{H}   ~\reuze{L}~   \level'\L\\
\Eqv{\law{InterPresent }}&
	\level'\L = \present~ \eqcl{(\interpret~(\present~\eqcl{h}{H})  ~\reuze{H}~  \level\H)}{H}   ~\reuze{L}~   
\level'\L\\
\Eqv{assumption}&
	\level'\L = \present~ \eqcl{\interpret~ \eqcl{\level'\L}{L}  ~\reuze{H}~   \level\H}{H}   ~\reuze{L}~   \level'\L\\
\Eqv{\law{\fn{wp}-$\gts$}}&
	\wp{\level''\H \gets \interpret~ \eqcl{\level'\L}{L}  ~\reuze{H}~   \level\H}{\level'\L = \present~ \eqcl{\level''\H}{H}   ~\reuze{L}~   \level'\L }\\
\Eqv{\law{$Up$-Def}}&
	\wp{Up}{\level'\L = \present~ \eqcl{\level''\H}{H}   ~\reuze{L}~   \level'\L }\\
\Eqv{\law{\fn{wp}-$\gts$}}&
	\wp{Up}{\wp{\level''\L \gets \present~ \eqcl{\level''\H}{H}   ~\reuze{L}~   \level'\L}{ \level'\L = \level''\L  }}\\
\Eqv{\law{$Dwn$-Def}}&
	\wp{Up}{\wp{Dwn}{ \level'\L = \level''\L  }}\\
\Eqv{\law{\fn{wp}-$\smi$}}&
	\wp{Up \semi Dwn}{ \level'\L = \level''\L  }\\
\Eqv{\law{$Comp$-Def}}&
	\wp{Comp}{ \level'\L = \level''\L  }\\
\end{Prf}
\end{proof}



\head{\law{Doc-Preserve} and \law{Imprecise} requirements}

Because of the nature of the \law{Doc-Preserve} and \law{Imprecise} requirements, we give an informal argumentation instead of a proof. 

From \law{$Up$-Def}, we know that $level''\H$ is the result of  $\interpret~ \eqcl{\level'\L}{L}  ~\reuze{H}~   \level\H$, which implies $level\H \close level''\H$ by \law{$\reuz$-Close}. Hence, \law{Doc-Preserve} holds.

The \law{Imprecise} requirement is somewhat more subtle, since it has a double function. On the one hand, it states that the equivalence class $\eqcl{\level''\L}{L}$ must be close to $\eqcl{\level'\L}{L}$. This corresponds to the \law{Imprecise} requirement in Section~\ref{sect:single_Editing} without extra state. In this sense, closeness is used to express that the final lower level resembles what the user intended. Thus, if $level'\L$ is not a valid presentation, then $\eqcl{level''\H}{H}$, must be chosen such that its presentation equivalence class $\eqcl{\level''\L}{L}$ is close to $\eqcl{\level'\L}{L}$. This part of the requirement is therefore a specification of $\interpret$.


On the other hand, \law{Imprecise} also states that from the equivalence class $\eqcl{\level''\L}{L}$,
%$\present \eqcl{level''\H}$
 we want to choose an element that is as close as possible to $level'\L$ regarding its extra state. This closeness is guararanteed by \law{$\reuz$-Close} in the same way as on the higher level for \law{Doc-Preserve}.





%																
%																
%																
\section{A wildcard representation for equivalence classes} \label{sect:wildcardEq}

%\note{call this a ``finite representation''?}
In this section, we give a representation for equivalence classes for a simple kind of tree data structures. We introduce a wildcard notation for representing extra state. Furthermore, we specify a reuse function ($\reuz$) for such wildcard values.

% now only trees, still enough. non tree also works if isomorphic.

The specification for reusing extra state is a first step, and needs to be extended further to allow reusing extra state for more edit operations. The final subsection sketches such an extension.



% Notes:
%
% $pres n = n `div` 2$ is no longer possible, since eq. classes on pres are 
% then $\set{\set{0,1},\set{2,3}, \dots }$, for which there is no * rep. (0 and 1 in eq. class implies all elts in eq. class)
% can we handle $\set{ {\tt "return\spc1" },{\tt "return\spc\spc1" }, {\tt "return\spc\spc\spc1" }, \dots}$?
%Yes, maybe use an isomorphic view 

\subsection{Trees with wildcards} \label{sect:treesWildcards}
% types are $$ because Int, Bool etc. are used also in a non-Haskell sense
% constructors are \tt
% C constructors are meta-constructors  (and T is type var.)

In a tree structured-data type, we can model extra state by leaving certain parts of the tree undetermined. We do this by representing each extra state part by a wildcard, which stands for any possible value of the correct type. The functions $\present$ and $\interpret$ return a value that contains wildcards, thus leaving the extra state in the result undetermined.

For a type $T$, the corresponding wildcard has type $*_T$ and is denoted by  $\texttt{*}_{T}$:

\xpr{
\data~*_T  = \texttt{*}_{T}\\
}
 
 A wildcard for a type $T$ stands for any possible value of type $T$. Thus, the value $\texttt{*}_{Bool}$ represents the set $\set{{\tt True}, {\tt False}}$, and the value $\texttt{*}_{Int}$ represents the set of all integers. An example shows how wildcards can be used to model extra state in a data type.

%explain diff between type $*$ and value for $\texttt{*}$

Consider a simple binary tree data type:

\xpr{
\data~Tree  = {\tt Bin}~Bool~Tree~Tree~|~{\tt Leaf}~Bool~Int\\
}

We can recursively define a type $Tree^*$ that declares the booleans in the nodes and the integers in the leaves to be extra state, by replacing these types in the declaration by wildcards.

\xpr{
\data~Tree^*  = {\tt Bin}~*_{Bool}~Tree^*~Tree^*~|~{\tt Leaf}~Bool^*~*_{Int}\\
}

For simplicity, the constructors for a type $T^*$ are the same as for $T$. A sample value of type $Tree^*$ is:
 ${\tt Bin} ~\texttt{*}_{Bool}~ ({\tt Leaf~True}~\texttt{*}_{Int})~({\tt Leaf~False}~\texttt{*}_{Int})$. Note that for a primitive type, such as the boolean in the {\tt Leaf}, we have $Bool^* \eq Bool$, because a primitive type has no children.
% mention that * are terms

For a type $T$, a type $T^*$ declares which parts are extra state. Note that the choice whether a value is extra state is not based on its type, but rather on the $T^*$ declarations in which  the value appears as a child. Hence, in the example, a boolean in a 
${\tt Bin}$ node is extra state, whereas a boolean in a ${\tt Leaf}$ is not. Furthermore, note that for a single type $T$ several possible types $T^*$ exist.

Because a wildcard represents the set of all possible values of a certain type, a value containing a wildcard represents a set of values. A value that contains several wildcards also represents the set that is formed by taking all possible combinations of values for the wildcards. 

We use the notation $\para{x}$ for the set of values represented by a value $x \tp T^*$. Thus,  $\para{ C \texttt{*}_{Bool} \texttt{*}_{Bool}} = \set{{\tt C~True~True}, {\tt C~True~False}, {\tt C~False~True}, {\tt C~False~False}}$.

In order to obtain a $T^*$ value for a value of type $T$, we define a function $\core \tp T \to T^*$, which drops all information that is masked by a wildcard in the $T^*$ definition. For example, for the type definition $\mathbf{data}~T^* = \texttt{T}~Int~*_{Int}$, we have $\core~(\texttt{T}~1~\texttt{True}) = \texttt{T}~1~\texttt{*}_{Bool}$.

Because the root type is not a child of any constructor, it cannot be extra state. Even though it is unlikely that we want the root to be extra state, it may still be declared as such by using a dummy root type $\data~R = {\tt R}~Root$, and declare the $Root$ child as extra state: $\data~R^* = {\tt R}^*~*_{Root}$.  

In general, we can regards a recursive first-order Haskell data type $T$ as:

% C is var
\xpr{
\data~T  =  C_0~T_{0,0} \dots T_{0,m_0} ~|~ \dots ~|~ C_n~T_{n,0} \dots T_{n,m_n} \\
}

Note that we denote the constructors with $C_{0\dots n}$ rather than $\texttt{C}_{0 \dots n}$ because they are variables that stand for the constructors of $T$.

We can specify what parts of $T$ are extra state by defining a wildcard type $T^*$. In the definition of $T^*$, we specify for each child of each constructor of $T$ whether or not is extra state:

\xpr{\data~T^* =  C_0~U_{0,0} \dots U_{0,m_0} ~|~ \dots ~|~ C_n~U_{n,0} \dots U_{n,m_n}\\ 
\text{with}~ U^*_{i,j} = T^*_{i,j}
}


%We define  $\para{x}$ to be the set of values represented by a value $x \tp T^*$. Thus, for example,  $\para{ C %\texttt{*}_{Bool} \texttt{*}_{Bool}} = \set{{\tt C~True~True}, {\tt C~True~False}, {\tt C~False~True},{\tt %C~False~False}}$

The definition of $\para{\hole}$ is:

\xprlab{
\para{\hole} \tp T^* \to \powerset T\\
\para{*_ T} \eq \setof{x}{x \tp T}\\
\para{C~x^*_0 \dots x^*_n} \eq \setof{ C~x_0 \dots x_n}{x_0 \in \para{x^*_0} \land \dots  \land x_n \in \para{x^*_n}} 
}{$\para{\hole}$-Def}


%In order to obtain a $T^*$ value for a value of type $T$, we define the function $\core \tp T \to T^*$, which drops all information %in a value that is masked by a $*$ in the type definition $T^*$. For example, for a type definition $\mathbf{data}~T^* = %\texttt{T}~Int~*_{Int}$, we have $\core~(\texttt{T}~1~\texttt{True}) = \texttt{T}~1~\texttt{*}_{Bool}$

And the definition of $\core$ is:

 \xprlab{
{\bf data}~T^* = \dots ~|~ C_i~U_{i,0} \dots U_{i,m_i} ~|~ \dots\\
\\  
\core \tp T \to T^*\\
\core~(C_i~x_0 \dots x_{m_i}) \eq C_i~x'_0 \dots x'_{m_i} \\
{\bf where}~ x'_j = \left\{
\begin{array}{ll}
\texttt{*}_X & , {\bf if}~ U_{i,j} = *_X \text{  for some type $X$}   \\
\core~x_j & , {\bf otherwise}
\end{array}\right.
}{$\core$-Def}


%Note that unlike $\para{\hole}$, $\core$ depends on the definition of $T^*$; different wildcard types give rise to different $\core$ %functions.

%% statement below was for * types with * alternative for each constructor. Does not hold for the new * types
%Because the constructors are the same, converting a value in $T$ to a value in $T*$ is trivial.
%any value of $T$Same constructor, therefore all vals of T are also values of $T^*$


\subsection{$T^*$ induces an equivalence relation on $T$}

We can define two values of type $T$ to be equivalent when they are equal, or only differ in extra state. The resulting binary relation on $T$ is denoted by $\eqstar~\tp T \rel T$. For the definition of $\eqstar$ we use the function $\core$, which is uniquely determined by $T^*$:

\xprlab{
%\setof{ x \eqstar y}{  x \in \para{x^*} \land y \in \para{y^*} \land x^* = y^*}
x \eqstar y \is  \core~x = \core~y
}{$\eqstar$-Def}

To see that $\eqstar$ is an equivalence relation, we need the theorem below, the simple proof of which has been omited:

\xpr{
(\exists f : \forall x,y : x R y ~\eqv~ (f~x = f~y)) ~\eqv~ \text{``$R$~is an equivalence relation''}
}

By substituting $\core$ for $f$ and $\eqstar$ for $R$, it immediately follows that~$\eqstar$ is an equivalence relation on $T$. 

Without giving a proof, we mention that the equivalence classes of $\eqstar$ can be expressed using $\para{\hole}$ and $\core$. 

\xpr{
\eqclass{x}{\eqstar} \eq \para{\core~x}
}
\bc
This one was already proven:

\xpr{
(\exists f : x R y ~\eqv~ (f~x = f~y) ~\imp~ R~\text{is an equivalence relation}
}


\begin{proof} \note{maybe leave this out, or prove equiv. See how much space/time we have}
\begin{Prf}&
x R x 	& \Eqv{definition of $R$}\\
f x = f x 	& \Eqv{reflexivity of =}\\
\true\\
\end{Prf}


\begin{Prf}&
x R y  	& \Eqv{definition of $R$}\\
f x = f y 	& \Eqv{symmetry of =}\\
f y = f x 	& \Eqv{definition of $R$}\\
y R x\\
\end{Prf}\note{get $\eqv$ instead of $\imp$}

\begin{Prf}&
x R y  \land y R z 		& \Eqv{definition of $R$}\\
f x = f y \land f y = f z	& \Imp{transitivity of =}\\
f x = f z 				& \Eqv{definition of $R$}\\
x R z\\
\end{Prf}
\end{proof}
\ec

\subsection{Reuse on wildcard types}\label{subsect:wildreuse}

We use wildcard types to represent the results of $\present$ and $\interpret$.  Because each wildcard represents a set of values, we need to select an element from each of these sets to obtain a final value for the result. This selection corresponds to filling in a value of type $T$ for each wildcard $\texttt{*}_{T}$ in the result. The values that are filled in for the wildcards are taken from a previous value of the level, if possible.

In this section, we define a function $\reuzestar$ that fills in the wildcards in its first argument by reusing values from its second argument. The type of $\reuzestar$ is:

\xpr{
\reuzestar ::  T^* \to T \to T\\
}

%The property that the parts of a value that are not extra state are maintained can be stated as $x^* \reuzestar y = \core~x^*$. 

We give two examples to show how $\reuzestar$ is used.

Consider a $Token$ data type with a presentation extra state tuple to denote the whitespace. If a token for \verb|"False"| with a whitespace of one linebreak and three spaces is updated to a token \verb|"True"|, then the whitespace of the old token is reused by $\reuzestar$:

$(\verb|Token |\texttt{*}_{(Int, Int)} \verb| "True"|) \reuzestar  (\verb|Token (1,3) "False"|) \eq \verb|Token (1,3) "True"|$

For the second  example, we take the declaration with the hidden right-hand side from Section~\ref{sect:eqclassForES}: \verb|Decl "f" (Sum 1 2)|. If a user renames the left-hand side in the presentation to \verb|g|, the result of $\interpret$ contains the new identifier \verb|"g"|, but the right-hand side is interpretation extra state and will be a $\texttt{*}_{Exp}$. Again, $\reuzestar$ recovers the extra state from the previous value: 

$(\verb|Decl "g" |\texttt{*}_{Exp}) \reuzestar  (\verb|Decl "f"  (Sum 1 2)|) \eq \verb|Decl "g" (Sum 1 2)|$

In some cases, reusing extra state from a previous value is not possible. For example, when a new subtree is inserted in a level, its extra state will not be present in the previous value of the level. Furthermore, if a level is structurally changed, even if all extra state is present in the previous value, it may not always be possible to recover it. In case extra state cannot be reused, we use a function to obtain a default value: $\default \tp a^* \rightarrow a$.

We give a $\default$ function for the declaration example. If a new declaration is inserted, its hidden righthand side is initialized to \texttt{Undefined}:

\xprlab{
\default~(\texttt{Decl}~i~e) = \left\{
\begin{array}{ll}
 \texttt{Decl}~i~\texttt{Undefined} & , {\bf if}~ e = \texttt{*}_{Exp} \\
\texttt{Decl}~i~e & , {\bf otherwise}
\end{array}\right.
}

We require that the result of $\default$ is equal to its argument, except for its wildcards. Wildcards are replaced by initial values.

\xprlab{
\default~x^* \in \para{x^*}\\
}{$\default$-Valid}

Because $\default \tp T^* \rightarrow T$ depends strongly on type $T$, we cannot give a general definition of the function. However, it will generally have this pattern:

\xprlab{
\default~\texttt{*}_T = \text{default value for type $T$}\\
\default~(C~x^*_0 \dots x^*_n) = C~(\default~x^*_0) \dots (\default~x^*_n) \\
}

The definition is just a sketch, because it suggests that the default for a value only depends on its type, whereas values of the same type that appear in different places may have different defaults. In the  $\default$ for declarations, as defined above, a $\texttt{*}_{Exp}$ wildcard appearing in a \texttt{Decl} gets the default value \texttt{Undefined}, but in other places the default may be different.

%For example, if whitespace is represented by a tuple of integers for line-breaks and spaces, then the algorithm above suggests that %the default for both integers is the same.

Another difficulty in giving a general definition is that a default value may also depend on information elsewhere in the tree, for example when default whitespace is computed by a pretty-printing algorithm. In that  case, the $\default$ function requires an extra argument containing the context of the subtree that is to be pretty-printed.

Using $\default$ we can give a first definition of $\reuzestar$. It takes a new value containing wildcards, together with an old value, and returns the new value with extra state from the old value.

\xprlab{
\texttt{*}_T ~\reuzestar~  y \eq y\\
C~x^*_0 \dots x^*_n ~\reuzestar~ C~y_0 \dots y_n \eq C~(x^*_0 \reuzestar y_0) \dots (x^*_n  \reuzestar y_n) \\
C~x^*_0 \dots x^*_n ~\reuzestar~ C'~y_0 \dots y_m \eq \default~(C~x^*_0 \dots x^*_n)
}{$\reuzestar$-Def}

This is only a basic definition of $\reuzestar$ that recovers extra state only if the old and the new value are structurally similar. If the constructors for the two values are different, a default value is chosen for extra state. Although sufficient for some cases, this method of reusing, based on structure only, is too coarse in general.

Consider an element that is deleted from a list (e.g.\ $[e_0, e_1] \leadsto [e_1]$). A structure-based reuse will recover extra state from $e_0$ for the new value $e_1$, which is not the desired behavior. Similarly, when swapping child nodes in a tree, the extra state will not swap. And finally, when a subtree is updated to a structurally similar subtree, such as 
$\verb|Sum|~e_1~e_2 \leadsto \verb|Product|~e_1~e_2$, we might want the extra state of the children to be reused, which is not possible if with this basic $\reuzestar$.

We can handle the problems mentioned above by extending the model with a notion of subtree identities, and defining a more powerful reuse function. Section~\ref{subsect:reuseid} sketches how such a function may be defined.


\subsection{Reuse on equivalence classes} \label{sect:defReuse}

The reuse function $\reuzestar$ defined in the previous section takes a wildcard argument of type $T^*$, whereas the reuse function required for $Comp$ in Section~\ref{sect:singleExtra_Editing} takes an equivalence class argument. Because a wildcard type definition induces an equivalence relation, we can use $\reuzestar$ for $\reuz$. However, since not every equivalence relation has a wildcard representation, we thus put a restriction on the equivalence relations that we can define on the results of $\present$ and $\interpret$, and hence on the kind of extra state we can model.

Recall the types of $\present$ and $\interpret$:

\xprlab{
\present &\tp& \Eqcl{\Level\H}{H} \rightarrow  \Eqcl{\Level\L}{L}\\
\interpret &\tp& \Eqcl{\Level\L}{L} \rightarrow  \Eqcl{\Level\H}{H}
}

%We assume that the equivalence relations $H$ and $L$ are implied by wildcard types $\Level^*\H$ and $\Level^*\L$. This %gives rise to  Hence:
%explain bit more, two or more implies all. also for constructor.\note{comment probably obsolete}

A wildcard type $\Level^*\H$ induces an equivalence relation $\eqstar$ and the corresponding $\core$ and $\reuzestar_{\rm H}$ functions. We restrict ourselves by requiring that the extra state on $\Level\H$ has a wildcard representation. Thus, we require the existence of a $\Level^*\H$, such that $H \eqv {\eqstar}$. A similar restriction applies to the lower level.

If we add subscripts for the relations to disambiguate $\para{\hole}$ and $\core$ for the different levels, the equivalence classes on the higher and lower levels can be expressed as:

\xprlab{
\eqcl{h}{H} \eq \para{ \core_{\!H}~h}_{\!_{H}}\\
\eqcl{l}{L} \eq \para{ \core_{\!L}~l}_{\!_{L}}\\
}{Restrict}


%A wildcard type $\Level^*\H$ induces an equivalence relation $\eqstar_{\rm H}$ and corresponding $\core_{\rm H}$, and %$\reuzestar_{\rm H}$ functions. Similarly, a type $\Level^*\L$ gives rise to a relation $\eqstar_{\rm H}$ and corresponding %functions. 
%
%We now restrict ourselves by requiring that the extra state on $\Level\H$ and $\Level\L$ has a wildcard representation. Thus, we %require the existence of a $\Level^*\H$ and a $\Level^*\L$, such that $H \eqv {\eqstar_{\rm H}}$ and
%$L \eqv {\eqstar_{\rm L}}$. The equivalence classes on the higher and lower level can therefore be expressed in terms of %$\para{\hole}$ and $\core$:
%
%\xprlab{
%\eqclass{h}{H} \eq \para{ \core_{\rm H}~h}\\
%\eqclass{l}{L} \eq \para{ \core_{\rm L}~l}\\
%}{Restrict}


Because the results in the remainder of this section apply to either level, we drop the subscripts to $\para{\hole}$ and $\core$. We use $R$ to denote either $H$ or $L$.

%For $x$ of type $T$, we assume that there is a $T^*$ wildcard type, let $\eqsim$ be the equivalence class 

%\xprlab{
%\eqclass{x}{\eqstar} \eq \para{ \core~x}
%}{Restrict}% deze weg doen?

We define $\reuz$ in terms of $\reuzestar$:

\xprlab{
\reuz ::  \Eqcl{T}{\eqstar} \to T \to T\\
\eqclass{x}{\eqstar} \reuz y \is \core~x \reuzestar y 
}{$\reuz$-Def}

%\note{maybe mention that we cannot use this one on combination eq. classes}

We have to prove that $\reuz$ is a well defined function and that it meets the \law{$\reuz$-Valid}, \law{$\reuz$-Idem}, and  
\law{$\reuz$-Close} requirements from Section~\ref{sect:singleExtra_Editing}. 

The function $\reuz$ is a well-defined function on equivalence classes if for all elements in an equivalence class, $\reuz$ gives the same result.

\xpr{
x \eqstar x' ~~\imp~~ \eqclass{x}{\eqstar} \reuz y \equ \eqclass{x'}{\eqstar} \reuz y
}

\begin{proof}
\begin{Prf}&
	\eqclass{x}{\eqstar} \reuz y \equ \eqclass{x'}{\eqstar} \reuz y\\
\Eqv{$\reuz$-Def}&
	\core~x \reuzestar y \equ \core~x' \reuzestar y\\ 
\Imp{Leibniz}&
	\core~x \equ \core~x' \\ 
\Eqv{\law{$\eqstar$-Def}}&
	x \eqstar x'\\
\end{Prf}
\end{proof}


Before we prove validity and idempotency, we introduce a more uniform wildcard type that simplifies the proofs.

\head{The $T\st$ type}

The structure of a wildcard type definition $T^*$ leads to awkward proofs, because each child of a constructor can be either a wildcard or a regular child. When pattern matching, this means that children cannot be handled uniformly. Therefore, we introduce a uniform construction assigining a data type $T\st$, which has an extra wildcard constructor, to every type $T$, including the primitive types. 
(Note the different star symbols: `$\star$' for the uniform type versus `$*$' for the regular wildcard type.) 
\todo{mention cons is the same}
For a type $T$:

\xpr{
\data~T  =  C_0~T_{0,0} \dots T_{0,m_0}~|~\dots~|~C_n~T_{n,0} \dots T_{n,m_n} \\
}

we can construct a data type $T\st$ by:

\xpr{
\data~T\st =  C_0~T\st_{0,0} \dots T\st_{0,m_0} ~|~\dots~|~C_n~T\st_{n,0} \dots T\st_{n,m_n}~|~\texttt{*}_T\\
}

For the binary tree from~\ref{sect:treesWildcards}, we get:

\xpr{
\data~Tree\st  = {\tt Bin}~Bool\st~Tree\st~Tree\st~|~{\tt Leaf}~Bool\st~Int\st~|~\texttt{*}_{Tree}\\
}

Note that the construction also applies to the primitive types $Bool$ and $Int$, and extends these types with a wildcard constructor. Hence, the possible values for the type $Bool\st$ are: $\texttt{True}$, $\texttt{False}$, and $\texttt{*}_{Bool}$.


%A $T^*$ type can be viewed as an inlined version of a $T\st$ type.  
Unlike $T^*$ types, a data type $T$ has only one $T\st$ type. Because $T^*$ and $T\st$ share the $\texttt{*}_T$ constructor, any $T^*$ value is also a $T\st$ value. Furthermore, the functions $\reuzestar$, $\para{\hole}$, which are defined by pattern matching on $T^*$ values, are also functions on $T\st$.
% \note{say how we use $T\st$ in proofs?}

%\bl
%\o We prove this for more general $x\st$ instead of just for $\core~x$. 
%\el

\head{Validity}

The validity requirement  follows from a more general statement on $T\st$:

\begin{Prf}&
	\eqclass{\eqclass{x}{\eqstar} \reuz y}{\eqstar} = \eqclass{x}{\eqstar}\\
\Eqv{\law{$\eqhole$-Member}}&
	\eqclass{x}{\eqstar} \reuz y \in \eqclass{x}{\eqstar}\\
\Eqv{\law{Restrict} and \law{$\reuz$-Def}}&
	\core~x \reuzestar y \in \para{ \core~x}\\
\FFr{taking  $\core~x$ for $x\st$}&
	x\st \reuzestar y \in \para{x\st}\\
%& \text{define $C x\st_0 \dots x\st_n = \core~x$, prim types are constrs with 0 arity}\\
\end{Prf}

We prove 

\xpr{x\st \reuzestar y \in \para{x\st}}

by structural induction on $x\st$

\begin{proof}
{\bf case} $x\st = \texttt{*}_T$:\\
\begin{Prf}&
	\texttt{*}_T \reuzestar y 	\in \para{\texttt{*}_T}\\
\Eqv{\law{$\reuzestar$-Def}}&
	y 				\in \para{\texttt{*}_T}\\		
\Eqv{\law{$\para{\hole}$-Def}}&
	y 				\in \setof{t}{t \tp T}\\	
\FFr{$y \tp T$}&
	\true\\
\end{Prf}

{\bf case} $x\st = C~x\st_0 \dots x\st_n$ and $y = C~y_0 \dots y_n$\\
The induction hypothesis is $x\st_i \reuzestar y_i \in \para{x\st_i}$ % \note{"property of \dots" step okay?}
\begin{Prf}&
	C~x\st_0 \dots x\st_n \reuzestar C~y_0 \dots y_n \in \para{C~x\st_0 \dots x\st_n}\\
\Eqv{\law{$\reuzestar$-Def}}&
	C~(x\st_0 \reuzestar y_0) \dots (x\st_n \reuzestar y_n) \in \para{C~x\st_0 \dots x\st_n}\\
\Eqv{\law{$\para{\hole}$-Def}}&
	C~(x\st_0 \reuzestar y_0) \dots (x\st_n \reuzestar y_n) \in  \setof{ C~x_0 \dots x_n}{x_0 \in \para{x\st_0} \land \dots  \land x_n \in \para{x\st_n}} \\
\Eqv{property of set comprehension}&
	x\st_0 \reuzestar y_0 \in \para{x\st_0} \land \dots \land x\st_n \reuzestar y_n \in \para{x\st_n}\\
\Eqv{Induction Hypothesis}&
	\true\\
\end{Prf}

{\bf case} $x\st = C~x\st_0 \dots x\st_n$ and $y = C'~y_0 \dots y_m$, with $C \neq C'$\\
\begin{Prf}&
	C~x\st_0 \dots x\st_n \reuzestar C'~y_0 \dots y_m \in \para{C~x\st_0 \dots x\st_n}\\
\Eqv{\law{$\reuzestar$-Def}}&
	\default (C~x\st_0 \dots x\st_n) \in \para{C~x\st_0 \dots x\st_n}\\
\Eqv{\law{$\default$-Valid}}&
	\true\\
\end{Prf}
\end{proof}


\head{Idempotency}

Similar to validity, we prove idempotency by proving a more general statement on $T\st$.
%\xprlab{\eqclass{y}{\eqstar} = \eqclass{x}{\eqstar} ~\imp~ \eqclass{x}{\eqstar} \reuz y = y}	{$\reuz$-Idem} 

\begin{Prf}&
	\eqclass{y}{\eqstar} = \eqclass{x}{\eqstar} ~\imp~ \eqclass{x}{\eqstar} \reuz y = y\\
\Eqv{\law{$\eqhole$-Member}}&
	y \in \eqclass{x}{\eqstar} ~\imp~ \eqclass{x}{\eqstar} \reuz y = y\\
\Eqv{\law{Restrict} and def}&
	y \in \para{ \core~x} ~\imp~ \core~x \reuzestar y = y\\
\FFr{taking  $\core~x$ for $x\st$}&
	y \in \para{x\st} ~\imp~ x\st \reuzestar y = y\\
\end{Prf}

The more general statement

$y \in \para{x\st} ~\imp~ x\st \reuzestar y = y$

is proven by structural induction on $x\st$:

\begin{proof}
{\bf case} $x\st = \texttt{*}_T$:\\
\begin{Prf}&
	y \in \para{\texttt{*}_T} ~\imp~ {\texttt{*}_T \reuzestar y = y}\\
\FFr{propositional calculus}&
	\texttt{*}_T \reuzestar y = y\\
\Eqv{\law{$\reuzestar$-Def}}&
	\true\\
\end{Prf}

{\bf case} $x\st = C~x\st_0 \dots x\st_n$ and $y = C~y_0 \dots y_n$\\
The induction hypothesis is 
$y^i \in \para{x\st_i} ~\imp~  x\st_i \reuzestar y_i = y_i$\\
\begin{Prf}&
	x\st \reuzestar y = y\\
\Eqv{definitions of $x\st$ and $y$}&
	C~x\st_0 \dots x\st_n \reuzestar C~y_0 \dots y_n = C~y_0 \dots y_n\\
\Eqv{\law{$\reuzestar$-Def}}&
	C~(x\st_0 \reuzestar y_0) \dots (x\st_n  \reuzestar y_n) = C~y_0 \dots y_n\\
\Ffr{$n$ times Leibniz)}&
	x\st_0 \reuzestar y_0 = y_0  \land \dots \land  x\st_n \reuzestar y_n = y_n\\
\Eqv{Induction Hypothesis}&
	y_0 \in \para{x\st_0} \land \dots \land y^n \in \para{x\st_n}\\
\Ffr{property of set comprehension}&
	C~y_0 \dots y_n \in \setof{ C~x_0 \dots x_n}{x_0 \in \para{x\st_0} \land \dots  \land x_n \in \para{x\st_n}}\\
\Eqv{\law{$\para{\hole}$-Def}}&
	C~y_0 \dots y_n \in \para{C~x\st_0 \dots x\st_n}\\
\Eqv{definitions of $x$ and $y$}&
	y \in \para{x\st}\\
\end{Prf}\todo{Leibniz step okay?}

{\bf case} $x\st = C~x\st_0 \dots x\st_n$ and $y = C'~y_0 \dots y_m$, with $C \neq C'$\\

This case does not occur, since the assumption $y \in \para{x\st}$ implies $C \equ C'$:


\begin{Prf}&
	y \in \para{x\st}\\
\Eqv{definitions of $x\st$ and $y$}&
	C'~y_0 \dots y_m \in \para{C~x\st_0 \dots x\st_n}\\
\Eqv{\law{$\para{\hole}$-Def}}&
	C'~y_0 \dots y_m \in \setof{ C~x_0 \dots x_n}{x_0 \in \para{x\st_0} \land \dots  \land x_n \in \para{x\st_n}}\\
\Eqv{property of set comprehension}&
	C' \equ C\\
\end{Prf}
\end{proof}


\head{Closeness}

For the requirement \law{$\reuz$-Close}, we cannot give a formal proof because we have no formal description of closeness. In fact, our first  definition of $\reuzestar$ based on structure only does not guarantee much closeness after a structural update.

Consider an expression editor with whitespace in extra state. If \verb|1+2| is updated to \verb|1*2|, then $\reuzestar$ will fail to recover the white space, because of the structural difference between the sum and the product. As a result, the default whitespace is chosen for the product, as well as for its children. Because of the structural similarity between sums and products, it can be argued that a product with white space copied from the sum is closer to the original sum than a product with default whitespace. The next section sketches a $\reuzestar$ function that can handle structural updates.


\subsection{Improving reuse} \label{subsect:reuseid}

A reuse strategy based only on the structure of the old and new level values cannot recover extra state when the level is structurally changed. In this section we sketch a more advanced reuse strategy that is based on identities of parent nodes of extra state.

If tree nodes have identities that are preserved by edit operations, an extra state child of a node can be recovered by looking up its value in the old tree. A definition of the new reuse function is:



\xpr{
\reuzestar ::  T^* \to Level \to T\\
C_{id}~x^*_0 \dots x^*_n ~\reuzestar~ y = C_{id}~x'_0 \dots x'_n\\
~\textbf{where}~x'_i = \left\{
\begin{array}{lll}
x^*_i ~\reuzestar~ y	& \textbf{if}~x^*_i \neq \texttt{*}_{t}\\
y_i  				& \textbf{if}~\fn{lookup}~id~y = C~y_0 \dots y_n \\
y_j  				& \textbf{if}~\fn{lookup}~id~y = C'~y_0 \dots y_n \land C \neq C' \\
				& ~~~~ \exists j : y_j~\text{``is similar to''}~x_i\\
\default~(C~x^*_0 \dots x^*_n) & \textbf{otherwise}
\end{array}\right.
}

In contrast to $\reuzestar$ from Section~\ref{sect:defReuse}, this $\reuzestar$ only recurses on its first argument. The second argument $y$ is the previous value of the root of the level, from which a previous value of a node can be looked up based on its identity. In the definition, there are four cases for $x'_i$. The first case is when $x_i$ is not an extra state value, and its result is the recursive application of $\reuzestar$.

If $x_i$ is extra state, then $\fn{lookup}~id~y$ is used to obtain the previous value of its parent. If the lookup succeeds and the previous value has the same constructor ($C$), then all extra state children can be copied from the previous value. This consitutes the second case of the definition.

% Unlike $\reuzestar$ from Section~\ref{sect:defReuse},

If the lookup returns a parent with a different constructor $C'$, it may still be possible to recover its previous value, provided that $C'~y_0 \dots y_n$ has a child that represents the same information as $x_i$. This is expressed by the phrase \hbox{``is~similar~to''} in the third case of the definition. An example illustrates this case.

Consider an expression editor with an edit operation that transforms a sum into a product. Both sums and products have an extra state child that represents the whitespace in the presentation. For the application $({\tt Product}_{id_0}*~e_1~e_2) \reuzestar y$, we have  $\fn{lookup}~id_0~y =~{\tt Sum}_{id_0}~extra_0~e_1~e_2 $, in which $extra_0$ represents the whitespace. It makes sense to reuse the whitespace from the old sum, because of the similarity between the presentation of the sum and the product. Hence, the third case applies, and we have $j=0$, yielding the final result is ${\tt Product}_{id_0}~extra_0~e_1~e_2$.

The last case of the definition applies if the extra state from the old value cannot be reused or if lookup fails. In that case, extra state is set to a default value.

Note that since the recursion is only on the first argument, the type is slightly different from the reuse function from Section~\ref{subsect:wildreuse}, which is $\reuzestar ::  T^* \to T \to T$. However, for the application on the root of the level, $T$ is equal to $Level$, yielding the type $\reuzestar \tp Level^* \to Level \to Level$.


The $\reuzestar$ from this section is able to reuse extra state after a structural update, such as moving a subtree or deleting from a list. Moreover, it also allows reuse when a node is updated to a similar node that has the same kind of extra state. However, it does require that editing preserves node identities. 
%\note{emphasize that details are left to implementation}
%The details concerning this case are left to the implementation of the layer since they depend heavily on the specific
% editor instance. 

%
%Whitespace always str. similar, no prob. Sum/Product. has to be specd by editor designer. 
%Sometimes makes no sense. Then es gets lost.



%\subsection{Conclusions?}
%
%

% need better reuzestar





%																
%																
%																
\section{A combined layer}  \label{sect:combinedExtra}

\todo{split rather than combine?}
In order to describe the architecture of Proxima, we need to refine the single layer model of the previous sections to accommodate multiple layers. Rather than considering all layers at once, we look at a combined layer that consists of an upper and a lower layer with a medium data level in between. Each layer of the composition may have presentation as well as interpretation extra state, which together determine the extra state for the combination. 

The upper layer may be a combined layer itself, whereas the lower layer is a single layer, such as specified in the previous section. This difference does not become important until Section~\ref{sect:defCombPres}, which also explains why the upper rather than the lower layer may be a combined layer.

It turns out that the condition that the upper and lower layer both meet the requirements, is not sufficient to guarantee that the combination also meets the requirements. Hence, the combination establishes extra requirements on its components, to ensure that they match.

%Specification is also for middle level, even though you don't see it if you combine a  combined layer. 
%in imp. we have to plumb middle levels around, but not in spec.


% say this?
%\bl
%\o we want: H M L \{pres inv, interpresent, update \rarr new H'' M'' L'' close, bla\}
%\o we have H M and M L  \{pres inv,  interpresent, update \rarr new H'' M'' L'' close, bla\}
%\el


%Not here: (but maybe elsewhere)
%\bl
%\o ES in middle level that is presented on lower will be ES there too. Same thing for higher.
%\o Are the eq. classes of combined * layers still * eq. classes?
%\el

\subsection{Composing $Present$ and $Interpret$} \label{sect:combinedExtraCompose}

The presentation and interpretation relations for the combined layer are compositions of the relations from the upper and higher relations: % ($Interpret$ and $Present$ are total in left ...)

\xpr{
\Present\C = \Present\L \oo \Present\H\\
\Interpret\C = \Interpret\H \oo\Interpret\L\\
}

In line with the previous sections, we would like to represent the two relations by functions between equivalence classes. However, before we can do so, we need to establish that the composition of two mappings between equivalence classes is a mapping between equivalence classes itself. This turns out not always to be the case, but we can state a requirement on the combination of the two layers to ensure that it is.

First, we take a look at the equivalence relations that play a role in the combination of two layers. Both the upper and lower layer 
define equivalence relations on their respective upper and lower levels. The four relations are apparent in the types of $\present\H$ and $\present\L$:

\xpr{
\present\H   &\tp& \Eqcl{\Level\H}{HH} \rightarrow  \Eqcl{\Level\M}{HL}\\
\present\L    &\tp& \Eqcl{\Level\M}{LH} \rightarrow  \Eqcl{\Level\L}{LL}\\
}

Although the type of the middle level ($\Level\M$) is equal for both layers, the equivalence relations are likely to be different ($HL \neq LH$), because the presentation extra state of the upper layer is most likely different from the interpretation extra state of the lower layer. Hence, we have four relations: $HH$, $HL$, $LH$, and $LL$.

When regarded as a mapping between equivalence classes, the type of $\present\C$ is:

\xpr{
\present\C &\tp& \Eqcl{\Level\H}{CH} \rightarrow  \Eqcl{\Level\L}{CL}\\
}

Again it is likely that the equivalence relations on $\Level\H$ and $\Level\L$ ($CH$ and $CL$) are not equal to the relations defined by the two composing layers ($HH$ and $LL$). Therefore, in total, we have the six equivalence relations that are shown in Figure~\ref{relationsInLayer}.

\begin{figure}
\begin{center} 
\begin{minipage}[t]{.45\textwidth}
 
\begin{array}[b]{l@{}l@{}l@{}l}
\Eqcl{Level\H}{CH}~~~ 	& \Eqcl{Level\H}{HH}~~~	&                    \\
~~~~\,\text{\textbar}& \present\H 			&	\\
\present\C 				& \Eqcl{Level\M}{HL}		& \Eqcl{Level\M}{LH} 	\\
~~~~\text{\textdownarrow} &						& \present\L	\\
\Eqcl{Level\L}{CL} 		&				 		& \Eqcl{Level\L}{LL} \\
\end{array} 
\end{minipage}
\end{center}
\caption{Equivalence relations in a combined layer. (draft)} \label{relationsInLayer} 
\end{figure}



%\xpr{
%\Eqcl{\Level\H}{CH}	&\quad& ~\Eqcl{\Level\H}{HH}	&\quad&                   \\
%					&& \qquad \text{\textdownarrow}\\
%\qquad \text{\textdownarrow}&& ~\Eqcl{\Level\M}{HL}	&& ~\Eqcl{\Level\M}{LH} \\
%					&&					&& \qquad \text{\textdownarrow}\\
%\Eqcl{\Level\L}{CL}	&&					&& ~\Eqcl{\Level\L}{LL}\\
%
%}

A simple example shows that equivalence relations on one level can be different. Consider two $\present$ functions with the types written in the wildcard style from Section~\ref{sect:wildcardEq}.

\xpr{
\present\H \tp (Int, Int) \to (Int,Int)~~~~ 	& \present\L \tp (Int, *_{Int}) \to (Int,Int)\\
\present\H (x,y) = (x,y) 					& \present\L (x,y) = (x)\\
}

The equivalence relation $LH$ for the result of $\present\L$ is $(Int,*_{Int})$, whereas $HL$ is $(Int, Int)$. Furthermore, because $\present\H$ is the identity, the composition is equal to $\present\L$, and hence $CH$ is $(Int,*_{Int})$, which is different from $HH$. Similar examples can be constructed to show different $CL$ and $LL$ relations.

We wish to define $\present\C$ and $\interpret\C$ as:

\xprlab{
\eqcl{l}{CL} = \present\C~\eqcl{h}{CH} & ~\eqv~ & \exists m :~
			& \eqcl{l}{LL}	& = \present\L~\eqcl{m}{LH}\\
 & &~~\land	& \eqcl{m}{HL}	& = \present\H~\eqcl{h}{HH}
}{$\present\C$-Def}

\xprlab{
\interpret\C~\eqcl{l}{CL} & ~\eqv~ & \exists m :~
			& \eqcl{h}{HH} & = \interpret\H~\eqcl{m}{HL}\\
 & &~~\land	& \eqcl{m}{LH} & = \interpret\L~\eqcl{l}{LL}
}{$\interpret\C$-Def}

Or, equivalently, in point-free style using Kleisli composition on sets:

\xpr{
\present\C \equ (\present\L \oo \eqcl{\hole}{LH}) \klei  (\present\H \oo \eqcl{\hole}{HH})\\
\interpret\C \equ (\interpret\H  \oo \eqcl{\hole}{HL}) \klei  (\interpret\L  \oo \eqcl{\hole}{LL})
}


Unfortunately, it turns out that a composition of two mappings between equivalence classes is itself not always a mapping between equivalence classes, in which case the two definitions are not valid. A simple example shows this fact. Consider the following $\present\H$ and $\present\L$, both of which meet the requirements of the previous section.

\xpr{
\present\H \tp Int \to (Int,Int)	&				& \present\L \tp (*_{Int},Int) \to Int\\
\present\H\ x\ = (x,x)   		& \hspace{1cm}	& \present\L\ (*_{Int},y) = y\\
\interpret\H \tp (Int,Int) \to Int	&				& \interpret\L \tp Int \to (*_{Int},Int) \\
\interpret\H\ (x,y) = x 			&				& \interpret\L\ y = (*_{Int},y)\\
}

\bc
We can derive that $\eqcl{0}{CH} = \eqcl{1}{CH}$:

\begin{Prf}&
	\eqcl{0}{CH} = \eqcl{1}{CH}\\
\Ffr{transitivity of $=$} &
	\eqcl{0}{CH} = \interpret\C~\eqcl{0}{CL} \land \eqcl{1}{CH} = \interpret\C~\eqcl{0}{CL}\\
\Ffr{$\interpret\C$-Def}&
	\eqcl{0}{HH} = \interpret\H~\eqcl{(0,0)}{HL} \land \eqcl{(0,0)}{LH} = \interpret\L~\eqcl{0}{LL} \land \\
&	\eqcl{1}{HH} = \interpret\H~\eqcl{(1,0)}{HL} \land \eqcl{(1,0)}{LH} = \interpret\L~\eqcl{0}{LL} \land \\
\Ffr{definitions of $\interpret\H$ and $\interpret\L$} &
	\true\\
\end{Prf}

Furthermore, because $\eqcl{0}{CL} = \present\C~\eqcl{0}{CH}$ (take $m = (0,0)$) we must also have 
$\eqcl{0}{CL} = \present\C~\eqcl{1}{CH}$. Hence, there must exist an $m$ such that  
$\eqcl{0}{LL} = \present\L~\eqcl{m}{LH}$ and $\eqcl{m}{HL} = \present\H~\eqcl{0}{HH}$. However, the latter is clearly not the case, since the only higher layer presentation of $1$ is $(1,1)$, which has lower layer presentation $1$, and not $0$.
\ec

By taking $(0,0)$ and $(1,0)$ for the middle level $m$, we have: $\eqcl{0}{CH} = \interpret\C~\eqcl{0}{CL}$ and $\eqcl{1}{CH} = \interpret\C~\eqcl{0}{CL}$, which implies $\eqcl{0}{CH} = \eqcl{1}{CH}$. And since  $\eqcl{0}{CL} = \present\C~\eqcl{0}{CH}$ (take $m = (0,0)$) we must also have $\eqcl{0}{CL} = \present\C~\eqcl{1}{CH}$. However, the latter is clearly not the case, since the only higher-layer presentation of $1$ is $(1,1)$, which has lower-layer presentation $1$, and not $0$.

%\xpr{
%%\eqcl{0}{HH} = \interpret\H~\eqcl{(0,0)}{HL} \land \eqcl{(0,0)}{LH} = \interpret\L~\eqcl{0}{LL}\\
%\eqcl{0}{CH} = \interpret\C~\eqcl{0}{CL}\\
%%\eqcl{1}{HH} = \interpret\H~\eqcl{(1,0)}{HL} \land \eqcl{(1,0)}{LH} = \interpret\L~\eqcl{0}{LL}\\
%\eqcl{0}{CH} = \interpret\C~\eqcl{0}{CL}\\ and \eqcl{1}{CH} = \interpret\C~\eqcl{0}{CL}\\
%\imp~\eqcl{0}{CH} = \eqcl{1}{CH}\\ 
%}


%We have:
%\xpr{
%\eqcl{0}{HH} = \interpret\H~\eqcl{(0,0)}{HL} \land \eqcl{(0,0)}{LH} = \interpret\L~\eqcl{0}{LL}\\
%\eqcl{0}{CH} = \interpret\C~\eqcl{0}{CL}\\
%\eqcl{1}{HH} = \interpret\H~\eqcl{(1,0)}{HL} \land \eqcl{(1,0)}{LH} = \interpret\L~\eqcl{0}{LL}\\
%\eqcl{1}{CH} = \interpret\C~\eqcl{0}{CL}\\
%\imp~\eqcl{0}{CH} = \eqcl{1}{CH}\\ 
%\eqcl{0}{LL} = \present\L~\eqcl{(0,0)}{LH} \land \eqcl{(0,0)}{HL} = \present\H~\eqcl{0}{HH}\\
%\eqcl{1}{CL} = \present\C~\eqcl{h}{CH}\\
%\eqcl{1}{LL} = \present\L~\eqcl{m}{LH} \land \eqcl{m}{HL} = \present\H~\eqcl{0}{HH}\\
%\eqcl{1}{LL} = \present\L~\eqcl{(1,1)}{LH} \land \eqcl{(0,\texttt{*})}{HL} = \present\H~\eqcl{0}{HH}\\
%}




\bc


\head{Are classes okay?}

Before we can say we have $\present\C$ and $\interpret\C$, we need to establish that the combined relations work on equivalence classes.
\bl
\o both defs, final class is union of eq. classes. 
\o Are classes from def disjoint? Should be, otherwise no eq. class. 
\o classes can be merged, so still equivalence classes (not star classes, but not req. as long as $\reuz$ is not used on these classes)
\o when doesn't this happen?
\el

Unclear:
\bl
\o What are requirements on classes. upper are equal? lower pres $\leq$ lower intr?
\o Which of these reqs are implied by interpresent?
\o if no longer works, then interpresent also fails, so if we have interpresent for combination, then classes are okay? 
\o How do we know that classes did not get to big?
\el

Maybe also add that combined classes are unions of component classes.

Maybe say something about invalid l's. They don't imply a class in CL, but we do have to be sure that classes in LL coming from Present L (and maybe interpretL) do not interfere with CL classes.

see appendix
\ec

In order for \law{$\present\C$-Def} and \law{$\interpret\C$-Def} to be valid, $\Present\C$ and $\Interpret\C$ must induce equivalence classes on $Level\H$ and $Level\L$. Moreover, the equivalence classes that are induced by $\Present\C$ must be equal to the classes induced by $\Interpret\C$. Because on the lower level, $\Present\C$ only induces equivalence classes on the valid part, the classes of $\present\C$ and $\Interpret\C$ only need to be equal on the valid part.

Without showing the details of their origin, we introduce two conditions that guarantee that the relations induce equivalence classes as well as that these equivalence classes are equal. First, we define an auxiliary function $\mathcal{I}$. The application $\mathcal{I}~m$ denotes the set of all higher-level elements onto which the members of the $LH$ equivalence class of $m$ can be interpreted.



% definition is valid iff eq classes exist and are equal (only on valid for lower level)
%\bl
%\o We need to know that classes are okay and that $Interpret$ is total, etc (for all assumptions not enforced by %\law{InterPresent}
%\o Then we can model these relations as functions between classes.
%\el
%
%Varying $h$ must end up in same lower set. varying $m$ must end up in same lower set.
%similar for \interpret. Sum both must be equal.



\xprlab{
\mathcal{I} \tp Level\M \tp \powerset~Level\H \\
\mathcal{I}~m = \setof{h}{\exists m' \in \eqcl{m}{LH} : \eqcl{h}{HH} = \interpret\H~\eqcl{m'}{HL} }
}{$\mathcal{I}$-Def}

The two conditions are:

\xprlab{
h,h' \in \mathcal{I}~m \land \eqcl{m'}{HL}= \present\H~\eqcl{h}{HH}  \imp\\
\exists m'' \in \eqcl{m'}{LH} : \eqcl{m''}{HL} = \present\H~\eqcl{h'}{HH} \\
}{$\present$-Match}

and

\xprlab{
h,h' \in \mathcal{I}~m \land  \eqcl{h}{HH} = \interpret\H~\eqcl{m'}{HL} \imp\\
\exists m'' \in \eqcl{m'}{LH} : \eqcl{h'}{HH} = \interpret\H~\eqcl{m''}{HL} \\
}{$\interpret$-Match}

If {$\present$-Match} and {$\interpret$-Match} hold, then \law{$\present\C$-Def} and \law{$\interpret\C$-Def} are valid definitions. \note{probably it is if and only if, but I'm not entirely sure about that}

%\head{Presentation invariant}
%
%Presentation invariant for combination $\level\L~\Present\C~ \level\H$ or
% $\eqcl{l}{CL} = \present\C \eqcl{h}{CH}$ is equivalent to:
%
%\xprlab{
%\eqcl{\level\L}{CL} = \setof{l}{h \in \eqcl{\level\H}{CH} \land \exists m : \eqcl{l}{LL} = \present\L~\eqcl{m}{LH} \and %\eqcl{m}{HL} = \present\H~\eqcl{h}{HH}}\\
%}{Present}
%
%Which implies there is a $\level\M$ such that \law{Present} holds between $\level\H$ and $\level\M$, as well as between %$\level\M$ and $\level\L$:
%
%\xpr{
%%l \in \eqcl{\level\L}{CL} \imp \exists m,h : \eqcl{l}{LL} = \present\L~\eqcl{m0}{LH} \land %\eqcl{m}{HL} = %\present\H~\eqcl{h}{HH} \land h \in \eqcl{\level\H}{CH} ??
%\exists \level\M : \eqcl{\level\L}{LL} = \present\L~\eqcl{\level\M}{LH} \land \eqcl{\level\M}{HL} = %\present\H~\eqcl{\level\H}{HH}
%}


\subsection{InterPresent}

The \law{InterPresent} property holds for a combination if it holds for the upper and lower layer.

\xprlab{\eqcl{l}{CL} = \present\C~\eqcl{h}{CH} ~\imp~ \eqcl{h}{CH} = \interpret\C~\eqcl{l}{CL}}{InterPresent}

The proof is simple:

\begin{Prf}&
	\eqcl{l}{CL} = \present\C~\eqcl{h}{CH}\\
\Eqv{ \law{$\present\C$-Def}}& 
	\exists m : \eqcl{l}{LL} = \present\L~\eqcl{m}{LH} \land \eqcl{m}{HL} = \present\H~\eqcl{h}{HH}\\
\Imp{ \law{InterPresent} for higher and lower layers}&
	\exists m : \eqcl{m}{LH} = \interpret\L~\eqcl{l}{LL} \land \eqcl{h}{HH} = \interpret\H~\eqcl{m}{HL}\\ 
\Eqv{ \law{$\interpret\C$-Def}}&
	\eqcl{h}{CH} = \interpret\C~\eqcl{l}{CL}\\
\end{Prf}



\subsection{An inductive definition of $\present\C$ and $\interpret\C$} \label{sect:defCombPres}

In this section, we give the inductive definition for the presentation and interpretation functions of an editor consisting of $n$ layers.  The building blocks of the combination are $n+1$ data levels and $n$ pairs of presentation and interpretation functions and corresponding equivalence relations:

\xpr{
\present_i   &\tp& \Eqcl{\Level_i}{H_i} \rightarrow  \Eqcl{\Level_{i+1}}{L_i}\\
\interpret_i &\tp& \Eqcl{\Level_{i+1}}{L_i} \rightarrow \Eqcl{\Level_i}{H_i}\\
}

Because $Level_0$ is the document and $Level_n$ the presentation, the top layer consists of  $\present_1$ and $\interpret_1$, whereas the lowest layer consists of $\present_{n}$ and $\interpret_{n}$. A combined layer consists of two combined functions: $\present_{\mathrm{C},i}$ and $\interpret_{\mathrm{C},i}$.

Layers are combined in a ``top-associative'' way; a combined layer is formed by taking a smaller combined layer, and putting a  single atomic layer underneath it. The reason for this choice stems from the order in which the updated lower level is computed. If we abuse the notation for function composition to denote the composition of layer functions, we can sketch the computation:

\bc When the lowest level is updated, it is first interpreted by the lower layer yielding an intermediate middle level, the intermediate level is then interpreted and subsequently presented by the layers above, after which the result from these layers is presented by the lower layer. \ec
%The process can be sketched as follows:

$(\present_{n} \oo \present_{n-1} \oo \cdots \present_1 \oo \interpret_1 \oo \cdots \oo \interpret_{n-1}\oo \interpret_{n})$

The most logical way to split this computation is by taking the middle part $(\present_{n-1} \oo \cdots \oo \interpret_{n-1})$ and surrounding it with $\present_{n}$ and $\interpret_{n}$. This corresponds to taking a combined layer and putting an atomic layer underneath. 



\begin{figure}[h]
  \hfill
  \begin{minipage}[t]{.45\textwidth}
    \begin{center}  
\begin{footnotesize}
\begin{array}[b]{l@{}l@{}l@{}l}
\Eqcl{Level\H}{CH}~~~ 	& \Eqcl{Level\H}{HH}~~~	&                    \\
~~~~\,\!\text{\textbar}		& \present\H 				&	\\
\present\C 				& \Eqcl{Level\M}{HL}		& \Eqcl{Level\M}{LH} 	\\
~~~~\text{\textdownarrow}&						& \present\L	\\
\Eqcl{Level\L}{CL} 		&				 		& \Eqcl{Level\L}{LL} \\
\end{array} 
\end{footnotesize}
%      \epsfig{file=pics/eps/singleToMulti2.eps, width = 60mm}\\ \vspace{0.765cm}
%      \caption{A combined layer} \label{relativeLayer}
    \end{center}
  \end{minipage}
  \hfill
  \begin{minipage}[t]{.45\textwidth}
    \begin{center}  
\begin{footnotesize}
\begin{array}[b]{l@{}l@{}l@{}l}
\Eqcl{Level_0}{CH_i} 			& \Eqcl{Level_0}{CH_{i-1}}			&    \\
~~~~\,\!\text{\textbar}		& \present_{\mathrm{C},{i-1}}~~~~&	\\
\present_{\mathrm{C},{i}} ~~~~& \Eqcl{Level_{i-1}}{CL_{i-1}} 	& \Eqcl{Level_{i-1}}{H_i} \\
~~~~\text{\textdownarrow}	&								& \present_i	\\
\Eqcl{Level_{i}}{CL	_i}		&	 							& \Eqcl{Level_{i}}{L_i} \\

%Level_0: 		&  CH_i 		& CH_{i-1} 	&                    \\
% 			&   			& \present_{\mathrm{C},{i-1}} ~~&	\\
%Level_{i-1}:~~& \present_{\mathrm{C},{i}} ~~	& CL_{i-1} 	 & H_i 	\\
%		 	&   			&		& \present_i	\\
%Level_{i}: 	& CL	_i		& 		& L_i \\
\end{array} 
\end{footnotesize}
%      \epsfig{file=pics/eps/singleToMulti1.eps, width = 60mm}
%      \caption{An indexed combined layer.} \label{indexedLayer}
    \end{center}
  \end{minipage}
  \hfill
\caption{Indices in a combined layer. (draft)} \label{indicesInLayer} 
\end{figure}



Figure~\ref{indicesInLayer} shows an overview of the levels, $\present$ functions, and equivalence relations that appear in a combined layer. The left-hand side shows the view from Figure~{relationsInLayer} with relative subscripts H, M, and L, whereas the right-hand side shows the inductively defined versions with numbered subscripts. The figure does not show $\interpret$  because it is similar to $\present$.

In a combined layer, there are six equivalence relations. The two equivalence relations that are induced by the combined layer are $CH_i$ and $CL_i$. The upper layer is the combination of the first $i-1$ layers, and hence its equivalence relations are $CH_{i-1}$ and $CH_{i-1}$. For the lower layer, the equivalence relations are the $H_i$ and $L_i$ relations that are associated with $\present_i$ and $\interpret_i$. 


\bc
Besides the levels and the mapping functions, also the equivalence relations at each layer get indices. The two equivalence relations that are established by the combined layer are $CH_i$ and $CL_i$. Since the upper layer is the combination of the first $i-1$ layers, its equivalence relations are $CH_{i-1}$ and $CH_{i-1}$. For the lower layer, the equivalence relations are the $H_i$ and $L_i$ relations that are associated with $\present_i$ and $\interpret_i$. 
\ec

The inductive definition of $\present_{\mathrm{C},i}$ is right-associative, whereas $\interpret_{\mathrm{C},i}$ is left-associative. The reason for this difference is that in the computation, the order of the $\present_i$ functions is the reverse of the order of the $\interpret_i$ functions. The basis for both definitions is $\id$. In the definition, we use the point-free style for the combined functions:

\xpr{
\present_{\mathrm{C},i} \tp \Eqcl{Level_0}{CH_i} \to \Eqcl{Level_{i}}{CL_i}\\
\present_{\mathrm{C},0} = \id\\
\present_{\mathrm{C},i} = (\present_{i} \oo \eqcl{\hole}{H_i}) \klei (\present_{\mathrm{C},i-1} \oo \eqcl{\hole}{{CH_{i-1}}})\\
}

\xpr{
\interpret_{\mathrm{C},i} \tp \Eqcl{Level_0}{CH_i} \to \Eqcl{Level_{i}}{CL_i}\\
\interpret_{\mathrm{C},0} = \id\\
\interpret_{\mathrm{C},i} =  (\interpret_{\mathrm{C},i-1}  \oo \eqcl{\hole}{CL_{i-1}}) \klei  (\interpret_{\mathrm{C},i-1} \oo \eqcl{\hole}{L_i})
}

The equivalence relations for the basis ($H_0$ and $L_0$) both are the equality relation ($=$). The reason for this is that the presentation function at the basis ($\present_0$) is the identity, which leaves no room for extra state since each element in $Level_0$ is mapped onto itself. Hence, the equivalence class for each element is the singleton set containing that element. The equality relation establishes exactly these singleton equivalence classes.

Because indices make proofs harder to read, and because at any time we only regard two layers and three levels, we use the notation from the left-hand side of Figure~\ref{indicesInLayer} in the rest of this section.

\bc
In a composition of $n$ presentation functions ($\present_n \oo \present_{n-1} \oo \cdots \oo \present_0$), the presentation function of the lowest layer is at the left. Hence, the definition of $present\C$ is right-associative. On the other hand, $interpret\C$, gets a left-associative definition, because the component from the lowest layer is at the right of the composition ($\interpret_0 \oo \interpret_1 \oo \cdots \oo \interpret_n$).
\ec


\bc
For the equivalence relations we denote $CH_i$, $CL_i$, $CH_{i-1}$, $CH_{i-1}$, $H_i$, and $L_i$ by $CH$, $CL$, $HH$, $HL$, $LH$, and $LL$. Figure~\ref{relativeLayer} shows what Figure~\ref{indexedLayer} looks like when using the short-hand notation. 
\note{mention that for levels $h$ stands for $0$, whereas for rels and mapping fns it stands for $i-1$?}
%Note that this means that for functions the H subscript stands for $n-1$ and not for $0$. Same thing holds for $\interpret$.
\note{mention that shorthand is not used for basis}
\ec






\subsection{Editing} \label{sect:combinedExtraEditing}

Besides $level\H$ and $level\L$, a combined layer also keeps track of the middle level $level\M$. Before an edit operation takes place we know that $\eqcl{Level\L}{CL} = present\C \eqcl{Level\H}{CH}$. By \law{$\present\C$-Def}, this implies there exists a middle level $m$ that is in the presentation of $level\H$ and that has $\level\L$ in its presentation. Although not explicitly denoted, we assume that $level\M$ is this $m$. 



\begin{figure}
\begin{small}
\begin{center}
\begin{center}
\epsfig{file=pics/eps/LayerCombined.eps, height=2in} % visio: Layer.vsd
\end{center}\caption{Single edit step in a combined layer.} \label{combinedEdit}
\end{center}
\end{small}
\end{figure}

%\begin{figure}
%\xpr{
%level\H 		&   			& level'\H 	&~\rightarrow~& level''\H\\
%~~~\downarrow&   		&~~~\uparrow&			&~~~\downarrow \\
%level\M 		&   			& level'\M 	& 			& level''\M\\
%~~~\downarrow 	&   		&~~~\uparrow&			&~~~\downarrow \\
%level\L 		&~\leadsto~& level'\L 	& 			& level''\L\\
%} \caption{Single edit step in a combined layer. (draft)} \label{combinedEdit}
%\end{figure}

Before the lower level is updated, we have:

\xpr{
\eqcl{\level\L}{LL} = \present\L~\eqcl{\level\M}{LH} ~\land~
\eqcl{\level\M}{HL} = \present\H~\eqcl{\level\H}{HH}\\
\level\L \leadsto \level'\L 
}

After the lower-level update, the lower layer computes an intermediate value $\level'\M$, from which the higher layer (which may be a combined layer itself) computes $\level'\H$. At the top, $\level'\H$ is assigned to $\level''\H$, which is subsequently presented onto $level''\M$. Finally, $level''\M$ presented onto $level''\L$. Figure~\ref{combinedEdit} sketches the updates to the various data levels.
\todo{explain a bit about what present and interpret in the figure mean} Just a sketch, pres and int need appl. of reuse. also H functions may be combined


Apart from a few changes to the subscripts, the requirements for $level''\H$ and $level''\L$ are equal to the requirements for the single layer editor in Section~\ref{sect:singleExtra_Editing}. The only difference is that we explicitly added the precondition of the edit step ($\eqcl{\level\L}{CL} = \present\C~\eqcl{\level\H}{CH}$) to the precondition of to the precondition of \law{Doc-Inert}. We need it here, because \law{Doc-Inert} can only hold if the middle level is a valid presentation of $\level\H$. 

\xprlab{\hoare{\true} {Comp} { \eqcl{\level''\L}{CL} = \present\C~\eqcl{\level''\H}{CH} } }		{Postcondition}
%\xprlab{\hoare{\eqcl{\level\L}{L} = \present\C~\eqcl{\level\H}{H} \land \eqcl{\level'\L}{CL} = %\present\C~\eqcl{\level\H}{CH}} {Comp} { \level\H = \level''\H}}  {Doc-Inert}
\xprlab{ 
\left\{ \begin{array}{l}
 \eqcl{\level\L}{CL} = \present\C~\eqcl{\level\H}{CH} \land\\
 \eqcl{\level'\L}{CL} = \present\C~\eqcl{\level\H}{CH}
\end{array}\right\}
{Comp} \{ \level\H = \level''\H\} }  {Doc-Inert}
\xprlab{\hoare{\eqcl{\level'\L}{CL} = \present\C~\eqcl{h}{CH}} {Comp} { \level'\L = \level''\L}}		{Pres-Inert}
\xprlab{\hoare{\true} {Comp} {\level\H \close \level''\H}}	{Doc-Preserve}
\xprlab{\hoare{\true} {Comp} {\level'\L \close \level''\L}}	{Imprecise}

\head{Definition of $Comp$}

The inductive definition of $Comp$ reads:

\xprlab{
Comp_0 \is 	& \level''\H \gets \level'\H\\
Comp_n \is 	& Up \semi Comp_{n-1} \semi Dwn}{$Comp$-Def}
\xprlab{
Up \is		& \level'\M \gets \interpret\L~ \eqcl{\level'\L}{LL}  ~\reuze{LH}~   \level\M}{$Up$-Def}
\xprlab{
Dwn \is		& \level''\L \gets \present\L~ \eqcl{\level''\M}{LH}   ~\reuze{LL}~   \level'\L}{$Dwn$-Def}

We prove that $Comp$ meets the requirements.


\subsection{\law{Postcondition} requirement}

In \fn{wp} notation, the \law{Postcondition} is:

\xprlab{\true ~\imp~ \wp{Comp_n}{\eqcl{\level''\L}{CL} = \present\C~\eqcl{\level''\H}{CH}}} {Postcondition}


\begin{proof} We prove the requirement by induction over the number of layers $n$. 

{\bf Case~} $n=0$

Filling in the base cases for $present\C$, the data levels, and relations $CH$ and $CL$ yields:

\xpr{\true ~\imp~ \wp{Comp}{\eqcl{\level''_0}{=} = \id~\eqcl{\level''_0}{=}}}

which holds because it is equivalent to $\true ~\imp~ \wp{Comp}{\true}$.

{\bf Case~} $n>0$

%\eqcl{l}{CL} = \present\C~\eqcl{h}{CH} & ~\eqv~ & \exists m :~
%			& \eqcl{l}{LL}	& = \present\L~\eqcl{m}{LH}\\
% & &~~\land	& \eqcl{m}{HL}	& = \present\H~\eqcl{h}{HH}
The induction hypothesis is:

\xprlab{\true ~\imp~ \wp{Comp_{n-1}}{ \eqcl{\level''\M}{HL} = \present\H~\eqcl{\level''\H}{HH}}} {I.H.}

In the proof, we need the property that the lower presentation of a valid middle level is in the result of the combined presentation:

\xpr{
\eqcl{m}{HL} = \present\H~\eqcl{h}{HH} ~\imp~ \eqcl{\present\L~ \eqcl{m}{LH}   ~\reuze{LL}~   l}{CL} = \present\C~\eqcl{h}{CH} \\
}

It has a simple proof:

\begin{Prf}&
	\eqcl{m}{HL} = \present\H~\eqcl{h}{HH} \\
\Eqv{reflexivity of $=$}&
 	\present\L~ \eqcl{m}{LH} = \present\L~\eqcl{m}{LH} \land
 	\eqcl{m}{HL} = \present\H~\eqcl{h}{HH}\\
\Eqv{\law{$\reuz$-Valid}}&
 	\eqcl{\present\L~ \eqcl{m}{LH}   ~\reuze{LL}~   l}{LL} = \present\L~\eqcl{m}{LH} \land
 	\eqcl{m}{HL} = \present\H~\eqcl{h}{HH}\\
\Imp{let $m' = m$}&
 	\exists m' :\eqcl{\present\L~ \eqcl{m}{LH}   ~\reuze{LL}~   l}{LL} = \present\L~\eqcl{m'}{LH} \land
 	\eqcl{m'}{HL} = \present\H~\eqcl{h}{HH}\\
\Eqv{\law{$\present\C$-Def}}&
	\eqcl{\present\L~ \eqcl{m}{LH}   ~\reuze{LL}~   l}{CL} = \present\C~\eqcl{h}{CH} \\
\end{Prf}


Using this result, we prove \law{Postcondition}.

\begin{Prf}&
	\true\\
\Eqv{\law{\fn{wp}-$\gts$}}&
	\wp{\level'\M \gets \interpret\L~ \eqcl{\level'\L}{LL}  ~\reuze{LH}~   \level\M}{ \true }\\
\Eqv{\law{$Up$-Def}}&
	\wp{Up}{ \true}\\
\Imp{\law{\fn{wp}-Mono} and \law{I.H.}}&
	\wp{Up}{ \wp{ Comp_{n-1}}{  \eqcl{\level''\M}{HL} = \present\H~\eqcl{\level''\H}{HH} }}\\
\Eqv{\law{\fn{wp}-$\smi$}}&
	\wp{Up \semi Comp_{n-1}}{\eqcl{\level''\M}{HL} = \present\H~\eqcl{\level''\H}{HH}} \\
\Imp{\law{\fn{wp}-Mono} and previous result}&
	\wp{Up \semi Comp_{n-1}}{ \eqcl{\present\L~ \eqcl{\level''\M}{LH}   ~\reuze{LL}~   \level'\L}{CL} = \present\C~\eqcl{\level''\H}{CH} }\\
\Eqv{\law{\fn{wp}-$\gts$}}&
	\wp{Up \semi Comp_{n-1}}{ \wp{\level''\L \gets \present\L~ \eqcl{\level''\M}{LH}   ~\reuze{LL}~   \level'\L}{ \eqcl{\level''\L}{CL} = \present\C~\eqcl{\level''\H}{CH} }}\\
\Eqv{\law{$Dwn$-Def}}&
	\wp{Up \semi Comp_{n-1}}{ \wp{Dwn }{ \eqcl{\level''\L}{CL} = \present\C~\eqcl{\level''\H}{CH} }}\\
\Eqv{\law{\fn{wp}-$\smi$}}&
	\wp{Up \semi Comp_{n-1} \semi Dwn}{ \eqcl{\level''\L}{CL} = \present\C~\eqcl{\level''\H}{CH} }\\
\Eqv{\law{$Comp$-Def}}&
	\wp{Comp}{\eqcl{\level''\L}{CL} = \present\C~\eqcl{\level''\H}{CH}}\\
\end{Prf}
\end{proof}






\subsection{\law{Doc-Inert} requirement}

\xprlab{\eqcl{\level\L}{CL} = \present\C~\eqcl{\level\H}{CH} \land \eqcl{\level'\L}{CL} = \present\C~\eqcl{\level\H}{CH} ~\imp\\ \wp{Comp_n}{\level\H = \level''\H}}{Doc-Inert}

Besides the two conditions specified in Section~\ref{sect:combinedExtra}, we need an additional condition for \law{Doc-Inert} to hold. From \law{InterPresent}, we know that if $\level'\L$ is a presentation of $\level\H$, then $\level\H$ is in the interpretation of $\level'\L$. Thus, there exists a middle level $m$ in the interpretation of $\level'\L$, which has $\level\H$ in its interpretation. However, the mere existence of such a middle level does not guarantee that this is the middle level resulting from $Comp$.

The problem lies in the fact that $level'\M$ is selected by $\reuze{LH}$ from an $LH$ class of elements, instead of an $HL$ class. Thus, reusing extra state from $level\M$ could cause $\level'\M$ to end up in an $HL$ class that does not contain $level\M$, which would break \law{Doc-Inert}. We avoid the problem by requiring that the result of $\reuze{LH}$ is in the correct $HL$ class, if possible:

\xprlab{
\eqcl{m'}{HL} = \eqcl{m}{HL} ~\imp~ \eqcl{\eqcl{m'}{LH} \reuze{LH} m}{HL} = \eqcl{m}{HL}}{Orthogonal}

If both $HL$ and $LH$ are described by the wildcard types from Section~\ref{sect:wildcardEq}, \law{Orthogonal} holds.
%\note{prove this?}


%
%\xprlab{
%\eqcl{m'}{HL} = \eqcl{m}{HL} ~\imp~ \eqcl{m'}{LH} \reuze{LH} m \in \eqcl{m}{HL}}{Orthogonal}
%
%
%Different notation:
%\xprlab{
%m'~HL~m ~\imp~ \eqcl{m'}{LH} \reuze{LH} m~HL~m}{Orthogonal}


%\xprlab{\hoare{\eqcl{\level'\M}{HL} = \present\H~\eqcl{\level\H}{H}} {Comp_{n-1}} { \level\H = \level''\H}}{I.H.}

\begin{proof}

The proof of \law{Doc-Inert} is by induction over $n$. 

{\bf Case~} $n=0$

\xpr{\eqcl{\level_0}{=} = \id~\eqcl{\level_0}{=} \land \eqcl{\level'_0}{=} = \id~\eqcl{\level_0}{=} ~\imp~ \wp{Comp_0}{\level_0 = \level''_0}}

%\xpr{\true ~\imp~ \wp{Comp}{\eqcl{\level''_0}{=} = \id~\eqcl{\level''_0}{=}}}

\begin{Prf}&
	\eqcl{\level_0}{=} = \id~\eqcl{\level_0}{=} \land \eqcl{\level'_0}{=} = \id~\eqcl{\level_0}{=}\\
\Eqv{definition of $\id$}&
	\eqcl{\level_0}{=} = \eqcl{\level_0}{=} \land \eqcl{\level'_0}{=} = \eqcl{\level_0}{=}\\
\Imp{\law{$\eqhole$-Member}}&
	\level'_0 \in \eqcl{\level_0}{=}\\
\Imp{property of equivalence class and symmetry of $=$}&
	\level_0 = \level'_0\\
\Eqv{\law{\fn{wp}-$\gts$}}&
	\wp{\level''_0 \gets \level'_0}{\level_0 = \level''_0}\\
\Eqv{\law{$Comp$-Def} and $\Level\H \eqv \Level_0$}&
	\wp{Comp_0}{\level_0 = \level''_0}\\
\end{Prf}


{\bf Case~} $n>0$

For the inductive case, we assume the antecedent of the implication. The first conjunct 
($\eqcl{\level\L}{CL} = \present\C~\eqcl{\level\H}{CH}$) has already been rewritten according to \law{$\present\C$-Def} and the implicit assumption that the middle level between $level\H$ and $\level\L$ is $level\M$:

\xpr{\eqcl{\level\L}{LL} = \present\L~\eqcl{\level\M}{LH} \land \eqcl{\level\M}{HL} = \present\H~\eqcl{\level\H}{HH} \land\\
 \eqcl{\level'\L}{L} = \present\C~\eqcl{\level\H}{H}}


In the proof, we need the existence of an $m_0$ that is in the equivalence class of the interpretation of $\level'\L$ and at the same time in the equivalence class of the presentation of $\level\H$:

\begin{Prf}&
	\eqcl{m_0}{LH} = \interpret\L~\eqcl{\level'\L}{LL} \land \eqcl{m_0}{HL} = \present\H~\eqcl{\level\H}{HH}\\
\FFr{let $m_0$ be the $m$ from the quantification}&
	\exists m : \eqcl{m}{LH} = \interpret\L~\eqcl{level'\L}{LL} \land \eqcl{m}{HL} = \present\H~\eqcl{\level\H}{HH}\\
\Eqv{\law{InterPresent}}&
	\exists m : \eqcl{level'\L}{LL} = \present\L~\eqcl{m}{LH} \land \eqcl{m}{HL} = \present\H~\eqcl{\level\H}{HH}\\
\Eqv{\law{$\present\C$-Def}}&
	\eqcl{level'\L}{CL} = \present\C~\eqcl{\level\H}{CH}\\
\Eqv{assumption}&
	\true\\
\end{Prf} \note{how to call the ``let $m_0$ be the $m$ from the quantification'' step? }
          
%\begin{Prf}&
%	\eqcl{m_0}{HL}\\
%\Equ{$\eqcl{m_0}{HL} = \present\H~\eqcl{\level\H}{HH}$}&
%	\present\H~\eqcl{\level\H}{HH}\\
%\Equ{\law{Present}}&
%	\eqcl{\level\M}{HL}\\
%\end{Prf}

Together with $\present\H~\eqcl{\level\H}{HH} = \eqcl{\level\M}{HL}$ from the precondition,
$\eqcl{m_0}{HL} = \present\H~\eqcl{\level\H}{HH}$ implies that $m_0$ and $\level\M$ are in the same $HL$ class: $\eqcl{m_0}{HL}=\eqcl{\level\M}{HL}$. This result is needed in order to apply \law{Orthogonal}.

% can be put in linear wp proof
%\begin{Prf}&
%	\eqcl{\interpret\L~ \eqcl{\level'\L}{LL}  ~\reuze{LH}~   \level\M}{HL}\\
%\Equ{$\eqcl{m_0}{LH} = \interpret\L~\eqcl{\level'\L}{LL}$}&
%	\eqcl{\eqcl{m_0}{LH}   ~\reuze{LH}~   \level\M}{HL}\\
%\Equ{\law{Orthogonal} (different notation) + $\eqcl{m_0}{HL}=\eqcl{\level\M}{HL}$}&
%	\eqcl{m_0}{HL}\\
%\Equ{\law{$\eqcl{m_0}{HL} = \present\H~\eqcl{\level\H}{HH}$}}&
%	\present\H~\eqcl{\level\H}{HH}\\
%\end{Prf}


For the inductive step, we have the following induction hypothesis:

\xprlab{\eqcl{\level\M}{HL} = \present\H~\eqcl{\level\H}{HH} \land \eqcl{\level'\M}{HL} = \present\H~\eqcl{\level\H}{HH} ~\imp\\ \wp{Comp_{n-1}}{\level\H = \level''\H}}{I.H.}

Note that the first conjunct in the antecedent of the induction hypothesis is already satisfied due to the assumption above.

Because we assumed the antecedent of \law{Doc-Inert} (in weakest precondition notation), we complete the proof of the implication by proving its conclusion.

\begin{Prf}&
	\true\\
\Eqv{symmetry of $=$}&
	\present\H~\eqcl{\level\H}{HH} = \present\H~\eqcl{\level\H}{HH}\\
\Eqv{\law{$\eqcl{m_0}{HL} = \present\H~\eqcl{\level\H}{HH}$}}&
	\eqcl{m_0}{HL} = \present\H~\eqcl{\level\H}{HH}\\
\Eqv{\law{Orthogonal} and $\eqcl{m_0}{HL}=\eqcl{\level\M}{HL}$}&
	\eqcl{\eqcl{m_0}{LH}   ~\reuze{LH}~   \level\M}{HL} = \present\H~\eqcl{\level\H}{HH}\\
\Eqv{$\eqcl{m_0}{LH} = \interpret\L~\eqcl{\level'\L}{LL}$}&
	\eqcl{\interpret\L~ \eqcl{\level'\L}{LL}  ~\reuze{LH}~   \level\M}{HL} = \present\H~\eqcl{\level\H}{HH}\\
%\end{Prf}
%
%
%\begin{Prf}&
%	\eqcl{\interpret\L~ \eqcl{\level'\L}{LL}  ~\reuze{LH}~   \level\M}{HL} =  \present\H~\eqcl{\level\H}{HH}\\
\Eqv{\law{\fn{wp}-$\gts$}}&
	\wp{\level'\M \gets \interpret\L~ \eqcl{\level'\L}{LL}  ~\reuze{LH}~   \level\M}{ \eqcl{\level'\M}{HL} = \present\H~\eqcl{\level\H}{HH} }\\
\Eqv{\law{$Up$-Def}}&
	\wp{Up}{ \eqcl{\level'\M}{HL} = \present\H~\eqcl{\level\H}{HH}}\\
\Imp{\law{\fn{wp}-Mono}, \law{I.H.}, and $\eqcl{\level\M}{HL} = \present\H~\eqcl{\level\H}{HH}$}&
	\wp{Up}{ \wp{ Comp_{n-1}}{ \level\H = \level''\H }}\\
\Eqv{\law{\fn{wp}-$\smi$}}&
	\wp{Up \semi Comp_{n-1}}{ \level\H = \level''\H }\\
\Eqv{\law{\fn{wp}-$\gts$}}&
	\wp{Up \semi Comp_{n-1}}{ \wp{\level''\L \gets \present\L~ \eqcl{\level''\M}{LH}   ~\reuze{LL}~   \level'\L}{ \level\H = \level''\H }}\\
\Eqv{\law{$Dwn$-Def}}&
	\wp{Up \semi Comp_{n-1}}{ \wp{Dwn }{ \level\H = \level''\H }}\\
\Eqv{\law{\fn{wp}-$\smi$}}&
	\wp{Up \semi Comp_{n-1} \semi Dwn}{ \level\H = \level''\H }\\
\Eqv{\law{$Comp$-Def}}&
	\wp{Comp_n}{\level\H = \level''\H}\\
\end{Prf}
\end{proof}






\subsection{\law{Pres-Inert} requirement}

\xprlab{\eqcl{\level'\L}{CL} = \present\C~\eqcl{h}{CH} ~\imp~ \wp{Comp_n} { \level'\L = \level''\L}}		{Pres-Inert}

Similar to \law{Doc-Inert}, we cannot guarantee \law{Pres-Inert} without assuming extra conditions. It turns out that we can prove \law{Pres-Inert} if we assume \law{$\present$-Match} together with a reversed \law{Orthogonal}, in which the $HL$ and $LH$ relations are swapped. However, because \law{Orthogonal} refers to $\reuze{LH}$, its reverse would have to refer to $\reuze{HL}$, which does not exist. The reason for this is because of the association order in $Comp$, reuse in the presentation direction of the higher layer is the result of the combined effect of the $\reuze{LL}$ functions of the components of the higher layer. Thus, the only way to specify a reversed \law{Orthogonal} is as a condition on the combined layer:

\xprlab{
\eqcl{\level'\L}{LH}  = \eqcl{m}{LH} ~\imp~ \wp{Comp_{n-1}} {\eqcl{\level''\L}{LH}  = \eqcl{m}{LH}}}{Orthogonal-R}

Because of the complexity of this condition, we introduce a stronger condition \law{Absorption} that is easier to verify. \law{Absorption} can be proven to imply both \law{$\present$-Match} and \law{$\interpret$-Match}, as well as \law{Orthogonal} and \law{Orthogonal-R}.

%\toHere
%
%PROBLEM:
%\xprlab{
%\eqcl{m'}{LH} = \eqcl{m}{LH} ~\imp~ \eqcl{\eqcl{m'}{HL} \reuze{HL} m}{LH} = \eqcl{m}{LH}}{Orthogonal-R}
%
%There is no $\reuze{HL}$, because it is the combination of several $\reuze{LL}$'s in the higher layers. This definition is %therefore not valid. 
%
%Furthermore, \law{Absorption} as defined below 
%
%There seem to be two options.
%
%1) No to mention \law{Orthogonal-R} at all and always assume \law{Absorption}. A separate 
%
%2) Introduce this definition of \law{Orthogonal-R}:
%
%\xprlab{
%\eqcl{\level'\L}{LH}  = \eqcl{m}{LH} ~\imp~ \wp{Comp_{n-1}} {\eqcl{\level''\L}{LH}  = \eqcl{m}{LH}}}{Orthogonal-R}
%
%
%For $Layer_1$ (composition of ($\present_1$,$interpret_1$) with ($\id$,$\id$)), we can easily prove that \law{Orthogonal-R} %always holds. 
%
%For the rest of the layers, we assume \law{Absorption}
%
%
%
%\fromHere

%However, because the precondition of \law{Pres-Inert} does not guarantee that the intermediate level is valid, we cannot use %\law{Pres-Inert} inductively on the higher layer. As a consequence, the proof of \law{Pres-Inert} becomes very tedious. 

%In order to simplify the proof, we introduce a stronger condition \law{Absorption}, which can be proven to imply both %\law{$\present$-Match} and \law{$\interpret$-Match}, as well as \law{Orthogonal}. 

%\xprlab{
%\forall m : \eqcl{m}{LH} \subset \eqcl{m}{HL}}{Absorption}

\xprlab{
\eqcl{m}{LH} = \eqcl{m'}{LH} ~\imp~ \eqcl{m}{HL} = \eqcl{m'}{HL}}{Absorption}

The condition states that two $Level\M$ values that are in the same $LH$ equivalence of the lower layer, also share the $HL$ equivalence class of the higher layer. Thus, interpretation extra state on the middle level is absorbed by presentation extra state on that level, hence the name.

As an example of \law{Absorption} for the wildcard types of Section~\ref{sect:wildcardEq}, consider the $LH$ relation represented by $(Int,(Int,*_{Int}))$.  This relation is absorbed by an $HL$ relation $(Int,(*_{Int},*_{Int}))$, and also by $(Int,*_{Int})$. 

For wildcard types, \law{Absorption} holds if and only if for all possible values of type $Level\M$, any node that is a $\texttt{*}$ according to the wildcard definition of $LH$, is either also a $\texttt{*}$ according $HL$ or has an ancestor that is a $\texttt{*}$.

More generally, \law{Absorption} holds when each $HL$ equivalence class is a union of $LH$ classes. A result of \law{Absorption} is that  $CH$ is equal to $HH$. For the proof of \law{Pres-Inert}, \law{Absorption} implies that the intermediate level that results from interpreting a valid lower level, is itself also valid, which allows us to apply \law{Pres-Inert} inductively to the higher layer.

We do not wish to assume \law{Absorption} for the top-most combination ($\present_1$, $\interpret_1$ and the identity), because it implies that the interpretation extra of $\present_1$ is absorbed by the interpretation extra state of $\id$. As a consequence, the top-most combination would not have interpretation extra state, and therefore neither of the combinations.

To allow interpretation extra state at the top-most combined layer, we give a separate proof the case $n=1$ for \law{Doc-Inert}, in which we do not use \law{Absorption}. Furthermore, we cannot use \law{Absorption} instead of \law{$\present$-Match}, \law{$\interpret$-Match}, and \law{Orthogonal}, for the $n=1$ case. However, since for $n=1$, all three conditions trivially hold, we do not need \law{Absorption} for this case.


\begin{proof}
In the inductive step of the proof, we need the fact that the lower level is not affected by the assignments of the higher layer. Therefore, we strengthen the pre- and postcondition of \law{Pres-Inert}: \note{more on this?}

\xpr{ \eqcl{\level'\L}{CL} = \present\C~\eqcl{h}{CH}  \land \level'_{n+1} = x ~\imp\\ \wp{Comp_n}{\level'\L = \level''\L  \land \level'_{n+1} = x}}

%Here we need:
%
%which implies
%
%\begin{Prf}&
%	\eqcl{\level'\L}{CL} = \present\C~\eqcl{h}{CH}\\
%\Imp{magic}&
%	\eqcl{\level'\L}{CL} = \present\C~\eqcl{h}{CH} \land \level_{n+1} = x\\
%\Imp{assumption}&
%	\wp{Comp_n}{\level'\L = \level''\L  \land \level_{n+1} = x}\\
%\Imp{\law{\fn{wp}-Mono} and $X \land Y ~\imp~ X$}&
%	\wp{Comp_n}{\level'\L = \level''\L}\\
%\end{Prf}

\bc
{\bf Case~} $n=0$

The base case

\xpr{\eqcl{\level'_0}{=} = \id~\eqcl{h}{=} \land \level'_{1} = x ~\imp~\wp {Comp_0} { \level'_0 = \level''_0 \land \level'_{1} = x}}

is evident if we substitute according to \law{$Comp$-Def}:

\xpr{\eqcl{\level'_0}{=} = \id~\eqcl{h}{H} \land \level'_{1} = x ~\imp~\wp {\level''_0 \gets \level'_0} { \level'_0 = \level''_0 \land \level'_{n+1} = x}}
\ec

{\bf Case~} $n=1$
\todo{Check proof+ mention/prove  $n=0$?}

The proof is similar to the proof of \law{Pres-Inert} for a single layer (see Section~\ref{sect:singleExtra_Editing}).

We assume $\eqcl{\level'\L}{L} = \present~\eqcl{h}{H}$.
	
\begin{Prf}&
	\true\\
\Eqv{reflexivity of $=$}&
	\eqcl{\level'\L}{L} = \eqcl{\level'\L}{L}\\
\Eqv{\law{$\reuz$-Idem} }&
	\level'\L  = \eqcl{\level'\L}{L}~\reuz~  \level'\L\\
\Eqv{assumption}&
	\level'\L  = \present~\eqcl{h}{H}  ~\reuze{L}~  \level'\L\\
\Eqv{\law{$\reuz$-Valid}}&
	\level'\L  = \present~ \eqcl{(\eqcl{h}{H}  ~\reuze{H}~   \level\H)}{H}   ~\reuze{L}~   \level'\L\\
\Eqv{\law{InterPresent }}&
	\level'\L = \present~ \eqcl{(\interpret~(\present~\eqcl{h}{H})  ~\reuze{H}~  \level\H)}{H}   ~\reuze{L}~   
\level'\L\\
\Eqv{assumption}&
	\level'\L = \present~ \eqcl{\interpret~ \eqcl{\level'\L}{L}  ~\reuze{H}~   \level\H}{H}   ~\reuze{L}~   \level'\L\\
\Eqv{\law{\fn{wp}-$\gts$}}&
	\wp{\level'\H \gets \interpret~ \eqcl{\level'\L}{L}  ~\reuze{H}~   \level\H}{\level'\L = \present~ \eqcl{\level'\H}{H}   ~\reuze{L}~   \level'\L }\\
\Eqv{\law{$Up$-Def}}&
	\wp{Up}{\level'\L = \present~ \eqcl{\level'\H}{H}   ~\reuze{L}~   \level'\L }\\
\Eqv{\law{\fn{wp}-$\gts$}}&
	\wp{Up}{\wp{\level''\H \gets \level'\H}{\level'\L = \present~ \eqcl{\level''\H}{H}   ~\reuze{L}~   \level'\L }}\\
\Eqv{\law{$Comp$-Def} and $Level_0 \eqv \Level\H$}&
	\wp{Up}{\wp{Comp_0}{\level'\L = \present~ \eqcl{\level''\H}{H}   ~\reuze{L}~   \level'\L }}\\
\Eqv{\law{\fn{wp}-$\smi$}}&
	\wp{Up \semi Comp_0}{\level'\L = \present~ \eqcl{\level''\H}{H}   ~\reuze{L}~   \level'\L }\\
\Eqv{\law{\fn{wp}-$\gts$}}&
	\wp{Up \semi Comp_0}{\wp{\level''\L \gets \present~ \eqcl{\level''\H}{H}   ~\reuze{L}~   \level'\L}{ \level'\L = \level''\L  }}\\
\Eqv{\law{$Dwn$-Def}}&
	\wp{Up \semi Comp_0}{\wp{Dwn}{ \level'\L = \level''\L  }}\\
\Eqv{\law{\fn{wp}-$\smi$}}&
	\wp{Up \semi Comp_0 \semi Dwn}{ \level'\L = \level''\L  }\\
\Eqv{\law{$Comp$-Def}}&
	\wp{Comp_1}{ \level'\L = \level''\L  }\\
\end{Prf}



%\xpr{\hoare{\eqcl{\level'\L}{L} = \present~\eqcl{h}{H}} {Comp_n} { \level'\L = \level''\L}}


%\xpr{ \eqcl{\level'_0}{H} = \present_0~\eqcl{h}{H} ~\imp~ \wp{Comp_0}{\level'_0 = \level''_0}} 
%
%\begin{Prf}
%\Eqv{\law{\fn{wp}-$\gts$}}&
%	\wp{\level''\H \gets \interpret\L~\level'\L}{ \wp{ \level''\L \gets \present~\level''\H}{\level\H = \level''\H}} \\
%\Eqv{\law{\fn{wp}-$\smi$}}&
%	\wp{\level''_0 \gets \level'_0}{\level_0 = \level''\H} \\
%\Eqv{\law{$Comp$-Def}}&
%	\wp{Comp_0}{\level'_0 = \level''_0}\\
%\end{Prf}

{\bf Case~} $n>1$

First we prove the first part of postcondition conjunct:

\xpr{ \eqcl{\level'\L}{CL} = \present\C~\eqcl{h}{CH} \land \level'_{n+1} = x  ~\imp~ \wp{Comp_n}{\level'\L = \level''\L}}

We only need to assume half of the antecedent:
 $\eqcl{\level'\L}{CL} = \present\C~\eqcl{h}{CH}$.


%result of $Up$ and $m_0$ are in same LH class.
%
%does not seem to work:
%\begin{Prf}&
%	(\interpret\L~ \eqcl{\level'\L}{LL})  \reuze{LH}   \level\M  \\
%\Eqv{$\eqcl{m_0}{LH} = \interpret\L~\eqcl{level'\L}{LL}$}&
%	\eqcl{m_0}{LH}  \reuze{LH}   \level\M  \\
%\Imp{\law{$\reuz$-Valid}}&
%	\eqcl{m_0}{LH}\\
%\Imp{\law{Absorption}}&
%	\level'\M \in \eqcl{m_0}{HL}\\
%\Imp{\law{$\eqhole$-Member}}&
%	\eqcl{\level'\M}{HL} = \eqcl{m_0}{HL}\\
%\end{Prf}
%\note{rewrite valid? or just mention that it can be rewritten (as = on eq. classes)}
%\xpr{
%\eqcl{\interpret\L~ \eqcl{\level'\L}{L}  ~\reuze{H}~  \level\M}{HL} = \present\H~\eqcl{h}{HH} \\
%}


From the assumption, we know there exists an $m_0$ that is in the presentation of $h$, and that has $\level'\L$ in its presentation:

\begin{Prf}&
	\eqcl{level'\L}{LL} = \present\L~\eqcl{m_0}{LH} \land \eqcl{m_0}{HL} = \present\H~\eqcl{h}{HH}\\
\Eqv{let $m_0$ be the $m$ from the quantification}&
	\exists m : \eqcl{level'\L}{LL} = \present\L~\eqcl{m}{LH} \land \eqcl{m}{HL} = \present\H~\eqcl{h}{HH}\\
\Eqv{\law{$\present\C$-Def}}&
	\eqcl{level'\L}{CL} = \present\C~\eqcl{h}{CH}\\
\Eqv{assumption}&
	\true\\
\end{Prf}

Furthermore, by the first part of this conjunct and \law{InterPresent} on the lower layer, we also have $\eqcl{m_0}{LH} = \interpret\L~\eqcl{level'\L}{LL}$
%$\eqcl{m_0}{HL} = \present\H~\eqcl{h}{HH}$


%Define an $m'$ to be $(\interpret\L~ \eqcl{\level'\L}{LL})  \reuze{LH}   \level\M$
%\begin{Prf}&
%	\true\\
%\Eqv{ bla }&
%	m' = (\interpret\L~ \eqcl{\level'\L}{LL})  \reuze{LH}   \level\M  \\
%\Imp{$\eqcl{m_0}{LH} = \interpret\L~\eqcl{level'\L}{LL}$}&
%	m' = \eqcl{m_0}{LH}  \reuze{LH}   \level\M  \\
%\Imp{\law{$\reuz$-Valid}}&
%	m' \in \eqcl{m_0}{LH}\\
%\Imp{\law{Absorption}}&
%	m' \in \eqcl{m_0}{HL}\\
%\Imp{\law{$\eqhole$-Member}}&
%	\eqcl{m'}{HL} = \eqcl{m_0}{HL}\\
%\Eqv{\law{$\eqhole$-Member}}&
%	\eqcl{(\interpret\L~ \eqcl{\level'\L}{LL})  \reuze{LH}   \level\M}{HL} = \eqcl{m_0}{HL}\\
%\end{Prf}

%or alternatively: using rewritten \law{Absorption}
%\eqcl{m}{LH} = \eqcl{m'}{LH} ~\imp~ \eqcl{m}{HL} = \eqcl{m'}{HL}}{Absorption}
We need two intermediate results for the inductive step of the proof. The first one is:

% states that the intermediate valua after interpret of lower layer is in presentation of $h$, hence precondition for doc-inert on higher layer is satis.

\begin{Prf}&
	\eqcl{\interpret\L~ \eqcl{\level'\L}{LL}  ~\reuze{LH}~  \level\M}{HL} = \present\H~\eqcl{h}{HH} \\
\Equ{$\eqcl{m_0}{HL} = \present\H~\eqcl{h}{HH}$}&
	\eqcl{\interpret\L~ \eqcl{\level'\L}{LL}  \reuze{LH}   \level\M}{HL} = \eqcl{m_0}{HL}\\
\Ffr{\law{Absorption}}&
	\eqcl{\interpret\L~ \eqcl{\level'\L}{LL}  \reuze{LH}   \level\M}{LH} = \eqcl{m_0}{LH}\\
\Eqv{$\eqcl{m_0}{LH} = \interpret\L~\eqcl{level'\L}{LL}$}&
	\eqcl{\eqcl{m_0}{LH}  \reuze{LH}   \level\M}{LH} = \eqcl{m_0}{LH}\\
\Eqv{\law{$\reuz$-Valid}}&
	\eqcl{m_0}{LH} = \eqcl{m_0}{LH}\\
\Eqv{reflexivity of $=$}&
	\true\\
\end{Prf}

A corollary from this proof is that $\eqcl{\interpret\L~ \eqcl{\level'\L}{LL}  \reuze{LH}   \level\M}{LH} = \eqcl{m_0}{LH}$, which is used in the proof of the second intermediate result:

% which states that if the middle (same as intermediate due to doc-inert) is presented, we get level'L again.


% this used to be a separate proof
%For the first equality in conjunct:
%\xpr{
%\eqcl{\interpret\L~ \eqcl{\level'\L}{L}  ~\reuze{LH}~  \level\M}{HL} = \present\H~\eqcl{h}{HH} \\
%}
%
%\begin{Prf}&
%	\eqcl{(\interpret\L~ \eqcl{\level'\L}{LL})  \reuze{LH}   \level\M}{HL}\\
%\Equ{previous result}&
%	\eqcl{m_0}{HL}\\
%\Equ{$\eqcl{m_0}{HL} = \present\H~\eqcl{h}{HH}$}&
%	\present\H~\eqcl{h}{HH}\\
%\end{Prf}


\xpr{
\level'\L = \present\L~ \eqcl{\interpret\L~ \eqcl{\level'\L}{LH}  ~\reuze{LH}~  \level\M}{LH}   ~\reuze{LL}~   \level'\L\\
}

\begin{Prf}&
	\level'\L\\
\Equ{\law{$\reuz$-Idem} and $\eqcl{level'\L}{LL} = \eqcl{level'\L}{LL}$}&
	\eqcl{level'\L}{LL}  \reuze{LL}  \level'\L\\
\Equ{$\eqcl{level'\L}{LL} = \present\L~\eqcl{m_0}{LH}$}&
	\present\L~ \eqcl{m_0}{LH}  \reuze{LL}  \level'\L\\
\Equ{corollary: $\eqcl{\interpret\L~ \eqcl{\level'\L}{L}  ~\reuze{LH}~  \level\M}{LH} = \eqcl{m_0}{LH}$}&
	\present\L~ \eqcl{\interpret\L~ \eqcl{\level'\L}{LL}  ~\reuze{LH}~  \level\M}{LH}  \reuze{LL}  \level'\L\\
\end{Prf}

Now we can prove the inductive step with induction hypothesis:

\xprlab{\eqcl{\level'\M}{HL} = \present\H~\eqcl{h}{HH}  \land \level'\L = x  ~\imp\\ \wp{Comp_{n-1}}{\level'\M = \level''\M \land \level'\L = x}}{I.H.}

%\xpr{
%	\begin{array}[b]{@{}l@{}l@{}l}
%	 \eqcl{\interpret\L~ \eqcl{\level'\L}{L}  ~\reuze{H}~  \level\M}{HL} = \present\H~\eqcl{h}{HH} \land\\
%	 \level'\L = \present\L~ \eqcl{\interpret\L~ \eqcl{\level'\L}{L}  ~\reuze{H}~  \level\M}{LH}   ~\reuze{L}~   \level'\L\\
%	\end{array}\\
%	 }

The proof starts with the conjunction of the two intermediate results that we just proved.

\begin{Prf}
  &	\eqcl{\interpret\L~ \eqcl{\level'\L}{LL}  ~\reuze{LH}~  \level\M}{HL} = \present\H~\eqcl{h}{HH} ~~\land\\
  &	\level'\L = \present\L~ \eqcl{\interpret\L~ \eqcl{\level'\L}{LL}  ~\reuze{LH}~  \level\M}{LH}   ~\reuze{LL}~   \level'\L\\
\Eqv{\law{\fn{wp}-$\gts$}}&
	\fn{wp}( \level'\M \gets \interpret\L~ \eqcl{\level'\L}{LL}  ~\reuze{LH}~  \level\M,\\
 & \hspace{0.7cm} \eqcl{\level'\M}{HL} = \present\H~\eqcl{h}{HH} \land \level'\L = \present\L~ \eqcl{\level'\M}{LH}   ~\reuze{LL}~   \level'\L ) \\
\Eqv{\law{$Up$-Def}}&
	\wp{Up}{ \eqcl{\level'\M}{HL} = \present\H~\eqcl{h}{HH}  ~~\land \level'\L = \present\L~ \eqcl{\level'\M}{LH}   ~\reuze{LL}~   \level'\L}\\
\Imp{\law{\fn{wp}-Mono} and \law{I.H.}}&
	\wp{Up}{ \wp{ Comp_{n-1}}{ \level'\M = \level''\M ~~\land \level'\L = \present\L~ \eqcl{\level'\M}{LH}   ~\reuze{LL}~   \level'\L}}\\
\Eqv{\law{\fn{wp}-$\smi$}}&
	\wp{Up \semi Comp_{n-1}}{  \level'\M = \level''\M ~~\land \level'\L = \present\L~ \eqcl{\level'\M}{LH}   ~\reuze{LL}~   \level'\L}\\
\Imp{\law{\fn{wp}-Mono} and Leibniz}&
	\wp{Up \semi Comp_{n-1}}{ \level'\L = \present\L~ \eqcl{\level''\M}{LH}   ~\reuze{LL}~   \level'\L}\\
\Eqv{\law{\fn{wp}-$\gts$}}&
	\wp{Up \semi Comp_{n-1}}{ \wp{\level''\L \gets \present\L~ \eqcl{\level''\M}{LH}   ~\reuze{LL}~   \level'\L}{ \level'\L = \level''\L }}\\
\Eqv{\law{$Dwn$-Def}}&
	\wp{Up \semi Comp_{n-1}}{ \wp{Dwn }{ \level'\L = \level''\L }}\\
\Eqv{\law{\fn{wp}-$\smi$}}&
	\wp{Up \semi Comp_{n-1} \semi Dwn}{ \level'\L = \level''\L }\\
\Eqv{\law{$Comp$-Def}}&
	\wp{Comp_n}{\level'\L = \level''\L}\\
\end{Prf}

This completes proof of:

\xpr{ \eqcl{\level'\L}{CL} = \present\C~\eqcl{h}{CH} \land \level'_{n+1} = x  ~\imp~ \wp{Comp_n}{\level'\L = \level''\L}}

The second part of the postcondition conjunct is:

\xpr{ \eqcl{\level'\L}{CL} = \present\C~\eqcl{h}{CH} \land \level'_{n+1} = x ~\imp~ \wp{Comp_n}{\level'_{n+1} = x}}

which trivially holds, because $Comp_n$ only does assignments on levels $0 \dots n$. Hence, by \law{\fn{wp}-And}, we can conclude: 

\xpr{ \eqcl{\level'\L}{CL} = \present\C~\eqcl{h}{CH}  \land \level'_{n+1} = x ~\imp~ \wp{Comp_n}{\level'\L = \level''\L  \land \level'_{n+1} = x}}

\end{proof}



%Story on compatibility here? Or in conclusions?
%
%Explanation compatible. Even if h exists, moving in lower med eq. class could lead to levelH not in [h] (probably must be an %imprecise edit). This would cause $l$ update. 
%
%In order to prevent, for all variation we require validity (and hence by pres-inert stay in correct class), or if invalid, at least stay %in same class.
%
%
%Compatibility (obsolete):

%% old version:
%%\xprlab{
%%\forall m_0 : & (\exists m \in \eqcl{m_0}{LH} : \exists h: m~Present~h) \imp\\
%%                   & \begin{array}[b]{@{}l@{}l@{}l}
%%                      \forall m' \in \eqcl{m_0}{LH} :~&  (\exists h_0 : \eqcl{m'}{HL} = pres \eqcl{h_0}{HH})~\lor\\
%%                    							& (\present\H \oo \interpret\H) \eqcl{m'}{HL} \subset 			\end{array}
%%\eqcl{m_0}{LH}}{Compatible}
%%
%%or if we define: $\valid~l \eqv \exists h : \eqcl{l}{L} \present \eqcl{h}{H}$ (note that this is on {\em a} layer, not on higher %%or lower)
%%
%%\xprlab{
%%\forall m_0 : & (\exists m \in \eqcl{m_0}{LH} : \valid~m) \imp\\
%%                   & \begin{array}[b]{@{}l@{}l@{}l}
%%                       \forall m' \in \eqcl{m_0}{LH} : ~ & \valid~m'~\lor\\
%%									&(\present\H \oo \interpret\H) \eqcl{m'}{HL} \subset \eqcl{m_0}{LH}
%%			\end{array}
%%}{Compatible}
%%
%%Lambert:
%%\xprlab{
%%\forall m_0 : \forall m,m' : \valid~m \land \lnot \valid~m' ~~\imp \dots \subset \dots
%%}

%\xprlab{
%\forall m_0 : & (\exists m \in \eqcl{m_0}{LH} : \valid~m) \imp\\
%                   & \begin{array}[b]{@{}l@{}l@{}l}
%                       & \valid~m_0~\lor\\
%			&(\present\H \oo \interpret\H) \eqcl{m_0}{HL} \subset \eqcl{m_0}{LH}
%			\end{array}
%}{Compatible}
%
%


\subsection{\law{Doc-Preserve} and \law{Imprecise} requirements}

Similar to the single layered editor, \law{Doc-Preserve} states that interpretation extra state is reused, whereas \law{Imprecise} has a double function. The requirement states both that presentation extra state is reused, as well as that the final lower level resembles the updated lower level. 

Consider the interpretation extra state of the combination, which is represented by the equivalence classes of $CH$. Each of these classes consists of a number of $HH$ classes. If we do not assume \law{Absorption }, then closeness in a class of $CH$ is established in two steps. The lower layer selects the closest $HH$ class by \law{$\reuz$-Close}, after which  \law{Doc-Preserve}  of the higher layer selects the closest element from this class.

On the other hand, if \law{Absorption} holds, then each $CH$ class corresponds to exactly one $HH$ class, and closeness is guaranteed by \law{Doc-Preserve} on the higher layer.

The part of \law{Imprecise} for reusing presentation extra state is guaranteed by the component layers in a similar way as for interpretation extra state (without assuming \law{Absorption}). The other part of \law{Imprecise} must be guaranteed by 
$\interpret\L$ and $\interpret\H$, and thus serves as the specification of these functions. \note{this seems to be quite complicated}


%\bl
%\o preses is combination of pres es on middle and on lower, combined reuse must guarantee closeness.
%\o imprecise is 2-step, each step does closer. hence, only editors that close is this way. if a h exists that is closer to l', but for %which m isn't, then not computed.
%\el

%\bl
%\o Is this the case when m'' is close to m and l'' is close to l, for the individual layers? Or is there an m'' that is not closest to m, %but for which pres m is closest to l?
%\o do es reqs also say something about middle es?
%\el

\bc from previous section:

From \law{$Up$-Def}, we know that $level''\H$ is the result of  $\interpret~ \eqcl{\level'\L}{L}  ~\reuze{H}~   \level\H$, which implies $level\H ``close~to'' level''\H$ by \law{$\reuz$-Close}. Hence, \law{Doc-Preserve} holds.

The \law{Imprecise} requirement is somewhat more subtle, since it has a double function. On the one hand, it states that the equivalence class $\eqcl{\level''\L}{L}$ must be close to $\eqcl{\level'\L}{L}$. This corresponds to the \law{Imprecise} requirement in Section~\ref{sect:single_Editing} without extra state. In this sense, closeness is used to express that the final lower level resembles what the user intended. Thus, if $level'\L$ is not a valid presentation, then $\eqcl{level''\H}{H}$, must be chosen such that its presentation equivalence class $\eqcl{\level''\L}{L}$ is close to $\eqcl{\level'\L}{L}$. The requirement is therefore a specification of $\interpret$.


On the other hand, \law{Imprecise} also states that from the equivalence class $\eqcl{\level''\L}{L}$,
%$\present \eqcl{level''\H}$
 we want to choose an element that is as close as possible to $level'\L$ regarding its extra state. This closeness is guararanteed by \law{$\reuz$-Close} analogous to the higher level.


\ec






\subsection{Conclusions}

A layered editor consisting of two component layers can be specified in the same manner as a single layered editor, but imposes additional requirements on the components. In order to guarantee that the combination is a mapping between equivalence classes, we need the 
{$\present$-Match} and {$\interpret$-Match} conditions on the components. Furthermore, for \law{Doc-Inert} and \law{Pres-Inert} requirements, we need to assume the conditions \law{Orthogonal} and the rather complex \law{Orthogonal-R}.


The stronger condition \law{Absorption} implies all four additional conditions: 

\xprlab{
\eqcl{m}{LH} = \eqcl{m'}{LH} ~\imp~ \eqcl{m}{HL} = \eqcl{m'}{HL}}{Absorption}

For the top-most combination, we cannot assume \law{Absorption} because this would rule out interpretation extra state altogether. However, {$\present$-Match}, {$\interpret$-Match}, \law{Orthogonal} trivially hold for the top-most combination, and \law{Pres-Inert} is proven without assuming \law{Absorption} for the top-most combination.

Because an editor consisting of $n$ layers is constructed by taking the top layer and repeatedly putting layers underneath, we need to prove \law{Absorption} for each of the $n-1$ combinations, except the top-most combination. 

\law{Absorption} is a rather strong condition. It only allows interpretation extra state at the document level, since all other interpretation extra state is absorbed by presentation extra state.  Further research is necessary to determine whether this restriction disallows the specification of useful editors, in which case a workable but less strict condition needs to be established. 

\note{mention that for actual editors, only a few layers are not fixed, making it easier to guarantee these conditions?}
%\note{We don't want absorption for the combination of $id$ and $layer_0$, because then there is no document extra state}
%Maybe different approach for handling imprecise edit will help.

%\bl
%\o In Proxima, only pres ES in lower layer and interpretation extra state in top.
%\o Putting doc extra state only in upper layer seems to prevent most problems.
%\el



%																
%																
%																
\section{Duplicate presentations} \label{sect:duplicates}
\note{call them dependent values rather than duplicates?}

%\toHere
%Rename to dependent values.
%
%Johan
% presentations "that duplicate information" <->
% "in which document values are used more than once, oid."
%\fromHere


% Introduction
The specification developed in the previous sections does not yet offer support for presentations that duplicate information (also see Section~\ref{sect:informalDuplicates}). A simple example of a duplicate presentation is the function $\present~x = (x, x)$. An intuitive way to handle edit operations on duplicates is to let the edited duplicate determine the document update. However, this behavior cannot be expressed by the specifications in the previous sections, since the specification does not take into account the original $level\L$.

Duplicates become particularly problematic in the combination with extra state and multiple layers. \note{add refs on duplicates from DB and inversion papers}

 \bc In fact, the pathological cases that give rise to the extra conditions in Section~\ref{sect:combinedExtraCompose} all contain some form of duplication. \ec 
In this section, we discuss how the editor specification can be adapted to support the handling of duplicate presentations. A formal definition of when exactly a presentation contains duplicates is hard to give without making additional assumptions on the presentation formalism. We have established a tentative definition, but it still requires improvement. Therefore, the remainder of this section is rather informal.
% close on document gets into trouble with pres-inert

\subsection{Dealing with duplicates}

% what are duplicates
Besides the obvious $\present~x = (x, x)$, we speak of duplication when a presentation contains several values that depend on the same document value (e.g.\ $\present~x = (2x, -x)$). This holds even if the computation for the derived value does not have an inverse, as in $\present~x = (x, x~\fn{mod}~256)$. Although the term may seem somewhat odd in this case, we do refer to such presentations as duplicates. A related example $\present~x = (x~\fn{div}~256, x~\fn{mod}~256)$ shows the subtlety of duplication, since in this case there is no duplication of information, and both elements of the presentation tuple can be edited without causing a conflict. 

Besides depending on a single document value, a duplicate may also depend on several values. Hence, an average value of a list of integers (when presented together with the list) can be regarded as a duplication of the values in the list. Other examples of duplication are derived type signatures for functions, or even the color of a keyword in a syntax-coloring editor.

% another one: $1 \to "one"$ can be seen as three partial duplicates. 
% what's this note? parsing with correction. ??? 


% simple solution
The easiest way to deal with duplicate information is to simply ignore one of the duplicates on interpretation and thus making the ignored duplicate non-editable. This is in fact the only way that is allowed by the specification of the previous sections. For 
$\present~x = (x,x)$, this leaves a choice of interpret functions: with $\interpret~(x,y) = x$, only the first value is editable, and with $\interpret~(x,y) = y$ only the second value.


In some cases non-editable duplicates are perfectly acceptable. In case of the list of integers with its average, few people will expect to be able to edit the average value. And perhaps even fewer people will expect to be able to edit colors in a syntax-coloring editor and thereby modify the edited program source. However, in many cases we do want to be able to edit duplicate values.

\subsection{Adapting the \law{Imprecise} requirement}
% This is not consistent with ``close to'' on presentation.  
% If $(1,1) \leadsto (1,8)$ then $(8,8)$ is probably closer as far as the user is concerned.
Instead of ignoring one of the duplicates, a more user-friendly approach is to use the value of the modified duplicate to determine the document update. This is in line with the requirement that if an update is imprecise, the editor will perform the operation that the user intended. 

%\note{not entirely true if we block out duplicates}
Edit operations on duplicates most probably result in an invalid presentation, unless a user has managed to consistently edit all appearences of the duplicate. Hence, the result of an edit operation on a duplicate value is mainly specified by the \law{Imprecise} requirement: 

%The problem with duplicates is that information from the document is present several times in the presentation.
%We tackle the problem by taking the 

\xprlab{\hoare{\true} {Comp} {\level'\L \close \level''\L}}	{Imprecise}

However, in its current form, \law{Imprecise} cannot specify the desired behavior, since it relates $\level''\L$ to $\level'\L$ without taking $\level\L$ into account. An example shows the problem that can occur.

Consider an editor with $\present~x = (x,x)$. Because the edit operation $(0,0) \leadsto (1,0)$, should result in the presentation $(1,1)$, we must have $(1,0) \close (1,1)$. On the other hand the desired result of $(1,1) \leadsto (1,0)$ should be $(0,0)$, implying $(1,0) \close (0,0)$. Thus, based on $level'\L$ alone, \law{Imprecise} cannot specify the correct behavior for an edit operation that updates the lower level to $(1,0)$.

%Hence, the value of $\interpret (1,0)$ depends not only on $\level'\L$, but also on the $level\L$.

A second example shows the problem more precisely. Consider the function 
$\present~x = (x,x,x)$. If a user edits the first element of the presentation
($(0,0,0) \leadsto (1,0,0)$) the intuitive result would be to change the document to $1$. However, since $(1,0,0)$ is arguably closer to $(0,0,0)$ than $(1,1,1)$, $level''\H$ is specified to be $0$ instead of $1$. Therefore, an editor conforming to the specification does not allow any editing in the presentation, unless two or more values are edited simultaneously and consistently. 


% just looking at change is not really enough. 
The problem with the \law{Imprecise} requirement is that the duplicates of the edited part of the presentation influence the final result of the edit operation. We tackle the problem by introducing an operator to ignore these duplicates:

\xpr{
\Delta \tp  T \to T \to T\st\\
}

In the application $x~\Delta~x'$, $x'$ represent the value of $x$ after it is updated by a user ($x \leadsto x'$). The result of $\Delta$  is a value that is structurally the same as $x'$, but in which for each edited part, all duplicates are replaced by wildcards. Thus, for a presentation without duplicates, we have $x \Delta x' = x'$. 
If two duplicates are updated simultaneously, the result of $\Delta$ is not defined.

Similar to Section~\ref{sect:wildcardEq}, a wildcard stands for any value, and therefore can be ignored when testing for equality, or evaluating closeness. Hence, $(1,\texttt{*}_{Int},\texttt{*}_{Int})$ is maximally close to $(1,1,1)$, but also to $(1,3,5)$, for example. The effect of the wildcards is that in the specification of $\interpret$, the duplicates that cause conflicts are blocked out of the presentation. 

We give two examples to illustrate the behavior of $\Delta$. For the first example, consider the presentation function $\present~(x,y) = (x,x,x,y,y)$. If a user updates the second element of the presentation tuple (e.g.\ $(1,1,1,5,5)\leadsto(1,2,1,5,5)$), we compute 
$(1,1,1,5,5)~\Delta~(1,2,1,5,5) = (\texttt{*}_{Int},2,\texttt{*}_{Int},5,5)$, which can be interpreted unambiguously as $(2,5)$ . 

Another example is $\present~(x,y) = (x,y,x+y)$. For an update on the first element of the tuple ($(1,2,3)\leadsto(10,2,3)$), we get  $(1,2,3)~\Delta~(10,2,3) = (10,2,\texttt{*}_{Int})$, which is interpreted as the document  $(10,2)$. If the sum is edited, for example by $(1,2,3)\leadsto(1,2,13)$, we get $(1,2,3)~\Delta~(1,2,13) = (\texttt{*}_{Int},\texttt{*}_{Int},12)$. The interpretation of $(\texttt{*}_{Int},\texttt{*}_{Int},12)$, which leaves a choice for the result of the interpretation.

Unfortunately, it is difficult to give a formal specification of $\Delta$, because we do not have a formal definition of the notion of duplicate information. Moreover, when a value influences the structure of presentation, rather than a specific value in the structure, this cannot be modeled with wildcards. For these reasons, we keep the description of $\Delta$ informal, and leave the behavior of the editor unspecified in conflict situations.


%\note{say a bit more about structural diffs?}


%Can we give a definition? Nope
%
%\xpr{
%\Delta \tp  T \to T \to T\st\\
%C~x\st_0 \dots x\st_n =\st C~y_0 \dots y_n ~=~ x\st_0 = y_0 \land \dots \land x\st_n  = y_n\\
%C~x\st_0 \dots x\st_n =\st C'~y_0 \dots y_m ~=~ \false\\
%}
%what about constructors? what about Bin 1 2 $\leadsto$ Bin 0 (Bin 1 2)  Bin 0 \texttt{*} ?
%Lists? same story with subobj. identities?

%
%\xpr{
%=\st ::  T\st \to T \to T\\
%\texttt{*} =\st  y ~=~ \true\\
%C~x\st_0 \dots x\st_n =\st C~y_0 \dots y_n ~=~ x\st_0 =\st y_0 \land \dots \land x\st_n =\st y_n\\
%C~x\st_0 \dots x\st_n =\st C'~y_0 \dots y_m ~=~ \false\\
%}{$\st$-Def}
%
%don't use = core, because we have no data def. Closeness between a wildcard value and an ordinary value is similar. 
%
%``close to'' on $T\st$ and $T$ is similar to $=\st$. everything is close to a $\texttt{*}$.

Using $\Delta$, we define an \law{Imprecise} requirement that does not require closeness on duplicates of the edited part of the presentation:

\xprlab{\hoare{\true} {Comp} {\level\L ~\Delta~\level'\L \close \level''\L}}	{Imprecise}

However, this requirement alone is not sufficient. Recall that the old \law{Imprecise} also served to preserve the presentation extra state. Because duplicates are ignored by the new \law{Imprecise}, the requirement says nothing about their extra state. Therefore, we need to add a weaker requirement for preserving extra state of the duplicates. The new requirement corresponds to the old \law{Imprecise} requirement:

\xprlab{\hoare{\true} {Comp} {\level'\L \close \level''\L}}	{Pres-Preserve}

With the new requirements, the two examples at the start of this section are no longer problematic. For the $\present~x = (x,x)$ example, after $(0,0) \leadsto (1,0)$ the requirement states $(1,\texttt{*}_{Int}) \close level''\L$, with $(1,1)$ as a solution, whereas for $(1,1)\leadsto (1,0)$ it states $(\texttt{*}_{Int},0)$, with $(0,0)$, as a solution. For the triple presentation, the requirement after updating the first element states $(1,\texttt{*}_{Int},\texttt{*}_{Int}) \close level''\L$, which has $(1,1,1)$ as a solution.

\subsection{Adapting the \law{Pres-Inert} requirement}

Besides the \law{Imprecise} requirement, also the \law{Pres-Inert} requirement needs to be adapted to support duplicates. An example shows the problem that can occur with the old \law{Pres-Inert} requirement.

Consider an editor for a very simple functional language. The document is a list of declarations, which is presented as a list of strings together with a message about type correctness. Furthermore, the body of a function may be hidden (see Section~\ref{sect:sourceeditor}), in which case it is represented by the string \verb|"..."|. 

A type-correct document $[f = a+2, a = 1]$ can be presented while hiding the body of $f$, yielding: \verb|"f = ...; a = 1;    ok"|. The string \verb|ok| signals that the program is type correct. 

If a user performs the update $a = 1 \leadsto a = True$, the most natural result would be an updated document 
$[f = a+2, a = True]$, with a presentation that shows the type error: \verb|"f = ...; a = True;    error"|. Of course, in a real-world editor we would like to have a somewhat more informative error message, but this basic message is sufficient for the example.

The problem that occurs is that because $level'\L$ (\verb|"f = ...; a = True;    ok"|) is a valid presentation (take the document  $[f = 2, a = True]$), \law{Pres-Inert} states that $level'\L = level''\L$. Therefore, according to the specification, the editor has to update the document such that its presentation is \verb|"f = ...; a = True;    ok"|. The only possible way to do this is by changing the hidden body of $f$, which is clearly not the desired behavior.

%\bl
%\o Pres-Inert suggests to update the hidden parts of the document!
%\el

%
%a = 1; f = a + 2;                                    a = True; f = a + 2              or   a = True; f = undefined
%
%a = 1; f = ...            a = True; f = ...     a = True; f = ... [type err]          a = True; f = ...
%                                \texttt{*}    True   \texttt{*}  

To prevent \law{Pres-Inert} from suggesting updates on hidden parts of the document, we adapt the requirement in a similar way as \law{Imprecise}; both the pre- and the postcondition are changed to ignore duplicates of the updated parts of the lower level. We use $=\st$ to denote equality on values that may contain wildcards.

%\note{Alternatively, could we make \law{Pres-Inert} weaker than \law{Doc-Preserve}?}
% no, pres inert usually conflicts with doc-preserve, making it weaker would disable it.

\xprlab{\hoare{\eqcl{\level\L ~\Delta~\level'\L}{L} =\st \present~\eqcl{h}{H}} {Comp} { \level\L ~\Delta~\level'\L =\st \level''\L}}		{Pres-Inert}

The precondition needs to be weakened because otherwise the presence of duplicates in the presentation may disable the requirement. The postcondition, on the other hand, is weakened because we only require the updated parts to stay the same. Duplicates of the updated part, such as the type error in the example above, may change.

\todo{say something about delta in precondition, plus the fact that it is on equivalence class?}

Because the precondition of \law{Pres-Inert} has been weakened, it is satisfied by the two examples $\present~x = (x,x)$ and 
$\present~x =(x,x,x)$. Hence, these examples no longer fall under the  \law{Imprecise} requirement. The \law{Imprecise} requirement now more appropriately only applies to presentation updates that are not valid even when duplicates are ignored. An example of such an update occurs in an expression editor with syntax coloring and  two views. If an expression is entered in one of the views, it is not a valid presentation even if the second view is ignored, because the new expression does not have the correct syntax coloring. Hence, the \law{Imprecise} requirement applies.


\subsection{The remaining requirements}

The other requirements (\law{Postcondition}, \law{Doc-Inert}, and \law{Doc-Preserve}) do not need to be updated. The postcondition should still hold between the entire higher and lower level, and \law{Doc-Preserve} only refers to higher-level values and therefore is not affected by duplicates in the presentation.

The precondition of \law{Doc-Inert} could be changed in a similar way as the precondition of \law{Pres-Inert}, but this is not necessary. Because the precondition ensures that the unchanged parts of the presentation are valid with respect to $\level\H$, only the changed parts may break the precondition. Hence it makes no difference to also include the unchanged parts in the precondition, as the changed parts determine whether it holds or not.




\subsection{Conclusions}

Summarizing, we have the following set of requirements:\nopagebreak[4]

\xprlab{\hoare{\true} {Comp} { \eqcl{\level''\L}{L} = \present~\eqcl{\level''\H}{H} } }		{Postcondition}
\xprlab{\hoare{\eqcl{\level'\L}{L} = \present~\eqcl{\level\H}{H}} {Comp} { \level\H = \level''\H}}  {Doc-Inert}
\xprlab{\hoare{\eqcl{\level\L ~\Delta~\level'\L}{L} =\st \present~\eqcl{h}{H}} {Comp} { \level\L ~\Delta~\level'\L = \level''\L}}		{Pres-Inert}
\xprlab{\hoare{\true} {Comp} {\level\L ~\Delta~\level'\L \close \level''\L}}	{Imprecise}
\xprlab{\hoare{\true} {Comp} {\level'\L \close \level''\L}}	{Pres-Preserve}
\xprlab{\hoare{\true} {Comp} {\level\H \close \level''\H}}	{Doc-Preserve}

If the presentation does not contain duplicates, then the requirements correspond exactly to the requirements of the previous section.

Further research is needed to establish a formal notion of duplicates in the presentation, as well as a specification of the $\Delta$ operator. Both are needed for a verification that $Comp$ as defined in Section~\ref{sect:combinedExtraEditing} meets the requirements.

With duplicates it is easy to specify presentation mappings for which it is difficult, if not impossible to specify an interpretation mapping. However, it must be noted that it is not the aim of the specification to be able to handle every possible presentation mapping. Rather, we wish to be able to specify editors for the common cases of duplication, which we know how to handle.

%\o How Proxima duplicates



%%%%%%%%% Choice crap:

%\bl
%\o Choice in $\interpret$ may be due to duplicates or '???'
%\o $type Document = Int$ 
%\o ???: $\present x = 2x$ also with several interprets: $\interpret 1 = 0 or 1$ 
%\o Hard to distinguish between the two.
%\o A difference seems to be that using stars on other fields but the edited one, make a non-ambiguous \interpret possible in the %duplication case, but not in the other case. e.g.\ $\interpret (1,\texttt{*},\texttt{*}) = 1$
%\o Old statement: if there are several choices for \interpret, which all obey \law{InterPresent}, then there are duplicates. This %does not seem to be true. (e.g.\ $\present n = 2n$)
%\el





%																
%																
%																
%\section{Incrementality}
%Informal. Maybe leave this one out


%																
%																
%																
%\section{Loose ends}
%\bl
%\o what about error nodes in document?
%\o what about inserting pres elts that resemble a chapter title? Is this handled well?
%\o difference between {\em presentation extra state} and {\em interpretion extra state}
%\o what if present is not total?
%\el


%																
%																
%																
%\section{Document-oriented editing}
%
%
%Skipping lower layers
%
%update (pres upd) pres \rarr pres'
%update (doc upd) pres \rarr pres$\times$(doc upd) , which interprets to (update (doc upd) doc)


%																
%																
%																
%\section{layer skipping}
%
%
%Skipping higher layers. Probably won't say much about that here.

%\subsection{}
%Do we need additional sections about (or mention) the subjects below?
%
%\bl
%\o Document-oriented editing
%\o Layer skipping
%\o Incrementality
%\el

\section{Related work and conclusions}

%\bl
%\o chapter specifies $\interpret$, given $\present$
%\o related work
%\o future: presentation language with (semi-)automatic $\interpret$
%\el


% meer over wat we precies specificeren?
In this chapter, we have provided a specification of the $\interpret$ mapping, given a presentation mapping $\present$. Together with the provided computation $Comp$ this constitutes a specification of a presentation-oriented editor. The specification is layered and supports extra state in both presentation and interpretation direction. 

The combination of extra state and duplications makes it easy to construct a presentation mapping for which we cannot specify an $\interpret$. However, the aim of the specification is not to specify an editor for every imaginable presentation mapping, but rather to be able to formally specify the editors for real-world examples in which basic cases of duplication and extra state occur.

Related to the specification in this chapter is the work by Meertens~\cite{meertens98maintainers} on maintainers for constraints between a document and its presentation. Given a constraint between two values, Meertens formulates a number of requirements for a pair of functions to be a maintainer for that constraint. In our case, the constraint would be the presentation relation. Meertens also provides a more formal approach to the concept of closeness and gives a number of maintainers for specific constraints.

Rather than specifying requirements for an editor, Greenwald, et al.~\cite{pierce03lenses}, and Mu, Hu, and Takeichi~\cite{muhu04inv}, describe injective languages that allow the computation of a document from its (possibly edited) presentation. The language by Mu, Hu, and Takeichi takes into account duplication of information.

The three formalisms have in common that in their current state they only handle simple presentations. It is not yet clear whether these simple presentations are scalable to the presentations of the use cases from Chapter~\ref{chap:requirements}. Furthermore, all of the formalisms only take into account interpretation extra state, while disregarding presentation extra state. And finally, only \cite{meertens98maintainers} deals explicitly with a layered presentation relation. 

%\note{also say that \law{Imprecise} is not handled?}

%\todo{?}
%** more on incrementality, also more lazy pres. evaluation only send request when info is needed. (maybe More impl than spec.)


%\bl
%\o all are just simple functions, map, zip, dup, etc. Nothing scaleable yet. None address layered architecture
%\o Lambert: combinators for specifying maintainers. no expl. model for es 
%\o Pierce  extra stuff only in one direction.
%\o Finally, a small functional language is. not clear how to scale, plus extra state only in one direction.
%\el


%We try to define what's a natural editor
%New things may break old. But parts remain valid

%Conditions: maybe weaker ones are possible. these are for the most general case.

An important area of future research lies in the development of a presentation language that is powerful enough to specify all use cases, and which automatically constructs $\interpret$. Because an efficient inverse cannot always be computed automatically, complex parts of the presentation can be annotated, whereas for simpler presentations $\interpret$ is constructed automatically. Until such a language has been developed, it is up to the implementor to guarantee correctness of the editor.


% restore old defs from thesis.sty


\endinput

\pagebreak
\section{Appendix with nasty proofs}



A combined layer defines two relations ($Present\C$ and $Interpret\C $) from four component relations ($Present\H$, $Present\L$, $Interpret\H$, and $Interpret\L$):

\xpr{
Present\C = Present\L \oo Present\H\\
Interpret\C = Interpret\H \oo Interpret\L\\
}

We know that the four component relations are mappings between equivalence classes: 

\xpr{
\present\H   &\tp& \Eqcl{\Level\H}{HH} \rightarrow  \Eqcl{\Level\M}{HL} ~~~\text{and}~~~
\present\L    &\tp& \Eqcl{\Level\M}{LH} \rightarrow  \Eqcl{\Level\L}{LL}\\
\interpret\H   &\tp& \Eqcl{\Level\M}{HL} \rightarrow  \Eqcl{\Level\H}{HH} ~~~\text{and}~~~
\interpret\L   &\tp& \Eqcl{\Level\L}{LL} \rightarrow  \Eqcl{\Level\M}{LH}\\
}

And we also wish to regard the combinations as mappings between equivalence classes:

\xpr{
\present\C &\tp& \Eqcl{\Level\H}{CH} \rightarrow  \Eqcl{\Level\L}{CL}~~~\text{and}~~~
\interpret\C &\tp&  \Eqcl{\Level\L}{CL} \rightarrow \Eqcl{\Level\H}{CH}\\
}

However, the counter-example from Section~\ref{sect:combinedExtraCompose} shows this is not necessarily true.

If we want to regard the combination as an equivalence class mapping, two things need to hold:

Firstly, $Present\C$ must induce an equivalence relation $CH_{\, \mathrm P}$ on $Level\H$ and a relation $CL_{\, \mathrm P}$ on the valid subset of $\Level\L$. Analogously, $Interpret\C$ must induce an equivalence relation $CH_{\, \mathrm I}$ on $Level\H$ and $CL_{\, \mathrm I}$ on $Level\L$ (including the subset that is not valid).

Secondly, the equivalence relations induced by $Present\C$ must be equal to the relations induced by $Interpret\C$. Hence, we need $CH_{\, \mathrm P} = CH_{\, \mathrm I}$, as well as  $CL_{\, \mathrm P} = CL_{\, \mathrm I}$ for the valid subset of $Level\L$.

The two conditions below guarantee this.

\xprlab{
\eqcl{h}{HH} = \interpret\H~\eqcl{m_0}{HL} \land \eqcl{h'}{HH} = \interpret\H~\eqcl{m'_0}{HL} \land\\
\eqcl{h}{HH} = \interpret\H~\eqcl{m_1}{HL} \land \eqcl{m_0}{LH} = \eqcl{m'_0}{LH} \\ 
\imp ~~ \exists m'_1 : \eqcl{h'}{HH} = \interpret\H~\eqcl{m'_1}{HL} \land \eqcl{m'_1}{LH} = \eqcl{m_1}{LH}
}{$~~\interpret$-Match}


\xprlab{
\eqcl{h}{HH} = \interpret\H~\eqcl{m_0}{HL} \land \eqcl{h'}{HH} = \interpret\H~\eqcl{m'_0}{HL} \land\\
\eqcl{m_1}{HL}= \present\H~\eqcl{h}{HH} \land \eqcl{m_0}{LH} = \eqcl{m'_0}{LH} \\ 
\imp ~~ \exists m'_1 : \eqcl{m'_1}{HL} = \present\H~\eqcl{h'}{HH} \land \eqcl{m'_1}{LH} = \eqcl{m_1}{LH}\\
}{$\present$-Match}

In Section~\ref{sect:combinedExtra} we use a more readable equivalent version of these two conditions, which we denote using the suffix \law{-Nice} in this appendix. Both conditions use an auxiliary function $\mathcal{I}$:

\xprlab{
\mathcal{I} \tp Level\M \tp \powerset Level\H \\
\mathcal{I}~m = \setof{h}{\exists m' \in \eqcl{m}{LH} : \eqcl{h}{HH} = \interpret\H~\eqcl{m'}{HL} }
}{$\mathcal{I}$-Def}


\xprlab{
h,h' \in \mathcal{I}~m \land  \eqcl{h}{HH} = \interpret\H~\eqcl{m'}{HL} \imp\\
\exists m'' \in \eqcl{m'}{LH} : \eqcl{h'}{HH} = \interpret\H~\eqcl{m''}{HL} \\
}{$\interpret$-Match-Nice}

and

\xprlab{
h,h' \in \mathcal{I}~m \land \eqcl{m'}{HL}= \present\H~\eqcl{h}{HH}  \imp\\
\exists m'' \in \eqcl{m'}{LH} : \eqcl{m''}{HL} = \present\H~\eqcl{h'}{HH} \\
}{$\present$-Match-Nice}


The stronger condition \law{Absorption} implies both.

\xprlab{
\eqcl{m}{LH} = \eqcl{m'}{LH} ~\imp~ \eqcl{m}{HL} = \eqcl{m'}{HL}}{Absorption}

\law{Absorption} also implies \law{Orthogonal}, which is needed in Section~\ref{sect:combinedExtraEditing} for \law{Doc-Inert}.


The next sections contain the proofs of these statements:

\begin{itemize}
\item $R$ induces an equivalence class mapping  iff $x~R~y \land x~R~y' \land x'~R~y \imp x'~R~y'$ (Section~\ref{sect:relIsEqClassMapping})
\item $Present\C$ and $Interpret\C$ induce equivalence class mappings. (Section~\ref{eqclassMappings})
\item Equivalence relations of $Present\C$ are equal to those of $Interpret\C$. (Section~\ref{presIntrEqual})
\item \law{Absorption} implies  \law{$\interpret$-Match}, \law{$\present$-Match}, and \law{Orthogonal}. (Section~\ref{absorptionImplies})
\item The (Section~\ref{sect:friendlier})
\end{itemize}
 

\toHere
*** UNCLEAR ***

\bl
\o $\Present\L$ also defines equivalence classes on invalid part of $Level\L$. What to do with these?
\o do we need to split the $\interpret$ lower classes which contain both valid and invalid elements? Otherwise $present$'s class for a valid element will not be equal to $\interpret$'s.
\o Prove the following?
\o $h' \in \eqcl{h}{HH} \imp h' \in \eqcl{h}{CH^P}$
\o $h' \in \eqcl{h}{HH} \imp h' \in \eqcl{h}{CH^P}$
\o $l' \in \eqcl{l}{LL} \imp l' \in \eqcl{l}{CL^I}$
\o $l' \in \eqcl{l}{LL} \imp l' \in \eqcl{l}{CL^I}$
\el


%comment: keep things separated unless they have to be eq. because of some rule.
\fromHere
\section{Equivalence classes}\label{sect:relIsEqClassMapping}

\note{Check this for partial eq. class on lower level.}

In this section, we show that a relation $R$:

$R \tp X \rel Y$ ($X$ is range, $Y$ is domain, so $x~R~y$ looks like $x = f~y$ for $f \tp Y \to X$) is total and surjective.

can be represented by a function $f \tp \Eqcl{Y}{H} \to \Eqcl{X}{L}$:

\xpr{
\eqcl{x}{L} = f~\eqcl{y}{H}~\eqv~x~R~y
}

if and only if the following condition holds:

\xprlab{
x~R~y \land x~R~y' \land x'~R~y \imp x'~R~y'\\
}{EqMap}

First, we show that \law{EqMap} implies the existence of a mapping $f$ (in Section~\ref{sect:EqMapImpMapping}), and then we show that the existence of $f$ implies \law{EqMap} (in Section~\ref{sect:MappingImpEqMap}).

\subsection{\law{EqMap} implies existence of equivalence class mapping}\label{sect:EqMapImpMapping}


\head{$R$ induces equivalence relations $H$ and $L$}

We define the equivalence relations $H$ and $L$ as:

\xpr{
x~L~x' \is \exists y: x~R~y \land x'~R~y\\
}
\xpr{
y~H~y' \is \exists x :  x~R~y \land x~R~y'\\
}

We prove that $H$ and $L$ are equivalence relations:

\begin{proof}

Reflexivity: $x~L~x$

\begin{Prf}&
	x~L~x\\
\Eqv{definition of $L$} &
	\exists y: x~R~y \land x~R~y\\
\Eqv{surjectivity of $R$} &
	\true\\
\end{Prf}

Symmetry: $x~L~x' ~\imp x'~L~x$

\begin{Prf}&
	x'~L~x\\
\Eqv{definition of $L$} &
	\exists y: x'~R~y \land x~R~y\\
\Eqv{commutativity of $\land$} &
	\exists y: x~R~y \land x'~R~y\\
\Eqv{definition of $L$} &
	x~L~x'\\
\end{Prf}


Transitivity: $x~L~y \land y~L~z ~\imp x~L~z$

\begin{Prf}&
	x~L~x''\\
\Eqv{definition of $L$} &
	\exists y: x~R~y \land x''~R~y\\
\Ffr{take $y = y_0'$} &
	x~R~y_0' \land x''~R~y_0'\\
\Ffr{\law{EqMap} for $x'~R~y_0 \land x'~R~y_0' \land x~R~y_0$ } &
	x~R~y_0 \land x'~R~y_0 \land x'~R~y_0' \land x''~R~y_0'\\
\Ffr{let $y_0,y_0'$ be the $y,y$ from the quantifications} &
	(\exists y: x~R~y \land x'~R~y) \land (\exists y: x'~R~y \land x''~R~y)\\
\Eqv{definition of $L$} &
	x~L~x' \land x'~L~x'' \\
\end{Prf}



Reflexivity: $y~H~y$

\begin{Prf}&
	y~H~y\\
\Eqv{definition of $H$} &
	\exists x: x~R~y \land x~R~y\\
\Eqv{totality of $R$} &
	\true\\
\end{Prf}

Symmetry: $y~H~y' ~\imp y'~H~y$

\begin{Prf}&
	y'~H~y\\
\Eqv{definition of $H$} &
	\exists x: x~R~y' \land x~R~y\\
\Eqv{commutativity of $\land$} &
	\exists x: x~H~y \land x~H~y'\\
\Eqv{definition of $H$} &
	y~H~y'\\
\end{Prf}

Transitivity: $x~L~y \land y~L~z ~\imp x~L~z$

\begin{Prf}&
	x~H~x''\\
\Eqv{definition of $H$} &
	\exists x: x~R~y \land x~R~y''\\
\Ffr{take $x = x_0'$} &
	x_0'~R~y \land x_0'~R~y''\\
\Ffr{\law{EqMap} for $x_0~R~y' \land x_0~R~y \land x_0'~R~y'$ } &
	x_0~R~y \land x_0~R~y' \land x_0'~R~y' \land x_0'~R~y''\\
\Ffr{let $x_0,x_0'$ be the $x,x$ from the quantifications} &
	(\exists x: x~R~y \land x~R~y') \land (\exists x: x~R~y' \land x~R~y'')\\
\Eqv{definition of $H$} &
	y~H~y' \land y'~H~y'' \\
\end{Prf}
\end{proof}

\head{$R$ induces a function $f \tp \Eqcl{Y}{H} \to \powerset X$}

We can define a function $f$:

\xpr{ 
f \tp \Eqcl{Y}{H} \to \powerset X\\
f~\eqcl{y}{H} \is \setof{x}{x~R~y}\\
}{$f$-Def}

The definition is only valid if:

\xpr{
y~H~y' ~\imp~ \setof{x}{x~R~y} = \setof{x}{x~R~y'}
}

\bc
\xpr{
y~H~y' ~\imp~ (x\in \setof{x}{x~R~y} \imp x \in \setof{x}{x~R~y'}) \land (x\in \setof{x}{x~R~y'} \imp x \in \setof{x}{x~R~y})\\
}

We get two:

\xpr{
y~H~y' ~\imp~ (x\in \setof{x}{x~R~y} \imp x \in \setof{x}{x~R~y'}) \land \\
y~H~y' ~\imp~  (x\in \setof{x}{x~R~y'} \imp x \in \setof{x}{x~R~y})\\
}
Only prove the first conjunct, the second follows immediately from symmetry of $H$. Rewrite it to:
\ec

\bc
To prove validity, we need this property:

\xpr{
y~H~y' \land x \in \setof{x}{x~R~y} \imp x \in \setof{x}{x~R~y'}

\begin{proof}
\begin{Prf}&
	x \in \setof{x}{x~R~y'}\\
\Eqv{property of set comprehension} &
	x~R~y'\\
\Ffr{\law{EqMap}} &
	x_0~R~y \land x_0~R~y' \land x~R~y\\
\Ffr{let $x_0$ be the $x$ from the quantification} &
	(\exists x: x~R~y \land x~R~y') \land x~R~y\\
\Eqv{definition of $H$} &
	y~H~y' \land x~R~y\\
\Eqv{property of set comprehension} &
	y~H~y' \land x \in \setof{x}{x~R~y}\\
\end{Prf}
\end{proof}

\begin{Prf} &
	y~H~y' ~\imp~ \setof{x}{x~R~y} = \setof{x}{x~R~y'}\\
\Eqv{calculus (?)} &
	y~H~y' ~\imp~ ((x'\in \setof{x}{x~R~y} \imp x \in \setof{x'}{x~R~y'}) \land (x''\in \setof{x}{x~R~y'} \imp x'' \in \setof{x}{x~R~y}))\\
\Eqv{propositional calculus} &
	y~H~y' \imp (x'\in \setof{x}{x~R~y} \imp x' \in \setof{x}{x~R~y'}) \land
	y~H~y' \imp (x''\in \setof{x}{x~R~y} \imp x'' \in \setof{x}{x~R~y'})\\
\Eqv{propositional calculus} &
	y~H~y' \land x' \in \setof{x}{x~R~y} \imp x' \in \setof{x}{x~R~y'} \land
	y~H~y' \land x'' \in \setof{x}{x~R~y} \imp x'' \in \setof{x}{x~R~y'}\\
\Eqv{symmetry of $H$} &
	y~H~y' \land x' \in \setof{x}{x~R~y} \imp x' \in \setof{x}{x~R~y'} \land
	y'~H~y \land x'' \in \setof{x}{x~R~y} \imp x'' \in \setof{x}{x~R~y'}\\
\Eqv{two times the property proven above} &
	\true\\
\end{Prf}
\ec
In the proof, we need this property:

\xpr{
y~H~y' \imp (x \in \setof{x}{x~R~y} \imp x \in \setof{x}{x~R~y'})
}

\begin{proof} 
By propositional calculus, the property is equivalent to:

\xpr{
y~H~y' \land x \in \setof{x}{x~R~y} \imp x \in \setof{x}{x~R~y'}
}

\begin{Prf}&
	x \in \setof{x}{x~R~y'}\\
\Eqv{property of set comprehension} &
	x~R~y'\\
\Ffr{\law{EqMap}} &
	x_0~R~y \land x_0~R~y' \land x~R~y\\
\Ffr{let $x_0$ be the $x$ from the quantification} &
	(\exists x: x~R~y \land x~R~y') \land x~R~y\\
\Eqv{definition of $H$} &
	y~H~y' \land x~R~y\\
\Eqv{property of set comprehension} &
	y~H~y' \land x \in \setof{x}{x~R~y}\\
\end{Prf}
\end{proof}


The proof of validity:

\begin{Prf} &
	\setof{x}{x~R~y} = \setof{x}{x~R~y'}\\
\Eqv{calculus (?)} &
	((x'\in \setof{x}{x~R~y} \imp x \in \setof{x'}{x~R~y'}) \land (x''\in \setof{x}{x~R~y'} \imp x'' \in \setof{x}{x~R~y}))\\
\Eqv{propositional calculus} &
	x' \in \setof{x}{x~R~y} \imp x' \in \setof{x}{x~R~y'} \land
	x'' \in \setof{x}{x~R~y} \imp x'' \in \setof{x}{x~R~y'}\\
\Ffr{two times the property proven above} &
	y~H~y' \land 	y'~H~y\\
\Eqv{symmetry of $H$} &
	y~H~y' \land y~H~y'\\
\Eqv{idempotency of $\land$} &
	y~H~y'\\
\end{Prf}

\head{result of $f$ is also an equivalence class: $f \tp \Eqcl{Y}{H} \to \Eqcl{X}{L}$}

Each resulting set $f~\eqcl{y}{H}$ corresponds to an equivalence class of $L$:

\xpr{
x \in f~\eqcl{y}{H} ~\eqv~\eqcl{x}{L} = f~\eqcl{y}{H}
}{$f$-Eq}

%x~L~x' \is \exists y: x~R~y \land x'~R~y\\
We prove both directions:

$x \in f~\eqcl{y}{H} ~\imp~\eqcl{x}{L} = f~\eqcl{y}{H}$:

\begin{proof} assume $\eqcl{x}{L} = f~\eqcl{y}{H}$
\begin{Prf}&
	x \in f~\eqcl{y}{H}\\
\Equ{assumption} &
	x \in \eqcl{x}{L}\\
\Eqv{\law{$\eqhole$-Member}} &
	\eqcl{x}{L} = \eqcl{x}{L}\\
\Eqv{symmetry of $=$} &
	\true\\
\end{Prf}
\end{proof}


And $x \in f~\eqcl{y}{H} ~\imp~\eqcl{x}{L} = f~\eqcl{y}{H}$

\begin{proof} assume $x \in f~\eqcl{y}{H}$

And hence
\begin{Prf}&
	x~R~y\\
\Eqv{property of set comprehension} &
	x \in \setof{x}{x~R~y}\\
\Eqv{\law{$f$-Def}} &
	x \in f~\eqcl{y}{H}\\
\end{Prf}

we prove $x'' \in f~\eqcl{y}{H} \imp x'' \in \setof{x'}{x'~L~x}$
\begin{Prf}&
	x'' \in \setof{x'}{x'~L~x}\\
\Eqv{\law{$f$-Def}} &
	x'' \in \setof{x'}{\exists y: x~R~y \land x'~R~y}\\
\Eqv{property of set comprehension} &
	\exists y: x~R~y \land x''~R~y\\
\Ffr{assumption + take $y=y$} &
	x''~R~y\\
\Eqv{property of set comprehension} &
	x'' \in \setof{x}{x~R~y}\\
\Eqv{\law{$f$-Def}} &
	x'' \in f~\eqcl{y}{H}\\
\end{Prf}

and $x'' \in f~\eqcl{y}{H} \ffr x'' \in \setof{x'}{x'~L~x}$
\begin{Prf}&
	x'' \in f~\eqcl{y}{H}\\
\Eqv{\law{$f$-Def}} &
	x'' \in \setof{x}{x~R~y}\\
\Eqv{property of set comprehension} &
	x''~R~y\\
\Ffr{assumption + \law{EqMap} ($x~R~y_0 \land x~R~y \land x''~R~y_0 \imp x''~R~y$)} &
	x~R~y_0 \land x''~R~y_0\\
\Ffr{let $y_0$ be the $y$ from the quantification} &
	\exists y: x~R~y \land x''~R~y\\
\Eqv{property of set comprehension} &
	x'' \in \setof{x'}{\exists y: x~R~y \land x'~R~y}\\
\Eqv{\law{$f$-Def}} &
	x'' \in \setof{x'}{x'~L~x}\\
\end{Prf}
\end{proof}




% old condition
%\xpr{
%x \in f~\eqcl{y}{H} ~\eqv~\eqcl{x}{L} = f~\eqcl{y}{H}
%}

\head{$R$ can be expressed as a mapping between equivalence classes}

\xpr{
\eqcl{x}{L} = f~\eqcl{y}{H}~\eqv~x~R~y
}

\begin{proof}
\begin{Prf}&
	\eqcl{x}{L} = f~\eqcl{y}{H}\\
\Eqv{ \law{$f$-Eq} } &
	x \in f~\eqcl{y}{H}\\
\Eqv{\law{$f$-Def}} &
	x \in \setof{x}{x~R~y}\\
\Eqv{property of set comprehension} &
	x~R~y\\
\end{Prf}
\end{proof}


\subsection{existence of equivalence class mapping implies \law{EqMap} } \label{sect:MappingImpEqMap}

We show that the negation of \law{EqMap} implies non-existance of the equivalence class mapping. 

Suppose we do have such a mapping: $\eqcl{x}{L} = f~\eqcl{y}{H} ~\eqv~ x~R~y$, then the negation of \law{EqMap} leads to a contradiction.

\begin{Prf} &
	\false\\
\Ffr{propositional calculus} &
	\eqcl{x_0'}{L} = f~\eqcl{y_0'}{H} \land \eqcl{x_0'}{L} \neq f~\eqcl{y_0'}{H} \\
\Ffr{Leibniz} &
	\eqcl{x_0}{L} = \eqcl{x_0'}{L} \land \eqcl{x_0}{L} = f~\eqcl{y_0'}{H} \land \eqcl{x_0'}{L} \neq f~\eqcl{y_0'}{H} \\
\Ffr{transitivity of $=$} &
	\eqcl{x_0}{L} = f~\eqcl{y_0}{H} \land \eqcl{x_0}{L} = f~\eqcl{y_0'}{H} \land \eqcl{x_0'}{L} = f~\eqcl{y_0}{H} \land 
	\eqcl{x_0'}{L} \neq f~\eqcl{y_0'}{H} \\
\Eqv{assumption} &
	x_0~R~y_0 \land x_0~R~y_0' \land x_0'~R~y_0 \land \lnot (x_0'~R~y_0')\\
\Eqv{propositional calculus} &
	\lnot( \lnot(x_0~R~y_0 \land x_0~R~y_0' \land x_0'~R~y_0) \lor x_0'~R~y_0')\\
\Eqv{propositional calculus} &
	\lnot( x_0~R~y_0 \land x_0~R~y_0' \land x_0'~R~y_0 \imp x_0'~R~y_0')\\
\Ffr{let $x_0,y_0,x_0',y_0'$ be the $x,y,x',y'$ from the quantification} &
	\exists x,y,x',y' : \lnot( x~R~y \land x~R~y' \land x'~R~y \imp x'~R~y')\\
\Eqv{predicate calculus} &
	\lnot(\forall x,y,x',y' : x~R~y \land x~R~y' \land x'~R~y \imp x'~R~y')\\
\end{Prf}



\section{Definitions}

Formal definition of $\valid$:

\xprlab{
\valid~l ~~\eqv~~ \exists h : \eqcl{l}{L}= \present~\eqcl{h}{H}\\
}{\valid-Def}

Pointwise definitions of combined mapping functions (follow directly from definition of relation composition):

\xprlab{
l~\Present\C~h \eqv \exists m : l~\Present\L~m \land m~\Present\H~h\\
}{$Present\C$-Def}
\xprlab{
h~\Interpret\C~l \eqv \exists m : h~\Interpret\H~m \land m~\Interpret\L~l\\
}{$Interpret\C$-Def}


\section{$Interpret$ and $Present$ are equivalence class mappings}\label{eqclassMappings}


\note{is interpret class for valid elt bigger than present's class? if so, then if S = present h, it is not okay to say interpret S split classes in interpret (for valid/ invalid)?}

From section~\ref{sect:relIsEqClassMapping}, we know that if we want to consider a relation $R$ as a mapping between equivalence classes, $R$ must be total and surjective, and the following minimal condition must hold:

\xpr{
l~R~h \land l~Present~h' \land l'~Present~h \imp l'~Present~h'\\
}


Thus, if we want to consider $Present$ as a mapping between equivalence classes, we need:


\xpr{
l~Present~h \land l~Present~h' \land l'~Present~h \imp l'~Present~h'\\
}

And likewise, for $Interpret$:

\xpr{
l~Interpret~h \land l~Interpret~h' \land l'~Interpret~h \imp l'~Interpret~h'\\
}

\note{for interpret only on valid part, but this does not change the condition}


\subsection{$Present$ is an equivalence class mapping}

$Present$ is an equivalence class mapping only if this holds:

\xpr{
h~Present~l \land h~Present~l' \land h'~Present~l \imp h'~Present~l'\\
}

We can prove it if we assume \law{$\present$-Match}. However, it has not been established that \law{$\present$-Match} is the minimal condition.

\begin{proof}
\begin{Prf}&
	l'~Present~h'\\
\Ffr{\law{$\Present\C$-Def}+ take $m=m'_2$}&
	l'~\Present\L~m'_2 \land m'_2~\Present\H~h'\\
\Eqv{two times \law{$\present$-Char}} &
	\eqcl{l'}{LL} = \present\L~\eqcl{m'_2}{LH} \land \eqcl{m'_2}{HL} = \present\H~\eqcl{h'}{HH}\\ 
\Ffr{Leibniz} &
	\eqcl{m'_2}{HL} = \present\H~\eqcl{h'}{HH} \land \eqcl{m'_2}{LH} = \eqcl{m_1}{LH} \land\\
&	\eqcl{l'}{LL} = \present\L~\eqcl{m_1}{LH} \\
\Ffr{let $m'_2$ be the $m'_1$ from the quantification}&
	(\exists m'_1 : \eqcl{m'_1}{HL} = \present\H~\eqcl{h'}{HH} \land \eqcl{m'_1}{LH} = \eqcl{m_1}{LH})\land \\
&	\eqcl{l'}{LL} = \present\L~\eqcl{m_1}{LH} \\ 
\Ffr{\law{$\present$-Match}}&
	\eqcl{m_0}{LH} = \eqcl{m_0'}{LH} \land \eqcl{h}{HH} = \interpret\H~\eqcl{m_0}{HL} \land \\ 
&	\eqcl{l'}{LL} = \present\L~\eqcl{m_1}{LH} \land \eqcl{m_1}{HL} = \present\H~\eqcl{h}{HH} \land \\
&	\eqcl{h'}{HH} = \interpret\H~\eqcl{m_0'}{HL}\\ 
\Ffr{Transitivity of $=$}&
	\eqcl{m_0}{LH} = \interpret\L~\eqcl{l}{LL} \land \eqcl{h}{HH} = \interpret\H~\eqcl{m_0}{HL} \land \\
&	\eqcl{l'}{LL} = \present\L~\eqcl{m_1}{LH} \land \eqcl{m_1}{HL} = \present\H~\eqcl{h}{HH} \land \\
&	\eqcl{m_0'}{LH} = \interpret\L~\eqcl{l}{LL} \land \eqcl{h'}{HH} = \interpret\H~\eqcl{m_0'}{HL}\\ 
\Ffr{\law{InterPresent}}&
	\eqcl{l}{LL} = \present\L~\eqcl{m_0}{LH} \land \eqcl{m_0}{HL} = \present\H~\eqcl{h}{HH} \land \\
&	\eqcl{l'}{LL} = \present\L~\eqcl{m_1}{LH} \land \eqcl{m_1}{HL} = \present\H~\eqcl{h}{HH} \land \\
&	\eqcl{l}{LL} = \present\L~\eqcl{m_0'}{LH} \land \eqcl{m_0'}{HL} = \present\H~\eqcl{h'}{HH}\\ 
\Eqv{six times \law{$\present$-Char}} &
	l~\Present\L~m_0 \land m_0~\Present\H~h \land
	l'~\Present\L~m_1 \land m_1~\Present\H~h \land \\ &
	l~\Present\L~m_0' \land m_0'~\Present\H~h'\\
\Ffr{\law{$\Present\C$-Def} + $m_0,m'_0,m_1$ from quantifications}&
	l~Present~h \land l'~Present~h \land l~Present~h'\\
\end{Prf}
\end{proof}



\subsection{$Interpret$ is an equivalence class mapping}

$Interpret$ is an equivalence class mapping only if this holds:

\xpr{
h~Interpret~l \land h~Interpret~l' \land h'~Interpret~l \imp h'~Interpret~l'\\
}

Similar to the previous section, we can prove it if we assume \law{$\interpret$-Match}, but again it is not certain that it is the minimal condition.

\begin{proof}
\begin{Prf}&
	h'~Interpret~l'\\
\Ffr{\law{$\Interpret\C$-Def}+ take $m=m'_1$}&
	h'~\Interpret\H~m'_1 \land m'_1~\Interpret\L~l'\\
\Eqv{two times \law{$\interpret$-Char}} &
	\eqcl{h'}{HH} = \interpret\H~\eqcl{m'_1}{HL} \land \eqcl{m'_1}{LH} = \interpret\L~\eqcl{l'}{LL}\\ 
\Ffr{Transitivity of $=$}&
	\eqcl{h'}{HH} = \interpret\H~\eqcl{m'_1}{HL} \land \eqcl{m'_1}{LH} = \eqcl{m_1}{LH} \land \eqcl{m_1}{LH} = \interpret\L~\eqcl{l'}{LL}\\ 
\Ffr{\law{$\interpret$-Match}}&
	\eqcl{h}{HH} = \interpret\H~\eqcl{m_0}{HL} \land \eqcl{m_0}{LH} = \eqcl{m'_0}{LH} \land \\ &
	\eqcl{h'}{HH} = \interpret\H~\eqcl{m'_0}{HL} \land \\ &
	\eqcl{h}{HH} = \interpret\H~\eqcl{m_1}{HL} \land \eqcl{m_1}{LH} = \interpret\L~\eqcl{l'}{LL}\\ 
\Ffr{Transitivity of $=$}&
	\eqcl{h}{HH} = \interpret\H~\eqcl{m_0}{HL} \land \eqcl{m_0}{LH} = \interpret\L~\eqcl{l}{LL} \land \\ &
	\eqcl{h'}{HH} = \interpret\H~\eqcl{m'_0}{HL} \land \eqcl{m'_0}{LH} = \interpret\L~\eqcl{l}{LL} \land \\ &
	\eqcl{h}{HH} = \interpret\H~\eqcl{m_1}{HL} \land \eqcl{m_1}{LH} = \interpret\L~\eqcl{l'}{LL}\\ 
\Eqv{six times \law{$\interpret$-Char}} &
	h~\Interpret\H~m_0 \land m_0~\Interpret\L~l \land h'~\Interpret\H~m'_0 \land m'_0~\Interpret\L~l \land \\ &
	 h~\Interpret\H~m_1 \land m_1~\Interpret\L~l'\\
\Ffr{\law{$\Interpret\C$-Def} + $m_0,m'_0,m_1$ from quantifications}&
	h~Interpret~l \land h'~Interpret~l \land h~Interpret~l'\\
\end{Prf}
\end{proof}





\section{Classes implied by $Present$ and $Interpret$ are equal}\label{presIntrEqual}

Relations $Present$ and $Interpret$ both induce equivalence classes on $Level_H$, and the valid part of $Level_L$.
	
	
Higher classes induced by $\Present$:
\xpr{
\eqcl{h}{H} = \setof{h'}{\exists l : l~\Present\C~h \land l~\Present\C~h'}\\
}

Higher classes induced by $\Interpret$:
\xpr{
\eqcl{h}{H} = \setof{h'}{\exists l : h~\Interpret\C~l \land h'~\Interpret\C~l}\\
}

Lower classes induced by $\Present$:
\xpr{
\eqcl{l}{L} = \setof{l'}{\exists h : l~\Present\C~h \land l'~\Present\C~h}
}

Lower classes induced by $\Interpret$:
\xpr{
\eqcl{l}{L} = \setof{l'}{\exists h,h',h'' : h~\Interpret\C~l \land h~\Interpret\C~l' \land l~\Present\C~h' \land l'~\Present\C~h''}
}

Section~\ref{sect:combinedExtra} assumes that the equivalence relations for $Level_H$ are equal, and that for the lower level, they are equal for the valid subset of $Level_L$.


\subsection{Higher level equivalence classes equal}

The equivalence classes induced by $Present$ must be the same as those induced by $Interpret$:


\xpr{
\forall h : \setof{h'}{\exists l : l~\Present\C~h \land l~\Present\C~h'} \equ
\setof{h'}{\exists l : h~\Interpret\C~l \land h'~\Interpret\C~l}
}

We prove the two directions separately. In the proof, we need \law{InterPresent} on the combined relation:  
$l~\Present\C~h \imp h~\Interpret\C~l$.

\begin{proof}
\begin{Prf}&
        h~\Interpret\C~l\\
\Eqv{Def. $\Interpret\C$ (and commutativity of $\land$)}&
        \exists m : m~\Interpret\L~l \land h~\Interpret\H~m\\
\Eqv{\law{\interpret-Char}}&
        \exists m : \eqcl{m}{LH} = \interpret\L~\eqcl{l}{LL} \land \eqcl{h}{HH} = \interpret\H~\eqcl{m}{HL}\\
\Ffr{\law{InterPresent} on $\present\L$ and $\present\H$} &
        \exists m : \eqcl{l}{LL} = \present\L~\eqcl{m}{LH} \land \eqcl{m}{HL} = \present\H~\eqcl{h}{HH}\\
\Eqv{\law{\present-Char}}&
        \exists m : l~\Present\L~m \land m~\Present\H~h\\
\Eqv{Def. $\Present\C$}&
        l~\Present\C~h\\
\end{Prf}
\end{proof}


\head{Higher class from $Present$ $\subset$ class from $Interpret$}

$h' \in \setof{h'}{\exists l : l~\Present\C~h \land l~\Present\C~h'}$\\
$\imp$\\
$h' \in \setof{h'}{\exists l : h~\Interpret\C~l \land h'~\Interpret\C~l}$


\begin{proof}
\begin{Prf}&
	h' \in \setof{h'}{\exists l : h~\Interpret\C~l \land h'~\Interpret\C~l}\\
\Eqv{property of set comprehension, , take $l = l_0$}&
	h~\Interpret\C~l_0 \land h'~\Interpret\C~l_0\\
\Ffr{\law{Interpresent} twice}&
	l_0~\Present\C~h \land l_0~\Present\C~h'\\
\Eqv{property of set comprehension + let $l_0$ be the l from the quantification}&
	h' \in \setof{h'}{\exists l : l~\Present\C~h \land l~\Present\C~h'}\\
\end{Prf}
\end{proof}

\head{Higher class from $Present$ $\supset$ class from $Interpret$}

$h' \in \setof{h'}{\exists l : l~\Present\C~h \land l~\Present\C~h'}$\\
$\ffr$\\
$h' \in \setof{h'}{\exists l : h~\Interpret\C~l \land h'~\Interpret\C~l}$

\begin{proof}
\begin{Prf}&
	h' \in \setof{h'}{\exists l : l~\Present\C~h \land l~\Present\C~h'}\\
\Ffr{property of set comprehension + take $l = l_1$}&
	l_1~\Present\C~h \land l_1~\Present\C~h'\\
\Eqv{\law{$\Present\C$-Def}}&
	(\exists m : l_1~\Present\L~m \land m~\Present\H~h) \land (\exists m : l_1~\Present\L~m \land m~\Present\H~h')\\
\Ffr{{\sc \present-Char} on $\present\H$ and $\present\L$, take $m,m=m_1,m'_2$}&
%	\eqcl{l_1}{LL} = \present\L~\eqcl{m_1}{LH} \land \eqcl{m_1}{HL} = \present\H~\eqcl{h}{HH} \land 
%	\eqcl{l_1}{LL} = \Present\L~\eqcl{m'_1}{LH} \land \eqcl{m'_1}{HL} = \present\H~\eqcl{h'}{HH}\\
%\Imp{}&
	\eqcl{m_1}{HL}= \present\H~\eqcl{h}{HH} \land \eqcl{m'_2}{HL} = \present\H~\eqcl{h'}{HH} \land \\
&	\eqcl{l_1}{LL}= \present\L~\eqcl{m_1}{LH} \land \eqcl{l_1}{LL}= \present\L~\eqcl{m'_2}{LH}\\ 
\Ffr{transitivity of $=$}&
	\eqcl{m_1}{HL}= \present\H~\eqcl{h}{HH} \land \eqcl{m'_2}{HL} = \present\H~\eqcl{h'}{HH} \land \eqcl{m'_2}{LH} = \eqcl{m_1}{LH} \land  \\
&	\eqcl{l_1}{LL}= \present\L~\eqcl{m_1}{LH}\\ 
\Ffr{totality of $\present\L$ + let $l_1$ be the $l$ from the quantification}&
	\eqcl{m_1}{HL}= \present\H~\eqcl{h}{HH} \land \eqcl{m'_2}{HL} = \present\H~\eqcl{h'}{HH} \land \eqcl{m'_2}{LH} = \eqcl{m_1}{LH} \\ 
\Ffr{let $m'_2$ be the $m'_1$ from the quantification}&
	\eqcl{m_1}{HL}= \present\H~\eqcl{h}{HH}  \land (\exists m'_1 : \eqcl{m'_1}{HL} = \present\H~\eqcl{h'}{HH} \land \eqcl{m'_1}{LH} = \eqcl{m_1}{LH}) \\ 
\Ffr{\law{$\present$-Match}}&
	\eqcl{h}{HH} = \interpret\H~\eqcl{m_0}{HL} \land \eqcl{h'}{HH} = \interpret\H~\eqcl{m'_0}{HL} \land \eqcl{m_0}{LH} = \eqcl{m'_0}{LH} \\
&	\eqcl{m_1}{HL}= \present\H~\eqcl{h}{HH} \\ 
\Ffr{totality of $\present\H$ + let $m_1$ be the $m$ from the quantification}&
	\eqcl{h}{HH} = \interpret\H~\eqcl{m_0}{HL} \land \eqcl{h'}{HH} = \interpret\H~\eqcl{m'_0}{HL} \land \eqcl{m_0}{LH} = \eqcl{m'_0}{LH} \\
\Ffr{transitivity of $=$}&
	\eqcl{h}{HH} = \interpret\H~\eqcl{m_0}{HL} \land \eqcl{m_0}{LH} = \interpret\L~\eqcl{l_0}{LL} \land\\
& 	\eqcl{h'}{HH} = \interpret\H~\eqcl{m'_0}{HL} \land \eqcl{m'_0}{LH} = \interpret\L~\eqcl{l_0}{LL} \\
\Ffr{{\sc \interpret-Char} on $\interpret\H$ and $\interpret\L$ + let $m_0, m'_0$ be the $m, m'$ from the quantification}&
	(\exists m : h~\Interpret\H~m \land m~\Interpret\L~l_0) \land
	(\exists m' : h'~\Interpret\H~m' \land m'~\Interpret\L~l_0)\\
\Eqv{\law{$\Interpret\C$-Def}}&
	h~\Interpret\C~l_0 \land h'~\Interpret\C~l_0\\
\Ffr{property of set comprehension + let $l_0$ be the $l$ from the quantification}&
	h' \in \setof{h'}{\exists l : h~\Interpret\C~l \land h'~\Interpret\C~l}\\
\end{Prf}
\end{proof}

\subsection{Lower level equivalence classes equal for valid part}

The equivalence classes induced by $Present$ must be the same as those induced by $Interpret$, but only on the valid part of the lower level.


We prove the two directions separately. In the proof, we need \law{InterPresent} on the combined relation:  
$l~\Present\C~h \imp h~\Interpret\C~l$.

\xpr{
\setof{l'}{\exists h : l~\Present\C~h \land l'~\Present\C~h} \\ =\\ \setof{l'}{\exists h,h',h'' : h~\Interpret\C~l \land h~\Interpret\C~l' \land l~\Present\C~h' \land l'~\Present\C~h''}
}
\note{do we have both $l'~\Present\C~h'$ and $l~\Present\C~h''$?}


\head{Lower class from $Present$ $\subset$ class from $Interpret$}


$l' \in \setof{l'}{\exists h : l~\Present\C~h \land l'~\Present\C~h}$\\
$\imp$\\
$l' \in \setof{l'}{\exists h,h',h'' : h~\Interpret\C~l \land h~\Interpret\C~l'\land l~\Present\C~h' \land l'~\Present\C~h''}$

\begin{proof}
\begin{Prf}&
	l' \in \setof{l'}{\exists h : h~\Interpret\C~l \land h~\Interpret\C~l'\land l~\Present\C~h' \land l'~\Present\C~h''}\\
\Eqv{property of set comprehension, take $h,h',h'' = h_0$}&
	h_0~\Interpret\C~l \land h_0~\Interpret\C~l' \land l~\Present\C~h_0 \land l'~\Present\C~h_0\\
\Ffr{\law{Interpresent} twice}&
	l~\Present\C~h_0 \land l'~\Present\C~h_0\land l~\Present\C~h_0 \land l'~\Present\C~h_0\\
\Eqv{idempotency of $\land$}&
	l~\Present\C~h_0 \land l'~\Present\C~h_0\\
\Ffr{property of set comprehension + let $h_0$ be the $h$ from the quantification}&
	l' \in \setof{l'}{\exists h : l~\Present\C~h \land l'~\Present\C~h}\\
\end{Prf}
\end{proof}



\head{Lower class from $Present$ $\supset$ class from $Interpret$}

$l' \in \setof{l'}{\exists h : l~\Present\C~h \land l'~\Present\C~h}$
$\ffr$\\
$l' \in \setof{l'}{\exists h,h',h'' : h~\Interpret\C~l \land h~\Interpret\C~l'\land l~\Present\C~h' \land l'~\Present\C~h''}$\\


\begin{proof}
\begin{Prf}&
	\eqcl{l}{L} = \setof{l'}{\exists h : l~\Present\C~h \land l'~\Present\C~h}\\
\Ffr{property of set comprehension + take $h = h_0$}&
	l~\Present\C~h_0 \land l'~\Present\C~h_0\\
\Ffr{Lemma: $h~\Interpret\C~l \land l~\Present\C~h' ~\imp~ l~\Present\C~h$}&
	h_0~\Interpret\C~l \land l~\Present\C~h''_0 \land h_0~\Interpret\C~l' \land l'~\Present\C~h'_0\\
\Eqv{property of set comprehension + let $h_0, h'_0, h''_0$ be the $h,h',h''$ from the quantification}&
	l' \in \setof{l'}{\exists h,h',h'' : h~\Interpret\C~l \land h~\Interpret\C~l' \land l'~\Present\C~h' \land l~\Present\C~h''}\\
%
%	l_0~\Present\C~h \land l_0~\Present\C~h'\\
%\Eqv{Def. $\Present\C$}&
%	(\exists m : l_0~\Present\L~m \land m~\Present\H~h) \land (\exists m' : l_0~\Present\L~m' \land %m'~\Present\H~h')\\
%\Imp{{\sc Interpresent} on higher and lower}&
%	(\exists m : m~\Interpret\L~l_0 \land h~\Interpret\H~m) \land (\exists m' : m'~\Interpret\L~l_0 \land 
%	h'~\Interpret\H~m')\\
\end{Prf}
\end{proof}


%
%\xprlab{
%\forall m : \forall m_0, m'_0 \in \eqcl{m}{LH} & ~: & \exists m_1,m'_1 : \eqcl{m_1}{LH} = \eqcl{m'_1}{LH}\\   &\land   %&\eqcl{h}{HH} = \interpret\H \eqcl{m_0}{HL} \imp \eqcl{m_1}{HL} = \present\H~\eqcl{h}{HH}\\
%  &\land ~&\eqcl{h'}{HH} = \interpret\H \eqcl{m'_0}{HL} \imp \eqcl{m'_1}{HL} = \present\H ~\eqcl{h'}{HH}\\
%  &\land & something~like~~  {\bf valid}~m \imp \dots
%}{Property}   is now replaced by \law{Sane}


The lemma is: $h~\Interpret\C~l \land l~\Present\C~h' ~\imp~ l~\Present\C~h$

or, more intuitively:

$h~\Interpret\C~l \land \fn{valid} l ~\imp~ l~\Present\C~h$




\begin{proof}
$h~\Interpret\C~l \land l~\Present\C~h' ~\imp~ l~\Present\C~h$
\begin{Prf}&
	l~\Present\C~h\\
\Ffr{\law{$\Present\C$-Def} + take $m = m'_2$}&
	l~\Present\L~m'_2 \land m'_2~\Present\H~h\\
\Ffr{\law{$\present$-Char} and \law{$\interpret$-Char} on high and low}&
	\eqcl{l}{LL} = \present\L~\eqcl{m'_2}{LH} \land \eqcl{m'_2}{HL} = \present\H~\eqcl{h'}{HH} \\ 
\Ffr{Leibniz}&
	\eqcl{l}{LL} = \present\L~\eqcl{m'_0}{LH}\\
&	\eqcl{m'_2}{HL} = \present\H~\eqcl{h'}{HH} \land \eqcl{m'_2}{LH} = \eqcl{m_0'}{LH} \\ 
\Ffr{let $m'_2$ be the $m'_1$ from the quantification}&
	\eqcl{l}{LL} = \present\L~\eqcl{m'_0}{LH}\\
&	(\exists m'_1 : \eqcl{m'_1}{HL} = \present\H~\eqcl{h}{HH} \land \eqcl{m'_1}{LH} = \eqcl{m_0'}{LH}) \\ 
\Ffr{\law{$\present$-Match}}&
	\eqcl{h'}{HH} = \interpret\H \eqcl{m'_0}{HL} \land \eqcl{h}{HH} = \interpret\H~\eqcl{m_0}{HL} \land \\
&	\eqcl{m'_0}{HL} = \present\H~\eqcl{h'}{HH} \land \eqcl{m_0'}{LH} = \eqcl{m_0}{LH}  \land\\
&	\eqcl{l}{LL} = \present\L~\eqcl{m'_0}{LH}\\
\Ffr{commutativity of $\land$}&
	\eqcl{h}{HH} = \interpret\H~\eqcl{m_0}{HL} \land \\
&	\eqcl{l}{LL} = \present\L~\eqcl{m'_0}{LH} \land \eqcl{m'_0}{HL} = \present\H~\eqcl{h'}{HH} \land\\
&	\eqcl{m_0'}{LH} = \eqcl{m_0}{LH}  \land \eqcl{h'}{HH} = \interpret\H \eqcl{m'_0}{HL}\\
\Ffr{transitivity of $=$}&
	\eqcl{h}{HH} = \interpret\H~\eqcl{m_0}{HL} \land \eqcl{m_0}{LH} = \interpret\L~\eqcl{l}{LL} \land\\
&	\eqcl{l}{LL} = \present\L~\eqcl{m'_0}{LH} \land \eqcl{m'_0}{HL} = \present\H~\eqcl{h'}{HH} \land\\
&	\eqcl{m'_0}{LH} = \interpret\L~\eqcl{l}{LL} \land \eqcl{h'}{HH} = \interpret\H \eqcl{m'_0}{HL}\\
\Ffr{\law{InterPresent}}&
	\eqcl{h}{HH} = \interpret\H~\eqcl{m_0}{HL} \land \eqcl{m_0}{LH} = \interpret\L~\eqcl{l}{LL} \land\\
&	\eqcl{l}{LL} = \present\L~\eqcl{m'_0}{LH} \land \eqcl{m'_0}{HL} = \present\H~\eqcl{h'}{HH}\\
\Eqv{\law{\present-Char} and \law{\interpret-Char}}&
	h~\Interpret\H~m_0 \land m_0~\Interpret\L~l \land l~\Present\L~m'_0 \land  m'_0~\Present\H~h'\\
\Ffr{\law{$\Interpret\C$-Def} \& \law{$\Present\C$-Def} + let $m_0$ and $m'_0$ be $m$ from quantification}&
	h~\Interpret\C~l \land l~\Present\C~h'_0\\
\end{Prf}
\end{proof}






\section{\law{Absorption} implies the other conditions}\label{absorptionImplies}

\law{Absorption} implies \law{$\interpret$-Match}, \law{$\present$-Match}, and \law{Orthogonal}.

\xprlab{
\eqcl{m}{LH} = \eqcl{m'}{LH} ~\imp~ \eqcl{m}{HL} = \eqcl{m'}{HL}}{Absorption}


\head{\law{Absorption} implies \law{$\interpret$-Match}}


\begin{proof}
\begin{Prf}&
	\exists m'_1 : \eqcl{h'}{HH} = \interpret\H~\eqcl{m'_1}{HL} \land \eqcl{m'_1}{LH} = \eqcl{m_1}{LH}\\
\Ffr{take $m'_1 = m_1$  }&
	\eqcl{h'}{HH} = \interpret\H~\eqcl{m_1}{HL} \land \eqcl{m_1}{LH} = \eqcl{m_1}{LH} \\ 
\Ffr{symmetry of $=$} &
	\eqcl{h'}{HH} = \interpret\H~\eqcl{m_1}{HL} \\ 
\Ffr{Leibniz} &
	\eqcl{h}{HH} = \eqcl{h'}{HH} \land \eqcl{h}{HH} = \interpret\H~\eqcl{m_1}{HL} \\ 
\Ffr{transitivity of $=$} &
	\eqcl{h}{HH} = \interpret\H~\eqcl{m'_0}{HL} \land \eqcl{h'}{HH} = \interpret\H~\eqcl{m'_0}{HL} \land\\
&	\eqcl{h}{HH} = \interpret\H~\eqcl{m_1}{HL} \\ 
\Ffr{Leibniz} &
	\eqcl{h}{HH} = \interpret\H~\eqcl{m_0}{HL} \land \eqcl{h'}{HH} = \interpret\H~\eqcl{m'_0}{HL} \land\\
&	\eqcl{h}{HH} = \interpret\H~\eqcl{m_1}{HL} \land \eqcl{m_0}{HL} = \eqcl{m'_0}{HL} \\ 
\Ffr{\law{Absorption}}&
	\eqcl{h}{HH} = \interpret\H~\eqcl{m_0}{HL} \land \eqcl{h'}{HH} = \interpret\H~\eqcl{m'_0}{HL} \land\\
&	\eqcl{h}{HH} = \interpret\H~\eqcl{m_1}{HL} \land \eqcl{m_0}{LH} = \eqcl{m'_0}{LH} \\ 
\end{Prf}
\end{proof}


\head{\law{Absorption} implies \law{$\present$-Match}}

\xprlab{
\eqcl{h}{HH} = \interpret\H~\eqcl{m_0}{HL} \land \eqcl{h'}{HH} = \interpret\H~\eqcl{m'_0}{HL} \land\\
\eqcl{m_1}{HL}= \present\H~\eqcl{h}{HH} \land \eqcl{m_0}{LH} = \eqcl{m'_0}{LH} \\ 
\imp ~~ \exists m'_1 : \eqcl{m'_1}{HL} = \present\H~\eqcl{h'}{HH} \land \eqcl{m'_1}{LH} = \eqcl{m_1}{LH}\\
}{$\present$-Match}

\begin{proof}
\begin{Prf}&
	\exists m'_1 : \eqcl{m'_1}{HL} = \present\H~\eqcl{h'}{HH} \land \eqcl{m'_1}{LH} = \eqcl{m_1}{LH}\\
\Ffr{take $m'_1 = m_1$  }&
	\eqcl{m_1}{HL} = \present\H~\eqcl{h'}{HH} \land \eqcl{m_1}{LH} = \eqcl{m_1}{LH} \\ 
\Ffr{symmetry of $=$} &
	\eqcl{m_1}{HL} = \present\H~\eqcl{h'}{HH} \\ 
\Ffr{Leibniz} &
	\eqcl{h}{HH} = \eqcl{h'}{HH} \land \eqcl{m_1}{HL} = \present\H~\eqcl{h}{HH} \\ 
\Ffr{transitivity of $=$} &
	\eqcl{h}{HH} = \interpret\H~\eqcl{m'_0}{HL} \land \eqcl{h'}{HH} = \interpret\H~\eqcl{m'_0}{HL} \land\\
&	\eqcl{m_1}{HL} = \present\H~\eqcl{h}{HH}\\
\Ffr{Leibniz} &
	\eqcl{h}{HH} = \interpret\H~\eqcl{m_0}{HL} \land \eqcl{h'}{HH} = \interpret\H~\eqcl{m'_0}{HL} \land\\
&	\eqcl{m_1}{HL} = \present\H~\eqcl{h}{HH} \land \eqcl{m_0}{HL} = \eqcl{m'_0}{HL} \\ 
\Ffr{\law{Absorption}}&
	\eqcl{h}{HH} = \interpret\H~\eqcl{m_0}{HL} \land \eqcl{h'}{HH} = \interpret\H~\eqcl{m'_0}{HL} \land\\
&	\eqcl{m_1}{HL} = \present\H~\eqcl{h}{HH} \land \eqcl{m_0}{LH} = \eqcl{m'_0}{LH} \\ 
\end{Prf}
\end{proof}


\head{\law{Absorption} implies \law{Orthogonal}}

\xprlab{
\eqcl{m'}{HL} = \eqcl{m}{HL} ~\imp~ \eqcl{\eqcl{m'}{LH} \reuze{LH} m}{HL} = \eqcl{m}{HL}}{Orthogonal}

\begin{proof} Assume $\eqcl{m'}{HL} = \eqcl{m}{HL}$
\begin{Prf}&
	\eqcl{\eqcl{m'}{LH} \reuze{LH} m}{HL} = \eqcl{m}{HL}\\
\Eqv{assumption}&
	\eqcl{\eqcl{m'}{LH} \reuze{LH} m}{HL} = \eqcl{m'}{HL}\\
\Ffr{\law{Absorption}}&
	\eqcl{\eqcl{m'}{LH} \reuze{LH} m}{LH} = \eqcl{m'}{LH}\\
\Eqv{\law{$\reuz$-Valid}}&
	\true\\
\end{Prf}
\end{proof}




\section{Friendlier looking conditions}\label{sect:friendlier}

Instead of the rather complex conditions:

\xprlab{
\eqcl{h}{HH} = \interpret\H~\eqcl{m_0}{HL} \land \eqcl{h'}{HH} = \interpret\H~\eqcl{m'_0}{HL} \land\\
\eqcl{h}{HH} = \interpret\H~\eqcl{m_1}{HL} \land \eqcl{m_0}{LH} = \eqcl{m'_0}{LH} \\ 
\imp ~~ \exists m'_1 : \eqcl{h'}{HH} = \interpret\H~\eqcl{m'_1}{HL} \land \eqcl{m'_1}{LH} = \eqcl{m_1}{LH}
}{$~~\interpret$-Match}

and

\xprlab{
\eqcl{h}{HH} = \interpret\H~\eqcl{m_0}{HL} \land \eqcl{h'}{HH} = \interpret\H~\eqcl{m'_0}{HL} \land\\
\eqcl{m_1}{HL}= \present\H~\eqcl{h}{HH} \land \eqcl{m_0}{LH} = \eqcl{m'_0}{LH} \\ 
\imp ~~ \exists m'_1 : \eqcl{m'_1}{HL} = \present\H~\eqcl{h'}{HH} \land \eqcl{m'_1}{LH} = \eqcl{m_1}{LH}\\
}{$\present$-Match}

We can use a function $\mathcal{I}$:

\xprlab{
\mathcal{I} \tp Level\M \tp \powerset Level\H \\
\mathcal{I}~m = \setof{h}{\exists m' \in \eqcl{m}{LH} : \eqcl{h}{HH} = \interpret\H~\eqcl{m'}{HL} }
}{$\mathcal{I}$-Def}

to define the more friendly looking

\xprlab{
h,h' \in \mathcal{I}~m \land  \eqcl{h}{HH} = \interpret\H~\eqcl{m'}{HL} \imp\\
\exists m'' \in \eqcl{m'}{LH} : \eqcl{h'}{HH} = \interpret\H~\eqcl{m''}{HL} \\
}{$\interpret$-Match-Nice}

and

\xprlab{
h,h' \in \mathcal{I}~m \land \eqcl{m'}{HL}= \present\H~\eqcl{h}{HH}  \imp\\
\exists m'' \in \eqcl{m'}{LH} : \eqcl{m''}{HL} = \present\H~\eqcl{h'}{HH} \\
}{$\present$-Match-Nice}

The conditions are equivalent to their friendlier counterparts. Below is the proof for \law{$\interpret$-Match-Nice} and \law{$\interpret$-Match}. The proof for \law{$\present$-Match-Nice} and \law{$\present$-Match} is analogous.


\law{$\interpret$-Match-Nice} implies \law{$\interpret$-Match}

\xprlab{
\eqcl{h}{HH} = \interpret\H~\eqcl{m_0}{HL} \land \eqcl{h'}{HH} = \interpret\H~\eqcl{m'_0}{HL} \land\\
\eqcl{h}{HH} = \interpret\H~\eqcl{m_1}{HL} \land \eqcl{m_0}{LH} = \eqcl{m'_0}{LH} \\ 
\imp ~~ \exists m'_1 : \eqcl{h'}{HH} = \interpret\H~\eqcl{m'_1}{HL} \land \eqcl{m'_1}{LH} = \eqcl{m_1}{LH}
}{$~~\interpret$-Match}

\begin{proof}
\begin{Prf}&
	\exists m'' : \eqcl{h'}{HH} = \interpret\H~\eqcl{m''}{HL} \land \eqcl{m''}{LH} = \eqcl{m_1}{LH}\\
\Eqv{\law{$\eqhole$-Member}} &
	\exists m'' \in \eqcl{m_1}{LH} : \eqcl{h'}{HH} = \interpret\H~\eqcl{m''}{HL} \\
\Ffr{\law{$\interpret$-Match-Nice}} &
	h,h' \in \mathcal{I}~m_0 \land \eqcl{h}{HH} = \interpret\H~\eqcl{m_1}{HL} \\
\Eqv{\law{$\mathcal{I}$-Def}} &
	h,h' \in \setof{h}{\exists m' \in \eqcl{m_0}{LH} : \eqcl{h}{HH} = \interpret\H~\eqcl{m'}{HL} } \\
&	\eqcl{h}{HH} = \interpret\H~\eqcl{m_1}{HL} \\ 
\Eqv{property of set comprehension} &
	(\exists m' \in \eqcl{m_0}{LH} : \eqcl{h}{HH} = \interpret\H~\eqcl{m'}{HL}) \land \\
&	(\exists m' \in \eqcl{m_0}{LH} : \eqcl{h}{HH} = \interpret\H~\eqcl{m'}{HL}) \land \\
&	\eqcl{h}{HH} = \interpret\H~\eqcl{m_1}{HL} \\ 
\Ffr{take $m',m'$ = $m_0,m'_0$} &
	\eqcl{m_0}{LH} = \eqcl{m_0}{LH} \land  \eqcl{h}{HH} = \interpret\H~\eqcl{m_0}{HL} \land\\
&	\eqcl{m_0}{LH} = \eqcl{m'_0}{LH} \land \eqcl{h'}{HH} = \interpret\H~\eqcl{m'_0}{HL} \land\\
&	\eqcl{h}{HH} = \interpret\H~\eqcl{m_1}{HL} \\ 
\Ffr{symmetry of $=$} &
	\eqcl{h}{HH} = \interpret\H~\eqcl{m_0}{HL} \land \eqcl{h'}{HH} = \interpret\H~\eqcl{m'_0}{HL} \land\\
&	\eqcl{h}{HH} = \interpret\H~\eqcl{m_1}{HL} \land \eqcl{m_0}{LH} = \eqcl{m'_0}{LH}\\ 
\end{Prf}
\end{proof}

\law{$\interpret$-Match} implies \law{$\interpret$-Match-Nice}

\begin{proof}
\begin{Prf}&
	\exists m'_1 \in \eqcl{m'}{LH} : \eqcl{h'}{HH} = \interpret\H~\eqcl{m'}{HL} \\
\Eqv{\law{$\eqhole$-Member}} &
	\exists m'_1 : \eqcl{h'}{HH} = \interpret\H~\eqcl{m'_1}{HL} \land \eqcl{m'_1}{LH} = \eqcl{m'}{LH}\\
\Ffr{\law{$\interpret$-Match}} &
	\eqcl{h}{HH} = \interpret\H~\eqcl{m_0}{HL} \land \eqcl{h'}{HH} = \interpret\H~\eqcl{m'_0}{HL} \land\\
&	\eqcl{h}{HH} = \interpret\H~\eqcl{m'}{HL} \land \eqcl{m_0}{LH} = \eqcl{m'_0}{LH} \\ 
\Ffr{transitivity of $=$} &
	\eqcl{m_0}{LH} = \eqcl{m}{LH} \land \eqcl{h}{HH} = \interpret\H~\eqcl{m_0}{HL} \land
	\eqcl{m'_0}{LH} = \eqcl{m}{LH} \land  \eqcl{h'}{HH} = \interpret\H~\eqcl{m'_0}{HL} \land\\
&	\eqcl{h}{HH} = \interpret\H~\eqcl{m'}{HL}\\ 
\Ffr{let $m_0,m_0'$ be the $m'$ from the quantification}&
	(\exists m' \in \eqcl{m}{LH} : \eqcl{h}{HH} = \interpret\H~\eqcl{m'}{HL}) \land 
	(\exists m' \in \eqcl{m}{LH} : \eqcl{h}{HH} = \interpret\H~\eqcl{m'}{HL}) \land \\
&	\eqcl{h}{HH} = \interpret\H~\eqcl{m'}{HL}\\
\Eqv{property of set comprehension} &
	h,h' \in \setof{h}{\exists m' \in \eqcl{m}{LH} : \eqcl{h}{HH} = \interpret\H~\eqcl{m'}{HL} } \\
&	\eqcl{h}{HH} = \interpret\H~\eqcl{m'}{HL}\\
\Eqv{\law{$\mathcal{I}$-Def}} &
	h,h' \in \mathcal{I}~m \land \eqcl{h}{HH} = \interpret\H~\eqcl{m'}{HL}\\
\end{Prf}
\end{proof}




\subsection{The top layer}
\note{Unclear where this came from.}

* associativity seems be in reverse order for \law{Pres-Inert}



For the top layer, we have the combination 

$\eqcl{m}{LH} = \eqcl{m'}{LH} ~\imp~ \eqcl{m}{=} = \eqcl{m'}{=}$ $\eqcl{m}{LH} = \eqcl{m'}{LH} ~\imp~ m=m$


\begin{Prf}&
	\eqcl{m'}{LH} = \eqcl{m}{LH} ~\imp~ \eqcl{\eqcl{m'}{=} \reuze{HL} m}{LH} = \eqcl{m}{LH}\\
\Ffr{} &
	\eqcl{m'}{LH} = \eqcl{m}{LH} ~\imp~ \eqcl{\eqcl{m'}{HL} \reuze{HL} m}{LH} = \eqcl{m}{LH}\\
\Ffr{} &
	\eqclass{m'}{=} \reuze{HL} y = x\\
\Ffr{} &
	\eqcl{\eqclass{m'}{=} \reuze{HL} m}{=} = \eqclass{m}{=}\\
\end{Prf}

\law{$\mathcal{I}$-Def} amounts to
\xprlab{
\mathcal{I} \tp Level\M \tp \powerset~Level\H \\
\mathcal{I}~m = \setof{h}{\exists m' \in \eqcl{m}{LH} : \eqcl{h}{=} = \id~\eqcl{m'}{=} }\\
\mathcal{I}~m = \setof{h}{\exists m' \in \eqcl{m}{LH} : h = m' }\\
\mathcal{I}~m = \eqcl{m}{LH}\\
}{$\mathcal{I}$-Def}

The two conditions are:

assume $h,h' \in \mathcal{I}~m \land \eqcl{m'}{HL}= \present\H~\eqcl{h}{HH} $, which amounts to 
$\eqcl{h}{LH} = \eqcl{m}{LH}$ and $\eqcl{h'}{LH} =  \eqcl{m}{LH}$ and $m'=h$
\law{$\present$-Match}
\begin{Prf} &
	\exists m'' \in \eqcl{m'}{LH} : \eqcl{m''}{HL} = \present\H~\eqcl{h'}{HH} \\
\Ffr{take $m'' = h'$} &
	h' \in \eqcl{m'}{LH} \land \eqcl{h'}{HL} = \present\H~\eqcl{h'}{HH} \\
\Ffr{$HL$ and $HH$ are $=$, and $\present\H = \id$} &
	h' \in \eqcl{m'}{LH} \land h' = h'\\
\Ffr{assumption} &
	h' \in \eqcl{h}{LH} \land h' = h'\\
\Ffr{$\eqcl{h}{LH} = \eqcl{m}{LH}$ and $\eqcl{h'}{LH} = \eqcl{m}{LH}$} &
	h' \in \eqcl{h'}{LH} \land h' = h'\\
\end{Prf}

Because $\interpret\H = \present\H = \id$, the proof for {$\interpret$-Match} is analogous.



\bc

\section{Various}\label{sect:various}

\head{\law{Orthogonal} holds when $HL$ and $LH$ are wildcard types}

If both $HL$ and $LH$ are described by the wildcard types from Section~\ref{sect:wildcardEq}, \law{Orthogonal} holds.


\xprlab{
\eqcl{m'}{HL} = \eqcl{m}{HL} ~\imp~ \eqcl{\eqcl{m'}{LH} \reuze{LH} m}{HL} = \eqcl{m}{HL}}{Orthogonal}

\head{law{$\present$-Match} is sufficient for \law{Doc-Inert}}

The two conditions from Section~\ref{sect:combinedExtra} are strong enough to guarantee \law{Pres-Inert}. However, the proof of this is very tedious, partly because of the reference to $present\H$ and $interpret\H$ in \law{$\present$-Match}. Therefore, we introduce a stronger condition \law{Absorption}, which allows for a simpler proof of \law{Pres-Inert}, and which can be proven to imply the other two conditions, as well as \law{Orthogonal}.

Will be very tedious.

\xprlab{
\eqcl{h}{HH} = \interpret\H~\eqcl{m_0}{HL} \land \eqcl{h'}{HH} = \interpret\H~\eqcl{m'_0}{HL} \land\\
\eqcl{m_1}{HL}= \present\H~\eqcl{h}{HH} \land \eqcl{m_0}{LH} = \eqcl{m'_0}{LH} \\ 
\imp ~~ \exists m'_1 : \eqcl{m'_1}{HL} = \present\H~\eqcl{h'}{HH} \land \eqcl{m'_1}{LH} = \eqcl{m_1}{LH}\\
}{$\present$-Match}

For valid $m_0$, one interpret comes from \law{interPresent} and if we fill in $h'$, we can leave it from the antecedent:

\xprlab{
\eqcl{m_0}{HL}= \present\H~\eqcl{h}{HH} \land \eqcl{m_0}{LH} = \eqcl{m'_0}{LH} \\ 
\imp ~~ \exists m'_1 : \eqcl{m'_1}{HL} = \present\H~ (\interpret\H~\eqcl{m'_0}{HL}) \land \eqcl{m'_1}{LH} = \eqcl{m_0}{LH}\\
}{$\present$-Match}

Without \law{Absorption}, the $\level'\M$ is not automatically valid, and hence we cannot use \law{Pres-Inert} on the higher layer.


\xprlab{  \level'\L = x  ~\imp~ \wp{Comp_{n-1}}{ \eqcl{\level''\M}{HL} = \present\H (\interpret\H \eqcl{\level'\M}{HL})  \land \level'\L = x }}{Law}




Using this result, we prove \law{Postcondition}.

\begin{Prf}&
  	~~\land\\
  &	\level'\L = \present\L~ \eqcl{\interpret\L~ \eqcl{\level'\L}{LL}  ~\reuze{LH}~  \level\M}{LH}   ~\reuze{LL}~   \level'\L\\
\Eqv{\law{\fn{wp}-$\gts$}}&
	\wp{\level'\M \gets \interpret\L~ \eqcl{\level'\L}{LL}  ~\reuze{LH}~   \level\M}{ ~~\land \level'\L = \present\L~ \eqcl{\level'\M}{LH}   ~\reuze{LL}~   \level'\L }\\
\Eqv{\law{$Up$-Def}}&
	\wp{Up}{ \level'\L = \present\L~ \eqcl{\level'\M}{LH}   ~\reuze{LL}~   \level'\L}\\
\Imp{\law{\fn{wp}-Mono} and \law{Law}}&
	\wp{Up}{ \wp{ Comp_{n-1}}{  \eqcl{\level''\M}{HL} = \present\H (\interpret\H \eqcl{\level'\M}{HL})  ~~\land \level'\L = \present\L~ \eqcl{\level'\M}{LH}   ~\reuze{LL}~   \level'\L }}\\
\Eqv{\law{\fn{wp}-$\smi$}}&
	\wp{Up \semi Comp_{n-1}}{ \eqcl{\level''\M}{HL} = \present\H (\interpret\H \eqcl{\level'\M}{HL}) ~~\land \level'\L = \present\L~ \eqcl{\level'\M}{LH}   ~\reuze{LL}~   \level'\L } \\
\Imp{\law{\fn{wp}-Mono} and previous result}&
	\wp{Up \semi Comp_{n-1}}{ \level'\L = \present\L~ \eqcl{\level''\M}{LH}   ~\reuze{LL}~   \level'\L }\\
\Eqv{\law{\fn{wp}-$\gts$}}&
	\wp{Up \semi Comp_{n-1}}{ \wp{\level''\L \gets \present\L~ \eqcl{\level''\M}{LH}   ~\reuze{LL}~   \level'\L}{ \level'\L = \level''\L }}\\
\Eqv{\law{$Dwn$-Def}}&
	\wp{Up \semi Comp_{n-1}}{ \wp{Dwn }{ \level'\L = \level''\L }}\\
\Eqv{\law{\fn{wp}-$\smi$}}&
	\wp{Up \semi Comp_{n-1} \semi Dwn}{ \level'\L = \level''\L }\\
\Eqv{\law{$Comp$-Def}}&
	\wp{Comp}{\level'\L = \level''\L}\\
\end{Prf}



\begin{Prf}&
	\eqcl{m_0}{HL}= \present\H~\eqcl{h}{HH} \land \eqcl{m_0}{LH} = \eqcl{\level'\M}{LH} \\ 
\Imp{match}&
	\eqcl{\level''\M}{HL} = \present\H (\interpret\H \eqcl{\level'\M}{HL}) \land \\
&	\eqcl{m'_1}{HL} = \present\H~ (\interpret\H~\eqcl{\level'\M}{HL}) \land \eqcl{m'_1}{LH} = \eqcl{m_0}{LH}\\
\Imp{}&
	\eqcl{\level''\M}{LH} = \eqcl{\level'\M}{LH}\\
\Imp{also need $\eqcl{\level'\L}{LL} = \present\L~ \eqcl{\level'\M}{LH}$}&
	\level'\L = \present\L~ \eqcl{\level'\M}{LH}   ~\reuze{LL}~   \level'\L\\
\end{Prf}
\ec





\bc
\section{Equivalence classes}

We want to express $R \tp X \rel Y$ as a bijective function $f \tp \Eqclass{Y}{H} \to \Eqclass{X}{L}$.

We can define the classes:

\xpr{
x~L~x' \is \exists y: x~R~y \land x'~R~y\\
}

and

\xpr{
y~H~y' \is \exists x :  x~R~y \land x~R~y'\\
}

We want:$x~R~y \eqv \eqclass{x}{L} = f~\eqclass{y}{H}$.


* for interpret, split the classes in valid/invalid, so it becomes a surjective function.

A relation $R \tp X \rel Y$ can define equivalence relations on $X$ and on $Y$:

\xpr{
x \simeq x' \is \exists y: x~R~y \land x'~R~y\\
}

and

\xpr{
y \simeq y' \is \exists x :  x~R~y \land x~R~y'\\
}


The first definition is valid only if for********. \note{is this also if? (and hence iff)}

\xpr{
x~R~y \land x~R~y' \imp (x'~R~y \imp x'~R~y')\\
}

Or, equivalently:

\xpr{
x~R~y \land x~R~y' \land x'~R~y \imp x'~R~y'\\
}

For the second definition, we need:
 
\xpr{
x~R~y \land x'~R~y \imp (x~R~y' \imp x'~R~y')\\
}

Or, equivalently:

\xpr{
x~R~y \land x'~R~y \land x~R~y' \imp x'~R~y'\\
}

Which (somewhat surprisingly) is equal to the first condition.


The class for $x$ is:

\xpr{
\eqcl{x}{} \is \setof{x'}{\forall y: x~R~y \imp x'~R~y}\\
}

If this is a valid definition, then we can define the equivalence relation as follows:

\xpr{
x \simeq x' \is \eqcl{x}{} = \eqcl{x'}{}\\
}
\ec







\bc

\section{Old stuff}

%\law{Compatible} condition implies \law{Sane'} for valid $m$, but needs a different clause for non-valid $m$.

% Old compatible
%\xprlab{
%\forall m_0 : & (\exists m \in \eqcl{m_0}{LH} : \fn{valid}~m) \imp\\
%                   & \begin{array}[b]{@{}l@{}l@{}l}
%                       \forall m' \in \eqcl{m_0}{LH} : ~ & \valid~m'~\lor\\
%									&(\fn{\present}_{\mathrm H} \present\H \oo \interpret\H) \eqcl{m'}{HL} \subset %\eqcl{m_0}{LH}
%			\end{array}
%}{Compatible}
*****

\xprlab{
\forall m : & (\exists m_0 \in \eqcl{m}{LH} : \valid~m_0) \imp\\
                   & \begin{array}[b]{@{}l@{}l@{}l}
                       & \valid~m~\lor\\
			&(\present\H \oo \interpret\H) \eqcl{m}{HL} \subset \eqcl{m}{LH}
			\end{array}
}{Compatible}



\subsection{\law{Compatible} implies \law{Sane'}}
** subscripts in \law{Sane'} have changed, see if proof is still okay.

\begin{proof}
\begin{Prf}&
	\exists m_1 : \eqcl{m_1}{LH } = \eqcl{m_0}{LH} \land \eqcl{m_1}{HL} = \present\H (\interpret\H \eqcl{m_0}{HL})\\
\Ffr{}&
	\eqcl{m_1}{LH } = \eqcl{m_0}{LH} \land \eqcl{m_1}{HL} = \present\H (\interpret\H \eqcl{m_0}{HH})\\ 
\Ffr{let $m_1 = m_0$}&
	\eqcl{m_0}{HL} = \present\H (\interpret\H \eqcl{m_0}{HH})\\ 
\Ffr{propositional logic}&
	\eqcl{m_0}{HL} = \present\H \eqcl{h_0}{HH} 	\eqcl{h_0}{HH} = \interpret\H \eqcl{m_0}{HH}\\
\Ffr{\law{InterPresent}}&
	\eqcl{m_0}{HL} = \present\H \eqcl{h_0}{HH}\\
\Ffr{let $h_0$ to be the $h$ from the quantification}&
	\exists h : \eqcl{m_0}{HL} = \present\H \eqcl{h}{HH}\\
\Eqv{\law{\valid-Def}}&
	\valid~m_0\\
\end{Prf}

and

Assume $(\present\H \oo \interpret\H) \eqcl{m_0}{HL} \subset \eqcl{m_0}{LH}$
\begin{Prf}&
	\exists m_1 : \eqcl{m_1}{LH } = \eqcl{m_0}{LH} \land \eqcl{m_1}{HL} = \present\H (\interpret\H \eqcl{m_0}{HL})\\
\Ffr{}&
	\eqcl{m_1}{LH } = (\present\H \oo \interpret\H) \eqcl{m_0}{HL} \land \eqcl{m_1}{LH } = \eqcl{m_0}{LH}\\
\Ffr{ }&
	\eqcl{m_1}{LH } = (\present\H \oo \interpret\H) \eqcl{m_0}{HL} \imp \eqcl{m_1}{LH } = \eqcl{m_0}{LH}\\
\Ffr{\law{$\eqhole$-Member}}&
	m_1 \in (\present\H \oo \interpret\H) \eqcl{m_0}{HL} \imp m_1 \in \eqcl{m_0}{LH}\\
\Ffr{sets}&
	(\present\H \oo \interpret\H) \eqcl{m_0}{HL} \subset \eqcl{m_0}{LH}\\
\end{Prf}
\end{proof}



%another old sanity
%
%\xprlab{
%\forall m : \forall m_0, m'_0 \in \eqcl{m}{LH} & ~: & \exists m_1,m'_1 : \eqcl{m_1}{LH} = \eqcl{m'_1}{LH}\\   &\land   %&\eqcl{h}{HH} = \interpret\H \eqcl{m_0}{HL} \imp \eqcl{m_1}{HL} = \present\H~\eqcl{h}{HH}\\
%  &\land ~&\eqcl{h'}{HH} = \interpret\H \eqcl{m'_0}{HL} \imp \eqcl{m'_1}{HL} = \present\H ~\eqcl{h'}{HH} 
%}{Sane'}

% old Sanity condition
%\xpr{
%\forall m : \forall m_0, m'_0 \in \eqcl{m}{LH} & : & \valid~m_0 \imp\\
%  &         &\exists m_1,m'_1 : \eqcl{m_1}{LH} = \eqcl{m'_1}{LH}\\
%  &\land &\eqcl{m_1}{HL} = (\present\H \oo \interpret\H) \eqcl{m_0}{HL}\\
%  &\land &\eqcl{m'_1}{HL} = (\present\H \oo \interpret\H) \eqcl{m'_0}{HL}
%}
%
%
%\xpr{
%\forall m_0 & : & (\exists m'_0 \in \eqcl{m_0}{LH} : \valid~m'_0) \imp\\
%  &         &\exists m_1,m'_1 : \eqcl{m_1}{LH} = \eqcl{m'_1}{LH}\\
%  &\land &\eqcl{m_1}{HL} = \eqcl{m_0}{HL}\\
%  &\land &\eqcl{m'_1}{HL} = (\present\H \oo \interpret\H) \eqcl{m'_0}{HL}
%}
\ec