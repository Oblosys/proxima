\chapter{One Layer}
\label{chap:singleLayer}

\renewcommand{\present}{\ensuremath{\mathit{present}}}
\renewcommand{\interpret}{\ensuremath{\mathit{interpret}}}
\newcommand{\spc}{\textvisiblespace}

{\em *** Version: \today~ ***}


\section{Questions:}

\subsection{Unclear}

\bl
\* what identifiers to use, $\present, \Present$?
\* how to layout the equations and put label at the right?
\* How to use increased vertical spacing in proofs?
\* Operators between identifiers look asymmetrical: $\Level_H \times \Level_L$. Fix using \verb|\:|? (eg. \verb|\times\:| \rarr $\Level_H \times\, \Level_L$) solution: use \verb|\!|
\el

More important:
\bl
\* $True \imp P$ vs. $True \eq P$
\el

\subsection{Problems}

{\bf Asymmetry between $interpret$ and $present$:}

\bl
\* When two Documents present as the same presentation. They are equal up to extra state.
\* When two Presentations interpret to the same document. They may be equal up to extra state, but they may also be incorrect presentations.
\el

Example: 

\begin{math}
Document \tp (Int, Char) ~~~ Presentation \tp String\\
present (i,\_) = whitespace \cat english~i\\ 
h \in {(7, 'a'),(7,'b'),(7,'c'),\dots} : present~h = \{"seven", "\spc seven", "\spc\spc seven", \dots\}\\
l \in {
 }
 \left\{ \begin{array}{l}
            "seven", " seven", "  seven", \dots \\
            "sevven", "\spc sevven", "\spc\spc sevven", \dots \\
            \dots
            \end{array}
\right\} : interpret~l = \{(7, 'a'),(7,'b'),(7,'c'),\dots\}\\
\end{math}

\bigskip {\bf Avoiding "close to" for extra state}

Maybe define a $==^*$ ("equality up to extra state") instead of using close to?

\begin{math}
(==^*) \tp a^* \rightarrow a^* \rightarrow Bool\\
x ==^* * ~=~ True\\
* ==^* y ~=~ True\\
x ==^* y ~=~ x == y\\
\end{math}

Useless, result of interpret/present will in general not be equal up to ES to old value. eg $\lnot (Token (1,0)~"True") ==^* (Token * "True")$

\bigskip {\bf {\sc Extra} property}

{\sc InterPresent}  is not enough. Following is not a valid pres/intr with e.s., but it does not break {\sc InterPresent}:

This one is not allowed by {\sc InterPresent}
\begin{math}
\{a,aa\} = present 1\\
\{1\} = interpret~a\\
\{2\} = interpret~aa
\end{math}

This one is incorrect, but allowed by  {\sc InterPresent}

Problem is that a is not in all presentations of (interpret a). 
\begin{math}
\{a\} = present~1\\
\{aa\} = present~2\\
\{1,2\} = interpret~a\\
\{1,2\} = interpret~aa\\
\end{math}

However, if this is allowed, then interpreting a valid presentation $l'$ and presenting it, does not necessarily lead to $l'$ again. 


In the next example "drrie" is not in every presentation of (interpret  "drrie"). But it's okay, since there is no h such that "drrie" = pres h.
\begin{math}
\{3\} = interpret~"drie"\\
\{3\} = interpret~"drrie"\\
\{drie\} = present~3
\end{math}

This property prevents the problem from occurring.

\xprlab{
l \in \present~h' \imp (h \in \interpret~l \imp l \in \present~h)
}{Extra}

If we add the {\sc Extra} requirement then second example is not allowed anymore. The requirement states that if the lower level $l$ is a presentation of some higher level, then all interpretations of $l$ have $l$ in their presentation.

%																
%																
%																
\section{Old stuff about mappings and trees}

\bl
\* From first half of old chapter 5
\el



%																
%																
%																
\section{Intro}

%Somewhere: combinators guaranteeing safety are not what we want. 
%Only spec. responsibility is left to layer. Pierce: only one way E.S. No 
%structural updates. Incomplete. No duplicates.

\bl
\* Specification of interpret
\* Process we use is to start with basic case: an abstract editor. 
\* Then step by step add complications.
\el

\note{Add small examples (a la $7 \leftrightarrow $"sevven")}


%																
%																
%																
\section{Single layer}

\bl
\* Simple abstract editor: Two levels: document and presentation.
\* Immediate presentation.
\* Editing is changing presentation. (unrealistic)
\el

%The presentation invariant is satisfied if and only if the lower level is a correct presentation of the higher %level. The invariant is expressed using an abstract function  
%$\Present \tp \Level_{H} \rightarrow \Level_{L}$.

Given a $\present$, we specify an $\interpret$.

\xpr{
\present & \tp &  \Level_{H} \rightarrow \Level_{L}\\
\interpret  & \tp & \Level_{L} \rightarrow \Level_{H}\\
}


\bigskip {\bf Presentation invariant}

\bl
\* The presentation invariant states that the lower level is a correct presentation of the higher level.
\el

\xprlab{
\level_{L} & \equ & \present~\level_{H}
}{Present}

$present$ is total function. all docs have pres. but not surjective. not all pres have doc. mention injective here?

\bigskip {\bf InterPresent}

\bl
\* Property {\sc InterPresent}\note{name: Correctness/Well behaved/\dots?} 
\* Presenting followed by interpreting is identity on higher level: \note{normalizing doc may not occur}
\el

\xprlab{
\level_{L} \equ \present~\level_{H} \imp \level_{H} \equ \interpret~\level_{L}  
}{InterPresent}

Equivalently, we can express the {\sc InterPresent} property using function composition: \note{worry about domain?}

\xpr{
\interpret \oo \present = id_{\Level_H} 
}

\bl
\* Consequence: $present$ is injective. \note{Explain, prove?}
\el

\bl
\* Reverse need not hold.  (example here?)
\* eg. syntax highlighting: \present ({\tt Return True}) = {\tt "{\bf Return} True"}
\* but also need entering without colors/styles: \interpret ({\tt "Return True"}) = ({\tt Return True})
\* And $\present \oo \interpret$ ({\tt "Return True"}) $\neq$ ({\tt "{\bf Return} True"}) 
\* Reverse also does not hold for duplicates, but these are not explained until later.
\el

\subsection{Edit}

\bl
\* Modeling an Editor, so values change.
\* Higher level update, simply re-present. No problem
\* Lower level is updated by a user. Need to find updates on both levels.
\el

Explain that from now on $level_L$ and $level_H$ etc. are global. initial, $level_L$ and $level_H$. update and final.

An edit operation takes place when {\sc Present} holds:

\xpr{
& & \level_{L} = \present~\level_{H}\\
& & \level_{L} \leadsto \level'_{L} 
}

\bl
\* Most likely invariant no longer holds: $\level'_{L} \neq \present~\level_{H}$
\* Find new upper level (and lower).
\el

\bl 
\* If  $\level'$ is a presentation of some $\level''_H$, this is the one we want.
\* However, possible that $\level'$ is not a presentation of any higher level. 
\* Can discard the edit operation, but can also try to find one that is and was intended by the user
\* Interpret chooses.
\el

Summarizing, we need:

\xpr{
(level''_{H}, level''_{L})~\text{such that}~ 
\left\{ \begin{array}{l}
            \level''_{L} = \present~\level''_{H}\\
            \level''_{L}~\text{"close to"}~\level'_{L}\\
           \end{array}
\right.
}

We also want:

$\level'_L = \present~h \imp \level''_{L} = \level'_{L}$ \note{$h$ instead of $\level_H''$?}

\note {"close to" zachte req unless equality is possible? Isn't that logical?}

$\level'_L = \present~\level_H \imp \level''_{H} = \level_{H}$


The solution is this computation: \note{align label with last eq.? how?}

\xprlab{
\level''_{H} & \equ & \interpret~\level'_{L}\\
\level''_{L} & \equ & \present~\level''_{H} 
}{Compute}

no unn. ll change:

If the updated lower level ($\level'_{L}$) is a valid presentation of some $h \tp Level_H$, then the {\sc InterPresent} guarantees that final value the lower level is equal to $\level'_{L}$.

If we assume $\level''_{H}$ and $\level''_{L}$ to be defined according to {\sc Compute} then:

$\level'_L = \present~h \imp \level''_{L} = \level'_{L}$

\begin{proof} Assume $\level'_L = \present~h$ then
\prf{
\level''_{L}						& \Eqv{\sc Compute}\\
\present~\level''_{H}				& \Eqv{\sc Compute}\\
\present~(\interpret~\level'_{L})		& \Eqv{$\level'_L = \present~h$}\\
\present~(\interpret~(\present~h))	& \Eqv{definition of $\oo$}\\
\present~((\interpret \oo \present)~h)	& \Eqv{\sc InterPresent}\\
\present~h 						& \Eqv{$\level'_L = \present~h$}\\
\level'_L
}
\end{proof}

Other one (no unn. hl change) is trivial

On the other hand, if $\level'_{L}$ is not a valid presentation, $interpret$ needs to choose a  $\level''_{L}$ that resembles what the user intended by performing the edit operation. This is reflected in the specification by the requirement $\level'_{L}~\text{"close to"}~\level''_{L}$.

\bl
\* $\interpret$ must be defined in such a way that we get the closest one.
\* Responsibility of the designer.
\el

\bl
\* Is "close to" what we want? For simple editors, maybe it is, but is "-$>$" close to \rarr? For duplicates, "close to" is definitely not what we want (but there are no duplicates here yet).
\* What about Chapter titles and fonts? Will these be handled correctly with "close to" req.?
\el
%is interpret the inverse of present? If one exist, we can use it, but it must also work for L not in 
%range of present.


%																
%																
%																
\section{Extra state}


Extra state: present and translate are no longer functions, but binary relations. example

Next section we give a concrete instance of these classes

\bl
\* Simple example a declaration (identifier \& rhs) in a source editor is presented by leaving out the righthand side:
\* \verb| (Decl "b" True) <-> "b  =  ..."|\note{or complex expression?}
\* Whitespace is presentation extra state: \verb| (Decl "b" True) -> "*b*=*..."|
\* Right-hand side is interpretation extra state: \verb|b = ... -> (Decl "b" *)|
\el

\bl
\* Intuitively: Presentation extra state: information on how document is viewed. 
\* Interpretation extra state: information in doc that is not visible. 
\el

\bl
\* move these to first half (or previous chapter)
\* Examples Pres: tree browser expansion state, table view sorting, file manager details/icons (positions), layout.
\* Intr: Structure view.
\el

\bl
\* Model as eq. classes on doc and on pres.
\* Elements of result are equal except for E.S nodes.
\* New types:
\el

\xpr{
\present &\tp& \Level_{H} \rightarrow \{ \Level_{L} \}\\
\interpret &\tp& \Level_{L} \rightarrow \{ \Level_{H} \}\\
}

\bigskip {\bf Presentation invariant}

\bl
\* Presentation invariant changes: Any presentation in the result is ok: 
\* (\verb|"b = ..."| as well as more spatious \verb|"b    =    ..."| are correct presentations of \verb|Decl "b" True|
\el

\xprlab{
\level_{L} \in \present~\level_{H}\\
}{Present}

\bigskip {\bf {\sc InterPresent} property}

\bl
\* {\sc InterPresent}  also changes. 
\* Cannot compose $present$ and $interpret$ because $interpret$ returns several higher level values.
\* Therefore restate: if l is a presentation of h then H must be an interpretation of L.
\el

\xprlab{
\level_{L} \in \present~\level_{H} \imp \level_{H} \in \interpret~\level_{L}
}{InterPresent}

% l in (pres  `kleisli` int) l       is not True, because that alread holds if there is s single h in int l
% for which l in pres h, but we want for all h in int l that l in pres h
 


Extra property: (3 different notations, 2nd is probably the best)

\xprlab{
(\exists h' : l \in \present~h') \imp \forall h : h \in \interpret~l \imp l \in \present~h\\
l \in \present~h' \imp (h \in \interpret~l \imp l \in \present~h)\\
l \in \present~h' \land h \in \interpret~l \imp l \in \present~h\\
}{Extra}

Its reverse:
 
\xpr{
(\exists l' : h \in \interpret~l') \imp \forall l : l \in \present~h \imp h \in \interpret~l
}

is superfluous because it follows immediately from {\sc InterPresent}.

For an editor without extra state (see previous section), {\sc Extra} (with $=$ instead of $\in$) also follows from {\sc InterPresent}

\subsection{Edit}

\bl
\* Edit lower level, when presentation invariant holds:
\el

\xpr{
& & \level_{L} \in \present~\level_{H}\\
& & \level_{L} \leadsto \level'_{L} 
}

Pres inv. must be restored, so compute $level''_{H}$ and $level''_{L}$ that restore the invariant. 
Both $\interpret$ and $\present$ (may) provide several results, so we have to choose:

\xpr{
& & (level''_{H}, level''_{L})~\text{such that}~
\left\{ \begin{array}{ll}
            \level''_{L} \in \present~\level''_{H}\\
            \level''_{L}~\text{"close to"}~\level'_{L} & \text{\{imprecise edit + preserve lower e.s\}}\\
            \level''_{H}~\text{"close to"}~\level_{H} & \text{\{preserve higher e.s \}}\\
           \end{array}
\right.
}

$\level'_L \in \present~h \imp \level''_{L} = \level'_{L}$

$\level'_L \in \present~\level_H \imp \level''_{H} = \level_{H}$

Solution:

Because we cannot use $\present$ and $\interpret$ directly, since both have a set as result type, we introduce two functions $\present*$ and $\interpret*$, which select the appropriate element from the resulting set:

\xpr{
\interpret^* \tp \Level_{L} \times \Level_{H} \rightarrow \Level_{H}\\
\present^* \tp \Level_{H} \times \Level_{L} \rightarrow \Level_{L}\\
}

\xprlab{
\level''_{H} = \interpret^* (\level'_{L},\level_{H})\\ 
\level''_{L} = \present^* (\level''_{H}, level'_{L})
}{Compute}

\bl
\* Two "close to"s, explain more. One is for correct behavior of intended edit. Other is for maintaining extra state
\el

\bigskip {\bf No unnecessary lower level changes}

If result of edit is presentation of something, it is unchanged by {\sc Compute}: 

$\exists h : level'_L \in \present~h \imp level''_L = level'_L$\note{how to make clear that $\level''_H$ comes from {\sc Compute}?}


\begin{proof}  In the proof, we assume: $level'_L \in \present~h$, and show that if we perform the substitutions from {\sc Compute} it follows that $level''_L = level'_L$.

First, we derive the values for $\level_H$ and $\level'_L$:

$\level_H = \interpret^* (\level'_{L},\level_{H})$

\prf{
True 						& \Imp{assumption}\\
\level'_L \in \present~h 			& \Imp{\sc Extra}\\
\level_H \in \interpret~\level'_L 	& \Imp{\sc Intr$^*$-Idem}\\
\level_H = \interpret^* (\level'_{L},\level_{H})
}


And $\level'_{L} = \present^* (\level_{H}, level'_{L})$

\prf{
True 						& \Imp{assumption}\\
\level'_L \in \present~h 			& \Imp{\sc Extra}\\
\level_H \in \interpret~\level'_L 	& \Imp{\sc InterPresent}\\
\level'_L \in \present~\level_H	& \Imp{\sc Pres$^*$-Idem}\\
\level'_{L} = \present^* (\level_{H}, level'_{L})\\
}

Using these results, we can show the equality of $level''_L$ and $level'_L$:

\prf{
\level''_{L} 						& \Eqv{\sc Compute}\\
\present^* (\level''_{H}, level'_{L})	& \Eqv{\sc Compute}\\
\present^* (\interpret^* (\level'_{L},\level_{H}), level'_{L}) & \Eqv{$\level_H = \interpret^* (\level'_{L},\level_{H})$} \\
\present^* (\level_{H}, level'_{L}) 	& \Eqv{$\level'_{L} = \present^* (\level_{H}, level'_{L})$} \\
\level'_{L}
}
\end{proof}

\bigskip {\bf No unnecessary higher level changes}

With extra state, also possible to edit while preserving the invariant. (only add spaces in language without layout rule). In that case not only we don't want $l'=l''$, but also that higher level does not change. This is only an issue with extra state, since in previous section, $present$ was injective, and hence $\level_L' = present~\level_H \land \level_L'' = present~\level_H \imp \level'_L = \level''_L$ \dots \note{explain more?} 

$\level'_L \in \present~\level_H \imp \level''_H = \level_H$\\

\begin{proof} 
\prf{
\level'_L \in \present~\level_H	& \Imp{\sc InterPresent}\\
\level_H \in \interpret~\level'_L	& \Imp{\sc Intr$^*$-Idem}\\
\level_{H} = \interpret^* (\level'_{L},\level_{H}) & \Imp{\sc Compute}\\ 
\level_{H} = \level''_{H} 
}
\end{proof}

\note{Doing this proof by starting with $\level_H$ and substituting is tricky, because {\sc InterPresent} is needed in one step, so we would need a lemma-like thing (like in the previous proof).}

\bl
\* If $\level'_{L}$ is not a valid presentation, $\level''_{L}$ must resemble what the user intended (requirement $\level'_{L}~\text{"close to"}~\level''_{L}$).
\el



\section{Finite representation for equivalence classes}

will give $present$ and $interpret$ that satisfy laws from prev. section.

\subsection{Trees with holes}
Introduce datatype with 'holes'. Not placeholders from prev. chapters, but holes. Holes represent any value (of correct type)

A simple tree data type with boolean values in the leafs:

\xpr{
\data~Tree  = Bin~Tree~Tree~|~Leaf~Bool\\
\data~Bool = True~|~False\\
}

becomes

\xpr{
\data~Tree^*  = Bin~Tree^*~Tree^*~|~Leaf~Bool^*~|~*_{Tree}\\
\data~Bool^* = True~|~False~|~*_{Bool}\\
}

$Bin *_{Tree} (Leaf~*_{Bool})$ 
Or, more generally:

\xpr{
\data~T  & = & C_0~T_{0,0} \dots T_{0,m_0} | \dots | C_n~T_{n,0} \dots T_{n,m_n} \\
\data~T^* & = & C_0~T^*_{0,0} \dots T^*_{0,m_0} | \dots | C_n~T^*_{n,0} \dots T^*_{n,m_n} | *_T
}\note{braces around * don't affect spacing}

Same constructor, thus all vals of T are also values of $T^*$

Stars represent sets. All $t^*$ are sets, but not reverse. example

\xprlab{
\para{\hole} \tp T^* \to \set{T} \\
\para{*_ T} \eq \setof{x}{x \tp T}\\
\para{C~x^*_0 \dots x^*_n} \eq \setof{ C~x_0 \dots x_n}{x_0 \in \para{x^*_0} \land \dots  \land x_n \in \para{x^*_n}} 
}{$\para{\hole}$-Def}\note{name it {\sc $\para{\hole}$-Def} (or {\sc $\para{\hole}$-Char})?} \note{use $x^*_i$?}

Restrict ourselves to reversible. So no longer all sets, but only those that have hole-representations.

\xprlab{
interpret~l = \para{interpret'~l}\\
present~h = \para{present'~h}
}{Restrict}

Reusing may fail. So we need a default function: $default \tp a^* \rightarrow a$.

\xprlab{
default~x^* \in \para{x^*}\\
}{$default$-Valid}

\bl
\* A default value is equal to its arg, except for the $*$'s, which are filled in with initial values.
\* Def may be misleading, because recursive def means that each type has a default whereas it may be context sensitive: ie Whitespace = (int,int) , but we don't want (0,0) but (1,0).
\* Moreover, default may depend on other information. Eg. whitespace coming from a pretty printing algorithm. This would be an extra argument to default, but the req. stays.
\el

Now we define a function for reusing stuff. when *, just use righthand side. When not star, left has priority.

\xprlab{
(\,\triangleright) \tp a^* \rightarrow a \rightarrow a\\
*_a \triangleright  y = y\\
C~x^*_0 \dots x^*_n \triangleright C~y_0 \dots y_n = C~(x^*_0 \triangleright y_0) \dots (x^*_n  \triangleright y_n) \\
C~x^*_0 \dots x^*_n \triangleright C'~y_0 \dots y_m = default (C~x^*_0 \dots x^*_n)
}{$\triangleright$-Def}


\bl
\* Examples:
\* $(\verb|Token |* \verb| "True"|) \triangleright  (\verb|Token (1,2) "False"|) = \verb|Token (1,2) "True"|$
\* $(\verb|Decl "x" |*) \triangleright  (\verb|Decl "y" | True) = (\verb|Decl "x" | True)$\note{or complex expression?}
\* When constructors don't match, there is a problem. Types of children most probably will not match, so can't recurse. 
\* $\verb|Plus|~e_1~e_2 \leadsto \verb|Times|~e_1~e_2$ is a problem
\* Responsibility of layer to handle. Whitespace always str. similar, no prob. Plus/Times. has to be specd by editor designer. Sometimes makes no sense. Then es gets lost.
\* Also, no sub-object identities here, so $[e_0, e_1] \leadsto [e_1,e_0]$ is a problem
\* even $[e_0, e_1] \leadsto [e_0]$ is not nice, because constructor does not match on tail
\* IMPORTANT: Look at reuse for tokens, is this correct? 
\el

With $\triangleright$ we can define $\interpret^*$ and $\present^*$. Define in terms of $\interpret'$ and $present'$. 

\xpr{
\interpret^* \tp \Level_{L} \times \Level_{H} \rightarrow \Level_{H}\\
\interpret^*~(l, h) = \interpret'~l \triangleright h\\ 
\present^* \tp \Level_{H} \times \Level_{L} \rightarrow \Level_{L}\\
\present^*~(h, l) = \present'~h \triangleright l
}

$\interpret^*$ and $\present^*$ meet following requirements. We show the proofs for $\interpret$. The $\present^*$ proofs are obtained by substituting $present$ for $interpret$ in the proofs.

$\present*$ and $\interpret*$ only return results that are valid, and moreover, if old level is argument, then that one is returned: \note{only seem to need half of these reqs for the proofs.}

\xprlab{
\interpret^* (l,h) \in \interpret~l}{Intr$^*$-Valid} 
\xprlab{
h \in \interpret~l \imp h = \interpret^* (l,h)}{Intr$^*$-Idem} 
\xprlab{
\present^* (h,l) \in \present~h}{Pres$^*$-Valid}  %never used!
\xprlab{
l \in \present~h \imp l = \present^* (h,l)}{Pres$^*$-Idem}
\note{find out when (and if) these are used}


\xpr{
\interpret^* (l, h) \in \interpret~l		& \qquad \text{\sc Intr$^*$-Valid}\\ %Intr$^*$-Valid
h \in \interpret~l \imp h = \interpret^* (l,h) 		& \qquad \text{\sc Intr$^*$-Idem}\\ 
}

\bigskip
{\bf Validity}

In order to prove {\sc Intr$^*$-Valid}, we use the property $x \triangleright y \in \para{x}$, which can be proved by structural induction on $x$

\begin{proof} 
{\bf case} $x = *_T$:\\
\prf{
True & \Imp{$y \tp T$} \\
y 				\in \setof{t}{t \tp T}	& \Imp{{\sc $\para{\hole}$-Def}}\\
y 				\in \para{*_T}		& \Imp{{\sc $\triangleright$-Def}}\\
*_T \triangleright y 	\in \para{*_T}
}


{\bf case} $x = C~x^*_0 \dots x^*_n$ and $y = C~y_0 \dots y_n$\\
Induction Hypothesis is $x^*_i \triangleright y_i \in \para{x*_i}$ \note{How to make this first step a bit nicer?}
\prf{
True\\
				 \Imp{Induction Hypothesis}\\
C~(x^*_0 \triangleright y_0) \dots (x^*_n \triangleright y_n) \in  \setof{ C~x_0 \dots x_n}{x_0 \in \para{x^*_0} \land \dots  \land x_n \in \para{x^*_n}} \\
				 \Eqv{{\sc $\para{\hole}$-Def}}\\
C~(x^*_0 \triangleright y_0) \dots (x^*_n \triangleright y_n) \in \para{C~x^*_0 \dots x^*_n}\\
				 \Eqv{{\sc $\triangleright$-Def}}\\
C~x^*_0 \dots x^*_n \triangleright C~y_0 \dots y_n \in \para{C~x^*_0 \dots x^*_n}
}

{\bf case} $x = C~x^*_0 \dots x^*_n$ and $y = C'~y_0 \dots y_m$, with $C \neq C'$\\
\prf{
True\\
		\Imp{{\sc $default$-Valid}}\\
default (C~x^*_0 \dots x^*_n) \in \para{C~x^*_0 \dots x^*_n}\\
		\Eqv{{\sc $\triangleright$-Def}}\\
C~x^*_0 \dots x^*_n \triangleright C'~y_0 \dots y_m \in \para{C~x^*_0 \dots x^*_n} 
}
\end{proof}

Now we can prove {\sc Intr$^*$-Valid}: 

\begin{proof}
\prf{
True 									\\
		\Imp{$y \triangleright x \in \para{y}$}\\
\interpret'~l \triangleright h \in \para{interpret' l}	\\
		\Imp{\sc Restrict}\\
\interpret'~l \triangleright h \in \interpret~l		& \Imp{definition of $interpret^*$}\\
\interpret^* (l, h) \in \interpret~l
}
\end{proof}

\bigskip
{\bf Idempotency}

We prove the idempotency: {\sc Intr$^*$-Idem}.

Need this property:  $y \in \para{x} \imp x \triangleright y = y$, structural induction on $x$:

\begin{proof}
{\bf case} $x = *_T$:\\
\prf{
True					& \Eqv{reflexivity of $=$} \\
y = y				& \Eqv {\sc $\triangleright$-Def}\\
*_T \triangleright y = y	& \Imp{how do we call this?}\\
y \in \para{*_T} \imp {*_T \triangleright y = y} % braces are for spacing around \triangle
}

{\bf case} $x = C~x^*_0 \dots x^*_n$ and $y = C~y_0 \dots y_n$\\
Induction Hypothesis is 
$y^i \in \para{x*^i} \imp  x^*_i \triangleright y_i = y_i$\\
\prf{
y \in \para{x}
				& \Eqv{definitions of $x$ and $y$}\\
C~y_0 \dots y_n \in \para{C~x^*_0 \dots x^*_n}
				& \Eqv{{\sc $\para{\hole}$-Def}}\\
C~y_0 \dots y_n \in \setof{ C~x_0 \dots x_n}{x_0 \in \para{x^*_0} \land \dots  \land x_n \in \para{x^*_n}} 
				& \Imp{property of set comprehension}\\
y_0 \in \para{x^*_0} \land \dots \land y^n \in \para{x^*_n}
				& \Eqv{Induction Hypothesis}\\
x^*_0 \triangleright y_0 = y_0  \land \dots \land  x^*_n \triangleright y_n = y_n
				& \Imp{$n$ times {\sc Leibniz}}\\
C~(x^*_0 \triangleright y_0) \dots (x^*_n  \triangleright y_n) = C~y_0 \dots y_n
				& \Eqv{{\sc $\triangleright$-Def}}\\
C~x^*_0 \dots x^*_n \triangleright C~y_0 \dots y_n = C~y_0 \dots y_n
				& \Eqv{definitions of $x$ and $y$}\\
x \triangleright y = y
}

The third case will not occur.\\
{\bf case} $x = C~x^*_0 \dots x^*_n$ and $y = C'~y_0 \dots y_m$, with $C \neq C'$\\
\prf{
y \in \para{x}
				& \Eqv{definitions of $x$ and $y$}\\
C'~y_0 \dots y_m \in \para{C~x^*_0 \dots x^*_n} 
				& \Eqv{{\sc $\para{\hole}$-Def}}\\
C'~y_0 \dots y_m \in \setof{ C~x_0 \dots x_n}{x_0 \in \para{x^*_0} \land \dots  \land x_n \in \para{x^*_n}} 
				& \Eqv{property of set comprehension}\\
\exists x_0 \dots x_n : C'~y_0 \dots y_m = C'~x_0 \dots x_n 
				& \Eqv{$C \neq C'$}\\
False
				& \Imp{This step seems a bit uncommon}\\
x \triangleright y = y
}
\end{proof}

Now the proof of idempotency is easy:

Proof of $h \in \interpret~l \imp h = \interpret^* (l,h)$:

\begin{proof}
\prf{
h \in \interpret~l 				& \Imp{\sc Restrict}\\
h \in \para{\interpret'~l}		& \Imp{$y \in \para{x} \imp x \triangleright y = y$}\\
h = \interpret'~l \triangleright h 	& \Imp{definition of $interpret^*$}\\
h = \interpret^* (l,h)
}
\end{proof}




%																
%																
%																
\section{Combining two layers}

\bl
\* we want: H M L \{pres inv, identity, update \rarr new H'' M'' L'' close, bla\}
\* we have H M and M L  \{pres inv, identity, update \rarr new H'' M'' L'' close, bla\}
\* we can prove close, bla
\el

Want to model a layered architecture. bla bla. First split this one in two. An intermediate level appears $Level_M$, and we have two layers according to previous spec. 

We have: 
\xpr{
\present_H &\tp& \Level_{H} \rightarrow \{ \Level_{M} \}\\
\present_L &\tp& \Level_{M} \rightarrow \{ \Level_{L} \}\\
\interpret_H &\tp& \Level_{L} \rightarrow \{ \Level_{M} \}\\
\interpret_L &\tp& \Level_{M} \rightarrow \{ \Level_{H} \}\\
}

We can define $\present$ and $\interpret$ in terms of the two layers:

\xpr{
\present\ \level_{H} & \equ & \{ \level_L \:|\: \level_L \in \present_L~\level_M \land \level_M \in \present_L~\level_H \}\\
\interpret~\level_{L} & \equ & \{ \level_H \:|\: \level_H \in \interpret_H~\level_M \land \level_M \in \interpret_L~\level_L \}\\
}

or: (mention this?)

\xpr{
\present & \equ & \present_L \klei  \present_H\\
\interpret & \equ &\interpret_H \klei  \interpret_L
}

\bigskip {\bf Presentation invariant}

Presentation invariant for combination:

\xprlab{
\level_{L} \in \present~\level_{H}\\
}{Present-HL}

Equivalent to (?): 
%there is an $\level_{M}$ such that {\sc Present-H} and {\sc Present-L} hold:

\xpr{
\exists \level_{M}: \level_{L} \in \present_L~\level_{M} \wedge \level_{M} \in \present_H~\level_{H}\\
}

\bl
\* make it an invariant for three levels? (dropping the $\exists \level_{M}$)
\el

Can express it with Kleisli as well:

\xprlab{
\level_{L} \in (\present_{L} \klei \present_{H})~\level_{H}
}{Present-HL}



\bigskip {\bf InterPresent}

Using:

\xprlab{
\level_{M} \in \present_H~\level_{H} \imp \level_{H} \in \interpret_H~\level_{M}
}{InterPresent-H}

and

\xprlab{
\level_{L} \in \present_L~\level_{M} \imp \level_{M} \in \interpret_L~\level_{L}
}{InterPresent-L}


we want to get:

\xprlab{
\level_{L} \in \present~\level_{H} \imp \level_{H} \in \interpret~\level_{L}
}{InterPresent}


\begin{proof}
\prf{
\level_{L} \in \present~\level_{H} 
		& \Imp{definition of $present$} \\
\exists \level_M : \level_L = \present_L~\level_M \land \level_M = \present_L~\level_H 
		& \Imp{\sc InterPresent-H} \\
\exists \level_M : \level_L = \present_L~\level_M \land \level_{H} \in \interpret_H~\level_{M}
		& \Imp{\sc InterPresent-L} \\
\exists \level_M : \level_M = \interpret_L~\level_L \land \level_{H} \in \interpret_H~\level_{M} 
		& \Imp{definition of $interpret$} \\
\level_{H} \in \interpret~\level_{L}
}
\end{proof}

%Kleisli bits for {\sc InterPresent-L} and {\sc InterPresent-H}
%
%\xpr{
%\level_{H}~ \in (\interpret_{H} \klei \present_{H})~\level_{H}\\
%\level_{M}~ \in (\interpret_{M} \klei \present_{M})~\level_{M}
%}


\subsection{Edit}

We have $level_{H}$, $level_{M}$, and $level_{L}$:

\xpr{
\level_{L} \in \present_L~\level_{M} \wedge \level_{M} \in \present_H~\level_{H}\\
\level_{L} \leadsto \level'_{L} 
}

We need $level''_{H}$,  $level''_{M}$, and $level''_{L}$ that restore the invariant. \note{do we need to preserve medium? if apparent in H, or L, automatic, and if not maybe not necessary? Still, we probably do: eg. when med e.s is temporarily hidden, we don't want it to get lost}

\xpr{
& & (level''_{H}, level''_{L})~\text{such that}~
\left\{ \begin{array}{ll}
            \level''_{L} \in \present~\level''_{H}\\
            \level''_{L}~\text{"close to"}~\level'_{L} & \text{\{imprecise edit and preserve lower e.s \}}\\
            \level''_{H}~\text{"close to"}~\level_{H} & \text{\{preserve higher e.s \}}\\
           \end{array}
\right.
}


Solution is these computations:

%\xpr{
%\interpret_L^* \tp \Level_{L} \times \Level_{M} \rightarrow \Level_{M}\\
%\interpret_H^* \tp \Level_{M} \times \Level_{H} \rightarrow \Level_{H}\\
%\present_H^* \tp \Level_{H} \times \Level_{M} \rightarrow \Level_{M}\\
%\present_L^* \tp \Level_{M} \times \Level_{L} \rightarrow \Level_{L}\\
%}

\xprlab{
\level'_{M} = \interpret_L^* (\level'_{L},\level_{M})\\ 
\level''_{H} = \interpret_H^* (\level'_{M},\level_{H})\\
\level''_{M} = \present_H^* (\level''_{H}, level'_{M})\\
\level''_{L} = \present_L^* (\level''_{M}, level'_{L})
}{Compute}


not exactly the same. Upper is the same, but lower is split. Kind of nested: lowerUp (upper ) lowerDwn

Mention that this can be made more uniform by always using $level' = \interpret$ and add $\level''_{H} = \level'_{H}$?

\bc more uniform:
\interpret_L^* \tp \Level_{L} \times \Level_{M} \rightarrow \Level_{M}\\
\level'_{M} = \interpret_L^* (\level'_{L},\level_{M})\\ 
\interpret_H^* \tp \Level_{M} \times \Level_{H} \rightarrow \Level_{H}\\
\level''_{H} = \interpret_H^* (\level'_{M},\level_{H})\\ 
\present_H^* \tp \Level_{H} \times \Level_{M} \rightarrow \Level_{M}\\
\level''_{M} = \present_H^* (\level''_{H}, level'_{M})
\present_L^* \tp \Level_{M} \times \Level_{L} \rightarrow \Level_{L}\\
\level''_{L} = \present_L^* (\level''_{H}, level'_{L})
\ec

\bl
\* We want h'' s.t. l'' close to l
\* Is this the case when m'' is close to m and l'' is close to l, for the individual layers? Or is there an m'' that is not closest to m, but for which pres m is closest to l?
\el

UNCLEAR: how do we relate old val for $level_M$? put it in presentation inv? We need it for es.

\bigskip {\bf No unnecessary lower level changes}

If result of edit is presentation of something, it is unchanged by {\sc Compute}: \note{How to formulate this one?}

\xpr{
\exists h : level'_L \in \present~h \imp level''_L = level'_L
}

Unfortunately, this is not true:

\xpr{
\present_H x\ = (x,x)   & \hspace{1cm} & \present_L\ (x,y) = y \\
\interpret_H\ (x,y) = x &                     & \interpret_L\ y = (*,y)\\
}

we have $1 \in present 1$, but according to compute: 

\xpr{
0			&		& (0,0)	  & \\ 
\downarrow	&		& \uparrow & \downarrow\\
(0,0)			&		& (0,1)	  & (0,0)\\
\downarrow	&		& \uparrow & \downarrow\\
0			&\leadsto	& 1		  & 0
}

\bl
\* Counter example
\* L' Pres H0 (L' Pres M0 Pres H0), but result is L'' Pres H' with L' /= L''
\* interpret gives M' for which L' Pres M' (we know there is one (M0), so it cannot fail to return one, bla)
\* if higher interpret gives H' for which M' Pres H' then Extra says M'' = M' and L'' = L', so (not M' Pres H')
\el

\bigskip {\bf No unnecessary higher level changes}

$\level'_L \in \present~\level_H \imp \level''_H = \level_H$\\
We should probably use the fact that $\level_M$ is related by {\sc Present}.

%																
%																
%																
\section{Combining multiple layers}

\bl
\* Similar to previous section, but now $n$ instead of 2
\* 'Recursive' approach? Does not seem possible because of explicit intermediate levels.
\el

We have:

\xpr{
\present_i &\tp& \Level_{i} \rightarrow \{ \Level_{i+1} \}\\
\interpret_i &\tp& \Level_{i+1} \rightarrow \{ \Level_{i} \}\\
}

We define $\present$ and $\interpret$:

\xpr{
\present~\level_{0} & \equ & \{ \level_n \:|\: \forall i<n :  \level_{i+1} \in \present_i~\level_i \}\\
\interpret~\level_{n} & \equ & \{ \level_0 \:|\: \forall i<n : \level_i \in \interpret_{i+1}~\level_{i+1}  \}\\
}


\bigskip {\bf Presentation invariant}

\bigskip {\bf InterPresent}

\subsection{Edit}

We have $level_{H}$, $level_{M}$, and $level_{L}$:

\xpr{
\level_{L} \in \present_L~\level_{M} \wedge \level_{M} \in \present_H~\level_{H}\\
\level_{n} \leadsto \level'_{n} 
}

We need $level''_i$,   that restore the invariant.

\xprlab{
& & (level''_{i})~\text{such that}~
\left\{ \begin{array}{ll}
            \level''_{n} \in \present~\level''_{0}\\
            \level''_{n}~\text{"close to"}~\level'_{n} & \text{\{imprecise edit \}}\\
            \level''_{i}~\text{"close to"}~\level'_{i} & \text{\{preserve e.s \}}\\
           \end{array}
\right.
}{Compute}


Solution is these computations: \note{be more precise about indices?}

\xpr{
\interpret_{i}^* \tp \Level_{i+1} \times \Level_{i} \rightarrow \Level_{i}\\
\level'_{i} = \interpret_{i+1}^* (\level'_{i+1},\level_{i})\\ 
\level''_{0} = \level'_{0}\\
\present_{i}^* \tp \Level_{i} \times \Level_{i+1} \rightarrow \Level_{i+1}\\
\level''_{i+1} = \present_i^* (\level''_{i}, level'_{i+1})
}

%																
%																
%																
\section{Duplicate presentations}

Informal
\bl
\* Choice in interpret may be due to duplicates or '???'
\* $type Document = Int$ 
\* Duplicate: $present x = (x,x)$ with several possible interprets: $interpret (0,1) = 0 or 1$ 
\* ???: $present x = 2x$ also with several interprets: $interpret 1 = 0 or 1$ 
\* Hard to distinguish between the two.
\* Somehow for duplicates, closeness is not an issue in selecting the one we want:
\* eg. $present x = (x,x,x)$ with edit $(0,0,0)\leadsto(1,0,0)$ should give $(1,1,1)$, which is not as close as $(0,0,0)$
\* A difference seems to be that using stars on other fields but the edited one, make a non-ambiguous interpret possible in the duplication case, but not in the other case.
\* eg. $interpret (1,*,*) = 1$
\* duplicates may be hard to spot: eg. $present x = (x `div` 0xff, x `mod` 0xff)$ is not a duplication.
\* $1 \to "one"$ can be seen as three partial duplicates. 
\el

Old statement: if there are several choices for interpret, which all obey {\sc InterPresent}, then there are duplicates. This does not seem to be true. (eg. $present n = 2n$)

%																
%																
%																
\section{Incrementality}
Informal


%																
%																
%																
\section{Loose ends}
\bl
\* what about error nodes in document?
\* what about inserting pres elts that resemble a chapter title? Is this handled well?
\* difference between {\em presentation extra state} and {\em interpretion extra state}
\* what if present is not total?
\el


%																
%																
%																
\section{document editing}
Skipping lower layers



%																
%																
%																
\section{layer skipping}
Skipping higher layers

\renewcommand{\present}[0]{{\tt present}}					%56
\renewcommand{\interpret}[0]{{\tt interpret}}				%56
                                                                          