\chapter{Specifying a layered editor}
\label{chap:singleLayer}

\renewcommand{\present}{\ensuremath{\mathit{present}}}
\renewcommand{\interpret}{\ensuremath{\mathit{interpret}}}
\newcommand{\spc}{\textvisiblespace}


% not used, so we redefine these commands
\renewcommand{\H}{_{\, \mathrm H}}  % old \H seems to put '' above the next character
\renewcommand{\L}{_{\, \mathrm L}} % was an L with a dash in the middle
\newcommand{\M}{_{\, \mathrm M}}
\newcommand{\HH}{_{\, \mathrm {HH}}} 
\newcommand{\HL}{_{\, \mathrm {HL}}} 
\newcommand{\LH}{_{\, \mathrm {LH}}} 
\newcommand{\LL}{_{\, \mathrm {LL}}} 
\newcommand{\CH}{_{\, \mathrm {CH}}} 
\newcommand{\CL}{_{\, \mathrm {CL}}} 
\newcommand{\C}{_{\, \mathrm C}} 
\newcommand{\Eqclass}[2]{{#1}/_{\!{#2}}}
\newcommand{\eqclass}[2]{[\,{#1}\,]_{#2}}
\newcommand{\Eqcl}[2]{\Eqclass{#1}{\simeq {\mathrm {#2}}}}
\newcommand{\eqcl}[2]{\eqclass{#1}{\simeq {\mathrm {#2}}}}
\newcommand{\Eqstarcl}[2]{{#1}/_{\!\stackrel{*}{\simeq} {\mathrm {#2}}}}
\newcommand{\eqstarcl}[2]{[\,{#1}\,]_{\!\stackrel{*}{\simeq} {\mathrm {#2}}}}
\newcommand{\eqr}{\ensuremath{\simeq}}
\newcommand{\eqstar}{\ensuremath{\stackrel{*}{\simeq}}}
\newcommand{\reuz}{\ensuremath{\triangleright}}
\newcommand{\reuze}[1]{\ensuremath{\triangleright_{\!_\mathrm{#1}}}}
\newcommand{\reuzestar}{\ensuremath{\stackrel{*}{\triangleright}}}
\newcommand{\rel}{\ensuremath{\sim}}



{\em *** Version: \today~ ***}


\section{Questions:}

\subsection{Unclear}

%\bl
%\o what identifiers to use, $\present, \Present$?
%\o how to layout the equations and put label at the right?
%\o How to use increased vertical spacing in proofs?
%\o Operators between identifiers look asymmetrical: $\Level\H \times \Level_L$. Fix using \verb|\:|? %(eg. \verb|\times\:| \rarr $\Level\H \times\, \Level_L$) solution: use \verb|\!|
%\el


%$True \imp P$ vs. $True \eq P$. Answer: usually $\eq$ only in some weird cases $\imp$

%\subsection{Problems}
%
%{\bf Asymmetry between $interpret$ and $present$:}
%
%\bl
%\o When two Documents present as the same presentation. They are equal up to extra state.
%\o When two Presentations interpret to the same document. They may be equal up to extra state, but %they may also be incorrect presentations.
%\el
%
%Example: 
%
%\begin{math}
%Document \tp (Int, Char) ~~~ Presentation \tp String\\
%present (i,\_) = whitespace \cat english~i\\ 
%h \in {(7, 'a'),(7,'b'),(7,'c'),\dots} : present~h = \{"seven", "\spc seven", "\spc\spc seven", \dots\}\\
%l \in {
% }
% \left\{ \begin{array}{l}
%            "seven", " seven", "  seven", \dots \\
%            "sevven", "\spc sevven", "\spc\spc sevven", \dots \\
%            \dots
%            \end{array}
%\right\} : interpret~l = \{(7, 'a'),(7,'b'),(7,'c'),\dots\}\\
%\end{math}




%																
%																
%																
\section{Old stuff about mappings and trees}

\bl
\o From first half of old chapter 5
\el



%																
%																
%																
\section{Intro}

%Somewhere: combinators guaranteeing safety are not what we want. 
%Only spec. responsibility is left to layer. Pierce: only one way E.S. No 
%structural updates. Incomplete. No duplicates.
\bl
\o Even in pure structure editor there are pres. oriented bits. eg navigation (pointing problem)
\el

\bl
\o Following is a specification of interpret. Presentation is assumed to be given.
\o Process we use is to start with basic case: an abstract editor. 
\o Then step by step add complications.
\el

\note{Add small examples (a la $7 \leftrightarrow $"sevven")}


%																
%																
%																
\section{Single layer} \label{sect:singleSimple}

\bl
\o Simple abstract editor: Two levels: document and presentation.
\o Immediate presentation.
\o Editing is changing presentation. (unrealistic)
\o Duplicates are allowed, but cannot be handled in a way that a user would expect.
\el

%The presentation invariant is satisfied if and only if the lower level is a correct presentation of the higher %level. The invariant is expressed using an abstract function  
%$\Present \tp \Level\H \rightarrow \Level_L$.

Given a $\present$, we specify an $\interpret$.

\xpr{
\present & \tp &  \Level\H \rightarrow \Level_L\\
\interpret  & \tp & \Level_L \rightarrow \Level\H\\
}

\bl
\o $present$ total+explanation (what if not total)
\o $interpret$ is total as well + expl. (easy to make total)
\o present is injective ($present h = present h' \imp h = h'$)
\o present is not surjective. not all pres have a doc
\o we also want interpret to be total. So it is more than just the inverse. 
\el
\head{Presentation invariant}

\bl
\o The presentation invariant states that the lower level is a correct presentation of the higher level.
\el

\xprlab{
\level_L & \equ & \present~\level\H
}{Present}

\head{InterPresent}

\bl
\o Property {\sc InterPresent}\note{name: Correctness/Well behaved/\dots?} 
\o Presenting followed by interpreting is identity on higher level: \note{normalizing doc may not occur}
\o name comes from compose interpret and present
\el

\xprlab{
l \equ \present~h \imp h \equ \interpret~l  
}{InterPresent}

Equivalently, we can express the {\sc InterPresent} property using function composition: \note{worry about domain?}

\xpr{
\interpret \oo \present = id_{\Level\H} 
}

\bl
\o implies that present is injective ($present h = present h' \imp h = h'$)
\o does not imply that it is surjective. not all pres have a doc
\o we also wanted interpret to be total. So it is more than just the inverse. 
\o implies that interpret is surjective.
\el

\bl
\o Reverse need not hold, since present is not nec. surjective.
\o eg. syntax highlighting: \present ({\tt Return True}) = {\tt "{\bf Return} True"}
\o but also need entering without colors/styles: \interpret ({\tt "Return True"}) = ({\tt Return True})
\o And $\present \oo \interpret$ ({\tt "Return True"}) $\neq$ ({\tt "{\bf Return} True"}) 
\o Reverse also does not hold for duplicates, but these are not explained until later.
\el

\subsection{Editing}

\bl
\o We are modeling an Editor, so values change.
\o On a higher level update, simply re-present. No problem
\o Lower level is updated by a user. Need to find updates on both levels.
\el


From now on $level\L$ and $level\H$ are state of editor before edit. $Level'\L$ is result of update, and  $level''\L$ and $level''\H$ are final values after computation.

An edit operation takes place when {\sc Present} holds:

\xpr{
& & \level\L = \present~\level\H\\
& & \level\L \leadsto \level'\L 
}

\bl
\o Most likely the invariant no longer holds: $\level'\L \neq \present~\level\H$
\o Find new upper level (and lower).
\el

\bl 
\o If  $\level'$ is a presentation of some $\level''\H$, this is the one we want. (cannot guarantee that with extra state)
\o explain {\sc Pres-Inert} and {\sc Doc-Inert}
\o Also possible that $\level'\L$ is not a presentation of any higher level. 
\o Can discard the edit operation, but can also try to find one that is and was intended by the user
\o Interpret chooses.
\el

Summarizing, we need:

\xpr{
(level''\H, level''\L)~\text{such that:}
}
\xpr{
\level''\L = \present~\level''\H 				& \jstf{Postcondition}\\
\level''\L~\text{"close to"}~\level'\L 			& \jstf{Imprecise edit}\\
(\exists h : \level'\L = \present~h) \imp \level''\L = \level'\L	& \jstf{\sc Pres-Inert}\\
\level'\L = \present~\level\H \imp \level''\H = \level\H & \jstf{{\sc Doc-Inert}}
}

Mention that {\sc Doc-Inert} also implies $\level''\L = \level'\L$ by {\sc Pres-Inert}.

We could add that if there is an $h$ then $level''\H = h$ but in next section we will lose this.

The solution is this computation: \note{align label with last eq.? how?}

\xprlab{
\level''\H & \equ & \interpret~\level'\L\\
\level''\L & \equ & \present~\level''\H 
}{Compute}

\head{Postcondition}

by definition, the postcondition holds.

\head{{\sc Pres-Inert}}

If the updated lower level ($\level'\L$) is a valid presentation of some $h \tp Level\H$, then the {\sc InterPresent} guarantees that final value the lower level is equal to $\level'\L$.

If we assume $\level''\H$ and $\level''\L$ to be defined according to {\sc Compute} then:

$\level'\L = \present~h \imp \level''\L = \level'\L$

\begin{proof} Assume $\level'\L = \present~h$ then
\prf{
\level''\L						& \Equ{\sc Compute}\\
\present~\level''\H				& \Equ{\sc Compute}\\
\present~(\interpret~\level'\L)		& \Equ{$\level'\L = \present~h$}\\
\present~(\interpret~(\present~h))	& \Equ{\sc InterPresent}\\ % \Equ{definition of $\oo$}\\
%\present~((\interpret \oo \present)~h)	& 
\present~h 						& \Equ{$\level'\L = \present~h$}\\
\level'\L
}
\end{proof}

\head{{\sc Doc-Inert}}

$\level'\L = \present~\level\H \imp \level''\H = \level\H$ has a simple proof:


\begin{proof} Assume $\level'\L = \present~\level\H$ then
\prf{
\level''\H 						& \Equ{\sc Compute}\\
\interpret~\level'\L				& \Equ{$\level'\L = \present~\level\H$}\\
\interpret~(\present~\level\H)		& \Equ{\sc InterPresent}\\
\level\H
}
\end{proof}


\head{Imprecise edit}

On the other hand, if $\level'\L$ is not a valid presentation, $interpret$ needs to choose a  $\level''\L$ that resembles what the user intended by performing the edit operation. This is reflected in the specification by the requirement $\level'\L~\text{"close to"}~\level''\L$.

\bl
\o $\interpret$ must be defined in such a way that we get the closest one.
\o Responsibility of the designer.
\el

\bl
\o Is "close to" what we want? For simple editors, maybe it is, but is "-$>$" close to \rarr? For duplicates, "close to" is definitely not what we want (but there are no duplicates here yet).
\o What about Chapter titles and fonts? Will these be handled correctly with "close to" req.?
\el
%is interpret the inverse of present? If one exist, we can use it, but it must also work for L not in 
%range of present.





%																
%																
%																
\section{Extra state} \label{sect:singleExtra}


Extra state: present and translate are no longer functions, but binary relations. example, still, we model these with functions from sets to sets.

Next section we give a concrete instance of these classes.

\bl
\o Simple example a declaration (identifier \& rhs) in a source editor is presented by leaving out the righthand side:
\o  \verb| (Decl "b" True) <-> "b  =  ..."|\note{or complex expression?}
\o Whitespace is presentation extra state: \verb| (Decl "b" True) -> "*b*=*..."|
\o Right-hand side is interpretation extra state: \verb|b = ... -> (Decl "b" *)|
\el

\bl
\o Intuitively: Presentation extra state: information on how document is viewed. 
\o Interpretation extra state: information in doc that is not visible. 
\el

\bl
\o move these to first half (or previous chapter)
\o Examples Pres: tree browser expansion state, table view sorting, file manager details/icons (positions), layout.
\o Intr: Structure view.
\el

\bl
\o Model as eq. classes on doc and on pres.
\o Elements of class are equal except for E.S nodes.
\el


\subsection{Equivalence classes}

\renewcommand{\Eqcl}[2]{\Eqclass{#1}{\!_{#2}}}
\renewcommand{\eqcl}[2]{\eqclass{#1}{\!_{#2}}}

Equivalence relation:

$x \eqr y$ or if there are two:  $x \eqr\H y$  and $x \eqr\L y$ 


$\eqclass{x}{R}$ is the equivalence class that contains $x$

\xpr{
%( \eqclass{\hole}{R}) \tp S \to  \Eqclass{S}{R}\\
\eqclass{x}{R} = \setof{y}{x R y}
}


$\Eqcl{S}{R}$ is set of all equivalence classes of $R$ (call it factor set)?
\xpr{
%( \eqclass{\hole}{R}) \tp S \to \Eqclass{S}{R}\\
\Eqclass{S}{R} = \setof{\eqclass{x}{R}}{ x \in S}
}


For level types, we add a letter to disambiguate: (maybe get rid of $\sim$ and use $\Eqclass{Level\H}{H}$ and $\eqclass{h}{H}$, then $H$ and $L$ are the eq. relations)

$\Eqcl{Level\H}{H}$ and $\eqcl{h}{H}$ vs $\Eqcl{Level\L}{L}$ and $\eqcl{h}{L}$ 

Finite rep:

$x \eqstar y$ and $x \eqstar\H y$  vs.  $x \eqstar\L y$ 

Notation on a type:

\xpr{
\Eqclass{S}{R} \subset \mathcal{P} S
}

overload this one on values, to get from a value to its eq. class. \note{Figure out details. If types are sets, values and types are not that distinct anymore}



The relations we use here are $H$ and $L$, so classes are 

\xpr{
\eqcl{Level\H}{H} \subset \mathcal{P} Level\H
}

and value:

\xpr{
(\eqcl{\hole}{H}) \tp Level\H \to \eqcl{\Level\H}{H}
}

Proposition:
\xpr{
\eqclass{x}{R} = \eqclass{y}{R} ~\lor~ (\eqclass{x}{R} \cap \eqclass{y}{R}) = \emptyset
}


Add some examples?


\subsection{Presenting and interpreting}

\bl
\o New types, no longer on elements, but on sets of elements. (so relations). And, more specifically on eq. classes.
\o intuition: because arg is also an eq. class, es from one function can never influence result of its dual.
\el

\head{$present$ and $interpret$}

\xpr{
Present &\tp& \Level\H \rel \Level\L\\
Interpret &\tp& \Level\L \rel \Level\H
}

Something about what the equivalence classes are: Lower is underspecified: 
PER story




\xpr{
\present &\tp& \Eqcl{\Level\H}{H} \rightarrow  \Eqcl{\Level\L}{L}\\
\interpret &\tp& \Eqcl{ \Level\L}{L} \rightarrow \Eqcl{\Level\H}{H}
}

result is always an eq. class (follows from type)

\xpr{
L = \present~H \imp L = \eqcl{l}{L}\\
H = \interpret~L \imp H = \eqcl{h}{H}
}

How $\present$ and $\interpret$ are related to $\Present$ and $\Interpret$

\xpr{
l~Present~h ~\eqv~ \eqcl{l}{L} = \present~ \eqcl{h}{H}\\
h~Interpret~l ~\eqv~ \eqcl{h}{H} = \interpret~\eqcl{l}{L}
}


\head{Presentation invariant}

\bl
\o Presentation invariant changes: Works on sets now.
\o provide $present$ with eq. class for $level\H$ and demand $level\L$ is in resulting class.
%\o (\verb|"b = ..."| as well as more spatious \verb|"b    =    ..."| are correct presentations of \verb|Decl "b" True|
\el

\xprlab{
\level\L~\Present~\level\H\\
\text{or, equivalently}\\
\eqcl{\level\L}{L} = \present~\eqcl{\level\H}{H}
}{Present}

\head{{\sc InterPresent} property}

\bl
\o {\sc InterPresent} is about sets instead of values, but it stays pretty much the same.
\el

\xprlab{
l~\Present~h \imp h~\Interpret~l\\
or\\
\eqcl{l}{L} = \present~\eqcl{h}{H} \imp \eqcl{h}{H} = \interpret~\eqcl{l}{L}\\
}{InterPresent}

or:

\xpr{
\interpret \oo \present = id_{\Eqcl{\Level\H}{H}} 
}

% Kleisli is not applicable anymore. Maybe useful somewhere below.
% old problem with Kleisli:
% l in (pres  `kleisli` int) l       is not True, because that alread holds if there is s single h in int l
% for which l in pres h, but we want for all h in int l that l in pres h


\subsection{Editing}

\bl
\o Edit lower level, when presentation invariant holds:
\el


\xpr{
\eqcl{\level\L}{L} = \present~\eqcl{\level\H}{H}\\
\level\L \leadsto \level'\L 
}

Pres inv. must be restored, so compute $level''\H$ and $level''\L$ that restore the invariant. 
Both $\interpret$ and $\present$ (may) provide several results, so we have to choose:

We now have relations, so we restate some of the requirements from previous section. (and maybe a new one arises)

We need:
\xpr{
(level''\H, level''\L)~\text{such that:}
}
\xpr{
\level''\L~\Present~ \level''\H 		& \jstf{Postcondition}\\
\level''\L~\text{"close to"}~\level'\L 			& \jstf{Imprecise edit (+pres. lower extr.st.?)}\\
%(\exists h : \eqcl{\level'\L}{L} = \present~\eqcl{h}{H}) \imp \level''\L = \level'\L	& \jstf{{\sc Pres-Inert}}\\
(\exists h : \level'\L~\Present~h) \imp \level''\L = \level'\L	& \jstf{{\sc Pres-Inert}}\\
\level'\L~\Present~\level\H \imp \level''\H = \level\H & \jstf{{\sc Doc-Inert}}\\
\level''\H~\text{"close to"}~\level\H & \jstf{preserve higher es}\\
}
\bl
\o Two "close to"s, explain more. One is for correct behavior of intended edit and extra state. Other is for maintaining extra state only.
\el


Solution:

Have to extract one from the eq. class. Choice from e.s. values. We want one for which e.s. resembles the previous value for the level as much as possible. (h'' resembles h, and l'' resembles l')

Assume a function $\reuz$, which takes old and new value and returns resembling one from eq. class of new val. More precisely, we need two: $\reuze{H}$ and $\reuze{L}$.


Here, only the type and a few requirements, but in next section, an actual instance.

\xprlab{
\reuz ::  \Eqclass{X}{R} \to X \to X\\
}

\xprlab{X \reuz y \in X}						{$\reuz$-Valid} 
\xprlab{y \in X \imp X \reuz y = y}				{$\reuz$-Idem} 
\xprlab{(X \reuz y) \text{~``close to''~} y}		{$\reuz$-Close} 

If $y \in X$, then {\sc $\reuz$-Idem} guarantees close to, because we have equality. In other cases, the requirement remains vague.


With $\reuz$ function we can extract, and with $\eqcl{\hole}{X}$ we can inject, so now we can give compute:

\xprlab{
\level''\H = (\interpret~ \eqcl{\level'\L}{L})  \reuze{H}   \level\H  \\ %(\level'\L,\level\H)\\ 
\level''\L = (\present~ \eqcl{\level''\H}{H})   \reuze{L}   \level'\L % ^* (\level''\H, level'\L)
}{Compute}

The levels defined by compute meet the requirements:

\head{Postcondition holds}

Rather trivial again.

\head{{\sc Pres-Inert}}

If result of edit is presentation of something, it is unchanged by {\sc Compute}: 

$\level'\L \in \present~H \imp \level''\L = \level'\L$

\begin{proof}  In the proof, we assume: $level'\L \in \present~H$, and show that if we perform the substitutions from {\sc Compute} it follows that $level''\L = level'\L$.

\xpr{
 \eqcl{( \eqcl{x}{X} \reuz y)}{X} =  \eqcl{x}{X}
}

$y \in  \eqcl{x}{X} ~\imp~  \eqcl{y}{X} =  \eqcl{x}{X}$

\prf{
\setof{x'}{ y \simeq x'}\\
 \eqcl{y}{X} =  \eqcl{x}{X} 
}

\prf{
True 						& \Imp{\sc $\reuz$-Valid}\\
\eqcl{x}{X} \reuz y \in \eqcl{x}{X}	& \Imp{prop}\\
\eqcl{x}{X} \reuz \eqcl{y}{X} =  \eqcl{x}{X}
}

$l \in \present~H \imp \eqcl{l}{L} = \present~H$
Assume $l \in \present~H$ 
\prf{
l' \in \eqcl{l}{L} \imp l' \in \present~H\\
l' \in \present~H \imp l' \in \eqcl{l}{L}\\
}

\prf{
\level''\L\\
			\Equ{\sc Compute}\\
\present~ \eqcl{\level''\H}{H}   ~\reuz~   \level'\L\\
			\Equ{\sc Compute}\\
\present~ \eqcl{(\interpret~ \eqcl{\level'\L}{L}  ~\reuz~  \level\H)}{H}   ~\reuz~   \level'\L\\
			\Equ{ }\\
\present~ \eqcl{(\interpret~(\present~H)  ~\reuz~  \level\H)}{H}   ~\reuz~   \level'\L\\
			\Equ{\sc InterPresent }\\
\present~ \eqcl{(H  ~\reuz~   \level\H)}{H}   ~\reuz~   \level'\L\\
			\Equ{ }\\
\present~H  ~\reuz~  \level'\L\\
			\Equ{ {\sc $\reuz$-Idem} and $\level'\L \in \present~H$ }\\
\level'\L
} 

\end{proof}

% Simple layer
%Assume $\level'\L = \present~h$ then
%\prf{
%\level''\L						& \Equ{\sc Compute}\\
%\present~\level''\H				& \Equ{\sc Compute}\\
%\present~(\interpret~\level'\L)		& \Equ{$\level'\L = \present~h$}\\
%\present~(\interpret~(\present~h))	& \Equ{\sc InterPresent}\\ % \Equ{definition of $\oo$}\\
%%\present~((\interpret \oo \present)~h)	& 
%\present~h 						& \Equ{$\level'\L = \present~h$}\\
%\level'\L
%} 
%\end{proof}

%OLD proof without eq. classes
%First, we derive the values for $\level\H$ and $\level'\L$:
%
%$\level\H = \interpret^* (\level'\L,\level\H)$
%
%\prf{
%True 						& \Imp{assumption}\\
%\level'\L \in \present~h 			& \Imp{\sc Extra}\\
%\level\H \in \interpret~\level'\L 	& \Imp{\sc Intr$^*$-Idem}\\
%\level\H = \interpret^* (\level'\L,\level\H)
%}
%
%
%And $\level'\L = \present^* (\level\H, level'\L)$
%
%\prf{
%True 						& \Imp{assumption}\\
%\level'\L \in \present~h 			& \Imp{\sc Extra}\\
%\level\H \in \interpret~\level'\L 	& \Imp{\sc InterPresent}\\
%\level'\L \in \present~\level\H	& \Imp{\sc Pres$^*$-Idem}\\
%\level'\L = \present^* (\level\H, level'\L)\\
%}
%
%Using these results, we can show the equality of $level''\L$ and $level'\L$:
%
%\prf{
%\level''\L 						& \Eqv{\sc Compute}\\
%\present^* (\level''\H, level'\L)	& \Eqv{\sc Compute}\\
%\present^* (\interpret^* (\level'\L,\level\H), level'\L) & \Eqv{$\level\H = \interpret^* %(\level'\L,\level\H)$} \\
%\present^* (\level\H, level'\L) 	& \Eqv{$\level'\L = \present^* (\level\H, level'\L)$} \\
%\level'\L
%}
%\end{proof}

\head{{\sc Doc-Inert}}


%\level''\H = \interpret~ \eqcl{\level'\L}{L}  \reuz   \level\H  \\
%\level''\L =  \present~ \eqcl{\level''\H}{H}   \reuz   \level'\L 

$\level'\L~\Present~\level\H \imp \level''\H = \level\H $

Assumption is equivalent to $\eqcl{\level'\L}{L} = present~\eqcl{\level\H}{H}$, either because of its type or because we define present like that.

\begin{proof} Assume $\level'\L \in \present~\eqcl{\level\H}{H}$ then
\prf{
\level''\H 						                 	& \Equ{\sc Compute}\\
\interpret~ \eqcl{\level'\L}{L}  \reuz   \level\H 	& \Equ{$l \in \present~H \imp \eqcl{l}{L} ~=~ \present~H$}\\
\interpret~(\present~\eqcl{\level\H}{H})  \reuz  \level\H 	& \Equ{\sc InterPresent}\\
\eqcl{\level\H}{H}  \reuz  \level\H 				& \Equ{{\sc $\reuz$-Idem} and $\level\H \in \eqcl{\level\H}{H}$} \\
\level\H
}
\end{proof}


%With extra state, also possible to edit while preserving the invariant. (only add spaces in language %without layout rule). In that case not only we don't want $l'=l''$, but also that higher level does not %change. This is only an issue with extra state, since in previous section, $present$ was injective, and %hence $\level\L' = present~\level\H \land \level\L'' = present~\level\H \imp \level'\L = \level''\L$ %\dots \note{explain more?} 
%
%$\level'\L \in \present~\level\H \imp \level''\H = \level\H$\\
%
%\begin{proof} 
%\prf{
%\level'\L \in \present~\level\H	& \Imp{\sc InterPresent}\\
%\level\H \in \interpret~\level'\L	& \Imp{\sc Intr$^*$-Idem}\\
%\level\H = \interpret^* (\level'\L,\level\H) & \Imp{\sc Compute}\\ 
%\level\H = \level''\H 
%}
%\end{proof}
%
%\note{Doing this proof by starting with $\level\H$ and substituting is tricky, because {\sc InterPresent} %is needed in one step, so we would need a lemma-like thing (like in the previous proof).}

\head{Imprecise edit}

\bl
\o If $\level'\L$ is not a valid presentation, $\level''\L$ must resemble what the user intended (requirement $\level'\L~\text{"close to"}~\level''\L$).
\el






%																
%																
%																
\section{Finite representation for equivalence classes} \label{sect:finiteRep}

Notes:

\bl
\o $pres n = n `div` 2$ is no longer possible, since eq. classes on pres are then $\set{\set{0,1},\set{2,3}, \dots }$, for which there is no * rep. (0 and 1 in eq. class implies all elts in eq. class)
\o can we handle $\set{ {\tt "return\spc1" },{\tt "return\spc\spc1" }, {\tt "return\spc\spc\spc1" }, \dots}$? Yes, maybe use an isomorphic view 
\el 

will give $present$ and $interpret$ that satisfy laws from prev. section.

commit ourselves to certain eq. classes only.




\subsection{Trees with wildcards}

Introduce datatype with some wildcards. (Not placeholders from prev. chapters) Wildcards represent any value (of correct type) Wildcards represent extra state.


A simple tree data type with boolean values in the nodes and leafs, and ints in leafs:

\xpr{
\data~Tree  = Bin~Bool~Tree~Tree~|~Leaf~Bool~Int\\
}

A possible $Tree^*$ is when int in leaf, and bool in node are extra:

\xpr{
\data~Tree^*  = Bin~*~Tree^*~Tree^*~|~Leaf~Bool~*\\
}

With value: $Bin *_{Tree} (Leaf~*_{Bool})$ 

Note that * is not on a type (bool in leaf is still bool), but on the child type of the constructor. Prim types (arity 0) therefore have no *.

Root cannot be star (not logical either). But can be fixed by adding an extra constructor to the level.

More generally:

\xpr{
\data~T  =  C_0~T_{0,0} \dots T_{0,m_0} | \dots | C_n~T_{n,0} \dots T_{n,m_n} \\
}
becomes:
\xpr{\data~T^* =  C_0~U_{0,0} \dots U_{0,m_0} | \dots | C_n~U_{n,0} \dots U_{n,m_n}\\ 
with~ T^*_{i,j} = T^*_{i,j}  \text{~or~} *    
}

Same constructor, therefore all vals of T are also values of $T^*$


Still need this one?

Stars represent sets. All $t^*$ are sets, but not reverse. example

\xprlab{
\para{\hole} \tp T^* \to \set{T} \\
\para{*_ T} \eq \setof{x}{x \tp T}\\
\para{C~x^*_0 \dots x^*_n} \eq \setof{ C~x_0 \dots x_n}{x_0 \in \para{x^*_0} \land \dots  \land x_n \in \para{x^*_n}} 
}{$\para{\hole}$-Def}\note{name it {\sc $\para{\hole}$-Def} (or {\sc $\para{\hole}$-Char})?} \note{use $x^*_i$?}



\subsection{A type $T^*$ defines an equivalence relation on $T$}

For a type $T$, if we add some wildcards, we get an equivalence relation $\eqstar$ on $T$

We define an ``equality up to extra state''. So two values are equal for those parts that are not in es (ie. *).

Do it by making a function that drops all extra state and replaces by *. It depends on the *-data type. 

\renewcommand{\core}{\mathbf{core}}


\xprlab{
{\bf data}~T^* = \dots | C~t_0 \dots t_n | \dots\\
\\  
\core~(C~x_0 \dots x_n) \eq C~x'_0 \dots x'_n \\
{\bf where}~ x'_i = \left\{
\begin{array}{ll}
* & , {\bf if}~ t_i = *   \\
\core~x_i & , {\bf otherwise}
\end{array}\right.
}{$\core$-Def}


Then compare the two core bits.


\xprlab{
%\setof{ x \eqstar y}{  x \in \para{x^*} \land y \in \para{y^*} \land x^* = y^*}
x \eqstar y ~\eq~  \core~x = \core~y
}{$\eqstar$-Def}

Since $\eqstar$ is defined as equality on the result of a function (ie. $\core$), we know it is an equivalence relation on the domain of that function by the following theorem:

Actual theorem is

\xpr{
(\exists f : \forall x,y : x R y ~\eqv~ (f~x = f~y)) ~\eqv~ R~\text{is an equivalence relation}
}


This one was already proven:

\xpr{
(\exists f : x R y ~\eqv~ (f~x = f~y) ~\imp~ R~\text{is an equivalence relation}
}


\begin{proof} \note{maybe leave this out}
\prf{
x R x 	& \Eqv{definition of $R$}\\
f x = f x 	& \Eqv{reflexivity of =}\\
True	
}


\prf{
x R y  	& \Eqv{definition of $R$}\\
f x = f y 	& \Eqv{symmetry of =}\\
f y = f x 	& \Eqv{definition of $R$}\\
y R x 
}\note{get $\eqv$ instead of $\imp$}

\prf{
x R y  \land y R z 		& \Eqv{definition of $R$}\\
f x = f y \land f y = f z	& \Imp{transitivity of =}\\
f x = f z 				& \Eqv{definition of $R$}\\
x R z 
}
\end{proof}

\subsection{Reuse/\reuzestar}

Restrict ourselves to reversible. So no longer all eq. classes, but only those that have wildcard-representations. explain bit more, two or more implies all. also for constructor.\note{comment probably obsolete}

\xprlab{
\present &\tp& \Eqstarcl{\Level\H}{H} \rightarrow  \Eqstarcl{\Level\L}{L}\\
\interpret &\tp& \Eqstarcl{\Level\L}{L} \rightarrow  \Eqstarcl{\Level\H}{H}
}
%interpret~l = \para{interpret'~l}\\
%present~h = \para{present'~h}
%}{Restrict}

Now we define a reuse function.

Reusing may fail. So we need a default function: $default \tp a^* \rightarrow a$.

\xprlab{
default~x^* \in \para{x^*}\\
}{$default$-Valid}

\bl
\o A default value is equal to its arg, except for the $*$'s, which are filled in with initial values.
\o Def may be misleading, because recursive def means that each type has a default whereas it may be context sensitive: ie Whitespace = (int,int) , but we don't want (0,0) but (1,0).
\o Moreover, default may depend on other information. Eg. whitespace coming from a pretty printing algorithm. This would be an extra argument to default, but the req. stays.
\el

When *, just use righthand side. When not star, left has priority. \note{subscribt X is not right in $\eqstarcl{X}{X}$}

\xprlab{
\reuzestar ::  \eqstarcl{X}{X} \to X \to X\\
*_a \reuzestar  y = y\\
C~x^*_0 \dots x^*_n \reuzestar C~y_0 \dots y_n = C~(x^*_0 \reuzestar y_0) \dots (x^*_n  \reuzestar y_n) \\
C~x^*_0 \dots x^*_n \reuzestar C'~y_0 \dots y_m = default (C~x^*_0 \dots x^*_n)
}{$\reuzestar$-Def}


\bl
\o Examples:
\o $(\verb|Token |* \verb| "True"|) \reuzestar  (\verb|Token (1,2) "False"|) = \verb|Token (1,2) "True"|$
\o $(\verb|Decl "x" |*) \reuzestar  (\verb|Decl "y" | True) = (\verb|Decl "x" | True)$\note{or complex expression?}
\o When constructors don't match, there is a problem. Types of children most probably will not match, so can't recurse. 
\o $\verb|Plus|~e_1~e_2 \leadsto \verb|Times|~e_1~e_2$ is a problem
\o Responsibility of layer to handle. Whitespace always str. similar, no prob. Plus/Times. has to be specd by editor designer. Sometimes makes no sense. Then es gets lost.
\o Also, no sub-object identities here, so $[e_0, e_1] \leadsto [e_1,e_0]$ is a problem
\o even $[e_0, e_1] \leadsto [e_0]$ is not nice, because constructor does not match on tail
\o IMPORTANT: Look at reuse for tokens, is this correct? 
\el

Now we have to prove the requirements for $\reuzestar$

\xprlab{X \reuzestar y \in X}						{$\reuz$-Valid} 
\xprlab{y \in X \imp X \reuzestar y = y}				{$\reuz$-Idem} 
\xprlab{X \reuzestar y \imp x \text{~``close to''~} y}	{$\reuz$-Close} 


\head{Validity}

\begin{proof}
\prf{
}
\end{proof}

\head{Idempotency}

\begin{proof}
\prf{
}
\end{proof}

\head{Closeness}

A bit vague. Better reuse gets closer.

\subsection{Conclusions?}

\bl
\o improve reuse with subobject identities.
\el





%																
%																
%																
\section{Combining two layers}  \label{sect:combinedExtra}


Notes:
\bl
\o ES in middle level that is presented on lower will be ES there too. Same thing for higher.
\o Are the eq. classes of combined * layers still * eq. classes?
\o Specification is also for middle level, even though you don't see it if you combine a  combined layer. in imp. we have to plumb middle levels around, but not in spec.
\el

%\bl
%\o we want: H M L \{pres inv, interpresent, update \rarr new H'' M'' L'' close, bla\}
%\o we have H M and M L  \{pres inv,  interpresent, update \rarr new H'' M'' L'' close, bla\}
%\o we cannot prove much yet.
%\el

Want to model a layered architecture. bla bla. First split this one in two. An intermediate level appears $Level\M$, and we have two layers according to previous spec. 

\head{$present$ and $interpret$}


We have: 

\xpr{
\present\H   &\tp& \Eqcl{\Level\H}{HH} \rightarrow  \Eqcl{\Level\M}{HL}\\
\interpret\H &\tp& \Eqcl{ \Level\M}{HL} \rightarrow \Eqcl{\Level\H}{HH}\\
\present\L    &\tp& \Eqcl{\Level\M}{LH} \rightarrow  \Eqcl{\Level\L}{LL}\\
\interpret\L  &\tp& \Eqcl{ \Level\L}{LL} \rightarrow \Eqcl{\Level\M}{LH}\\
}

Middle level type is equal, but the equivalence relations are very likely to be different. ($\eqr\HL \neq \eqr\LH$)

We define a combined present and interpret as functions between eq. classes: (similar to Section~\ref{sect:singleExtra})

\xpr{
\present\C &\tp& \Eqcl{\Level\H}{CH} \rightarrow  \Eqcl{\Level\L}{CL}\\
\interpret\C &\tp& \Eqcl{ \Level\L}{CL} \rightarrow \Eqcl{\Level\H}{CH}
}

Again it is likely that  $\eqr\CH \neq \eqr\HH$ and $\eqr\CL \neq \eqr\LL$.


All classes together:
\xpr{
\Eqcl{\Level\H}{CH} &                   & ~~~~\rightarrow     &                   & \Eqcl{\Level\L}{CL}\\
\Eqcl{\Level\H}{HH} & ~~\rightarrow~~ & \Eqcl{\Level\M}{HL}\\
                                &                   & \Eqcl{\Level\M}{LH} & ~~\rightarrow~~ & \Eqcl{\Level\L}{LL}\\
}

The definition of $\present\C$ and $\interpret\C$ : 

\xpr{
\present\C~H & \equ & \bigcup~\setof{ present\L \eqcl{m }{LH}~} {~ h \in H \land m \in \present\H \eqcl{h}{HH}}\\
\interpret\C~L & \equ & \bigcup~\setof{ interpret\H \eqcl{m }{HL}~} {~ l \in L \land m \in \interpret\L \eqcl{l}{LL}}\\
%\interpret~\level\L & \equ & \{ \level\H \:|\: \level\H \in \interpret\H~\level\M \land \level\M \in %\interpret\L~\level\L \}\\
}

Kleisli:

\xpr{
\present & \equ & (\present\L \oo \eqcl{\hole}{LH}) \klei  (\present\H \oo \eqcl{\hole}{HH})\\
\interpret & \equ &(\interpret\H  \oo \eqcl{\hole}{HL}) \klei  (\interpret\L  \oo \eqcl{\hole}{LL})
}

When are the results of these equivalence classes?

\head{Equivalence classes for combination}

\bl
\o combining presents and interprets may affect classes. 
\o example of this
\o sometimes interpret is no longer okay for present, since its classes are too coarse
\o when doesn't this happen?
\el

Maybe
\bl
\o if no longer works, then interpresent also fails, so if we have interpresent for combination, then classes are okay? 
\o does not prevent classes of present from getting to big
\el

\head{Presentation invariant}

Presentation invariant for combination $\eqcl{l}{CL} = \present\C \eqcl{h}{CH}$ is equivalent to:

\xprlab{
\eqcl{\level\L}{CL} = \bigcup~\setof{ present\L \eqcl{m }{LH}~} {~ h \in \eqcl{\level\H}{CH} \land m \in \present\H \eqcl{h}{HH}}\\
}{Present}

Which implies there is a $\level\M$ such that {\sc Present} holds between $\level\H$ and $\level\M$, as well as between $\level\M$ and $\level\L$:

\xpr{
%l \in \eqcl{\level\L}{CL} \imp \exists m,h : \eqcl{l}{LL} = \present\L \eqcl{m0}{LH} \land %\eqcl{m}{HL} = \present\H \eqcl{h}{HH} \land h \in \eqcl{\level\H}{CH} ??
\exists \level\M : \eqcl{\level\L}{LL} = \present\L \eqcl{\level\M}{LH} \land \eqcl{\level\M}{LL} = \present\H \eqcl{\level\H}{HH}
}


%\xpr{
%\exists \level\M: \level\L \in \present\L~\level\M \wedge \level\M \in \present\H~\level\H\\
%}



\head{InterPresent}

Using interpresent on both parts of the combined layer:

\xprlab{
\eqcl{m}{HL} = \present\H~\eqcl{h}{HH} \imp \eqcl{h}{HH} = \interpret\H~\eqcl{m}{HL}
}

and

\xprlab{
\eqcl{l}{LL} = \present\L~\eqcl{m}{LH} \imp \eqcl{m}{LH} = \interpret\L~\eqcl{l}{LL}
}


we want to get:

\xprlab{
\eqcl{l}{CL} = \present\C~\eqcl{h}{CH} \imp \eqcl{h}{CH} = \interpret\C~\eqcl{l}{CL}\\
}{InterPresent}

Which is not true. But if the lower layer in the combination is always a single layer, and we do not use interpresent on the higher layer, then we don't need it on the combined layer.
%
%\begin{proof}
%\prf{
%\level\L \in \present~\level\H 
%		& \Imp{definition of $present$} \\
%\exists \level\M : \level\L = \present\L~\level\M \land \level\M = \present\L~\level\H 
%		& \Imp{\sc InterPresent-H} \\
%\exists \level\M : \level\L = \present\L~\level\M \land \level\H \in \interpret\H~\level\M
%		& \Imp{\sc InterPresent-L} \\
%\exists \level\M : \level\M = \interpret\L~\level\L \land \level\H \in \interpret\H~\level\M 
%		& \Imp{definition of $interpret$} \\
%\level\H \in \interpret~\level\L
%}
%\end{proof}



\subsection{Editing}

Pres inv holds for high and low, so we have $level\H$, $level\M$, and $level\L$:

\xpr{
\eqcl{\level\L}{LL} = \present\L~\eqcl{\level\M}{LH} ~\land~
\eqcl{\level\M}{HL} = \present\H~\eqcl{\level\H}{HH}\\
\level\L \leadsto \level'\L 
}

We need $level''\H$,  $level''\M$, and $level''\L$ that restore the invariant. \note{do we need to preserve medium? if apparent in H, or L, automatic, and if not maybe not necessary? Still, we probably do: eg. when med e.s is temporarily hidden, we don't want it to get lost}


Copied from single layer extra state section:

We need:
\xpr{
(level''\H, level''\L)~\text{such that:}
}

\xpr{
\level''\L~\Present~ \level''\H 		& \jstf{Postcondition}\\
\level''\L~\text{"close to"}~\level'\L 			& \jstf{Imprecise edit (+pres. lower extr.st.?)}\\
%(\exists h : \eqcl{\level'\L}{L} = \present~\eqcl{h}{H}) \imp \level''\L = \level'\L	& \jstf{{\sc Pres-Inert}}\\
(\exists h : \level'\L~\Present~h) \imp \level''\L = \level'\L	& \jstf{{\sc Pres-Inert}}\\
\level'\L~\Present~\level\H \imp \level''\H = \level\H & \jstf{{\sc Doc-Inert}}\\
\level''\H~\text{"close to"}~\level\H & \jstf{preserve higher es}\\
}


Solution is these computations:

%\xpr{
%\interpret\L^* \tp \Level\L \times \Level\M \rightarrow \Level\M\\
%\interpret\H^* \tp \Level\M \times \Level\H \rightarrow \Level\H\\
%\present\H^* \tp \Level\H \times \Level\M \rightarrow \Level\M\\
%\present\L^* \tp \Level\M \times \Level\L \rightarrow \Level\L\\
%}

\xprlab{
\level''\M = (\interpret\L~ \eqcl{\level'\L}{LL})  \reuze{bLH}   \level\M  \\
\level''\H = (\interpret\H~ \eqcl{\level'\M}{LH})  \reuze{HH}   \level\H  \\
\level''\M = (\present\H~ \eqcl{\level''\H}{HH})   \reuze{HL}   \level'\M\\
\level''\L = (\present\L~ \eqcl{\level''\M}{LH})   \reuze{LL}   \level'\L
}{Compute}

\xprlab{
compute^{intr}:
\level'\M = (\interpret\L~ \eqcl{\level'\L}{LL})  \reuze{LH}   \level\M  \\
\level'\H = compute^{intr}\H \level'\M  \level\H \\
\\
compute^{pres}:
\level''\M = compute^{pres}\H \level''\H  \level'\M\\
\level''\L = (\present\L~ \eqcl{\level''\M}{LH})   \reuze{LL}   \level'\L
}{Compute}
%\xprlab{
%\level'\M = \interpret\L^* (\level'\L,\level\M)\\ 
%\level''\H = \interpret\H^* (\level'\M,\level\H)\\
%\level''\M = \present\H^* (\level''\H, level'\M)\\
%\level''\L = \present\L^* (\level''\M, level'\L)
%}{Compute}


not exactly the same. Upper is the same, but lower is split. Kind of nested: lowerUp (upper ) lowerDwn

Mention that this can be made more uniform by always using $level' = \interpret$ and add $\level''\H = \level'\H$?

\bc more uniform:
\interpret\L^* \tp \Level\L \times \Level\M \rightarrow \Level\M\\
\level'\M = \interpret\L^* (\level'\L,\level\M)\\ 
\interpret\H^* \tp \Level\M \times \Level\H \rightarrow \Level\H\\
\level''\H = \interpret\H^* (\level'\M,\level\H)\\ 
\present\H^* \tp \Level\H \times \Level\M \rightarrow \Level\M\\
\level''\M = \present\H^* (\level''\H, level'\M)
\present\L^* \tp \Level\M \times \Level\L \rightarrow \Level\L\\
\level''\L = \present\L^* (\level''\H, level'\L)
\ec

\bl
\o We want h'' s.t. l'' close to l
\o Is this the case when m'' is close to m and l'' is close to l, for the individual layers? Or is there an m'' that is not closest to m, but for which pres m is closest to l?
\el


\xprlab{
\eqcl{m'}{LH} \reuze{LH} m \in \eqcl{m}{HL}}{Orthogonal}


\xprlab{
m' \in \eqcl{m}{HL} ~\imp~ \eqcl{m'}{LH} \reuze{LH} m \in \eqcl{m}{HL}}{Weaker-Orthogonal}

Different notation:
\xprlab{
m'~HL~m ~\imp~ \eqcl{m'}{LH} \reuze{LH} m~HL~m}{Weaker-Orthogonal}


\xprlab{
\forall m \in [m_0]\LH : & (\exists h_0 : m = pres \eqcl{h_0}{HH}) \lor\\
& (present\H \oo interpret\H) \eqcl{m}{HL} \subset \eqcl{m_0}{LH}}{Compatible}

There should be an extra condition in compatible, or we can always prove $l''=l'$.

\head{{\sc Pres-Inert}}

If result of edit is presentation of something, it is unchanged by {\sc Compute}: \note{How to formulate this one?}

\xpr{
\exists h : level'\L \in \present~h \imp level''\L = level'\L
}

Unfortunately, this is not true:

\xpr{
\present\H x\ = (x,x)   & \hspace{1cm} & \present\L\ (x,y) = y \\
\interpret\H\ (x,y) = x &                     & \interpret\L\ y = (*,y)\\
}

we have $1 \in present 1$, but according to compute: 

\xpr{
0			&		& (0,0)	  & \\ 
\downarrow	&		& \uparrow & \downarrow\\
(0,0)			&		& (0,1)	  & (0,0)\\
\downarrow	&		& \uparrow & \downarrow\\
0			&\leadsto	& 1		  & 0
}

\bl
\o Counter-example
\o L' Pres H0 (L' Pres M0 Pres H0), but result is L'' Pres H' with L' /= L''
\o interpret gives M' for which L' Pres M' (we know there is one (M0), so it cannot fail to return one, bla)
\o if higher interpret gives H' for which M' Pres H' then Extra says M'' = M' and L'' = L', so (not M' Pres H')
\el

\head{{\sc Doc-Inert}}

$\level'\L ~\Present~\level\H \imp \level''\H = \level\H$\\







\bc
%																
%																
%																
\section{Combining multiple layers}

\bl
\o Similar to previous section, but now $n$ instead of 2
\o 'Recursive' approach? Does not seem possible because of explicit intermediate levels.
\el

We have:

\xpr{
\present_i &\tp& \Level_{i} \rightarrow \{ \Level_{i+1} \}\\
\interpret_i &\tp& \Level_{i+1} \rightarrow \{ \Level_{i} \}\\
}

We define $\present$ and $\interpret$:

\xpr{
\present~\level_{0} & \equ & \{ \level_n \:|\: \forall i<n :  \level_{i+1} \in \present_i~\level_i \}\\
\interpret~\level_{n} & \equ & \{ \level_0 \:|\: \forall i<n : \level_i \in \interpret_{i+1}~\level_{i+1}  \}\\
}


\head{Presentation invariant}

\head{InterPresent}

\subsection{Edit}

We have $level\H$, $level\M$, and $level\L$:

\xpr{
\level\L \in \present\L~\level\M \wedge \level\M \in \present\H~\level\H\\
\level_{n} \leadsto \level'_{n} 
}

We need $level''_i$,   that restore the invariant.

\xprlab{
& & (level''_{i})~\text{such that}~
\left\{ \begin{array}{ll}
            \level''_{n} \in \present~\level''_{0}\\
            \level''_{n}~\text{"close to"}~\level'_{n} & \text{\{imprecise edit \}}\\
            \level''_{i}~\text{"close to"}~\level'_{i} & \text{\{preserve e.s \}}\\
           \end{array}
\right.
}{Compute}


Solution is these computations: \note{be more precise about indices?}

\xpr{
\interpret_{i}^* \tp \Level_{i+1} \times \Level_{i} \rightarrow \Level_{i}\\
\level'_{i} = \interpret_{i+1}^* (\level'_{i+1},\level_{i})\\ 
\level''_{0} = \level'_{0}\\
\present_{i}^* \tp \Level_{i} \times \Level_{i+1} \rightarrow \Level_{i+1}\\
\level''_{i+1} = \present_i^* (\level''_{i}, level'_{i+1})
}
\ec


%																
%																
%																
\section{Duplicate presentations}

Informal
\bl
\o Choice in interpret may be due to duplicates or '???'
\o $type Document = Int$ 
\o Duplicate: $present x = (x,x)$ with several possible interprets: $interpret (0,1) = 0 or 1$ 
\o ???: $present x = 2x$ also with several interprets: $interpret 1 = 0 or 1$ 
\o Hard to distinguish between the two.
\o Somehow for duplicates, closeness is not an issue in selecting the one we want:
\o eg. $present x = (x,x,x)$ with edit $(0,0,0)\leadsto(1,0,0)$ should give $(1,1,1)$, which is not as close as $(0,0,0)$
\o A difference seems to be that using stars on other fields but the edited one, make a non-ambiguous interpret possible in the duplication case, but not in the other case.
\o eg. $interpret (1,*,*) = 1$
\o duplicates may be hard to spot: eg. $present x = (x `div` 0xff, x `mod` 0xff)$ is not a duplication.
\o $1 \to "one"$ can be seen as three partial duplicates. 
\el

Old statement: if there are several choices for interpret, which all obey {\sc InterPresent}, then there are duplicates. This does not seem to be true. (eg. $present n = 2n$)

%																
%																
%																
\section{Incrementality}
Informal


%																
%																
%																
\section{Loose ends}
\bl
\o what about error nodes in document?
\o what about inserting pres elts that resemble a chapter title? Is this handled well?
\o difference between {\em presentation extra state} and {\em interpretion extra state}
\o what if present is not total?
\el


%																
%																
%																
\section{document editing}
Skipping lower layers



%																
%																
%																
\section{layer skipping}
Skipping higher layers

% restore old defs from thesis.sty
\renewcommand{\present}[0]{{\tt present}}					%56
\renewcommand{\interpret}[0]{{\tt interpret}}				%56
\renewcommand{\Core}[0]{\ensuremath{\mathit{Core}}}	%56
                                 