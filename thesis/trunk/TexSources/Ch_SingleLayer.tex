\chapter{One Layer}
\label{chap:singleLayer}

\renewcommand{\present}{\ensuremath{\mathit{present}}}
\renewcommand{\interpret}{\ensuremath{\mathit{interpret}}}
\newcommand{\spc}{\textvisiblespace}


% not used, so we redefine these commands
\renewcommand{\H}{_{\, \mathrm H}}  % old \H seems to put '' above the next character
\renewcommand{\L}{_{\, \mathrm L}} % was an L with a dash in the middle



{\em *** Version: \today~ ***}


\section{Questions:}

\subsection{Unclear}

%\bl
%\o what identifiers to use, $\present, \Present$?
%\o how to layout the equations and put label at the right?
%\o How to use increased vertical spacing in proofs?
%\o Operators between identifiers look asymmetrical: $\Level\H \times \Level_L$. Fix using \verb|\:|? %(eg. \verb|\times\:| \rarr $\Level\H \times\, \Level_L$) solution: use \verb|\!|
%\el
\bl
%\o $True \imp P$ vs. $True \eq P$. Answer: usually $\eq$ only in some weird cases $\imp$
\o $\set{\Level_L}$ vs. $\mathcal{P}\Level_L$
\el

%\subsection{Problems}
%
%{\bf Asymmetry between $interpret$ and $present$:}
%
%\bl
%\o When two Documents present as the same presentation. They are equal up to extra state.
%\o When two Presentations interpret to the same document. They may be equal up to extra state, but %they may also be incorrect presentations.
%\el
%
%Example: 
%
%\begin{math}
%Document \tp (Int, Char) ~~~ Presentation \tp String\\
%present (i,\_) = whitespace \cat english~i\\ 
%h \in {(7, 'a'),(7,'b'),(7,'c'),\dots} : present~h = \{"seven", "\spc seven", "\spc\spc seven", \dots\}\\
%l \in {
% }
% \left\{ \begin{array}{l}
%            "seven", " seven", "  seven", \dots \\
%            "sevven", "\spc sevven", "\spc\spc sevven", \dots \\
%            \dots
%            \end{array}
%\right\} : interpret~l = \{(7, 'a'),(7,'b'),(7,'c'),\dots\}\\
%\end{math}




%																
%																
%																
\section{Old stuff about mappings and trees}

\bl
\o From first half of old chapter 5
\el



%																
%																
%																
\section{Intro}

%Somewhere: combinators guaranteeing safety are not what we want. 
%Only spec. responsibility is left to layer. Pierce: only one way E.S. No 
%structural updates. Incomplete. No duplicates.
\bl
\o Even in pure structure editor there are pres. oriented bits. eg navigation (pointing problem)
\el

\bl
\o Following is a specification of interpret. Presentation is assumed to be given.
\o Process we use is to start with basic case: an abstract editor. 
\o Then step by step add complications.
\el

\note{Add small examples (a la $7 \leftrightarrow $"sevven")}


%																
%																
%																
\section{Single layer}

\bl
\o Simple abstract editor: Two levels: document and presentation.
\o Immediate presentation.
\o Editing is changing presentation. (unrealistic)
\o Duplicates are allowed, but cannot be handled in a way that a user would expect.
\el

%The presentation invariant is satisfied if and only if the lower level is a correct presentation of the higher %level. The invariant is expressed using an abstract function  
%$\Present \tp \Level\H \rightarrow \Level_L$.

Given a $\present$, we specify an $\interpret$.

\xpr{
\present & \tp &  \Level\H \rightarrow \Level_L\\
\interpret  & \tp & \Level_L \rightarrow \Level\H\\
}


\head{Presentation invariant}

\bl
\o The presentation invariant states that the lower level is a correct presentation of the higher level.
\el

\xprlab{
\level_L & \equ & \present~\level\H
}{Present}

$present$ is total function. all docs have pres. but not surjective. not all pres have doc. mention injective here?

$interpret$ is total as well.

\head{InterPresent}

\bl
\o Property {\sc InterPresent}\note{name: Correctness/Well behaved/\dots?} 
\o Presenting followed by interpreting is identity on higher level: \note{normalizing doc may not occur}
\o name comes from compose interpret and present
\el

\xprlab{
l \equ \present~h \imp h \equ \interpret~l  
}{InterPresent}

Equivalently, we can express the {\sc InterPresent} property using function composition: \note{worry about domain?}

\xpr{
\interpret \oo \present = id_{\Level\H} 
}

\bl
\o implies that present is injective ($present h = present h' \imp h = h'$)
\o does not imply that present is total nor that it is surjective. (we do want it to be total)
\o we also want interpret to be total. So it is more than just the inverse. 
\el

\bl
\o Reverse need not hold, since present is not nec. surjective.
\o eg. syntax highlighting: \present ({\tt Return True}) = {\tt "{\bf Return} True"}
\o but also need entering without colors/styles: \interpret ({\tt "Return True"}) = ({\tt Return True})
\o And $\present \oo \interpret$ ({\tt "Return True"}) $\neq$ ({\tt "{\bf Return} True"}) 
\o Reverse also does not hold for duplicates, but these are not explained until later.
\el

\subsection{Edit}

\bl
\o We are modeling an Editor, so values change.
\o On a higher level update, simply re-present. No problem
\o Lower level is updated by a user. Need to find updates on both levels.
\el


From now on $level\L$ and $level\H$ are state of editor before edit. $Level'\L$ is result of update, and  $level''\L$ and $level''\H$ are final values after computation.

An edit operation takes place when {\sc Present} holds:

\xpr{
& & \level\L = \present~\level\H\\
& & \level\L \leadsto \level'\L 
}

\bl
\o Most likely the invariant no longer holds: $\level'\L \neq \present~\level\H$
\o Find new upper level (and lower).
\el

\bl 
\o If  $\level'$ is a presentation of some $\level''\H$, this is the one we want. (cannot guarantee that with extra state)
\o mention no unn. higher level upd.
\o Also possible that $\level'\L$ is not a presentation of any higher level. 
\o Can discard the edit operation, but can also try to find one that is and was intended by the user
\o Interpret chooses.
\el

Summarizing, we need:

\xpr{
(level''\H, level''\L)~\text{such that:}
}
\xpr{
\level''\L = \present~\level''\H 				& \jstf{Postcondition (?)}\\
\level''\L~\text{"close to"}~\level'\L 			& \jstf{Imprecise edit}\\
\level'\L = \present~h \imp \level''\L = \level'\L	& \jstf{no unnecessary lower level changes}\\
\level'\L = \present~\level\H \imp \level''\H = \level\H & \jstf{no unnecessary higher level changes}
}

\note{$h$ instead of $\level\H''$ in no unn. lower level change?}
\note {"close to" is " zachte eis" unless equality is possible? Isn't that logical?}

no unn. h.l. changes also implies $\level''\L = \level'\L$ by no unn. l.l. changes. Mention this?

The solution is this computation: \note{align label with last eq.? how?}

\xprlab{
\level''\H & \equ & \interpret~\level'\L\\
\level''\L & \equ & \present~\level''\H 
}{Compute}

\head{Postcondition}

by definition, the postcondition holds.

\head{No unnecessary lower level changes}

If the updated lower level ($\level'\L$) is a valid presentation of some $h \tp Level\H$, then the {\sc InterPresent} guarantees that final value the lower level is equal to $\level'\L$.

If we assume $\level''\H$ and $\level''\L$ to be defined according to {\sc Compute} then:

$\level'\L = \present~h \imp \level''\L = \level'\L$

\begin{proof} Assume $\level'\L = \present~h$ then
\prf{
\level''\L						& \Equ{\sc Compute}\\
\present~\level''\H				& \Equ{\sc Compute}\\
\present~(\interpret~\level'\L)		& \Equ{$\level'\L = \present~h$}\\
\present~(\interpret~(\present~h))	& \Equ{\sc InterPresent}\\ % \Equ{definition of $\oo$}\\
%\present~((\interpret \oo \present)~h)	& 
\present~h 						& \Equ{$\level'\L = \present~h$}\\
\level'\L
}
\end{proof}

\head{No unnecessary higher level changes}

$\level'\L = \present~\level\H \imp \level''\H = \level\H$ has a simple proof:


\begin{proof} Assume $\level'\L = \present~\level\H$ then
\prf{
\level''\H 						& \Equ{\sc Compute}\\
\interpret~\level'\L				& \Equ{$\level'\L = \present~\level\H$}\\
\interpret~(\present~\level\H)		& \Equ{\sc InterPresent}\\
\level\H
}
\end{proof}


\head{Imprecise edit}

On the other hand, if $\level'\L$ is not a valid presentation, $interpret$ needs to choose a  $\level''\L$ that resembles what the user intended by performing the edit operation. This is reflected in the specification by the requirement $\level'\L~\text{"close to"}~\level''\L$.

\bl
\o $\interpret$ must be defined in such a way that we get the closest one.
\o Responsibility of the designer.
\el

\bl
\o Is "close to" what we want? For simple editors, maybe it is, but is "-$>$" close to \rarr? For duplicates, "close to" is definitely not what we want (but there are no duplicates here yet).
\o What about Chapter titles and fonts? Will these be handled correctly with "close to" req.?
\el
%is interpret the inverse of present? If one exist, we can use it, but it must also work for L not in 
%range of present.





%																
%																
%																
\section{Extra state}


Extra state: present and translate are no longer functions, but binary relations. example, still, we model these with functions from sets to sets.

Next section we give a concrete instance of these classes.

\bl
\o Simple example a declaration (identifier \& rhs) in a source editor is presented by leaving out the righthand side:
\o  \verb| (Decl "b" True) <-> "b  =  ..."|\note{or complex expression?}
\o Whitespace is presentation extra state: \verb| (Decl "b" True) -> "*b*=*..."|
\o Right-hand side is interpretation extra state: \verb|b = ... -> (Decl "b" *)|
\el

\bl
\o Intuitively: Presentation extra state: information on how document is viewed. 
\o Interpretation extra state: information in doc that is not visible. 
\el

\bl
\o move these to first half (or previous chapter)
\o Examples Pres: tree browser expansion state, table view sorting, file manager details/icons (positions), layout.
\o Intr: Structure view.
\el

\bl
\o Model as eq. classes on doc and on pres.
\o Elements of class are equal except for E.S nodes.
\el


\subsection{Equivalence classes}

\newcommand{\Eqclass}[2]{{#1}/_{\!{#2}}}
\newcommand{\eqclass}[2]{[\,{#1}\,]_{#2}}

\newcommand{\Eqcl}[2]{\Eqclass{#1}{\sim {\mathrm #2}}}
\newcommand{\eqcl}[2]{\eqclass{#1}{\sim {\mathrm #2}}}
\newcommand{\eqstarcl}[2]{{#1}/_{\!\stackrel{*}{\sim} {\mathrm #2}}}

\newcommand{\eqr}{\ensuremath{\sim}}
\newcommand{\eqstar}{\ensuremath{\stackrel{*}{\sim}}}

\newcommand{\reuze}{\ensuremath{\triangleright}}
\newcommand{\reuzestar}{\ensuremath{\stackrel{*}{\triangleright}}}

Notation:

Equivalence relation:

$x \eqr y$ or if there are two:  $x \eqr\H y$  and $x \eqr\L y$ 


$\eqclass{x}{R}$ is the equivalence class that contains $x$ Sometimes denoted as $[x]_R$

\xpr{
%( \eqclass{\hole}{R}) \tp S \to  \Eqclass{S}{R}\\
\eqclass{x}{R} = \setof{y}{x R y}
}


$\Eqclass{S}{R}$ is set of all equivalence classes of $R$ (call it factor set)?
\xpr{
%( \eqclass{\hole}{R}) \tp S \to \Eqclass{S}{R}\\
S\Eqclass{}{R} = \setof{x\eqclass{}{R}}{ x \in S}
}


For level types, we add a letter to disambiguate: (maybe get rid of $\sim$ and use $\Eqclass{Level\H}{H}$ and $\eqclass{h}{H}$, then $H$ and $L$ are the eq. relations)

$\Eqcl{Level\H}{H}$ and $\eqcl{h}{H}$ vs $\Eqcl{Level\L}{L}$ and $\eqcl{h}{L}$ 

Finite rep:

$x \eqstar y$ and $x \eqstar\H y$  vs.  $x \eqstar\L y$ 

Notation on a type:

\xpr{
\Eqclass{S}{R} \subset \mathcal{P} S
}

overload this one on values, to get from a value to its eq. class. \note{Figure out details. If types are sets, values and types are not that distinct anymore}



The relations we use here are $\sim H$ and $\sim L$, so classes are 

\xpr{
\eqcl{Level\H}{H} \subset \mathcal{P} Level\H
}

and value:

\xpr{
(\eqcl{\hole}{H}) \tp Level\H \to \eqcl{\Level\H}{H}
}

Proposition:
\xpr{
\eqclass{x}{R} = \eqclass{y}{R} ~\lor~ (\eqclass{x}{R} \cap \eqclass{y}{R}) = \emptyset
}


Add some examples?


\subsection{?}

\bl
\o New types, no longer on elements, but on sets of elements. And, more specifically on eq. classes.
\o intuition: because arg is also an eq. class, es from one function can never influence result of its dual.
\el

\xpr{
\present &\tp& \Level\H \eqcl{}{H} \rightarrow \Level\L  \eqcl{}{L}\\
\interpret &\tp& \Level\L  \eqcl{}{L} \rightarrow \Level\H \eqcl{}{H}
}

result is always an eq. class
\xpr{
L = \present~H \imp L = l\eqcl{}{L}\\
H = \interpret~L \imp H = h\eqcl{}{H}
}

\head{Presentation invariant}

\bl
\o Presentation invariant changes: Works on sets now, so we use capital letters.
\o provide $present$ with eq. class for $level\H$ and demand $level\L$ is in resulting class.
%\o (\verb|"b = ..."| as well as more spatious \verb|"b    =    ..."| are correct presentations of \verb|Decl "b" True|
\el

\xprlab{
\level\L \in \present~\level\H \eqcl{}{H}
}{Present}

\head{{\sc InterPresent} property}

\bl
\o {\sc InterPresent} is about sets instead of values, but it stays pretty much the same.
\el

\xprlab{
L = \present~H \imp H = \interpret~L\\
}{InterPresent}

or:

\xpr{
\interpret \oo \present = id_{\Level\H \eqcl{}{H}} 
}

% l in (pres  `kleisli` int) l       is not True, because that alread holds if there is s single h in int l
% for which l in pres h, but we want for all h in int l that l in pres h

Extra property:

\xprlab{
L = \present~H' \imp (H = \interpret~L \imp L = \present~H)\\
}{Extra}

is not needed anymore, since it follows from {\sc InterPresent}. Easy to see. No proof here, because this will disappear, since the reader does not know there used to be an {\sc Extra}.


\subsection{Edit}

\bl
\o Edit lower level, when presentation invariant holds:
\el

\xpr{
& & \level\L \in \present~\level\H\eqcl{}{H}\\
& & \level\L \leadsto \level'\L 
}

Pres inv. must be restored, so compute $level''\H$ and $level''\L$ that restore the invariant. 
Both $\interpret$ and $\present$ (may) provide several results, so we have to choose:

functions are between sets, and levelh and levell are values, so we restate some of the requirements from previous section. (and maybe a new one arises)

We need:
\xpr{
(level''\H, level''\L)~\text{such that:}
}

\xpr{
\level''\L \in \present~\level''\H \eqcl{}{H} 		& \jstf{Postcondition (?)}\\
\level''\L~\text{"close to"}~\level'\L 			& \jstf{Imprecise edit (+pres. lower extr.st.?)}\\
\level'\L \in \present~H \imp \level''\L = \level'\L	& \jstf{no unnecessary lower level changes}\\
\level'\L \in \present~\level\H\eqcl{}{H} \imp \level''\H = \level\H & \jstf{no unnecessary higher level changes}\\
\level''\H~\text{"close to"}~\level\H & \jstf{preserve higher es (is this one necessary?)}\\
}
\bl
\o Two "close to"s, explain more. One is for correct behavior of intended edit. Other is for maintaining extra state
\el


%Old version without eq. classes
%\xpr{
%            \level''\L \in \present~\level''\H\\
%            \level''\L~\text{"close to"}~\level'\L & \text{\{imprecise edit + preserve lower e.s\}}\\
%            \level''\H~\text{"close to"}~\level\H & \text{\{preserve higher e.s \}}\\
%}
%$\level'\L \in \present~h \imp \level''\L = \level'\L$
%$\level'\L \in \present~\level\H \imp \level''\H = \level\H$

Solution:

% Old compute without eq. classes
%Because we cannot use $\present$ and $\interpret$ directly, since both have a set as result type, we %introduce two functions $\present*$ and $\interpret*$, which select the appropriate element from the %resulting set:
%
%\xpr{
%\interpret^* \tp \Level\L \times \Level\H \rightarrow \Level\H\\
%\present^* \tp \Level\H \times \Level\L \rightarrow \Level\L\\
%}
%
%\xprlab{
%\level''\H = \interpret^* (\level'\L,\level\H)\\ 
%\level''\L = \present^* (\level''\H, level'\L)
%}{Compute}

Have to extract one from the eq. class. Choice from e.s. values. We want one for which e.s. resembles the previous value for the level as much as possible. (h'' resembles h, and l'' resembles l')

Assume a function $\reuze$, which takes old and new value and returns resembling one from eq. class of new val. More precisely, we need two $\reuze$ functions (notation?).


Here, only the type and a few requirements, but in next section, an actual instance.

\xprlab{
\reuze ::  \eqclass{X}{R} \to X \to X\\
}

\xprlab{X \reuze y \in X}						{$\reuze$-Valid} 
\xprlab{y \in X \imp X \reuze y = y}				{$\reuze$-Idem} 
\xprlab{X \reuze y \imp x \text{~``close to''~} y}	{$\reuze$-Close} 

If $y \in X$, then {\sc $\reuze$-Idem} guarantees close to, because we have equality. In other cases, the requirement remains vague.


With $\reuze$ function we can extract, and with $\eqcl{}{X}$ we can inject, so now we can give compute:

\xprlab{
\level''\H = \interpret~\level'\L \eqcl{}{L}  \reuze   \level\H  \\ %(\level'\L,\level\H)\\ 
\level''\L = \present~\level''\H \eqcl{}{H}   \reuze   \level'\L % ^* (\level''\H, level'\L)
}{Compute}

The levels defined by compute meet the requirements: (or say ``establish postcondition''?)

\head{Postcondition holds}

Rather trivial again.

\head{No unnecessary lower level changes}

If result of edit is presentation of something, it is unchanged by {\sc Compute}: 


$\level'\L \in \present~H \imp \level''\L = \level'\L$

\begin{proof}  In the proof, we assume: $level'\L \in \present~H$, and show that if we perform the substitutions from {\sc Compute} it follows that $level''\L = level'\L$.

\xpr{
(x \eqcl{}{X} \reuze y) \eqcl{}{X} = x \eqcl{}{X}
}

$y \in x \eqcl{}{X} ~\imp~ y \eqcl{}{X} =  x\eqcl{}{X}$

\prf{
\setof{x'}{ y \simeq x'}\\
y \eqcl{}{X} =  x\eqcl{}{X} 
}

\prf{
True 						& \Imp{\sc $\reuze$-Valid}\\
x \eqcl{}{X} \reuze y \in x \eqcl{}{X}	& \Imp{prop}\\
x \eqcl{}{X} \reuze y \eqcl{}{X} =  x\eqcl{}{X}
}

$l \in \present~H \imp l\eqcl{}{L} = \present~H$
Assume $l \in \present~H$ 
\prf{
l' \in l\eqcl{}{L} \imp l' \in \present~H\\
l' \in \present~H \imp l' \in l\eqcl{}{L}\\
}

\prf{
\level''\L\\
			\Equ{\sc Compute}\\
\present~\level''\H \eqcl{}{H}   ~\reuze~   \level'\L\\
			\Equ{\sc Compute}\\
\present~(\interpret~\level'\L \eqcl{}{L}  ~\reuze~  \level\H) \eqcl{}{H}   ~\reuze~   \level'\L\\
			\Equ{ }\\
\present~(\interpret~(\present~H)  ~\reuze~  \level\H) \eqcl{}{H}   ~\reuze~   \level'\L\\
			\Equ{\sc InterPresent }\\
\present~(H  ~\reuze~   \level\H) \eqcl{}{H}   ~\reuze~   \level'\L\\
			\Equ{ }\\
\present~H  ~\reuze~  \level'\L\\
			\Equ{ {\sc $\reuze$-Idem} and $\level'\L \in \present~H$ }\\
\level'\L
} 

\end{proof}

% Simple layer
%Assume $\level'\L = \present~h$ then
%\prf{
%\level''\L						& \Equ{\sc Compute}\\
%\present~\level''\H				& \Equ{\sc Compute}\\
%\present~(\interpret~\level'\L)		& \Equ{$\level'\L = \present~h$}\\
%\present~(\interpret~(\present~h))	& \Equ{\sc InterPresent}\\ % \Equ{definition of $\oo$}\\
%%\present~((\interpret \oo \present)~h)	& 
%\present~h 						& \Equ{$\level'\L = \present~h$}\\
%\level'\L
%} 
%\end{proof}

%OLD proof without eq. classes
%First, we derive the values for $\level\H$ and $\level'\L$:
%
%$\level\H = \interpret^* (\level'\L,\level\H)$
%
%\prf{
%True 						& \Imp{assumption}\\
%\level'\L \in \present~h 			& \Imp{\sc Extra}\\
%\level\H \in \interpret~\level'\L 	& \Imp{\sc Intr$^*$-Idem}\\
%\level\H = \interpret^* (\level'\L,\level\H)
%}
%
%
%And $\level'\L = \present^* (\level\H, level'\L)$
%
%\prf{
%True 						& \Imp{assumption}\\
%\level'\L \in \present~h 			& \Imp{\sc Extra}\\
%\level\H \in \interpret~\level'\L 	& \Imp{\sc InterPresent}\\
%\level'\L \in \present~\level\H	& \Imp{\sc Pres$^*$-Idem}\\
%\level'\L = \present^* (\level\H, level'\L)\\
%}
%
%Using these results, we can show the equality of $level''\L$ and $level'\L$:
%
%\prf{
%\level''\L 						& \Eqv{\sc Compute}\\
%\present^* (\level''\H, level'\L)	& \Eqv{\sc Compute}\\
%\present^* (\interpret^* (\level'\L,\level\H), level'\L) & \Eqv{$\level\H = \interpret^* %(\level'\L,\level\H)$} \\
%\present^* (\level\H, level'\L) 	& \Eqv{$\level'\L = \present^* (\level\H, level'\L)$} \\
%\level'\L
%}
%\end{proof}

\head{No unnecessary higher level changes}


%\level''\H = \interpret~\level'\L \eqcl{}{L}  \reuze   \level\H  \\
%\level''\L =  \present~\level''\H \eqcl{}{H}   \reuze   \level'\L 
$\level'\L \in \present~\level\H\eqcl{}{H} \imp \level''\H = \level\H $

\begin{proof} Assume $\level'\L \in \present~\level\H\eqcl{}{H}$ then
\prf{
\level''\H 						                 	& \Equ{\sc Compute}\\
\interpret~\level'\L \eqcl{}{L}  \reuze   \level\H 	& \Equ{$l \in \present~H \imp l\eqcl{}{L} ~=~ \present~H$}\\
\interpret~(\present~\level\H\eqcl{}{H})  \reuze  \level\H 	& \Equ{\sc InterPresent}\\
\level\H\eqcl{}{H}  \reuze  \level\H 				& \Equ{{\sc $\reuze$-Idem} and $\level\H \in \level\H\eqcl{}{H}$} \\
\level\H
}
\end{proof}


%With extra state, also possible to edit while preserving the invariant. (only add spaces in language %without layout rule). In that case not only we don't want $l'=l''$, but also that higher level does not %change. This is only an issue with extra state, since in previous section, $present$ was injective, and %hence $\level\L' = present~\level\H \land \level\L'' = present~\level\H \imp \level'\L = \level''\L$ %\dots \note{explain more?} 
%
%$\level'\L \in \present~\level\H \imp \level''\H = \level\H$\\
%
%\begin{proof} 
%\prf{
%\level'\L \in \present~\level\H	& \Imp{\sc InterPresent}\\
%\level\H \in \interpret~\level'\L	& \Imp{\sc Intr$^*$-Idem}\\
%\level\H = \interpret^* (\level'\L,\level\H) & \Imp{\sc Compute}\\ 
%\level\H = \level''\H 
%}
%\end{proof}
%
%\note{Doing this proof by starting with $\level\H$ and substituting is tricky, because {\sc InterPresent} %is needed in one step, so we would need a lemma-like thing (like in the previous proof).}

\head{Imprecise edit}

\bl
\o If $\level'\L$ is not a valid presentation, $\level''\L$ must resemble what the user intended (requirement $\level'\L~\text{"close to"}~\level''\L$).
\el






%																
%																
%																
\section{Finite representation for equivalence classes}

Notes:

\bl
\o $pres n = n `div` 2$ is no longer possible, since eq. classes on pres are then $\set{\set{0,1},\set{2,3}, \dots }$, for which there is no * rep. (0 and 1 in eq. class implies all elts in eq. class)
\o can we handle $\set{ {\tt "return\spc1" },{\tt "return\spc\spc1" }, {\tt "return\spc\spc\spc1" }, \dots}$?
\el 

will give $present$ and $interpret$ that satisfy laws from prev. section.

commit ourselves to certain eq. classes only.






\subsection{Trees with holes}
Introduce datatype with some 'holes'. Not placeholders from prev. chapters, but holes. Holes represent any value (of correct type)


vvv NOT RIGHT: only some children will be stars.

%A simple tree data type with boolean values in the leafs:
%
%\xpr{
%\data~Tree  = Bin~Tree~Tree~|~Leaf~Bool\\
%\data~Bool = True~|~False\\
%}
%
%becomes 
%
%\xpr{
%\data~Tree^*  = Bin~Tree^*~Tree^*~|~Leaf~Bool^*~|~*_{Tree}\\
%\data~Bool^* = True~|~False~|~*_{Bool}\\
%}
%
%
%Example: $Bin *_{Tree} (Leaf~*_{Bool})$ 

Or, more generally:

\xpr{
\data~T  & = & C_0~T_{0,0} \dots T_{0,m_0} | \dots | C_n~T_{n,0} \dots T_{n,m_n} \\
}
becomes:
\xpr{\data~T^* & = & C_0~T^*_{0,0} \dots T^*_{0,m_0} | \dots | C_n~T^*_{n,0} \dots T^*_{n,m_n} | *_T
}\note{braces around * don't affect spacing}

Same constructor, therefore all vals of T are also values of $T^*$

Stars represent sets. All $t^*$ are sets, but not reverse. example

\xprlab{
\para{\hole} \tp T^* \to \set{T} \\
\para{*_ T} \eq \setof{x}{x \tp T}\\
\para{C~x^*_0 \dots x^*_n} \eq \setof{ C~x_0 \dots x_n}{x_0 \in \para{x^*_0} \land \dots  \land x_n \in \para{x^*_n}} 
}{$\para{\hole}$-Def}\note{name it {\sc $\para{\hole}$-Def} (or {\sc $\para{\hole}$-Char})?} \note{use $x^*_i$?}

\subsection{An equivalence relation for $T^*$}

For a type $T$, if we add some holes, we get an equivalence relation $\eqstar$ on $T$

We define an ``equality up to extra state''. So two values are equal for those parts that are not in es (ie. *).

Do it by making a function that drops all extra state and replaces by *. It depends on the *-data type. 

\renewcommand{\core}{\mathbf{core}}

* are always in a constructor. So root is no star (not logical either). If we want that add a Root constructor to level.

\xprlab{
{\bf data}~T^* = \dots | C~t_0 \dots t_n | \dots\\
\\  
\core~(C~x_0 \dots x_n) \eq C~x'_0 \dots x'_n \\
{\bf where}~ x'_i = \left\{
\begin{array}{ll}
* & , {\bf if}~ t_i = *   \\
\core~x_i & , {\bf otherwise}
\end{array}\right.
}{$\core$-Def}


Then compare the two core bits.


\xprlab{
%\setof{ x \eqstar y}{  x \in \para{x^*} \land y \in \para{y^*} \land x^* = y^*}
x \eqstar y ~\eq~  \core~x = \core~y
}{$\eqstar$-Def}

Since $\eqstar$ is defined as equality on the result of a function (ie. $\core$), we know it is an equivalence relation on the domain of that function with the following theorem:

\xprlab{
x R y ~=~ (f~x = f~y) ~\imp~ R~\text{is an equivalence relation}
}

\begin{proof} \note{maybe leave this out}
\prf{
x R x 	& \Eqv{definition of $R$}\\
f x = f x 	& \Eqv{reflexivity of =}\\
True	
}


\prf{
x R y  	& \Eqv{definition of $R$}\\
f x = f y 	& \Eqv{symmetry of =}\\
f y = f x 	& \Eqv{definition of $R$}\\
y R x 
}\note{get $\eqv$ instead of $\imp$}

\prf{
x R y  \land y R z 		& \Eqv{definition of $R$}\\
f x = f y \land f y = f z	& \Imp{transitivity of =}\\
f x = f z 				& \Eqv{definition of $R$}\\
x R z 
}
\end{proof}
%\xprlab{
%(\eqstar) \tp a^* \rightarrow a^* \rightarrow Bool\\
%x \eqstar * ~=~ True\\
%* \eqstar y ~=~ True\\
%C~x_0 \dots x_n \eqstar C~y_0 \dots y_n ~=~ (x_0 \eqstar y_0)  \land \dots \land  (x_n \eqstar y_n)\\
%C~x_0 \dots x_n \eqstar C'~y_0 \dots y_m ~=~ False
%}{$\eqstar$-Def}
%
%or with stars in identifiers (more consistent with other defs, but less readable\\
%
%\xpr{
%(\eqstar) \tp a^* \rightarrow a^* \rightarrow Bool\\
%x^* \eqstar * ~=~ True\\
%* \eqstar y^* ~=~ True\\
%C~x^*_0 \dots x^*_n \eqstar C~y^*_0 \dots y^*_n ~=~ (x^*_0 \eqstar y^*_0)  \land \dots \land  %(x^*_n \eqstar y^*_n)\\
%C~x^*_0 \dots x^*_n \eqstar C'~y^*_0 \dots y^*_m ~=~ False
%}\note{all recusive defs, say that $C' \neq C$}
%
%$\eqstar$ is equivalence relation:
%
%\xpr{
%x \eqstar x							& \jstf{Reflexivity}\\
%x \eqstar y \imp y \eqstar x				& \jstf{Symmetry}\\
%x \eqstar y \land y \eqstar z \imp x \eqstar z	& \jstf{Transitivity}
%}
%
%Give proofs?
%
%\begin{proof}
%Assume $x \eqstar y \land y \eqstar z$ then by induction over $x$ , we prove $x \eqstar z$:
%
%{\bf Case} $x = *$:
%\prf{
%* \eqstar z & \Eqv{\sc $\eqstar$-Def}\\
%True
%}
%
%$x = C~x_0 \dots x_n$, three cases: $z = *$, $z = C~z_0 \dots z_n$ or $z = C'~z_0 \dots z_m$
%
%{\bf Case} $x = C~x_0 \dots x_n$ and $z = *$
%\prf{
%C~x_0 \dots x_n \eqstar * & \Eqv{\sc $\eqstar$-Def}\\
%True
%}
%
%{\bf Case} $x = C~x_0 \dots x_n$ and $z = C~z_0 \dots z_n$
%\prf{
%C~x_0 \dots x_n \eqstar C~z_0 \dots z_n 			& \Eqv{\sc $\eqstar$-Def}\\
%(x_0 \eqstar z_0)  \land \dots \land  (x_n \eqstar z_n) 	& \Eqv{Induction Hypothesis}\\
%True
%}
%
%{\bf Case} $x = C~x_0 \dots x_n$ and $z = C'~z_0 \dots z_m$
%?
%
%Inductive proofs on functions that only recurse in certain cases are a bit awkward. How should we do this %nicely?
%
%\end{proof}
%%OLD REMARK, why eqstar was not useful: 
%%Useless, result of interpret/present will in general not be equal up to ES to old value. eg 
%%$\lnot (Token (1,0)~"True") ==^* (Token * "True")$


Restrict ourselves to reversible. So no longer all eq. classes, but only those that have hole-representations. explain bit more, two or more implies all. also for constructor.

\xprlab{
\present &\tp& \Level\H\eqstarcl{}{H} \rightarrow \Level\L \eqstarcl{}{L}\\
\interpret &\tp& \Level\L\eqstarcl{}{L} \rightarrow \Level\H \eqstarcl{}{H}
}
%interpret~l = \para{interpret'~l}\\
%present~h = \para{present'~h}
%}{Restrict}

Now we define a reuse function.

Reusing may fail. So we need a default function: $default \tp a^* \rightarrow a$.

\xprlab{
default~x^* \in \para{x^*}\\
}{$default$-Valid}

\bl
\o A default value is equal to its arg, except for the $*$'s, which are filled in with initial values.
\o Def may be misleading, because recursive def means that each type has a default whereas it may be context sensitive: ie Whitespace = (int,int) , but we don't want (0,0) but (1,0).
\o Moreover, default may depend on other information. Eg. whitespace coming from a pretty printing algorithm. This would be an extra argument to default, but the req. stays.
\el

When *, just use righthand side. When not star, left has priority. \note{subscribt X is not right in $\eqstarcl{X}{X}$}

\xprlab{
\reuze ::  \eqstarcl{X}{X} \to X \to X\\
*_a \reuzestar  y = y\\
C~x^*_0 \dots x^*_n \reuzestar C~y_0 \dots y_n = C~(x^*_0 \reuzestar y_0) \dots (x^*_n  \reuzestar y_n) \\
C~x^*_0 \dots x^*_n \reuzestar C'~y_0 \dots y_m = default (C~x^*_0 \dots x^*_n)
}{$\reuzestar$-Def}


\bl
\o Examples:
\o $(\verb|Token |* \verb| "True"|) \reuzestar  (\verb|Token (1,2) "False"|) = \verb|Token (1,2) "True"|$
\o $(\verb|Decl "x" |*) \reuzestar  (\verb|Decl "y" | True) = (\verb|Decl "x" | True)$\note{or complex expression?}
\o When constructors don't match, there is a problem. Types of children most probably will not match, so can't recurse. 
\o $\verb|Plus|~e_1~e_2 \leadsto \verb|Times|~e_1~e_2$ is a problem
\o Responsibility of layer to handle. Whitespace always str. similar, no prob. Plus/Times. has to be specd by editor designer. Sometimes makes no sense. Then es gets lost.
\o Also, no sub-object identities here, so $[e_0, e_1] \leadsto [e_1,e_0]$ is a problem
\o even $[e_0, e_1] \leadsto [e_0]$ is not nice, because constructor does not match on tail
\o IMPORTANT: Look at reuse for tokens, is this correct? 
\el

Now we have to prove the requirements for $\reuze$

\xprlab{X \reuze y \in X}						{$\reuze$-Valid} 
\xprlab{y \in X \imp X \reuze y = y}				{$\reuze$-Idem} 
\xprlab{X \reuze y \imp x \text{~``close to''~} y}	{$\reuze$-Close} 

%$\present*$ and $\interpret*$ only return results that are valid, and moreover, if old level is argument, %then that one is returned: \note{only seem to need half of these reqs for the proofs.}


%\xprlab{
%\interpret^* (l,h) \in \interpret~l}{Intr$^*$-Valid} 
%\xprlab{
%h \in \interpret~l \imp h = \interpret^* (l,h)}{Intr$^*$-Idem} 
%\xprlab{
%\present^* (h,l) \in \present~h}{Pres$^*$-Valid}  %never used!
%\xprlab{
%l \in \present~h \imp l = \present^* (h,l)}{Pres$^*$-Idem}
%\note{find out when (and if) these are used}

\bc
Old proofs:
\bigskip
{\bf Validity}

In order to prove {\sc Intr$^*$-Valid}, we use the property $x \reuzestar y \in \para{x}$, which can be proved by structural induction on $x$

\begin{proof} 
{\bf case} $x = *_T$:\\
\prf{
True & \Imp{$y \tp T$} \\
y 				\in \setof{t}{t \tp T}	& \Imp{{\sc $\para{\hole}$-Def}}\\
y 				\in \para{*_T}		& \Imp{{\sc $\reuzestar$-Def}}\\
*_T \reuzestar y 	\in \para{*_T}
}


{\bf case} $x = C~x^*_0 \dots x^*_n$ and $y = C~y_0 \dots y_n$\\
Induction Hypothesis is $x^*_i \reuzestar y_i \in \para{x*_i}$ \note{How to make this first step a bit nicer?}
\prf{
True\\
				 \Imp{Induction Hypothesis}\\
C~(x^*_0 \reuzestar y_0) \dots (x^*_n \reuzestar y_n) \in  \setof{ C~x_0 \dots x_n}{x_0 \in \para{x^*_0} \land \dots  \land x_n \in \para{x^*_n}} \\
				 \Eqv{{\sc $\para{\hole}$-Def}}\\
C~(x^*_0 \reuzestar y_0) \dots (x^*_n \reuzestar y_n) \in \para{C~x^*_0 \dots x^*_n}\\
				 \Eqv{{\sc $\reuzestar$-Def}}\\
C~x^*_0 \dots x^*_n \reuzestar C~y_0 \dots y_n \in \para{C~x^*_0 \dots x^*_n}
}

{\bf case} $x = C~x^*_0 \dots x^*_n$ and $y = C'~y_0 \dots y_m$, with $C \neq C'$\\
\prf{
True\\
		\Imp{{\sc $default$-Valid}}\\
default (C~x^*_0 \dots x^*_n) \in \para{C~x^*_0 \dots x^*_n}\\
		\Eqv{{\sc $\reuzestar$-Def}}\\
C~x^*_0 \dots x^*_n \reuzestar C'~y_0 \dots y_m \in \para{C~x^*_0 \dots x^*_n} 
}
\end{proof}

Now we can prove {\sc Intr$^*$-Valid}: 

\begin{proof}
\prf{
True 									\\
		\Imp{$y \reuzestar x \in \para{y}$}\\
\interpret'~l \reuzestar h \in \para{interpret' l}	\\
		\Imp{\sc Restrict}\\
\interpret'~l \reuzestar h \in \interpret~l		& \Imp{definition of $interpret^*$}\\
\interpret^* (l, h) \in \interpret~l
}
\end{proof}

\bigskip
{\bf Idempotency}

We prove the idempotency: {\sc Intr$^*$-Idem}.

Need this property:  $y \in \para{x} \imp x \reuzestar y = y$, structural induction on $x$:

\begin{proof}
{\bf case} $x = *_T$:\\
\prf{
True					& \Eqv{reflexivity of $=$} \\
y = y				& \Eqv {\sc $\reuzestar$-Def}\\
*_T \reuzestar y = y	& \Imp{how do we call this?}\\
y \in \para{*_T} \imp {*_T \reuzestar y = y} % braces are for spacing around \triangle
}

{\bf case} $x = C~x^*_0 \dots x^*_n$ and $y = C~y_0 \dots y_n$\\
Induction Hypothesis is 
$y^i \in \para{x*^i} \imp  x^*_i \reuzestar y_i = y_i$\\
\prf{
y \in \para{x}
				& \Eqv{definitions of $x$ and $y$}\\
C~y_0 \dots y_n \in \para{C~x^*_0 \dots x^*_n}
				& \Eqv{{\sc $\para{\hole}$-Def}}\\
C~y_0 \dots y_n \in \setof{ C~x_0 \dots x_n}{x_0 \in \para{x^*_0} \land \dots  \land x_n \in \para{x^*_n}} 
				& \Imp{property of set comprehension}\\
y_0 \in \para{x^*_0} \land \dots \land y^n \in \para{x^*_n}
				& \Eqv{Induction Hypothesis}\\
x^*_0 \reuzestar y_0 = y_0  \land \dots \land  x^*_n \reuzestar y_n = y_n
				& \Imp{$n$ times {\sc Leibniz}}\\
C~(x^*_0 \reuzestar y_0) \dots (x^*_n  \reuzestar y_n) = C~y_0 \dots y_n
				& \Eqv{{\sc $\reuzestar$-Def}}\\
C~x^*_0 \dots x^*_n \reuzestar C~y_0 \dots y_n = C~y_0 \dots y_n
				& \Eqv{definitions of $x$ and $y$}\\
x \reuzestar y = y
}

The third case will not occur.\\
{\bf case} $x = C~x^*_0 \dots x^*_n$ and $y = C'~y_0 \dots y_m$, with $C \neq C'$\\
\prf{
y \in \para{x}
				& \Eqv{definitions of $x$ and $y$}\\
C'~y_0 \dots y_m \in \para{C~x^*_0 \dots x^*_n} 
				& \Eqv{{\sc $\para{\hole}$-Def}}\\
C'~y_0 \dots y_m \in \setof{ C~x_0 \dots x_n}{x_0 \in \para{x^*_0} \land \dots  \land x_n \in \para{x^*_n}} 
				& \Eqv{property of set comprehension}\\
\exists x_0 \dots x_n : C'~y_0 \dots y_m = C'~x_0 \dots x_n 
				& \Eqv{$C \neq C'$}\\
False
				& \Imp{This step seems a bit uncommon}\\
x \reuzestar y = y
}
\end{proof}

Now the proof of idempotency is easy:

Proof of $h \in \interpret~l \imp h = \interpret^* (l,h)$:

\begin{proof}
\prf{
h \in \interpret~l 				& \Imp{\sc Restrict}\\
h \in \para{\interpret'~l}		& \Imp{$y \in \para{x} \imp x \reuzestar y = y$}\\
h = \interpret'~l \reuzestar h 	& \Imp{definition of $interpret^*$}\\
h = \interpret^* (l,h)
}
\end{proof}
\ec












%																
%																
%																
\section{Combining two layers}

Notes:
\bl
\o ES in middle level that is presented on lower will be ES there too.
\o Are the eq. classes of combined layer still * eq. classes?
\el

\bl
\o we want: H M L \{pres inv, identity, update \rarr new H'' M'' L'' close, bla\}
\o we have H M and M L  \{pres inv, identity, update \rarr new H'' M'' L'' close, bla\}
\o we can prove close, bla
\el

Want to model a layered architecture. bla bla. First split this one in two. An intermediate level appears $Level_M$, and we have two layers according to previous spec. 

We have: 
\xpr{
\present\H &\tp& \Level\H \rightarrow \{ \Level_M \}\\
\present\L &\tp& \Level_M \rightarrow \{ \Level\L \}\\
\interpret\H &\tp& \Level\L \rightarrow \{ \Level_M \}\\
\interpret\L &\tp& \Level_M \rightarrow \{ \Level\H \}\\
}

We can define $\present$ and $\interpret$ in terms of the two layers:

\xpr{
\present\ \level\H & \equ & \{ \level\L \:|\: \level\L \in \present\L~\level_M \land \level_M \in \present\L~\level\H \}\\
\interpret~\level\L & \equ & \{ \level\H \:|\: \level\H \in \interpret\H~\level_M \land \level_M \in \interpret\L~\level\L \}\\
}

or: (mention this?)

\xpr{
\present & \equ & \present\L \klei  \present\H\\
\interpret & \equ &\interpret\H \klei  \interpret\L
}

\head{Presentation invariant}

Presentation invariant for combination:

\xprlab{
\level\L \in \present~\level\H\\
}{Present-HL}

Equivalent to (?): 
%there is an $\level_M$ such that {\sc Present-H} and {\sc Present-L} hold:

\xpr{
\exists \level_M: \level\L \in \present\L~\level_M \wedge \level_M \in \present\H~\level\H\\
}

\bl
\o make it an invariant for three levels? (dropping the $\exists \level_M$)
\el

Can express it with Kleisli as well:

\xprlab{
\level\L \in (\present\L \klei \present\H)~\level\H
}{Present-HL}



\head{InterPresent}

Using:

\xprlab{
\level_M \in \present\H~\level\H \imp \level\H \in \interpret\H~\level_M
}{InterPresent-H}

and

\xprlab{
\level\L \in \present\L~\level_M \imp \level_M \in \interpret\L~\level\L
}{InterPresent-L}


we want to get:

\xprlab{
\level\L \in \present~\level\H \imp \level\H \in \interpret~\level\L
}{InterPresent}


\begin{proof}
\prf{
\level\L \in \present~\level\H 
		& \Imp{definition of $present$} \\
\exists \level_M : \level\L = \present\L~\level_M \land \level_M = \present\L~\level\H 
		& \Imp{\sc InterPresent-H} \\
\exists \level_M : \level\L = \present\L~\level_M \land \level\H \in \interpret\H~\level_M
		& \Imp{\sc InterPresent-L} \\
\exists \level_M : \level_M = \interpret\L~\level\L \land \level\H \in \interpret\H~\level_M 
		& \Imp{definition of $interpret$} \\
\level\H \in \interpret~\level\L
}
\end{proof}

%Kleisli bits for {\sc InterPresent-L} and {\sc InterPresent-H}
%
%\xpr{
%\level\H~ \in (\interpret\H \klei \present\H)~\level\H\\
%\level_M~ \in (\interpret_M \klei \present_M)~\level_M
%}


\subsection{Edit}

We have $level\H$, $level_M$, and $level\L$:

\xpr{
\level\L \in \present\L~\level_M \wedge \level_M \in \present\H~\level\H\\
\level\L \leadsto \level'\L 
}

We need $level''\H$,  $level''_M$, and $level''\L$ that restore the invariant. \note{do we need to preserve medium? if apparent in H, or L, automatic, and if not maybe not necessary? Still, we probably do: eg. when med e.s is temporarily hidden, we don't want it to get lost}

\xpr{
& & (level''\H, level''\L)~\text{such that}~
\left\{ \begin{array}{ll}
            \level''\L \in \present~\level''\H\\
            \level''\L~\text{"close to"}~\level'\L & \text{\{imprecise edit and preserve lower e.s \}}\\
            \level''\H~\text{"close to"}~\level\H & \text{\{preserve higher e.s \}}\\
           \end{array}
\right.
}


Solution is these computations:

%\xpr{
%\interpret\L^* \tp \Level\L \times \Level_M \rightarrow \Level_M\\
%\interpret\H^* \tp \Level_M \times \Level\H \rightarrow \Level\H\\
%\present\H^* \tp \Level\H \times \Level_M \rightarrow \Level_M\\
%\present\L^* \tp \Level_M \times \Level\L \rightarrow \Level\L\\
%}

\xprlab{
\level'_M = \interpret\L^* (\level'\L,\level_M)\\ 
\level''\H = \interpret\H^* (\level'_M,\level\H)\\
\level''_M = \present\H^* (\level''\H, level'_M)\\
\level''\L = \present\L^* (\level''_M, level'\L)
}{Compute}


not exactly the same. Upper is the same, but lower is split. Kind of nested: lowerUp (upper ) lowerDwn

Mention that this can be made more uniform by always using $level' = \interpret$ and add $\level''\H = \level'\H$?

\bc more uniform:
\interpret\L^* \tp \Level\L \times \Level_M \rightarrow \Level_M\\
\level'_M = \interpret\L^* (\level'\L,\level_M)\\ 
\interpret\H^* \tp \Level_M \times \Level\H \rightarrow \Level\H\\
\level''\H = \interpret\H^* (\level'_M,\level\H)\\ 
\present\H^* \tp \Level\H \times \Level_M \rightarrow \Level_M\\
\level''_M = \present\H^* (\level''\H, level'_M)
\present\L^* \tp \Level_M \times \Level\L \rightarrow \Level\L\\
\level''\L = \present\L^* (\level''\H, level'\L)
\ec

\bl
\o We want h'' s.t. l'' close to l
\o Is this the case when m'' is close to m and l'' is close to l, for the individual layers? Or is there an m'' that is not closest to m, but for which pres m is closest to l?
\el

UNCLEAR: how do we relate old val for $level_M$? put it in presentation inv? We need it for es.

\head{No unnecessary lower level changes}

If result of edit is presentation of something, it is unchanged by {\sc Compute}: \note{How to formulate this one?}

\xpr{
\exists h : level'\L \in \present~h \imp level''\L = level'\L
}

Unfortunately, this is not true:

\xpr{
\present\H x\ = (x,x)   & \hspace{1cm} & \present\L\ (x,y) = y \\
\interpret\H\ (x,y) = x &                     & \interpret\L\ y = (*,y)\\
}

we have $1 \in present 1$, but according to compute: 

\xpr{
0			&		& (0,0)	  & \\ 
\downarrow	&		& \uparrow & \downarrow\\
(0,0)			&		& (0,1)	  & (0,0)\\
\downarrow	&		& \uparrow & \downarrow\\
0			&\leadsto	& 1		  & 0
}

\bl
\o Counter example
\o L' Pres H0 (L' Pres M0 Pres H0), but result is L'' Pres H' with L' /= L''
\o interpret gives M' for which L' Pres M' (we know there is one (M0), so it cannot fail to return one, bla)
\o if higher interpret gives H' for which M' Pres H' then Extra says M'' = M' and L'' = L', so (not M' Pres H')
\el

\head{No unnecessary higher level changes}

$\level'\L \in \present~\level\H \imp \level''\H = \level\H$\\
We should probably use the fact that $\level_M$ is related by {\sc Present}.







\bc
%																
%																
%																
\section{Combining multiple layers}

\bl
\o Similar to previous section, but now $n$ instead of 2
\o 'Recursive' approach? Does not seem possible because of explicit intermediate levels.
\el

We have:

\xpr{
\present_i &\tp& \Level_{i} \rightarrow \{ \Level_{i+1} \}\\
\interpret_i &\tp& \Level_{i+1} \rightarrow \{ \Level_{i} \}\\
}

We define $\present$ and $\interpret$:

\xpr{
\present~\level_{0} & \equ & \{ \level_n \:|\: \forall i<n :  \level_{i+1} \in \present_i~\level_i \}\\
\interpret~\level_{n} & \equ & \{ \level_0 \:|\: \forall i<n : \level_i \in \interpret_{i+1}~\level_{i+1}  \}\\
}


\head{Presentation invariant}

\head{InterPresent}

\subsection{Edit}

We have $level\H$, $level_M$, and $level\L$:

\xpr{
\level\L \in \present\L~\level_M \wedge \level_M \in \present\H~\level\H\\
\level_{n} \leadsto \level'_{n} 
}

We need $level''_i$,   that restore the invariant.

\xprlab{
& & (level''_{i})~\text{such that}~
\left\{ \begin{array}{ll}
            \level''_{n} \in \present~\level''_{0}\\
            \level''_{n}~\text{"close to"}~\level'_{n} & \text{\{imprecise edit \}}\\
            \level''_{i}~\text{"close to"}~\level'_{i} & \text{\{preserve e.s \}}\\
           \end{array}
\right.
}{Compute}


Solution is these computations: \note{be more precise about indices?}

\xpr{
\interpret_{i}^* \tp \Level_{i+1} \times \Level_{i} \rightarrow \Level_{i}\\
\level'_{i} = \interpret_{i+1}^* (\level'_{i+1},\level_{i})\\ 
\level''_{0} = \level'_{0}\\
\present_{i}^* \tp \Level_{i} \times \Level_{i+1} \rightarrow \Level_{i+1}\\
\level''_{i+1} = \present_i^* (\level''_{i}, level'_{i+1})
}
\ec


%																
%																
%																
\section{Duplicate presentations}

Informal
\bl
\o Choice in interpret may be due to duplicates or '???'
\o $type Document = Int$ 
\o Duplicate: $present x = (x,x)$ with several possible interprets: $interpret (0,1) = 0 or 1$ 
\o ???: $present x = 2x$ also with several interprets: $interpret 1 = 0 or 1$ 
\o Hard to distinguish between the two.
\o Somehow for duplicates, closeness is not an issue in selecting the one we want:
\o eg. $present x = (x,x,x)$ with edit $(0,0,0)\leadsto(1,0,0)$ should give $(1,1,1)$, which is not as close as $(0,0,0)$
\o A difference seems to be that using stars on other fields but the edited one, make a non-ambiguous interpret possible in the duplication case, but not in the other case.
\o eg. $interpret (1,*,*) = 1$
\o duplicates may be hard to spot: eg. $present x = (x `div` 0xff, x `mod` 0xff)$ is not a duplication.
\o $1 \to "one"$ can be seen as three partial duplicates. 
\el

Old statement: if there are several choices for interpret, which all obey {\sc InterPresent}, then there are duplicates. This does not seem to be true. (eg. $present n = 2n$)

%																
%																
%																
\section{Incrementality}
Informal


%																
%																
%																
\section{Loose ends}
\bl
\o what about error nodes in document?
\o what about inserting pres elts that resemble a chapter title? Is this handled well?
\o difference between {\em presentation extra state} and {\em interpretion extra state}
\o what if present is not total?
\el


%																
%																
%																
\section{document editing}
Skipping lower layers



%																
%																
%																
\section{layer skipping}
Skipping higher layers

% restore old defs from thesis.sty
\renewcommand{\present}[0]{{\tt present}}					%56
\renewcommand{\interpret}[0]{{\tt interpret}}				%56
\renewcommand{\Core}[0]{\ensuremath{\mathit{Core}}}	%56
                                 