\chapter{One Layer}
\label{chap:singleLayer}

\renewcommand{\present}{\ensuremath{\mathit{present}}}
\renewcommand{\interpret}{\ensuremath{\mathit{interpret}}}
\newcommand{\spc}{\textvisiblespace}

{\em *** Version: \today~ ***}


\section{Questions:}

\subsection{Unclear}

\bl
\* what identifiers to use, $\present, \Present$?
\* how to layout the equations and put label at the right?
\* Operators between identifiers look asymmetrical: $\Level_H \times \Level_L$. Fix using \verb|\:|? (eg. \verb|\times\:| \rarr $\Level_H \times\, \Level_L$) solution: use \verb|\!|
\el

More important:
\bl
\* $True \imp P$ vs. $True \eq P$
\el

\subsection{Problems}

{\bf Asymmetry between $interpret$ and $present$:}

\bl
\* When two Documents present as the same presentation. They are equal up to extra state.
\* When two Presentations interpret to the same document. They may be equal up to extra state, but they may also be incorrect presentations.
\el

Example: 

\begin{math}
Document \tp (Int, Char) ~~~ Presentation \tp String\\
present (i,\_) = whitespace \cat english~i\\ 
h \in {(7, 'a'),(7,'b'),(7,'c'),\dots} : present~h = \{"seven", "\spc seven", "\spc\spc seven", \dots\}\\
l \in {
 }
 \left\{ \begin{array}{l}
            "seven", " seven", "  seven", \dots \\
            "sevven", "\spc sevven", "\spc\spc sevven", \dots \\
            \dots
            \end{array}
\right\} : interpret~l = \{(7, 'a'),(7,'b'),(7,'c'),\dots\}\\
\end{math}

\bigskip {\bf Avoiding "close to" for extra state}

Maybe define a $==^*$ ("equality up to extra state") instead of using close to?

\begin{math}
(==^*) \tp a^* \rightarrow a^* \rightarrow Bool\\
x ==^* * ~=~ True\\
* ==^* y ~=~ True\\
x ==^* y ~=~ x == y\\
\end{math}

Useless, result of interpret/present will in general not be equal up to ES to old value. eg $\lnot (Token (1,0)~"True") ==^* (Token * "True")$

\bigskip {\bf {\sc Extra} property}

{\sc Correctness}  is not enough. Following is not a valid pres/intr with e.s., but it does not break {\sc Correctness}:

This one is not allowed by {\sc Correctness}
\begin{math}
{a,aa} = present 1\\
{1} = interpret~a\\
{2} = interpret~aa
\end{math}

This one is incorrect, but allowed by  {\sc Correctness}

a is not in all presentations of (interpret a). 
\begin{math}
{1,2} = interpret~a\\
{a} = present~1\\
{aa} = present~2\\
\end{math}

"drrie" is not in every presentation of (interpret  "drrie"). But it's okay, since there is no h: "drrie" = pres h.
\begin{math}
{3} = interpret~"drie"\\
{3} = interpret~"drrie"\\
{drie} = present~3
\end{math}

However, if this is allowed, then interpreting a valid presentation $l'$ and presenting it, does not necessarily lead to $l'$ again. 

If we add this requirement then second example is not allowed anymore. The requirement states that if the lower level $l$ is a presentation of some higher level, then all interpretations of $l$ have $l$ in their presentation.

%																
%																
%																
\section{Old stuff about mappings and trees}

\bl
\* From first half of old chapter 5
\el



%																
%																
%																
\section{Intro}

%Somewhere: combinators guaranteeing safety are not what we want. 
%Only spec. responsibility is left to layer. Pierce: only one way E.S. No 
%structural updates. Incomplete. No duplicates.

\bl
\* Specification
\* Process we use is to start with basic case: an abstract editor. 
\* Then step by step add complications.
\el

\note{Add small examples (a la $7 \leftrightarrow $"sevven")}


%																
%																
%																
\section{Single layer}

\bl
\* Simple abstract editor: Two levels: document and presentation.
\* Immediate presentation.
\* Editing is changing presentation. (unrealistic)
\el

%The presentation invariant is satisfied if and only if the lower level is a correct presentation of the higher %level. The invariant is expressed using an abstract function  
%$\Present \tp \Level_{H} \rightarrow \Level_{L}$.

Given a $\present$, we specify an $\interpret$.

\xpr{
\present & \tp &  \Level_{H} \rightarrow \Level_{L}\\
\interpret  & \tp & \Level_{L} \rightarrow \Level_{H}\\
}


\bigskip {\bf Presentation invariant}

\bl
\* The presentation invariant states that the lower level is a correct presentation of the higher level.
\el

\xprlab{
\level_{L} & \equ & \present~\level_{H}
}{Presentation-Inv}

\bigskip {\bf Correctness}

\bl
\* Property Correctness\note{name: Correctness/Well behaved/\dots?} 
\* Presenting followed by interpreting is identity on higher level: 
\el

\xprlab{
\level_{L} \equ \present~\level_{H} \imp \level_{H} \equ \interpret~\level_{L}  
}{Correctness}

Equivalently, we can express the correctness property using a function composition: \note{worry about domain?}

\xpr{
\interpret \oo \present = id_{\Level_H} 
}

\bl
\* Consequence: $present$ is injective. \note{Explain, prove?}
\el

\bl
\* Reverse need not hold.  (example here?)
\* eg. syntax highlighting: \present ({\tt Return True}) = {\tt "{\bf Return} True"}
\* but also need entering without colors/styles: \interpret ({\tt "Return True"}) = ({\tt Return True})
\* And $\present \oo \interpret$ ({\tt "Return True"}) $\neq$ ({\tt "{\bf Return} True"}) 
\* Reverse also does not hold for duplicates, but these are not explained until later.
\el

\subsection{Edit}

\bl
\* Modeling an Editor, so values change.
\* Higher level update, simply re-present. No problem
\* Lower level is updated by a user. Need to find updates on both levels.
\el

An edit operation takes place when {\sc Presentation-Inv} holds:

\xpr{
& & \level_{L} = \present~\level_{H}\\
& & \level_{L} \leadsto \level'_{L} 
}

\bl
\* Most likely invariant no longer holds: $\level'_{L} \neq \present~\level_{H}$
\* Find new upper level (and lower).
\el

\bl 
\* If  $\level'$ is a presentation of some $\level''_H$, this is the one we want.
\* However, possible that $\level'$ is not a presentation of any higher level. 
\* Can discard the edit operation, but can also try to find one that is and was intended by the user
\* Interpret chooses.
\el

Summarizing, we need:

\xpr{
(level''_{H}, level''_{L})~\text{such that}~ 
\left\{ \begin{array}{l}
            \level''_{L} = \present~\level''_{H}\\
            \level''_{L}~\text{"close to"}~\level'_{L}\\
           \end{array}
\right.
}

The solution is this computation: \note{align label with last eq.? how?}

\xprlab{
\level''_{H} & \equ & \interpret~\level'_{L}\\
\level''_{L} & \equ & \present~\level''_{H} 
}{Compute}

Because $\present$ is assumed to be given, $\interpret$ is specified here.

If the updated lower level ($\level'_{L}$) is a valid presentation of some $h \tp Level_H$, then the correctness property guarantees that final value the lower level is equal to $\level'_{L}$.

If we assume $\level''_{H}$ and $\level''_{L}$ to be defined according to {\sc Compute} then:

$\level'_L = \present~h \imp \level''_{L} = \level'_{L}$
\begin{proof} Assume $\level'_L = \present~h$ then
\prf{
\level''_{L}						& \Eqv{\sc Compute}\\
\present~\level''_{H}				& \Eqv{\sc Compute}\\
\present~(\interpret~\level'_{L})		& \Eqv{$\level'_L = \present~h$}\\
\present~(\interpret~(\present~h))	& \Eqv{definition of $\oo$}\\
\present~((\interpret \oo \present)~h)	& \Eqv{\sc Correctness}\\
\present~h 						& \Eqv{$\level'_L = \present~h$}\\
\level'_L
}
\end{proof}


On the other hand, if $\level'_{L}$ is not a valid presentation, $interpret$ needs to choose a  $\level''_{L}$ that resembles what the user intended by performing the edit operation. This is reflected in the specification by the requirement $\level'_{L}~\text{"close to"}~\level''_{L}$.

\bl
\* $\interpret$ must be defined in such a way that we get the closest one.
\* Responsibility of the designer.
\el

\bl
\* Is "close to" what we want? For simple editors, maybe it is, but is "-$>$" close to \rarr? For duplicates, "close to" is definitely not what we want (but there are no duplicates here yet).
\* What about Chapter titles and fonts? Will these be handled correctly with "close to" req.?
\el
%is interpret the inverse of present? If one exist, we can use it, but it must also work for L not in 
%range of present.



%																
%																
%																
\section{Extra state}


Extra state: present and translate are no longer functions, but relations. example

\bl
\* Simple example a declaration (identifier \& rhs) in a source editor is presented by leaving out the righthand side:
\* \verb| (Decl "b" True) <-> "b  =  ..."|\note{or complex expression?}
\* Whitespace is presentation extra state: \verb| (Decl "b" True) -> "*b*=*..."|
\* Right-hand side is interpretation extra state: \verb|b = ... -> (Decl "b" *)|
\el

\bl
\* Intuitively: Presentation extra state: information on how document is viewed. 
\* Interpretation extra state: information in doc that is not visible. 
\el

\bl
\* Examples Pres: tree browser expansion state, table view sorting, file manager details/icons (positions), layout.
\* Intr: Structure view, Scrolled window.
\el

\bl
\* Model as multi-valued functions. 
\* Elements of result are equal except for E.S nodes.
\* New types:
\el

\xpr{
\present &\tp& \Level_{H} \rightarrow \{ \Level_{L} \}\\
\interpret &\tp& \Level_{L} \rightarrow \{ \Level_{H} \}\\
}

\bigskip {\bf Presentation invariant}

\bl
\* Presentation invariant changes: Any presentation in the result is ok: 
\* (\verb|"b = ..."| as well as more spatious \verb|"b    =    ..."| are correct presentations of \verb|Decl "b" True|
\el

\xprlab{
\level_{L} \in \present~\level_{H}\\
}{Presentation-Inv}

\bigskip {\bf Correctness}

\bl
\* Correctness property also changes. 
\* Cannot compose $present$ and $interpret$ because $interpret$ returns several higher level values.
\* Therefore restate: if l is a presentation of h then H must be an interpretation of L.
\el

\xprlab{
\level_{L} \in \present~\level_{H} \imp \level_{H} \in \interpret~\level_{L}
}{Correctness}


Or equivalently:

\xpr{
\exists \level_{L}: level_{H} ~\in  \interpret~\level_{L} \wedge \level_{L}~\in  \present~\level_{H}
}


express it using a Kleisli composition for sets ($f \klei g$) \cite{?}\note{add citation here?/explain?}   \note{prove this?}
 
\xpr{
(f \klei g)~x = \{z\:|\:\exists y : z \in f  y \land y \in g x \}
}

\xpr{
\level_{H}~ \in (\interpret \klei \present)~\level_{H}
}

Is Kleisli true? What if $present$ is partial? (some documents have no presentation) Or do we assume total pres. and intr.?


Extra property:

\xprlab{
\exists h' : l \in \present~h' \imp \forall h : h \in \interpret~l \imp l \in \present~h\\
l \in \present~h' \imp (h \in \interpret~l \imp l \in \present~h)\\
}{Extra}

It's reverse:
 
\xprlab{
\exists l' : h \in \interpret~l' \imp \forall l : l \in \present~h \imp h \in \interpret~l
}{Extra-reverse}

is superfluous because it follows from {\sc Correctness}.

For an editor without extra state (see previous section), {\sc Extra} (with $=$ instead of $\in$) also follows from {\sc Correctness}

\subsection{Edit}

\bl
\* Edit lower level, when presentation invariant holds:
\el

\xpr{
& & \level_{L} \in \present~\level_{H}\\
& & \level_{L} \leadsto \level'_{L} 
}

Pres inv. must be restored, so compute $level''_{H}$ and $level''_{L}$ that restore the invariant. 
Both $\interpret$ and $\present$ (may) provide several results, so we have to choose:

\xpr{
& & (level''_{H}, level''_{L})~\text{such that}~
\left\{ \begin{array}{ll}
            \level''_{L} \in \present~\level''_{H}\\
            \level''_{L}~\text{"close to"}~\level'_{L} & \text{\{imprecise edit + preserve lower e.s\}}\\
            \level''_{H}~\text{"close to"}~\level_{H} & \text{\{preserve higher e.s \}}\\
           \end{array}
\right.
}

Because we cannot use $\present$ and $\interpret$ directly, since both have a set as result type, we introduce two functions $\present*$ and $\interpret*$, which select the appropriate element from the resulting set:

\xpr{
\interpret^* \tp \Level_{L} \times \Level_{H} \rightarrow \Level_{H}\\
\present^* \tp \Level_{H} \times \Level_{L} \rightarrow \Level_{L}\\
}

\xprlab{
\level''_{H} = \interpret^* (\level'_{L},\level_{H})\\ 
\level''_{L} = \present^* (\level''_{H}, level'_{L})
}{Compute}

$\present*$ and $\interpret*$ only return results that are valid, and moreover, if old level is argument, then that one is returned: \note{only seem to need half of these reqs for the proofs.}

\xpr{
h' = \interpret^* (l,h) \imp h' \in \interpret~l		& \qquad \text{\sc Valid-Intr*}\\ 
h \in \interpret~l \imp h = \interpret^* (l,h) 		& \qquad \text{\sc Idempotent-Intr*}\\ 
l' = \present^* (h,l) \imp l' \in \present~h		& \qquad \text{\sc Valid-Pres*}\\ 
l \in \present~h \imp l = \present^* (h,l)  		& \qquad \text{\sc Idempotent-Pres*}\\ }

\bl
\* Two "close to"s, explain more. One is for correct behavior of intended edit. Other is for maintaining extra state
\el

\bigskip {\bf No unnecessary lower level changes}
If result of edit is presentation of something, it is unchanged by {\sc Compute}: 

$\exists h : level'_L \in \present~h \imp level''_L = level'_L$\note{how to make clear that $\level''_H$ comes from {\sc Compute}?}


\begin{proof}  In the proof, we assume: $level'_L \in \present~h$, and show that if we perform the substitutions from {\sc Compute} it follows that $level''_L = level'_L$.

First, we derive the values for $\level_H$ and $\level'_L$:

$\level_H = \interpret^* (\level'_{L},\level_{H})$

\prf{
True 						& \Imp{assumption}\\
\level'_L \in \present~h 			& \Imp{\sc Extra}\\
\level_H \in \interpret~\level'_L 	& \Imp{\sc Idempotent-Intr*}\\
\level_H = \interpret^* (\level'_{L},\level_{H})
}


And $\level'_{L} = \present^* (\level_{H}, level'_{L})$

\prf{
True 						& \Imp{assumption}\\
\level'_L \in \present~h 			& \Imp{\sc Extra}\\
\level_H \in \interpret~\level'_L 	& \Imp{\sc Correctness}\\
\level'_L \in \present~\level_H	& \Imp{\sc Idempotent-Pres*}\\
\level'_{L} = \present^* (\level_{H}, level'_{L})\\
}

Using these results, we can show the equality of $level''_L$ and $level'_L$:

\prf{
\level''_{L} 						& \Eqv{\sc Compute}\\
\present^* (\level''_{H}, level'_{L})	& \Eqv{\sc Compute}\\
\present^* (\interpret^* (\level'_{L},\level_{H}), level'_{L}) & \Eqv{$\level_H = \interpret^* (\level'_{L},\level_{H})$} \\
\present^* (\level_{H}, level'_{L}) 	& \Eqv{$\level'_{L} = \present^* (\level_{H}, level'_{L})$} \\
\level'_{L}
}
\end{proof}

\bigskip {\bf No unnecessary higher level changes}

With extra state, also possible to edit while preserving the invariant. (only add spaces in language without layout rule). In that case not only we don't want $l'=l''$, but also that higher level does not change. This is only an issue with extra state, since in previous section, $present$ was injective, and hence $\level_L' = present~\level_H \land \level_L'' = present~\level_H \imp \level'_L = \level''_L$ \dots \note{explain more?} 

$\level'_L \in \present~\level_H \imp \level''_H = \level_H$\\

\begin{proof} 
\prf{
\level'_L \in \present~\level_H	& \Imp{\sc Correctness}\\
\level_H \in \interpret~\level'_L	& \Imp{\sc Idempotent-Intr*}\\
\level_{H} = \interpret^* (\level'_{L},\level_{H}) & \Imp{\sc Compute}\\ 
\level_{H} = \level''_{H} 
}
\end{proof}

\note{Doing this proof by starting with $\level_H$ and substituting is tricky, because {\sc Correctness} is needed in one step, so we would need a lemma-like thing (like in the previous proof).}

\bl
\* If $\level'_{L}$ is not a valid presentation, $\level''_{L}$ must resemble what the user intended (requirement $\level'_{L}~\text{"close to"}~\level''_{L}$).
\el

\subsection{Definition of $\present*$ and $\interpret*$}


Introduce datatype with 'holes'. Not placeholders, but holes. Holes represent any value (of correct type)

\xpr{
\data~T  & = & C_0~T_{0,0} \dots T_{0,m_0} | \dots | C_n~T_{n,0} \dots T_{n,m_n} \\
\data~T^* & = & C_0~T^*_{0,0} \dots T^*_{0,m_0} | \dots | C_n~T^*_{n,0} \dots T^*_{n,m_n} | *_T
}\note{braces around * don't affect spacing}

Same constructor. thus all vals of T are also values of $T^*$

Stars represent sets. All $t^*$ are sets, but not reverse. example

\xprlab{
\para{\hole} \tp T^* \to \Set{T} \\
\para{*_ T} \eq \Set{x | x \tp T}\\
\para{C~x^*_0 \dots x^*_n} \eq \Set{ C~x_0 \dots x_n | x_0 \in \para{x^*_0} \land \dots  \land x_n \in \para{x^*_n}} 
}{Def-$\para{\hole}$}\note{name it {\sc $\para{\hole}$-Def} (or {\sc $\para{\hole}$-Char})?} \note{use $x^*_i$?}

Restrict ourselves to reversible. So no longer all sets, but only those that have hole-representations.

\xprlab{
interpret~l = \para{interpret'~l}\\
present~h = \para{present'~h}
}{Restrict}


Reusing may fail. So we need a default function:

\xprlab{
default \tp a^* \rightarrow a\\
default~x^* \in \para{x^*}\\
}{Def-Default}

\bl
\* A default value is equal to its arg, except for the $*$'s, which are filled in with initial values.
\* Def may be misleading, because recursive def means that each type has a default whereas it may be context sensitive: ie Whitespace = (int,int) , but we don't want (0,0) but (1,0).
\* Moreover, default may depend on other information. Eg. whitespace coming from a pretty printing algorithm. This would be an extra argument to default, but the req. stays.
\el

Now we define a function for reusing stuff. when *, just use righthand side. When not star, left has priority.

\xprlab{
(\,\triangleright) \tp a^* \rightarrow a \rightarrow a\\
*_a \triangleright  y = y\\
C~x^*_0 \dots x^*_n \triangleright C~y_0 \dots y_n = C~(x^*_0 \triangleright y_0) \dots (x^*_n  \triangleright y_n) \\
C~x^*_0 \dots x^*_n \triangleright C'~y_0 \dots y_m = default (C~x^*_0 \dots x^*_n)
}{Def-$\triangleright$}


\bl
\* Examples:
\* $(\verb|Token |* \verb| "True"|) \triangleright  (\verb|Token (1,2) "False"|) = \verb|Token (1,2) "True"|$
\* $(\verb|Decl "x" |*) \triangleright  (\verb|Decl "y" | True) = (\verb|Decl "x" | True)$\note{or complex expression?}
\* When constructors don't match, there is a problem. Types of children most probably will not match, so can't recurse. 
\* $\verb|Plus|~e_1~e_2 \leadsto \verb|Times|~e_1~e_2$ is a problem
\* Responsibility of layer to handle. Whitespace always str. similar, no prob. Plus/Times. has to be specd by editor designer. Sometimes makes no sense. Then es gets lost.
\* Also, no sub-object identities here, so $[e_0, e_1] \leadsto [e_1,e_0]$ is a problem
\* even $[e_0, e_1] \leadsto [e_0]$ is not nice, because constructor does not match on tail
\* IMPORTANT: Look at reuse for tokens, is this correct? 
\el

With $\triangleright$ we can define $\interpret^*$ and $\present^*$: \note{remove ' and ''?}

\xpr{
\interpret^* \tp \Level_{L} \times \Level_{H} \rightarrow \Level_{H}\\
\interpret^*~(level'_{L}, level_{H}) = \interpret'~\level'_{L} \triangleright \level_{H}\\ 
\present^* \tp \Level_{H} \times \Level_{L} \rightarrow \Level_{L}\\
\present^*~(\level''_{H}, \level'_{L}) = \present'~\level''_{H} \triangleright \level'_{L}
}

$\interpret^*$ and $\present^*$ meet the requirements from Section~\ref{bla}. We show the proofs for $\interpret$. The $\present^*$ proofs are obtained by substituting $present$ for $interpret$ in the proofs.

\xpr{
\interpret^* (l, h) \in \interpret~l		& \qquad \text{\sc Valid-Intr*}\\
h \in \interpret~l \imp h = \interpret^* (l,h) 		& \qquad \text{\sc Idempotent-Intr*}\\ 
}

\bigskip
{\bf Validity}

In order to prove {\sc Valid-Intr*}, we use the property $x \triangleright y \in \para{x}$, which can be proved by structural induction on $x$ \note{and y?}

\begin{proof} 
{\bf case} $x = *_T$:\\
\prf{
True & \Imp{$y \tp T$} \\
y 				\in \Set{t | t \tp T}	& \Imp{{\sc Def-$\para{\hole}$}}\\
y 				\in \para{*_T}		& \Imp{{\sc Def-$\triangleright$}}\\
*_T \triangleright y 	\in \para{*_T}
}

{\bf case} $x = C~x^*_0 \dots x^*_n$ and $y = C~y_0 \dots y_n$\\
Induction Hypothesis is $x^*_i \triangleright y_i \in \para{x*_i}$ \note{How to make this first step a bit nicer?}\\ 
\prf{
True
				& \Imp{Induction Hypothesis}\\
C~(x^*_0 \triangleright y_0) \dots (x^*_n \triangleright y_n) \in  \Set{ C~x_0 \dots x_n | x_0 \in \para{x^*_0} \land \dots  \land x_n \in \para{x^*_n}} 
				& \Eqv{{\sc Def-$\para{\hole}$}}\\
C~(x^*_0 \triangleright y_0) \dots (x^*_n \triangleright y_n) \in \para{C~x^*_0 \dots x^*_n}
				& \Eqv{{\sc Def-$\triangleright$}}\\
C~x^*_0 \dots x^*_n \triangleright C~y_0 \dots y_n \in \para{C~x^*_0 \dots x^*_n}
}

{\bf case} $x = C~x^*_0 \dots x^*_n$ and $y = C'~y_0 \dots y_m$, with $C \neq C'$\\
\prf{
True & \Imp{property of default (name?)}\\
default (C~x^*_0 \dots x^*_n) \in \para{C~x^*_0 \dots x^*_n} & \Eqv{{\sc Def-$\triangleright$}}\\
C~x^*_0 \dots x^*_n \triangleright C'~y_0 \dots y_m \in \para{C~x^*_0 \dots x^*_n} & 
}
\end{proof}

Now we can prove {\sc Valid-Intr*}: 

\begin{proof}
\prf{
True 									& \Imp{$y \triangleright x \in \para{y}$}\\
\interpret'~l \triangleright h \in \para{interpret' l}	& \Imp{\sc Restrict}\\
\interpret'~l \triangleright h \in \interpret~l		& \Imp{definition of $interpret^*$}\\
\interpret^* (l, h) \in \interpret~l
}
\end{proof}

\bigskip
{\bf Idempotency}

We prove the idempotency: {\sc Idempotent-Intr*}.

Need this property:  $y \in \para{x} \imp x \triangleright y = y$, structural induction on $x$:

\begin{proof}
{\bf case} $x = *_T$:\\
\prf{
True					& \Eqv{reflexivity of $=$} \\
y = y				& \Eqv {\sc Def-$\triangleright$}\\
*_T \triangleright y = y	& \Imp{how do we call this?}\\
y \in \para{*_T} \imp {*_T \triangleright y = y} % braces are for spacing around \triangle
}

{\bf case} $x = C~x^*_0 \dots x^*_n$ and $y = C~y_0 \dots y_n$\\
Induction Hypothesis is 
$y^i \in \para{x*^i} \imp  x^*_i \triangleright y_i = y_i$\\
\prf{
y \in \para{x}
				& \Eqv{definitions of $x$ and $y$}\\
C~y_0 \dots y_n \in \para{C~x^*_0 \dots x^*_n}
				& \Eqv{{\sc Def-$\para{\hole}$}}\\
C~y_0 \dots y_n \in \Set{ C~x_0 \dots x_n | x_0 \in \para{x^*_0} \land \dots  \land x_n \in \para{x^*_n}} 
				& \Imp{property of set comprehension}\\
y_0 \in \para{x^*_0} \land \dots \land y^n \in \para{x^*_n}
				& \Eqv{Induction Hypothesis}\\
x^*_0 \triangleright y_0 = y_0  \land \dots \land  x^*_n \triangleright y_n = y_n
				& \Imp{$n$ times {\sc Leibniz}}\\
C~(x^*_0 \triangleright y_0) \dots (x^*_n  \triangleright y_n) = C~y_0 \dots y_n
				& \Eqv{{\sc Def-$\triangleright$}}\\
C~x^*_0 \dots x^*_n \triangleright C~y_0 \dots y_n = C~y_0 \dots y_n
				& \Eqv{definitions of $x$ and $y$}\\
x \triangleright y = y
}

The third case will not occur.\\
{\bf case} $x = C~x^*_0 \dots x^*_n$ and $y = C'~y_0 \dots y_m$, with $C \neq C'$\\
\prf{
y \in \para{x}
				& \Eqv{definitions of $x$ and $y$}\\
C'~y_0 \dots y_m \in \para{C~x^*_0 \dots x^*_n} 
				& \Eqv{{\sc Def-$\para{\hole}$}}\\
C'~y_0 \dots y_m \in \Set{ C~x_0 \dots x_n | x_0 \in \para{x^*_0} \land \dots  \land x_n \in \para{x^*_n}} 
				& \Eqv{property of set comprehension$}\\
\exists x_0 \dots x_n : C'~y_0 \dots y_m = C'~x_0 \dots x_n 
				& \Eqv{$C \neq C'$}\\
False
				& \Imp{This step seems a bit uncommon}\\
x \triangleright y = y
}
\end{proof}

Now the proof of idempotency is easy:

Proof of $h \in \interpret~l \imp h = \interpret^* (l,h)$:

\begin{proof}
\prf{
h \in \interpret~l 				& \Imp{\sc Restrict}\\
h \in \para{\interpret'~l}		& \Imp{$y \in \para{x} \imp x \triangleright y = y$}\\
h = \interpret'~l \triangleright h 	& \Imp{definition of $interpret^*$}\\
h = \interpret^* (l,h)
}
\end{proof}



%																
%																
%																
\section{Combining two layers}

\bl
\* we want: H M L \{pres inv, identity, update \rarr new H'' M'' L'' close, bla\}
\* we have H M and M L  \{pres inv, identity, update \rarr new H'' M'' L'' close, bla\}
\* we can prove close, bla
\el

Want to model a layered architecture. bla bla. First split this one in two. An intermediate level appears $Level_M$, and we have two layers according to previous spec. 

We have: 
\xpr{
\present_H &\tp& \Level_{H} \rightarrow \{ \Level_{M} \}\\
\present_L &\tp& \Level_{M} \rightarrow \{ \Level_{L} \}\\
\interpret_H &\tp& \Level_{L} \rightarrow \{ \Level_{M} \}\\
\interpret_L &\tp& \Level_{M} \rightarrow \{ \Level_{H} \}\\
}

We can define $\present$ and $\interpret$ in terms of the two layers:

\xpr{
\present\ \level_{H} & \equ & \{ \level_L \:|\: \level_L \in \present_L~\level_M \land \level_M \in \present_L~\level_H \}\\
\interpret~\level_{L} & \equ & \{ \level_H \:|\: \level_H \in \interpret_H~\level_M \land \level_M \in \interpret_L~\level_L \}\\
}

or: (mention this?)

\xpr{
\present & \equ & \present_L \klei  \present_H\\
\interpret & \equ &\interpret_H \klei  \interpret_L
}

\bigskip {\bf Presentation invariant}

Presentation invariant for combination:

\xprlab{
\level_{L} \in \present~\level_{H}\\
}{Presentation-Inv-HL}

Equivalent to (?): 
%there is an $\level_{M}$ such that {\sc Presentation-Inv-H} and {\sc Presentation-Inv-L} hold:

\xpr{
\exists \level_{M}: \level_{L} \in \present_L~\level_{M} \wedge \level_{M} \in \present_H~\level_{H}\\
}

\bl
\* make it an invariant for three levels? (dropping the $\exists \level_{M}$)
\el

Can express it with Kleisli as well:

\xprlab{
\level_{L} \in (\present_{L} \klei \present_{H})~\level_{H}
}{Presentation-Inv-HL}



\bigskip {\bf Correctness}

Using:

\xprlab{
\level_{M} \in \present_H~\level_{H} \imp \level_{H} \in \interpret_H~\level_{M}
}{Correctness-H}

and

\xprlab{
\level_{L} \in \present_L~\level_{M} \imp \level_{M} \in \interpret_L~\level_{L}
}{Correctness-L}


we want to get:

\xprlab{
\level_{L} \in \present~\level_{H} \imp \level_{H} \in \interpret~\level_{L}
}{Correctness-B}


\begin{proof}
\prf{
\level_{L} \in \present~\level_{H} 
		& \Imp{definition of $present$} \\
\exists \level_M : \level_L = \present_L~\level_M \land \level_M = \present_L~\level_H 
		& \Imp{\sc Correctness-H} \\
\exists \level_M : \level_L = \present_L~\level_M \land \level_{H} \in \interpret_H~\level_{M}
		& \Imp{\sc Correctness-L} \\
\exists \level_M : \level_M = \interpret_L~\level_L \land \level_{H} \in \interpret_H~\level_{M} 
		& \Imp{definition of $interpret$} \\
\level_{H} \in \interpret~\level_{L}
}
\end{proof}

%Kleisli bits for {\sc Correctness-L} and {\sc Correctness-H}
%
%\xpr{
%\level_{H}~ \in (\interpret_{H} \klei \present_{H})~\level_{H}\\
%\level_{M}~ \in (\interpret_{M} \klei \present_{M})~\level_{M}
%}


\subsection{Edit}

We have $level_{H}$, $level_{M}$, and $level_{L}$:

\xpr{
\level_{L} \in \present_L~\level_{M} \wedge \level_{M} \in \present_H~\level_{H}\\
\level_{L} \leadsto \level'_{L} 
}

We need $level''_{H}$,  $level''_{M}$, and $level''_{L}$ that restore the invariant. \note{do we need to preserve medium? if apparent in H, or L, automatic, and if not maybe not necessary? Still, we probably do: eg. when med e.s is temporarily hidden, we don't want it to get lost}

\xpr{
& & (level''_{H}, level''_{L})~\text{such that}~
\left\{ \begin{array}{ll}
            \level''_{L} \in \present~\level''_{H}\\
            \level''_{L}~\text{"close to"}~\level'_{L} & \text{\{imprecise edit and preserve lower e.s \}}\\
            \level''_{H}~\text{"close to"}~\level_{H} & \text{\{preserve higher e.s \}}\\
           \end{array}
\right.
}


Solution is these computations:

%\xpr{
%\interpret_L^* \tp \Level_{L} \times \Level_{M} \rightarrow \Level_{M}\\
%\interpret_H^* \tp \Level_{M} \times \Level_{H} \rightarrow \Level_{H}\\
%\present_H^* \tp \Level_{H} \times \Level_{M} \rightarrow \Level_{M}\\
%\present_L^* \tp \Level_{M} \times \Level_{L} \rightarrow \Level_{L}\\
%}

\xprlab{
\level'_{M} = \interpret_L^* (\level'_{L},\level_{M})\\ 
\level''_{H} = \interpret_H^* (\level'_{M},\level_{H})\\
\level''_{M} = \present_H^* (\level''_{H}, level'_{M})\\
\level''_{L} = \present_L^* (\level''_{H}, level'_{L})
}{Compute}
not exactly the same. Upper is the same, but lower is split. Kind of nested: lowerUp (upper ) lowerDwn

Mention that this can be made more uniform by always using $level' = \interpret$ and add $\level''_{H} = \level'_{H}$?

\bc more uniform:
\interpret_L^* \tp \Level_{L} \times \Level_{M} \rightarrow \Level_{M}\\
\level'_{M} = \interpret_L^* (\level'_{L},\level_{M})\\ 
\interpret_H^* \tp \Level_{M} \times \Level_{H} \rightarrow \Level_{H}\\
\level''_{H} = \interpret_H^* (\level'_{M},\level_{H})\\ 
\present_H^* \tp \Level_{H} \times \Level_{M} \rightarrow \Level_{M}\\
\level''_{M} = \present_H^* (\level''_{H}, level'_{M})
\present_L^* \tp \Level_{M} \times \Level_{L} \rightarrow \Level_{L}\\
\level''_{L} = \present_L^* (\level''_{H}, level'_{L})
\ec

\bl
\* We want h'' s.t. l'' close to l
\* Is this the case when m'' is close to m and l'' is close to l, for the individual layers? Or is there an m'' that is not closest to m, but for which pres m is closest to l?
\el

If result of edit is presentation of something, it is unchanged by {\sc Compute}: \note{How to formulate this one?}

\xpr{
\exists m,h : \level'_{L} \in \present_L~m \wedge m \in \present_H~h  \imp \\
\forall level_M : \level_M~\text{"close to"}~m \imp level''_L = level'_L\\
}

Unfortunately, this is not true:

\bl
\* Counter example
\* L' Pres H0 (L' Pres M0 Pres H0), but result is L'' Pres H' with L' /= L''
\* interpret gives M' for which L' Pres M' (we know there is one (M0), so it cannot fail to return one, bla)
\* if higher interpret gives H' for which M' Pres H' then Extra says M'' = M' and L'' = L', so (not M' Pres H')
\el

%\xprlab{
%\exists h' : m \in \present_H~h' \imp \forall h : h \in \interpret_H~m \imp m \in \present_H~h
%}{Extra-H}
%\xprlab{
%\exists m' : l \in \present_L~m' \imp \forall m : m \in \interpret_L~l \imp l \in \present_H~m
%}{Extra-L}

%Lemma 2: 
%$h \in \interpret~\level'_L \imp \level'_L \in \present~h$\\

%\prf{
%\exists h : \level'_L \in \present~h & \Imp{def. binary present}\\
%\exists h,m : \level'_L \in \present_L~m \land m \in \present_H~h & \Imp{\sc Extra-H \& Extra-L}\\
%\forall m : m \in \interpret_H~\level'_L \imp \level'_L \in \present~m \land \\
%\forall h : h \in \interpret_H~\level'_H \imp \level'_L \in \present~m \land
%}

%From {\sc Compute}:
%
%\prf{
%\level'_{M} = \interpret_L^* (\level'_{L},\level_{M}) & \Imp{\sc Valid-Intr*-L} \\
%\level'_{M} \in \interpret'~\level'_L & \Imp{Lemma2}\\
%
%\level'_L \in \present~\level'_{M} & \\
%\level'_L = \present^* (\level''_{H},\level'_L) & \Imp{\sc Compute}\\
%\level'_L =\level''_L 
%}





%																
%																
%																
\section{Combining multiple layers}

\bl
\* Similar to previous section, but now $n$ instead of 2
\* 'Recursive' approach? Does not seem possible because of explicit intermediate levels.
\el

We have:

\xpr{
\present_i &\tp& \Level_{i} \rightarrow \{ \Level_{i+1} \}\\
\interpret_i &\tp& \Level_{i+1} \rightarrow \{ \Level_{i} \}\\
}

We define $\present$ and $\interpret$:

\xpr{
\present~\level_{0} & \equ & \{ \level_n \:|\: \forall i<n :  \level_{i+1} \in \present_i~\level_i \}\\
\interpret~\level_{n} & \equ & \{ \level_0 \:|\: \forall i<n : \level_i \in \interpret_{i+1}~\level_{i+1}  \}\\
}


\bigskip {\bf Presentation invariant}

\bigskip {\bf Correctness}

\subsection{Edit}

We have $level_{H}$, $level_{M}$, and $level_{L}$:

\xpr{
\level_{L} \in \present_L~\level_{M} \wedge \level_{M} \in \present_H~\level_{H}\\
\level_{n} \leadsto \level'_{n} 
}

We need $level''_i$,   that restore the invariant.

\xprlab{
& & (level''_{i})~\text{such that}~
\left\{ \begin{array}{ll}
            \level''_{n} \in \present~\level''_{0}\\
            \level''_{n}~\text{"close to"}~\level'_{n} & \text{\{imprecise edit \}}\\
            \level''_{i}~\text{"close to"}~\level'_{i} & \text{\{preserve e.s \}}\\
           \end{array}
\right.
}{Compute}


Solution is these computations: \note{be more precise about indices?}

\xpr{
\interpret_{i}^* \tp \Level_{i+1} \times \Level_{i} \rightarrow \Level_{i}\\
\level'_{i} = \interpret_{i+1}^* (\level'_{i+1},\level_{i})\\ 
\level''_{0} = \level'_{0}\\
\present_{i}^* \tp \Level_{i} \times \Level_{i+1} \rightarrow \Level_{i+1}\\
\level''_{i+1} = \present_i^* (\level''_{i}, level'_{i+1})
}

%																
%																
%																
\section{Duplicate presentations}

Informal
\bl
\* Choice in interpret may be due to duplicates or '???'
\* $type Document = Int$ 
\* Duplicate: $present x = (x,x)$ with several possible interprets: $interpret (0,1) = 0 or 1$ 
\* ???: $present x = 2x$ also with several interprets: $interpret 1 = 0 or 1$ 
\* Hard to distinguish between the two.
\* Somehow for duplicates, closeness is not an issue in selecting the one we want:
\* eg. $present x = (x,x,x)$ with edit $(0,0,0)\leadsto(1,0,0)$ should give $(1,1,1)$, which is not as close as $(0,0,0)$
\* A difference seems to be that using stars on other fields but the edited one, make a non-ambiguous interpret possible in the duplication case, but not in the other case.
\* eg. $interpret (1,*,*) = 1$
\* duplicates may be hard to spot: eg. $present x = (x `div` 0xff, x `mod` 0xff)$ is not a duplication.
\* $1 \to "one"$ can be seen as three partial duplicates. 
\el

%																
%																
%																
\section{Incrementality}
Informal


%																
%																
%																
\section{Loose ends}
\bl
\* what about error nodes in document?
\* what about inserting pres elts that resemble a chapter title? Is this handled well?
\el


%																
%																
%																
\section{document editing}
Skipping lower layers



%																
%																
%																
\section{layer skipping}
Skipping higher layers

\renewcommand{\present}[0]{{\tt present}}					%56
\renewcommand{\interpret}[0]{{\tt interpret}}				%56
