-- do not edit; automatically generated by UU.AG
module PresentationAG where

import CommonTypes
import PresLayerTypes
import PresLayerUtils

import XprezLib
import XLatex hiding (bold)

import DocumentEdit

import List
import Data.FiniteMap

import IOExts

import qualified Chess

pthFrmMsg :: HeliumMessage -> ([PathDoc], [PathDoc], [PathDoc])
pthFrmMsg (HError _ ps1 ps2 ps3) = (ps1, ps2, ps3)
pthFrmMsg _ = ([],[],[])

toMessage str = HError (lines str) [] [] []

-- if ps1 ++ ps2 ++ ps3 not null then head is link
presMessage :: HeliumMessage -> Presentation
presMessage (HError lns ps1 ps2 ps3) = case ps1++ps2++ps3 of []      -> col' (map (text' NoIDP) lns) `withColor` errColor
                                                             rng:_   -> col' (map (text' NoIDP) lns) `withColor` errColor
                                                                        `link` rng
presMessage (HMessage lns)           = col' (map (text' NoIDP) lns) `withColor` msgColor 

msgColor = blue
errColor = red


presentFocus NoPathD     path pres = pres
presentFocus (PathD pth) path pres = if pth==path then pres `withbgColor` lightBlue else pres

squiggleRanges (rngs1, rngs2, rngs3) pth pres =
  if (PathD pth) `elem` rngs1 then squiggly error1Color pres
  else if (PathD pth) `elem` rngs2 then pres -- squiggly error2Color pres
  else if (PathD pth) `elem` rngs3 then squiggly error3Color pres
  else pres
-- WX bitmap coloring is not ok yet, so squigglies are always red.
-- Until this is fixed, green squigglies are not shown

error1Color = red
error2Color = green
error3Color = red

link :: Xprez -> PathDoc -> Xprez
link xp NoPathD = xp
link xp path    = xp `withMouseDown` navigateTo path

navigateTo :: PathDoc -> UpdateDoc
navigateTo NoPathD = id
navigateTo (PathD pth) = (\(DocumentLevel d _ cl) -> DocumentLevel d (PathD pth) cl)


expand :: [Int] -> Decl -> UpdateDoc
expand pth (Decl idD idP0 idP1 idP2 idP3 expanded autoLayout ident exp) =
  \(DocumentLevel d path cl) ->
    let (DocumentLevel d' _ _) = editPasteD (DocumentLevel d (PathD pth) 
                                              (Clip_Decl (Decl idD idP0 idP1 idP2 idP3 True autoLayout ident exp))
                                            )
    in  (DocumentLevel d' path cl)

toggleExpanded :: [Int] -> Decl -> UpdateDoc
toggleExpanded pth (Decl idD idP0 idP1 idP2 idP3 expanded autoLayout ident exp) =
  \(DocumentLevel d path cl) ->
    let (DocumentLevel d' _ _) = editPasteD (DocumentLevel d (PathD pth) 
                                              (Clip_Decl (Decl idD idP0 idP1 idP2 idP3 (not expanded) autoLayout ident exp))
                                            )
    in  (DocumentLevel d' path cl)


toggleAutoLayout :: [Int] -> Decl -> UpdateDoc
toggleAutoLayout pth (Decl idD idP0 idP1 idP2 idP3 expanded autoLayout ident exp) =
  \(DocumentLevel d path cl) ->
    let (DocumentLevel d' _ _) = editPasteD (DocumentLevel d (PathD pth) 
                                              (Clip_Decl (Decl idD idP0 idP1 idP2 idP3 expanded (not autoLayout) ident exp))
                                            )
    in  (DocumentLevel d' path cl)




strFromIdent (Ident _ _ _ str) = str
strFromIdent _               = ""

idP0FromIdent (Ident _ idp0 _ str) = idp0
idP0FromIdent _                    = NoIDP

box xp = overlay [xp, poly [(0,0),(1,0),(1,1),(0,1),(0,0)],empty]
presHole focus typeStr nd pth = loc nd $ 
  structural $ row [text $ "{"++typeStr++"}"] `withColor` black `withbgColor` yellow `withFontFam` ("Courier New")
  
--  structural $ overlay [poly [(0,0),(1,0),(1,1),(0,1),(0,0)], text $ "{"++typeStr++"}"] `withColor` black `withbgColor` yellow `withFont'` ("Courier New", 10)
  
presParseErr node pres =
  loc node $ parsing $ pres {- $ overlay [ pres, poly [(0,0),(1,0),(1,1),(0,1),(0,0)] `withColor` red, empty ] -} 
                                                                                     -- empty trick
                          --`withbgColor` whiteSmoke


row'  = RowP (NoIDP) 0 
col'  = ColP (NoIDP) 0
text' idc = StringP idc

der:: IDP -> String -> Xprez
der idc str = StringP idc str `withColor` derCol
 

op :: IDP -> String -> Xprez
op idc str = StringP idc str `withColor` opCol

key :: IDP -> String -> Xprez
key idc str = StringP idc str `withColor` keyCol

sep :: IDP -> String -> Xprez
sep idc str = StringP idc str `withColor` sepCol

cons :: IDP -> String -> Xprez
cons idc str = StringP idc str `withColor` consCol

typeD :: IDP -> String -> Xprez
typeD idc str = bold $ StringP idc str `withColor` typeDCol



derCol = green
opCol = black
keyCol = blue
sepCol = brown
consCol = black
typeDCol = purple --darkViolet
--idC = unsafePerformIO $ newIORef (0 :: Int)

--newIDP _ = IDP $ unsafePerformIO $ do {modifyIORef idC (+1); readIORef idC}




-- oparen pprec cprec = if pprec > cprec then [text "("] else []
-- cparen pprec cprec = if pprec > cprec then [text ")"] else []

--addloc exp pth pres = loc (ExpNode exp pth)


idCounter = unsafePerformIO $ newIORef (0 :: Int)

-- needs a fresh arg to prevent sharing.
newIDP _ = IDP $ unsafePerformIO $ do {modifyIORef idCounter (+1); readIORef idCounter}


mkIDP NoIDP idC offset = IDP (idC + offset)
mkIDP id@(IDP _) _ _   = id


data TypeTree = TypeNode TypeInfo [TypeTree]  

data TypeInfo = TypeInfo String (Maybe String)

lookupType typeEnv path = case lookup (PathD path) typeEnv of 
                            Nothing -> "<no type>"  -- use Maybe here?
                            Just tp -> tp

type Bindings = [Binding]
type Binding = (String, Value)



data Value = BoolVal Bool
         | IntVal Int
         | LamVal (Value -> Value)
         | ListVal [Value]
         | ProdVal [Value]
         | ErrVal 

instance Show Value where
  show (BoolVal b) = show b
  show (IntVal i)  = show i
  show (LamVal _)  = "<function>"
  show (ListVal vs) = "[" ++ concat (intersperse ", " (map show vs)) ++ "]"
  show (ProdVal vs) = "(" ++ concat (intersperse ", " (map show vs)) ++ ")"
  show (ErrVal)   = "ERROR"
{-

evaluate :: Exp -> [(String, Val)] -> Val
evaluate (Lam ident exp) env =
evaluate (AppExp f a) env =   
-}
evaluateIntOp op (IntVal v1) (IntVal v2) = IntVal $ v1 `op` v2
evaluateIntOp _  _           _           = ErrVal



presentList []     = row' [sep NoIDP "  []"]
presentList (p:ps) = col' $  [ row' [sep NoIDP "  [ ", p ] ]
                          ++ [ row' [sep NoIDP "  , ", p]| p <- ps ]
                          ++ [ sep NoIDP "  ] "]

toggleViewType :: [Int] -> PPPresentation -> UpdateDoc
toggleViewType pth (PPPresentation idD viewtp slides) =
  \(DocumentLevel d path cl) ->
    let (DocumentLevel d' _ _) = editPasteD (DocumentLevel d (PathD pth) 
                                              (Clip_PPPresentation (PPPresentation idD (not viewtp) slides))
                                            )
    in  (DocumentLevel d' path cl)


itemStart i (Bullet _) = text' NoIDP "- "
itemStart i (Number _) = text' NoIDP (show (i+1) ++ ") ")
itemStart i (Alpha  _) = text' NoIDP (chr (ord 'a' + i):") ")
itemStart i (_)        = text' NoIDP "  "


presentElementXML :: FocusDoc -> Node -> [Int] -> String -> [Presentation] -> Presentation
presentElementXML focusD node path tag children =
  loc node $ parsing $ presentFocus focusD path $                  
    if null children
    then col [ text $ "<"++tag++"/>"]
    else col [ text  $ "<"++tag++">"
             , row [ text "  ", col children ]
             , text $ "</"++tag++">" ]      
    
presentPrimXMLBool :: Bool -> Presentation
presentPrimXMLBool x = text $ "<Bool>"++show x++"<Bool/>"

presentPrimXMLInt :: Int -> Presentation
presentPrimXMLInt x = text $ "<Int>"++show x++"<Int/>"

presentPrimXMLString :: String -> Presentation
presentPrimXMLString x = text $ "<String>"++x++"<String>"


presentElementTree :: FocusDoc -> Node -> [Int] -> String -> [Presentation] -> Presentation
presentElementTree focusD node path tag children =
  loc node $ parsing $ presentFocus focusD path $                  
    if null children
    then mkTreeLeaf False $ text $ tag
    else mkTreeNode False True (text tag) children
    
presentPrimTreeBool :: Bool -> Presentation
presentPrimTreeBool x =  mkTreeLeaf False $ text $ "Bool: "++show x

presentPrimTreeInt :: Int -> Presentation
presentPrimTreeInt x =  mkTreeLeaf False $ text $ "Int: "++show x

presentPrimTreeString :: String -> Presentation
presentPrimTreeString x =  mkTreeLeaf False $ text $ "String: "++x

--n2 = mkTreeNode False False (text "node 2" `withFontSize` 50) []

--addReductionPopupItems :: [ PopupItem ] -> Presentation -> Presentation
addReductionPopupItems its pres = addPopupItems pres its

pasteExp :: [Int] -> Exp -> UpdateDoc
pasteExp pth exp =
  \(DocumentLevel d path cl) ->
    let (DocumentLevel d' _ _) = editPasteD (DocumentLevel d (PathD pth) 
                                              (Clip_Exp exp)
                                            )
    in  (DocumentLevel d' path cl)


setIDPExp newIdp (PlusExp idd idp0 x1 x2)           = PlusExp idd newIdp x1 x2          
setIDPExp newIdp (TimesExp idd idp x1 x2)           = TimesExp idd newIdp x1 x2          
setIDPExp newIdp (DivExp idd idp0 x1 x2)            = DivExp idd idp0 x1 x2           
setIDPExp newIdp (PowerExp idd idp0 x1 x2)          = PowerExp idd newIdp x1 x2         
setIDPExp newIdp (BoolExp idd idp0 x1)              = BoolExp idd newIdp x1             
setIDPExp newIdp (IntExp idd idp0 x1)               = IntExp idd newIdp x1              
setIDPExp newIdp (CaseExp idd idp0 idp1 x1 x2)       = CaseExp idd newIdp idp1 x1 x2      
setIDPExp newIdp (LetExp idd idp0 idp1 dcls x2)     = LetExp idd newIdp idp1 dcls x2    
setIDPExp newIdp (LamExp idd idp0 idp1 x1 x2)       = LamExp idd newIdp idp1 x1 x2      
setIDPExp newIdp (AppExp idd x1 x2)                 = AppExp idd (setIDPExp newIdp x1) x2  -- has no pid of its own
setIDPExp newIdp (IdentExp idd x1)                  = IdentExp idd (setIDPIdent newIdp x1) -- has no pid of its own
setIDPExp newIdp (IfExp idd idp0 idp idp1 x1 x2 x3) = IfExp idd newIdp idp idp1 x1 x2 x3
setIDPExp newIdp (ParenExp idd idp0 idp1 x1)        = ParenExp idd newIdp idp1 x1    
setIDPExp newIdp (ListExp idd idp0 idp1 idps x1)    = ListExp idd newIdp idp1 idps x1
setIDPExp newIdp (ProductExp idd idp0 idp1 idps x1) = ProductExp idd newIdp idp1 idps x1
setIDPExp _   exp                                   = exp

setIDPIdent newIdp (Ident idd idp0 idp1 str) = Ident idd newIdp idp1 str

removeParens (ParenExp _ _ _ x1) = removeParens x1
removeParens exp                 = exp

ensureParens exp = ParenExp NoIDD NoIDP NoIDP (removeParens exp)
-- Alt ---------------------------------------------------------
{-
   inherited attributes:
      env                  : Bindings
      errs                 : [HeliumMessage]
      focusD               : FocusDoc
      ix                   : Int
      level                : Int
      path                 : [Int]
      ranges               : ([PathDoc],[PathDoc],[PathDoc])
      topLevelEnv          : [(String, String)]
      totalMaxLHSLength    : Int
      typeEnv              : [(PathDoc,String)]
      varsInScope          : FiniteMap String (PathDoc, String)

   chained attributes:
      col                  : Int
      layoutMap            : LayoutMap
      newlines             : Int
      pIdC                 : Int
      spaces               : Int
      varsInScopeAtFocus   : FiniteMap String (PathDoc, String)

   synthesised attributes:
      alt                  : Binding
      lhsLength            : Int
      pres                 : Presentation
      presTree             : Presentation
      presXML              : Presentation
      self                 : SELF

-}
{-
   local variables for Alt.Alt:
      lhsLength
      self

-}
{-
   local variables for Alt.HoleAlt:
      self

-}
{-
   local variables for Alt.ParseErrAlt:
      self

-}
-- semantic domain
type T_Alt = (Int) ->
             (Bindings) ->
             ([HeliumMessage]) ->
             (FocusDoc) ->
             (Int) ->
             (LayoutMap) ->
             (Int) ->
             (Int) ->
             (Int) ->
             ([Int]) ->
             (([PathDoc],[PathDoc],[PathDoc])) ->
             (Int) ->
             ([(String, String)]) ->
             (Int) ->
             ([(PathDoc,String)]) ->
             (FiniteMap String (PathDoc, String)) ->
             (FiniteMap String (PathDoc, String)) ->
             ( (Binding),(Int),(LayoutMap),(Int),(Int),(Int),(Presentation),(Presentation),(Presentation),(Alt),(Int),(FiniteMap String (PathDoc, String)))
-- cata
sem_Alt :: (Alt) ->
           (T_Alt)
sem_Alt ((Alt (_idD) (_idP0) (_idP1) (_ident) (_exp))) =
    (sem_Alt_Alt (_idD) (_idP0) (_idP1) ((sem_Ident (_ident))) ((sem_Exp (_exp))))
sem_Alt ((HoleAlt )) =
    (sem_Alt_HoleAlt )
sem_Alt ((ParseErrAlt (_node) (_presentation))) =
    (sem_Alt_ParseErrAlt (_node) (_presentation))
sem_Alt_Alt :: (IDD) ->
               (IDP) ->
               (IDP) ->
               (T_Ident) ->
               (T_Exp) ->
               (T_Alt)
sem_Alt_Alt (_idD) (_idP0) (_idP1) (_ident) (_exp) =
    \ _lhs_col
      _lhs_env
      _lhs_errs
      _lhs_focusD
      _lhs_ix
      _lhs_layoutMap
      _lhs_level
      _lhs_newlines
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_spaces
      _lhs_topLevelEnv
      _lhs_totalMaxLHSLength
      _lhs_typeEnv
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                Alt _idD _idP0 _idP1 _ident_self _exp_self
            (_lhsLength) =
                length $ strFromIdent _ident_self
            ( _ident_col,_ident_firstToken,_ident_idsPres,_ident_layoutMap,_ident_newlines,_ident_pIdC,_ident_pres,_ident_presTree,_ident_presXML,_ident_self,_ident_spaces,_ident_str,_ident_varsInScopeAtFocus) =
                (_ident (_lhs_col) (_lhs_focusD) (_lhs_ix) (addListToFM _lhs_layoutMap [(_idP0, (0,_lhs_totalMaxLHSLength - _lhsLength+1)), (_idP1, (0,0))]) (_lhs_level) (_lhs_newlines) (_lhs_pIdC + 2) (_lhs_path++[0]) (_lhs_ranges) (_lhs_spaces) (_lhs_varsInScope) (if (PathD _lhs_path) == _lhs_focusD then _lhs_varsInScope else _lhs_varsInScopeAtFocus))
            ( _exp_col,_exp_lamBody,_exp_layoutMap,_exp_newlines,_exp_pIdC,_exp_pres,_exp_presTree,_exp_presXML,_exp_self,_exp_spaces,_exp_substitute,_exp_type,_exp_val,_exp_varsInScopeAtFocus) =
                (_exp (_ident_col+ _lhs_totalMaxLHSLength - _lhsLength + 3) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_ix) (_ident_layoutMap) (_lhs_level) (0) (_ident_pIdC) (_lhs_path++[1]) (_lhs_ranges) (1) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_ident_varsInScopeAtFocus))
        in  ( (_ident_str, _exp_val)
             ,_lhs_col
             ,_exp_layoutMap
             ,_lhsLength
             ,1
             ,_exp_pIdC
             ,loc (AltNode _self _lhs_path) $ parsing $ presentFocus _lhs_focusD _lhs_path $
                squiggleRanges _lhs_ranges _lhs_path $
                row'  $ [ _ident_pres
                        , text' (mkIDP _idP0 _lhs_pIdC 0) "",
                                 key NoIDP "®"    `withFontFam` "symbol"
                        , _exp_pres
                        , sep (mkIDP _idP1 _lhs_pIdC 1) ";"
                        ]
             ,presentElementTree _lhs_focusD (AltNode _self _lhs_path) _lhs_path "Alt" [ _ident_presTree, _exp_presTree ]
             ,presentElementXML _lhs_focusD (AltNode _self _lhs_path) _lhs_path "Alt" [ _ident_presXML, _exp_presXML ]
             ,_self
             ,_lhs_col
             ,_exp_varsInScopeAtFocus
             )
sem_Alt_HoleAlt :: (T_Alt)
sem_Alt_HoleAlt  =
    \ _lhs_col
      _lhs_env
      _lhs_errs
      _lhs_focusD
      _lhs_ix
      _lhs_layoutMap
      _lhs_level
      _lhs_newlines
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_spaces
      _lhs_topLevelEnv
      _lhs_totalMaxLHSLength
      _lhs_typeEnv
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                HoleAlt
        in  ( ("XXXXXX", ErrVal),_lhs_col,_lhs_layoutMap,0,_lhs_newlines,_lhs_pIdC,presHole _lhs_focusD "Alt" (HoleAltNode _self _lhs_path) _lhs_path,presHole _lhs_focusD "Alt" (HoleAltNode _self _lhs_path) _lhs_path,presHole _lhs_focusD "Alt" (HoleAltNode _self _lhs_path) _lhs_path,_self,_lhs_spaces,_lhs_varsInScopeAtFocus)
sem_Alt_ParseErrAlt :: (Node) ->
                       (Presentation) ->
                       (T_Alt)
sem_Alt_ParseErrAlt (_node) (_presentation) =
    \ _lhs_col
      _lhs_env
      _lhs_errs
      _lhs_focusD
      _lhs_ix
      _lhs_layoutMap
      _lhs_level
      _lhs_newlines
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_spaces
      _lhs_topLevelEnv
      _lhs_totalMaxLHSLength
      _lhs_typeEnv
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                ParseErrAlt _node _presentation
        in  ( ("XXXXXX", ErrVal),_lhs_col,_lhs_layoutMap,0,_lhs_newlines,_lhs_pIdC,presParseErr _node _presentation,presParseErr _node _presentation,presParseErr _node _presentation,_self,_lhs_spaces,_lhs_varsInScopeAtFocus)
-- Board -------------------------------------------------------
{-
   inherited attributes:
      focusD               : FocusDoc
      ix                   : Int
      path                 : [Int]

   chained attributes:
      pIdC                 : Int

   synthesised attributes:
      pres                 : Presentation
      presTree             : Presentation
      presXML              : Presentation
      self                 : SELF

-}
{-
   local variables for Board.Board:
      possibleMoves
      self

-}
{-
   local variables for Board.HoleBoard:
      self

-}
{-
   local variables for Board.ParseErrBoard:
      self

-}
-- semantic domain
type T_Board = (FocusDoc) ->
               (Int) ->
               (Int) ->
               ([Int]) ->
               ( (Int),(Presentation),(Presentation),(Presentation),(Board))
-- cata
sem_Board :: (Board) ->
             (T_Board)
sem_Board ((Board (_idD) (_r1) (_r2) (_r3) (_r4) (_r5) (_r6) (_r7) (_r8))) =
    (sem_Board_Board (_idD) ((sem_BoardRow (_r1))) ((sem_BoardRow (_r2))) ((sem_BoardRow (_r3))) ((sem_BoardRow (_r4))) ((sem_BoardRow (_r5))) ((sem_BoardRow (_r6))) ((sem_BoardRow (_r7))) ((sem_BoardRow (_r8))))
sem_Board ((HoleBoard )) =
    (sem_Board_HoleBoard )
sem_Board ((ParseErrBoard (_node) (_presentation))) =
    (sem_Board_ParseErrBoard (_node) (_presentation))
sem_Board_Board :: (IDD) ->
                   (T_BoardRow) ->
                   (T_BoardRow) ->
                   (T_BoardRow) ->
                   (T_BoardRow) ->
                   (T_BoardRow) ->
                   (T_BoardRow) ->
                   (T_BoardRow) ->
                   (T_BoardRow) ->
                   (T_Board)
sem_Board_Board (_idD) (_r1) (_r2) (_r3) (_r4) (_r5) (_r6) (_r7) (_r8) =
    \ _lhs_focusD
      _lhs_ix
      _lhs_pIdC
      _lhs_path ->
        let (_self) =
                Board _idD _r1_self _r2_self _r3_self _r4_self _r5_self _r6_self _r7_self _r8_self
            (_possibleMoves) =
                case _r8_focusedPiece of
                  Just (square, (r,c)) -> Chess.computeMoves _self (r,c)
                  Nothing              -> []
            ( _r1_focusedPiece,_r1_pIdC,_r1_pres,_r1_presTree,_r1_presXML,_r1_rowNr,_r1_self,_r1_sqCol) =
                (_r1 (_lhs_focusD) (Nothing) (_lhs_ix) (_lhs_pIdC + 0) (_lhs_path++[0]) (_possibleMoves) (0) (False))
            ( _r2_focusedPiece,_r2_pIdC,_r2_pres,_r2_presTree,_r2_presXML,_r2_rowNr,_r2_self,_r2_sqCol) =
                (_r2 (_lhs_focusD) (_r1_focusedPiece) (_lhs_ix) (_r1_pIdC) (_lhs_path++[1]) (_possibleMoves) (_r1_rowNr) (_r1_sqCol))
            ( _r3_focusedPiece,_r3_pIdC,_r3_pres,_r3_presTree,_r3_presXML,_r3_rowNr,_r3_self,_r3_sqCol) =
                (_r3 (_lhs_focusD) (_r2_focusedPiece) (_lhs_ix) (_r2_pIdC) (_lhs_path++[2]) (_possibleMoves) (_r2_rowNr) (_r2_sqCol))
            ( _r4_focusedPiece,_r4_pIdC,_r4_pres,_r4_presTree,_r4_presXML,_r4_rowNr,_r4_self,_r4_sqCol) =
                (_r4 (_lhs_focusD) (_r3_focusedPiece) (_lhs_ix) (_r3_pIdC) (_lhs_path++[3]) (_possibleMoves) (_r3_rowNr) (_r3_sqCol))
            ( _r5_focusedPiece,_r5_pIdC,_r5_pres,_r5_presTree,_r5_presXML,_r5_rowNr,_r5_self,_r5_sqCol) =
                (_r5 (_lhs_focusD) (_r4_focusedPiece) (_lhs_ix) (_r4_pIdC) (_lhs_path++[4]) (_possibleMoves) (_r4_rowNr) (_r4_sqCol))
            ( _r6_focusedPiece,_r6_pIdC,_r6_pres,_r6_presTree,_r6_presXML,_r6_rowNr,_r6_self,_r6_sqCol) =
                (_r6 (_lhs_focusD) (_r5_focusedPiece) (_lhs_ix) (_r5_pIdC) (_lhs_path++[5]) (_possibleMoves) (_r5_rowNr) (_r5_sqCol))
            ( _r7_focusedPiece,_r7_pIdC,_r7_pres,_r7_presTree,_r7_presXML,_r7_rowNr,_r7_self,_r7_sqCol) =
                (_r7 (_lhs_focusD) (_r6_focusedPiece) (_lhs_ix) (_r6_pIdC) (_lhs_path++[6]) (_possibleMoves) (_r6_rowNr) (_r6_sqCol))
            ( _r8_focusedPiece,_r8_pIdC,_r8_pres,_r8_presTree,_r8_presXML,_r8_rowNr,_r8_self,_r8_sqCol) =
                (_r8 (_lhs_focusD) (_r7_focusedPiece) (_lhs_ix) (_r7_pIdC) (_lhs_path++[7]) (_possibleMoves) (_r7_rowNr) (_r7_sqCol))
        in  ( _r8_pIdC
             ,loc (BoardNode _self _lhs_path) $ presentFocus _lhs_focusD _lhs_path $
                structural $ colR 4 (reverse [_r1_pres,_r2_pres,_r3_pres,_r4_pres,_r5_pres,_r6_pres,_r7_pres,_r8_pres])
             ,presentElementTree _lhs_focusD (BoardNode _self _lhs_path) _lhs_path "Board" [ _r1_presTree, _r2_presTree, _r3_presTree, _r4_presTree, _r5_presTree, _r6_presTree, _r7_presTree, _r8_presTree ]
             ,presentElementXML _lhs_focusD (BoardNode _self _lhs_path) _lhs_path "Board" [ _r1_presXML, _r2_presXML, _r3_presXML, _r4_presXML, _r5_presXML, _r6_presXML, _r7_presXML, _r8_presXML ]
             ,_self
             )
sem_Board_HoleBoard :: (T_Board)
sem_Board_HoleBoard  =
    \ _lhs_focusD
      _lhs_ix
      _lhs_pIdC
      _lhs_path ->
        let (_self) =
                HoleBoard
        in  ( _lhs_pIdC,presHole _lhs_focusD "Board" (HoleBoardNode _self _lhs_path) _lhs_path,presHole _lhs_focusD "Board" (HoleBoardNode _self _lhs_path) _lhs_path,presHole _lhs_focusD "Board" (HoleBoardNode _self _lhs_path) _lhs_path,_self)
sem_Board_ParseErrBoard :: (Node) ->
                           (Presentation) ->
                           (T_Board)
sem_Board_ParseErrBoard (_node) (_presentation) =
    \ _lhs_focusD
      _lhs_ix
      _lhs_pIdC
      _lhs_path ->
        let (_self) =
                ParseErrBoard _node _presentation
        in  ( _lhs_pIdC,presParseErr _node _presentation,presParseErr _node _presentation,presParseErr _node _presentation,_self)
-- BoardRow ----------------------------------------------------
{-
   inherited attributes:
      focusD               : FocusDoc
      ix                   : Int
      path                 : [Int]
      possibleMoves        : [(Int, Int)]

   chained attributes:
      focusedPiece         :  Maybe (BoardSquare,(Int,Int)) 
      pIdC                 : Int
      rowNr                : Int
      sqCol                : Bool

   synthesised attributes:
      pres                 : Presentation
      presTree             : Presentation
      presXML              : Presentation
      self                 : SELF

-}
{-
   local variables for BoardRow.BoardRow:
      self

-}
{-
   local variables for BoardRow.HoleBoardRow:
      self

-}
{-
   local variables for BoardRow.ParseErrBoardRow:
      self

-}
-- semantic domain
type T_BoardRow = (FocusDoc) ->
                  ( Maybe (BoardSquare,(Int,Int)) ) ->
                  (Int) ->
                  (Int) ->
                  ([Int]) ->
                  ([(Int, Int)]) ->
                  (Int) ->
                  (Bool) ->
                  ( ( Maybe (BoardSquare,(Int,Int)) ),(Int),(Presentation),(Presentation),(Presentation),(Int),(BoardRow),(Bool))
-- cata
sem_BoardRow :: (BoardRow) ->
                (T_BoardRow)
sem_BoardRow ((BoardRow (_idD) (_ca) (_cb) (_cc) (_cd) (_ce) (_cf) (_cg) (_ch))) =
    (sem_BoardRow_BoardRow (_idD) ((sem_BoardSquare (_ca))) ((sem_BoardSquare (_cb))) ((sem_BoardSquare (_cc))) ((sem_BoardSquare (_cd))) ((sem_BoardSquare (_ce))) ((sem_BoardSquare (_cf))) ((sem_BoardSquare (_cg))) ((sem_BoardSquare (_ch))))
sem_BoardRow ((HoleBoardRow )) =
    (sem_BoardRow_HoleBoardRow )
sem_BoardRow ((ParseErrBoardRow (_node) (_presentation))) =
    (sem_BoardRow_ParseErrBoardRow (_node) (_presentation))
sem_BoardRow_BoardRow :: (IDD) ->
                         (T_BoardSquare) ->
                         (T_BoardSquare) ->
                         (T_BoardSquare) ->
                         (T_BoardSquare) ->
                         (T_BoardSquare) ->
                         (T_BoardSquare) ->
                         (T_BoardSquare) ->
                         (T_BoardSquare) ->
                         (T_BoardRow)
sem_BoardRow_BoardRow (_idD) (_ca) (_cb) (_cc) (_cd) (_ce) (_cf) (_cg) (_ch) =
    \ _lhs_focusD
      _lhs_focusedPiece
      _lhs_ix
      _lhs_pIdC
      _lhs_path
      _lhs_possibleMoves
      _lhs_rowNr
      _lhs_sqCol ->
        let (_self) =
                BoardRow _idD _ca_self _cb_self _cc_self _cd_self _ce_self _cf_self _cg_self _ch_self
            ( _ca_colNr,_ca_focusedPiece,_ca_pIdC,_ca_pres,_ca_presTree,_ca_presXML,_ca_self,_ca_sqCol) =
                (_ca (0) (_lhs_focusD) (_lhs_focusedPiece) (_lhs_ix) (_lhs_pIdC + 0) (_lhs_path++[0]) (_lhs_possibleMoves) (_lhs_rowNr) (_lhs_sqCol))
            ( _cb_colNr,_cb_focusedPiece,_cb_pIdC,_cb_pres,_cb_presTree,_cb_presXML,_cb_self,_cb_sqCol) =
                (_cb (_ca_colNr) (_lhs_focusD) (_ca_focusedPiece) (_lhs_ix) (_ca_pIdC) (_lhs_path++[1]) (_lhs_possibleMoves) (_lhs_rowNr) (_ca_sqCol))
            ( _cc_colNr,_cc_focusedPiece,_cc_pIdC,_cc_pres,_cc_presTree,_cc_presXML,_cc_self,_cc_sqCol) =
                (_cc (_cb_colNr) (_lhs_focusD) (_cb_focusedPiece) (_lhs_ix) (_cb_pIdC) (_lhs_path++[2]) (_lhs_possibleMoves) (_lhs_rowNr) (_cb_sqCol))
            ( _cd_colNr,_cd_focusedPiece,_cd_pIdC,_cd_pres,_cd_presTree,_cd_presXML,_cd_self,_cd_sqCol) =
                (_cd (_cc_colNr) (_lhs_focusD) (_cc_focusedPiece) (_lhs_ix) (_cc_pIdC) (_lhs_path++[3]) (_lhs_possibleMoves) (_lhs_rowNr) (_cc_sqCol))
            ( _ce_colNr,_ce_focusedPiece,_ce_pIdC,_ce_pres,_ce_presTree,_ce_presXML,_ce_self,_ce_sqCol) =
                (_ce (_cd_colNr) (_lhs_focusD) (_cd_focusedPiece) (_lhs_ix) (_cd_pIdC) (_lhs_path++[4]) (_lhs_possibleMoves) (_lhs_rowNr) (_cd_sqCol))
            ( _cf_colNr,_cf_focusedPiece,_cf_pIdC,_cf_pres,_cf_presTree,_cf_presXML,_cf_self,_cf_sqCol) =
                (_cf (_ce_colNr) (_lhs_focusD) (_ce_focusedPiece) (_lhs_ix) (_ce_pIdC) (_lhs_path++[5]) (_lhs_possibleMoves) (_lhs_rowNr) (_ce_sqCol))
            ( _cg_colNr,_cg_focusedPiece,_cg_pIdC,_cg_pres,_cg_presTree,_cg_presXML,_cg_self,_cg_sqCol) =
                (_cg (_cf_colNr) (_lhs_focusD) (_cf_focusedPiece) (_lhs_ix) (_cf_pIdC) (_lhs_path++[6]) (_lhs_possibleMoves) (_lhs_rowNr) (_cf_sqCol))
            ( _ch_colNr,_ch_focusedPiece,_ch_pIdC,_ch_pres,_ch_presTree,_ch_presXML,_ch_self,_ch_sqCol) =
                (_ch (_cg_colNr) (_lhs_focusD) (_cg_focusedPiece) (_lhs_ix) (_cg_pIdC) (_lhs_path++[7]) (_lhs_possibleMoves) (_lhs_rowNr) (_cg_sqCol))
        in  ( _ch_focusedPiece
             ,_ch_pIdC
             ,loc (BoardRowNode _self _lhs_path) $ presentFocus _lhs_focusD _lhs_path $
              structural $  row' [_ca_pres,_cb_pres,_cc_pres,_cd_pres,_ce_pres,_cf_pres,_cg_pres,_ch_pres]
             ,presentElementTree _lhs_focusD (BoardRowNode _self _lhs_path) _lhs_path "BoardRow" [ _ca_presTree, _cb_presTree, _cc_presTree, _cd_presTree, _ce_presTree, _cf_presTree, _cg_presTree, _ch_presTree ]
             ,presentElementXML _lhs_focusD (BoardRowNode _self _lhs_path) _lhs_path "BoardRow" [ _ca_presXML, _cb_presXML, _cc_presXML, _cd_presXML, _ce_presXML, _cf_presXML, _cg_presXML, _ch_presXML ]
             ,1 + _lhs_rowNr
             ,_self
             ,not _lhs_sqCol
             )
sem_BoardRow_HoleBoardRow :: (T_BoardRow)
sem_BoardRow_HoleBoardRow  =
    \ _lhs_focusD
      _lhs_focusedPiece
      _lhs_ix
      _lhs_pIdC
      _lhs_path
      _lhs_possibleMoves
      _lhs_rowNr
      _lhs_sqCol ->
        let (_self) =
                HoleBoardRow
        in  ( _lhs_focusedPiece,_lhs_pIdC,presHole _lhs_focusD "BoardRow" (HoleBoardRowNode _self _lhs_path) _lhs_path,presHole _lhs_focusD "BoardRow" (HoleBoardRowNode _self _lhs_path) _lhs_path,presHole _lhs_focusD "BoardRow" (HoleBoardRowNode _self _lhs_path) _lhs_path,_lhs_rowNr,_self,_lhs_sqCol)
sem_BoardRow_ParseErrBoardRow :: (Node) ->
                                 (Presentation) ->
                                 (T_BoardRow)
sem_BoardRow_ParseErrBoardRow (_node) (_presentation) =
    \ _lhs_focusD
      _lhs_focusedPiece
      _lhs_ix
      _lhs_pIdC
      _lhs_path
      _lhs_possibleMoves
      _lhs_rowNr
      _lhs_sqCol ->
        let (_self) =
                ParseErrBoardRow _node _presentation
        in  ( _lhs_focusedPiece,_lhs_pIdC,presParseErr _node _presentation,presParseErr _node _presentation,presParseErr _node _presentation,_lhs_rowNr,_self,_lhs_sqCol)
-- BoardSquare -------------------------------------------------
{-
   inherited attributes:
      focusD               : FocusDoc
      ix                   : Int
      path                 : [Int]
      possibleMoves        : [(Int, Int)]
      rowNr                : Int

   chained attributes:
      colNr                : Int
      focusedPiece         :  Maybe (BoardSquare,(Int,Int)) 
      pIdC                 : Int
      sqCol                : Bool

   synthesised attributes:
      pres                 : Presentation
      presTree             : Presentation
      presXML              : Presentation
      self                 : SELF

-}
{-
   local variables for BoardSquare.Bishop:
      self

-}
{-
   local variables for BoardSquare.Empty:
      self

-}
{-
   local variables for BoardSquare.HoleBoardSquare:
      self

-}
{-
   local variables for BoardSquare.King:
      self

-}
{-
   local variables for BoardSquare.Knight:
      self

-}
{-
   local variables for BoardSquare.ParseErrBoardSquare:
      self

-}
{-
   local variables for BoardSquare.Pawn:
      self

-}
{-
   local variables for BoardSquare.Queen:
      self

-}
{-
   local variables for BoardSquare.Rook:
      self

-}
-- semantic domain
type T_BoardSquare = (Int) ->
                     (FocusDoc) ->
                     ( Maybe (BoardSquare,(Int,Int)) ) ->
                     (Int) ->
                     (Int) ->
                     ([Int]) ->
                     ([(Int, Int)]) ->
                     (Int) ->
                     (Bool) ->
                     ( (Int),( Maybe (BoardSquare,(Int,Int)) ),(Int),(Presentation),(Presentation),(Presentation),(BoardSquare),(Bool))
-- cata
sem_BoardSquare :: (BoardSquare) ->
                   (T_BoardSquare)
sem_BoardSquare ((Bishop (_idD) (_color))) =
    (sem_BoardSquare_Bishop (_idD) (_color))
sem_BoardSquare ((Empty )) =
    (sem_BoardSquare_Empty )
sem_BoardSquare ((HoleBoardSquare )) =
    (sem_BoardSquare_HoleBoardSquare )
sem_BoardSquare ((King (_idD) (_color))) =
    (sem_BoardSquare_King (_idD) (_color))
sem_BoardSquare ((Knight (_idD) (_color))) =
    (sem_BoardSquare_Knight (_idD) (_color))
sem_BoardSquare ((ParseErrBoardSquare (_node) (_presentation))) =
    (sem_BoardSquare_ParseErrBoardSquare (_node) (_presentation))
sem_BoardSquare ((Pawn (_idD) (_color))) =
    (sem_BoardSquare_Pawn (_idD) (_color))
sem_BoardSquare ((Queen (_idD) (_color))) =
    (sem_BoardSquare_Queen (_idD) (_color))
sem_BoardSquare ((Rook (_idD) (_color))) =
    (sem_BoardSquare_Rook (_idD) (_color))
sem_BoardSquare_Bishop :: (IDD) ->
                          (Bool) ->
                          (T_BoardSquare)
sem_BoardSquare_Bishop (_idD) (_color) =
    \ _lhs_colNr
      _lhs_focusD
      _lhs_focusedPiece
      _lhs_ix
      _lhs_pIdC
      _lhs_path
      _lhs_possibleMoves
      _lhs_rowNr
      _lhs_sqCol ->
        let (_self) =
                Bishop _idD _color
        in  ( 1 + _lhs_colNr
             ,if (PathD _lhs_path) == _lhs_focusD then Just (_self, (_lhs_colNr,_lhs_rowNr)) else _lhs_focusedPiece
             ,_lhs_pIdC
             ,loc (BishopNode _self _lhs_path) $
                structural $ Chess.piece _self _color _lhs_sqCol _lhs_rowNr _lhs_colNr _lhs_possibleMoves _lhs_focusD _lhs_path
             ,presentElementTree _lhs_focusD (BishopNode _self _lhs_path) _lhs_path "Bishop" [ presentPrimTreeBool _color ]
             ,presentElementXML _lhs_focusD (BishopNode _self _lhs_path) _lhs_path "Bishop" [ presentPrimXMLBool _color ]
             ,_self
             ,not _lhs_sqCol
             )
sem_BoardSquare_Empty :: (T_BoardSquare)
sem_BoardSquare_Empty  =
    \ _lhs_colNr
      _lhs_focusD
      _lhs_focusedPiece
      _lhs_ix
      _lhs_pIdC
      _lhs_path
      _lhs_possibleMoves
      _lhs_rowNr
      _lhs_sqCol ->
        let (_self) =
                Empty
        in  ( 1 + _lhs_colNr
             ,_lhs_focusedPiece
             ,_lhs_pIdC
             ,loc (EmptyNode _self _lhs_path) $
                structural $ Chess.piece _self False _lhs_sqCol _lhs_rowNr _lhs_colNr _lhs_possibleMoves _lhs_focusD _lhs_path
             ,presentElementTree _lhs_focusD (EmptyNode _self _lhs_path) _lhs_path "Empty" [  ]
             ,presentElementXML _lhs_focusD (EmptyNode _self _lhs_path) _lhs_path "Empty" [  ]
             ,_self
             ,not _lhs_sqCol
             )
sem_BoardSquare_HoleBoardSquare :: (T_BoardSquare)
sem_BoardSquare_HoleBoardSquare  =
    \ _lhs_colNr
      _lhs_focusD
      _lhs_focusedPiece
      _lhs_ix
      _lhs_pIdC
      _lhs_path
      _lhs_possibleMoves
      _lhs_rowNr
      _lhs_sqCol ->
        let (_self) =
                HoleBoardSquare
        in  ( _lhs_colNr,_lhs_focusedPiece,_lhs_pIdC,presHole _lhs_focusD "BoardSquare" (HoleBoardSquareNode _self _lhs_path) _lhs_path,presHole _lhs_focusD "BoardSquare" (HoleBoardSquareNode _self _lhs_path) _lhs_path,presHole _lhs_focusD "BoardSquare" (HoleBoardSquareNode _self _lhs_path) _lhs_path,_self,_lhs_sqCol)
sem_BoardSquare_King :: (IDD) ->
                        (Bool) ->
                        (T_BoardSquare)
sem_BoardSquare_King (_idD) (_color) =
    \ _lhs_colNr
      _lhs_focusD
      _lhs_focusedPiece
      _lhs_ix
      _lhs_pIdC
      _lhs_path
      _lhs_possibleMoves
      _lhs_rowNr
      _lhs_sqCol ->
        let (_self) =
                King _idD _color
        in  ( 1 + _lhs_colNr
             ,if (PathD _lhs_path) == _lhs_focusD then Just (_self, (_lhs_colNr,_lhs_rowNr)) else _lhs_focusedPiece
             ,_lhs_pIdC
             ,loc (KingNode _self _lhs_path) $
                structural $ Chess.piece _self _color _lhs_sqCol _lhs_rowNr _lhs_colNr _lhs_possibleMoves _lhs_focusD _lhs_path
             ,presentElementTree _lhs_focusD (KingNode _self _lhs_path) _lhs_path "King" [ presentPrimTreeBool _color ]
             ,presentElementXML _lhs_focusD (KingNode _self _lhs_path) _lhs_path "King" [ presentPrimXMLBool _color ]
             ,_self
             ,not _lhs_sqCol
             )
sem_BoardSquare_Knight :: (IDD) ->
                          (Bool) ->
                          (T_BoardSquare)
sem_BoardSquare_Knight (_idD) (_color) =
    \ _lhs_colNr
      _lhs_focusD
      _lhs_focusedPiece
      _lhs_ix
      _lhs_pIdC
      _lhs_path
      _lhs_possibleMoves
      _lhs_rowNr
      _lhs_sqCol ->
        let (_self) =
                Knight _idD _color
        in  ( 1 + _lhs_colNr
             ,if (PathD _lhs_path) == _lhs_focusD then Just (_self, (_lhs_colNr,_lhs_rowNr)) else _lhs_focusedPiece
             ,_lhs_pIdC
             ,loc (KnightNode _self _lhs_path) $
                structural $ Chess.piece _self _color _lhs_sqCol _lhs_rowNr _lhs_colNr _lhs_possibleMoves _lhs_focusD _lhs_path
             ,presentElementTree _lhs_focusD (KnightNode _self _lhs_path) _lhs_path "Knight" [ presentPrimTreeBool _color ]
             ,presentElementXML _lhs_focusD (KnightNode _self _lhs_path) _lhs_path "Knight" [ presentPrimXMLBool _color ]
             ,_self
             ,not _lhs_sqCol
             )
sem_BoardSquare_ParseErrBoardSquare :: (Node) ->
                                       (Presentation) ->
                                       (T_BoardSquare)
sem_BoardSquare_ParseErrBoardSquare (_node) (_presentation) =
    \ _lhs_colNr
      _lhs_focusD
      _lhs_focusedPiece
      _lhs_ix
      _lhs_pIdC
      _lhs_path
      _lhs_possibleMoves
      _lhs_rowNr
      _lhs_sqCol ->
        let (_self) =
                ParseErrBoardSquare _node _presentation
        in  ( _lhs_colNr,_lhs_focusedPiece,_lhs_pIdC,presParseErr _node _presentation,presParseErr _node _presentation,presParseErr _node _presentation,_self,_lhs_sqCol)
sem_BoardSquare_Pawn :: (IDD) ->
                        (Bool) ->
                        (T_BoardSquare)
sem_BoardSquare_Pawn (_idD) (_color) =
    \ _lhs_colNr
      _lhs_focusD
      _lhs_focusedPiece
      _lhs_ix
      _lhs_pIdC
      _lhs_path
      _lhs_possibleMoves
      _lhs_rowNr
      _lhs_sqCol ->
        let (_self) =
                Pawn _idD _color
        in  ( 1 + _lhs_colNr
             ,if (PathD _lhs_path) == _lhs_focusD then Just (_self, (_lhs_colNr,_lhs_rowNr)) else _lhs_focusedPiece
             ,_lhs_pIdC
             ,loc (PawnNode _self _lhs_path) $
                structural $ Chess.piece _self _color _lhs_sqCol _lhs_rowNr _lhs_colNr _lhs_possibleMoves _lhs_focusD _lhs_path
             ,presentElementTree _lhs_focusD (PawnNode _self _lhs_path) _lhs_path "Pawn" [ presentPrimTreeBool _color ]
             ,presentElementXML _lhs_focusD (PawnNode _self _lhs_path) _lhs_path "Pawn" [ presentPrimXMLBool _color ]
             ,_self
             ,not _lhs_sqCol
             )
sem_BoardSquare_Queen :: (IDD) ->
                         (Bool) ->
                         (T_BoardSquare)
sem_BoardSquare_Queen (_idD) (_color) =
    \ _lhs_colNr
      _lhs_focusD
      _lhs_focusedPiece
      _lhs_ix
      _lhs_pIdC
      _lhs_path
      _lhs_possibleMoves
      _lhs_rowNr
      _lhs_sqCol ->
        let (_self) =
                Queen _idD _color
        in  ( 1 + _lhs_colNr
             ,if (PathD _lhs_path) == _lhs_focusD then Just (_self, (_lhs_colNr,_lhs_rowNr)) else _lhs_focusedPiece
             ,_lhs_pIdC
             ,loc (QueenNode _self _lhs_path) $
                structural $ Chess.piece _self _color _lhs_sqCol _lhs_rowNr _lhs_colNr _lhs_possibleMoves _lhs_focusD _lhs_path
             ,presentElementTree _lhs_focusD (QueenNode _self _lhs_path) _lhs_path "Queen" [ presentPrimTreeBool _color ]
             ,presentElementXML _lhs_focusD (QueenNode _self _lhs_path) _lhs_path "Queen" [ presentPrimXMLBool _color ]
             ,_self
             ,not _lhs_sqCol
             )
sem_BoardSquare_Rook :: (IDD) ->
                        (Bool) ->
                        (T_BoardSquare)
sem_BoardSquare_Rook (_idD) (_color) =
    \ _lhs_colNr
      _lhs_focusD
      _lhs_focusedPiece
      _lhs_ix
      _lhs_pIdC
      _lhs_path
      _lhs_possibleMoves
      _lhs_rowNr
      _lhs_sqCol ->
        let (_self) =
                Rook _idD _color
        in  ( 1 + _lhs_colNr
             ,if (PathD _lhs_path) == _lhs_focusD then Just (_self, (_lhs_colNr,_lhs_rowNr)) else _lhs_focusedPiece
             ,_lhs_pIdC
             ,loc (RookNode _self _lhs_path) $
                structural $ Chess.piece _self _color _lhs_sqCol _lhs_rowNr _lhs_colNr _lhs_possibleMoves _lhs_focusD _lhs_path
             ,presentElementTree _lhs_focusD (RookNode _self _lhs_path) _lhs_path "Rook" [ presentPrimTreeBool _color ]
             ,presentElementXML _lhs_focusD (RookNode _self _lhs_path) _lhs_path "Rook" [ presentPrimXMLBool _color ]
             ,_self
             ,not _lhs_sqCol
             )
-- ConsList_Alt ------------------------------------------------
{-
   inherited attributes:
      env                  : Bindings
      errs                 : [HeliumMessage]
      focusD               : FocusDoc
      ix                   : Int
      level                : Int
      path                 : [Int]
      ranges               : ([PathDoc],[PathDoc],[PathDoc])
      topLevelEnv          : [(String, String)]
      totalMaxLHSLength    : Int
      typeEnv              : [(PathDoc,String)]
      varsInScope          : FiniteMap String (PathDoc, String)

   chained attributes:
      col                  : Int
      layoutMap            : LayoutMap
      newlines             : Int
      pIdC                 : Int
      spaces               : Int
      varsInScopeAtFocus   : FiniteMap String (PathDoc, String)

   synthesised attributes:
      alts                 : Bindings
      maxLHSLength         : Int
      press                : [Presentation]
      pressTree            : [Presentation]
      pressXML             : [Presentation]
      self                 : SELF

-}
{-
   local variables for ConsList_Alt.Cons_Alt:
      self

-}
{-
   local variables for ConsList_Alt.Nil_Alt:
      self

-}
-- semantic domain
type T_ConsList_Alt = (Int) ->
                      (Bindings) ->
                      ([HeliumMessage]) ->
                      (FocusDoc) ->
                      (Int) ->
                      (LayoutMap) ->
                      (Int) ->
                      (Int) ->
                      (Int) ->
                      ([Int]) ->
                      (([PathDoc],[PathDoc],[PathDoc])) ->
                      (Int) ->
                      ([(String, String)]) ->
                      (Int) ->
                      ([(PathDoc,String)]) ->
                      (FiniteMap String (PathDoc, String)) ->
                      (FiniteMap String (PathDoc, String)) ->
                      ( (Bindings),(Int),(LayoutMap),(Int),(Int),(Int),([Presentation]),([Presentation]),([Presentation]),(ConsList_Alt),(Int),(FiniteMap String (PathDoc, String)))
-- cata
sem_ConsList_Alt :: (ConsList_Alt) ->
                    (T_ConsList_Alt)
sem_ConsList_Alt ((Cons_Alt (_head) (_tail))) =
    (sem_ConsList_Alt_Cons_Alt ((sem_Alt (_head))) ((sem_ConsList_Alt (_tail))))
sem_ConsList_Alt ((Nil_Alt )) =
    (sem_ConsList_Alt_Nil_Alt )
sem_ConsList_Alt_Cons_Alt :: (T_Alt) ->
                             (T_ConsList_Alt) ->
                             (T_ConsList_Alt)
sem_ConsList_Alt_Cons_Alt (_head) (_tail) =
    \ _lhs_col
      _lhs_env
      _lhs_errs
      _lhs_focusD
      _lhs_ix
      _lhs_layoutMap
      _lhs_level
      _lhs_newlines
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_spaces
      _lhs_topLevelEnv
      _lhs_totalMaxLHSLength
      _lhs_typeEnv
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                Cons_Alt _head_self _tail_self
            ( _head_alt,_head_col,_head_layoutMap,_head_lhsLength,_head_newlines,_head_pIdC,_head_pres,_head_presTree,_head_presXML,_head_self,_head_spaces,_head_varsInScopeAtFocus) =
                (_head (_lhs_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_ix) (_lhs_layoutMap) (_lhs_level) (_lhs_newlines) (_lhs_pIdC + 30) (_lhs_path++[_lhs_ix]) (_lhs_ranges) (_lhs_spaces) (_lhs_topLevelEnv) (_lhs_totalMaxLHSLength) (_lhs_typeEnv) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus))
            ( _tail_alts,_tail_col,_tail_layoutMap,_tail_maxLHSLength,_tail_newlines,_tail_pIdC,_tail_press,_tail_pressTree,_tail_pressXML,_tail_self,_tail_spaces,_tail_varsInScopeAtFocus) =
                (_tail (_head_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_ix + 1) (_head_layoutMap) (_lhs_level) (_head_newlines) (_head_pIdC) (_lhs_path) (_lhs_ranges) (_head_spaces) (_lhs_topLevelEnv) (_lhs_totalMaxLHSLength) (_lhs_typeEnv) (_lhs_varsInScope) (_head_varsInScopeAtFocus))
        in  ( _head_alt : _tail_alts,_tail_col,_tail_layoutMap,_head_lhsLength `max` _tail_maxLHSLength,_tail_newlines,_tail_pIdC,_head_pres : _tail_press,_head_presTree : _tail_pressTree,_head_presXML : _tail_pressXML,_self,_tail_spaces,_tail_varsInScopeAtFocus)
sem_ConsList_Alt_Nil_Alt :: (T_ConsList_Alt)
sem_ConsList_Alt_Nil_Alt  =
    \ _lhs_col
      _lhs_env
      _lhs_errs
      _lhs_focusD
      _lhs_ix
      _lhs_layoutMap
      _lhs_level
      _lhs_newlines
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_spaces
      _lhs_topLevelEnv
      _lhs_totalMaxLHSLength
      _lhs_typeEnv
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                Nil_Alt
        in  ( [],_lhs_col,_lhs_layoutMap,0,_lhs_newlines,_lhs_pIdC,[],[],[],_self,_lhs_spaces,_lhs_varsInScopeAtFocus)
-- ConsList_Decl -----------------------------------------------
{-
   inherited attributes:
      env                  : Bindings
      errs                 : [HeliumMessage]
      focusD               : FocusDoc
      ix                   : Int
      level                : Int
      path                 : [Int]
      ranges               : ([PathDoc],[PathDoc],[PathDoc])
      topLevelEnv          : [(String, String)]
      typeEnv              : [(PathDoc,String)]
      varsInScope          : FiniteMap String (PathDoc, String)

   chained attributes:
      col                  : Int
      layoutMap            : LayoutMap
      newlines             : Int
      pIdC                 : Int
      spaces               : Int
      varsInScopeAtFocus   : FiniteMap String (PathDoc, String)

   synthesised attributes:
      dcls                 : Bindings
      declaredVars         : [(String,(PathDoc,String))]
      idsPres              : Presentation
      parseErrs            : [String]
      press                : [Presentation]
      pressTree            : [Presentation]
      pressXML             : [Presentation]
      self                 : SELF

-}
{-
   local variables for ConsList_Decl.Cons_Decl:
      self

-}
{-
   local variables for ConsList_Decl.Nil_Decl:
      self

-}
-- semantic domain
type T_ConsList_Decl = (Int) ->
                       (Bindings) ->
                       ([HeliumMessage]) ->
                       (FocusDoc) ->
                       (Int) ->
                       (LayoutMap) ->
                       (Int) ->
                       (Int) ->
                       (Int) ->
                       ([Int]) ->
                       (([PathDoc],[PathDoc],[PathDoc])) ->
                       (Int) ->
                       ([(String, String)]) ->
                       ([(PathDoc,String)]) ->
                       (FiniteMap String (PathDoc, String)) ->
                       (FiniteMap String (PathDoc, String)) ->
                       ( (Int),(Bindings),([(String,(PathDoc,String))]),(Presentation),(LayoutMap),(Int),(Int),([String]),([Presentation]),([Presentation]),([Presentation]),(ConsList_Decl),(Int),(FiniteMap String (PathDoc, String)))
-- cata
sem_ConsList_Decl :: (ConsList_Decl) ->
                     (T_ConsList_Decl)
sem_ConsList_Decl ((Cons_Decl (_head) (_tail))) =
    (sem_ConsList_Decl_Cons_Decl ((sem_Decl (_head))) ((sem_ConsList_Decl (_tail))))
sem_ConsList_Decl ((Nil_Decl )) =
    (sem_ConsList_Decl_Nil_Decl )
sem_ConsList_Decl_Cons_Decl :: (T_Decl) ->
                               (T_ConsList_Decl) ->
                               (T_ConsList_Decl)
sem_ConsList_Decl_Cons_Decl (_head) (_tail) =
    \ _lhs_col
      _lhs_env
      _lhs_errs
      _lhs_focusD
      _lhs_ix
      _lhs_layoutMap
      _lhs_level
      _lhs_newlines
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_spaces
      _lhs_topLevelEnv
      _lhs_typeEnv
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                Cons_Decl _head_self _tail_self
            ( _head_col,_head_dcl,_head_declaredVars,_head_idsPres,_head_layoutMap,_head_newlines,_head_pIdC,_head_pres,_head_presTree,_head_presXML,_head_self,_head_spaces,_head_typeStr,_head_varsInScopeAtFocus) =
                (_head (_lhs_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_ix) (_lhs_layoutMap) (_lhs_level) (_lhs_newlines) (_lhs_pIdC + 30) (_lhs_path++[_lhs_ix]) (_lhs_ranges) (_lhs_spaces) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus))
            ( _tail_col,_tail_dcls,_tail_declaredVars,_tail_idsPres,_tail_layoutMap,_tail_newlines,_tail_pIdC,_tail_parseErrs,_tail_press,_tail_pressTree,_tail_pressXML,_tail_self,_tail_spaces,_tail_varsInScopeAtFocus) =
                (_tail (_head_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_ix + 1) (_head_layoutMap) (_lhs_level) (_head_newlines) (_head_pIdC) (_lhs_path) (_lhs_ranges) (_head_spaces) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_head_varsInScopeAtFocus))
        in  ( _tail_col,_head_dcl : _tail_dcls,_head_declaredVars ++ _tail_declaredVars,row' [ _head_idsPres, text " ", _tail_idsPres ],_tail_layoutMap,_tail_newlines,_tail_pIdC,[],_head_pres : _tail_press,_head_presTree : _tail_pressTree,_head_presXML : _tail_pressXML,_self,_tail_spaces,_tail_varsInScopeAtFocus)
sem_ConsList_Decl_Nil_Decl :: (T_ConsList_Decl)
sem_ConsList_Decl_Nil_Decl  =
    \ _lhs_col
      _lhs_env
      _lhs_errs
      _lhs_focusD
      _lhs_ix
      _lhs_layoutMap
      _lhs_level
      _lhs_newlines
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_spaces
      _lhs_topLevelEnv
      _lhs_typeEnv
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                Nil_Decl
        in  ( _lhs_col,[],[],empty,_lhs_layoutMap,_lhs_newlines,_lhs_pIdC,[],[],[],[],_self,_lhs_spaces,_lhs_varsInScopeAtFocus)
-- ConsList_Exp ------------------------------------------------
{-
   inherited attributes:
      env                  : Bindings
      errs                 : [HeliumMessage]
      focusD               : FocusDoc
      ix                   : Int
      level                : Int
      path                 : [Int]
      ranges               : ([PathDoc],[PathDoc],[PathDoc])
      topLevelEnv          : [(String, String)]
      typeEnv              : [(PathDoc,String)]
      varsInScope          : FiniteMap String (PathDoc, String)

   chained attributes:
      col                  : Int
      layoutMap            : LayoutMap
      newlines             : Int
      pIdC                 : Int
      spaces               : Int
      varsInScopeAtFocus   : FiniteMap String (PathDoc, String)

   synthesised attributes:
      press                : [Presentation]
      pressTree            : [Presentation]
      pressXML             : [Presentation]
      self                 : SELF
      vals                 : [Value]

-}
{-
   local variables for ConsList_Exp.Cons_Exp:
      self

-}
{-
   local variables for ConsList_Exp.Nil_Exp:
      self

-}
-- semantic domain
type T_ConsList_Exp = (Int) ->
                      (Bindings) ->
                      ([HeliumMessage]) ->
                      (FocusDoc) ->
                      (Int) ->
                      (LayoutMap) ->
                      (Int) ->
                      (Int) ->
                      (Int) ->
                      ([Int]) ->
                      (([PathDoc],[PathDoc],[PathDoc])) ->
                      (Int) ->
                      ([(String, String)]) ->
                      ([(PathDoc,String)]) ->
                      (FiniteMap String (PathDoc, String)) ->
                      (FiniteMap String (PathDoc, String)) ->
                      ( (Int),(LayoutMap),(Int),(Int),([Presentation]),([Presentation]),([Presentation]),(ConsList_Exp),(Int),([Value]),(FiniteMap String (PathDoc, String)))
-- cata
sem_ConsList_Exp :: (ConsList_Exp) ->
                    (T_ConsList_Exp)
sem_ConsList_Exp ((Cons_Exp (_head) (_tail))) =
    (sem_ConsList_Exp_Cons_Exp ((sem_Exp (_head))) ((sem_ConsList_Exp (_tail))))
sem_ConsList_Exp ((Nil_Exp )) =
    (sem_ConsList_Exp_Nil_Exp )
sem_ConsList_Exp_Cons_Exp :: (T_Exp) ->
                             (T_ConsList_Exp) ->
                             (T_ConsList_Exp)
sem_ConsList_Exp_Cons_Exp (_head) (_tail) =
    \ _lhs_col
      _lhs_env
      _lhs_errs
      _lhs_focusD
      _lhs_ix
      _lhs_layoutMap
      _lhs_level
      _lhs_newlines
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_spaces
      _lhs_topLevelEnv
      _lhs_typeEnv
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                Cons_Exp _head_self _tail_self
            ( _head_col,_head_lamBody,_head_layoutMap,_head_newlines,_head_pIdC,_head_pres,_head_presTree,_head_presXML,_head_self,_head_spaces,_head_substitute,_head_type,_head_val,_head_varsInScopeAtFocus) =
                (_head (_lhs_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_ix) (_lhs_layoutMap) (_lhs_level) (_lhs_newlines) (_lhs_pIdC + 30) (_lhs_path++[_lhs_ix]) (_lhs_ranges) (_lhs_spaces) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus))
            ( _tail_col,_tail_layoutMap,_tail_newlines,_tail_pIdC,_tail_press,_tail_pressTree,_tail_pressXML,_tail_self,_tail_spaces,_tail_vals,_tail_varsInScopeAtFocus) =
                (_tail (_head_col + 2) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_ix + 1) (_head_layoutMap) (_lhs_level) (_head_newlines) (_head_pIdC) (_lhs_path) (_lhs_ranges) (_head_spaces) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_head_varsInScopeAtFocus))
        in  ( _tail_col,_tail_layoutMap,_tail_newlines,_tail_pIdC,_head_pres : _tail_press,_head_presTree : _tail_pressTree,_head_presXML : _tail_pressXML,_self,_tail_spaces,_head_val : _tail_vals,_tail_varsInScopeAtFocus)
sem_ConsList_Exp_Nil_Exp :: (T_ConsList_Exp)
sem_ConsList_Exp_Nil_Exp  =
    \ _lhs_col
      _lhs_env
      _lhs_errs
      _lhs_focusD
      _lhs_ix
      _lhs_layoutMap
      _lhs_level
      _lhs_newlines
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_spaces
      _lhs_topLevelEnv
      _lhs_typeEnv
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                Nil_Exp
        in  ( _lhs_col,_lhs_layoutMap,_lhs_newlines,_lhs_pIdC,[],[],[],_self,_lhs_spaces,[],_lhs_varsInScopeAtFocus)
-- ConsList_Item -----------------------------------------------
{-
   inherited attributes:
      focusD               : FocusDoc
      ix                   : Int
      listType             : ListType
      path                 : [Int]
      ranges               : ([PathDoc],[PathDoc],[PathDoc])
      varsInScope          : FiniteMap String (PathDoc, String)

   chained attributes:
      pIdC                 : Int
      varsInScopeAtFocus   : FiniteMap String (PathDoc, String)

   synthesised attributes:
      press                : [Presentation]
      press2               : [Presentation]
      pressTree            : [Presentation]
      pressXML             : [Presentation]
      self                 : SELF

-}
{-
   local variables for ConsList_Item.Cons_Item:
      self

-}
{-
   local variables for ConsList_Item.Nil_Item:
      self

-}
-- semantic domain
type T_ConsList_Item = (FocusDoc) ->
                       (Int) ->
                       (ListType) ->
                       (Int) ->
                       ([Int]) ->
                       (([PathDoc],[PathDoc],[PathDoc])) ->
                       (FiniteMap String (PathDoc, String)) ->
                       (FiniteMap String (PathDoc, String)) ->
                       ( (Int),([Presentation]),([Presentation]),([Presentation]),([Presentation]),(ConsList_Item),(FiniteMap String (PathDoc, String)))
-- cata
sem_ConsList_Item :: (ConsList_Item) ->
                     (T_ConsList_Item)
sem_ConsList_Item ((Cons_Item (_head) (_tail))) =
    (sem_ConsList_Item_Cons_Item ((sem_Item (_head))) ((sem_ConsList_Item (_tail))))
sem_ConsList_Item ((Nil_Item )) =
    (sem_ConsList_Item_Nil_Item )
sem_ConsList_Item_Cons_Item :: (T_Item) ->
                               (T_ConsList_Item) ->
                               (T_ConsList_Item)
sem_ConsList_Item_Cons_Item (_head) (_tail) =
    \ _lhs_focusD
      _lhs_ix
      _lhs_listType
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                Cons_Item _head_self _tail_self
            ( _head_pIdC,_head_pres,_head_pres2,_head_presTree,_head_presXML,_head_self,_head_varsInScopeAtFocus) =
                (_head (_lhs_focusD) (_lhs_ix) (_lhs_listType) (_lhs_pIdC + 30) (_lhs_path++[_lhs_ix]) (_lhs_ranges) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus))
            ( _tail_pIdC,_tail_press,_tail_press2,_tail_pressTree,_tail_pressXML,_tail_self,_tail_varsInScopeAtFocus) =
                (_tail (_lhs_focusD) (_lhs_ix + 1) (_lhs_listType) (_head_pIdC) (_lhs_path) (_lhs_ranges) (_lhs_varsInScope) (_head_varsInScopeAtFocus))
        in  ( _tail_pIdC,_head_pres : _tail_press,_head_pres2 : _tail_press2,_head_presTree : _tail_pressTree,_head_presXML : _tail_pressXML,_self,_tail_varsInScopeAtFocus)
sem_ConsList_Item_Nil_Item :: (T_ConsList_Item)
sem_ConsList_Item_Nil_Item  =
    \ _lhs_focusD
      _lhs_ix
      _lhs_listType
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                Nil_Item
        in  ( _lhs_pIdC,[],[],[],[],_self,_lhs_varsInScopeAtFocus)
-- ConsList_Slide ----------------------------------------------
{-
   inherited attributes:
      focusD               : FocusDoc
      ix                   : Int
      path                 : [Int]
      ranges               : ([PathDoc],[PathDoc],[PathDoc])
      varsInScope          : FiniteMap String (PathDoc, String)

   chained attributes:
      pIdC                 : Int
      varsInScopeAtFocus   : FiniteMap String (PathDoc, String)

   synthesised attributes:
      press                : [Presentation]
      press2               : [Presentation]
      pressTree            : [Presentation]
      pressXML             : [Presentation]
      self                 : SELF

-}
{-
   local variables for ConsList_Slide.Cons_Slide:
      self

-}
{-
   local variables for ConsList_Slide.Nil_Slide:
      self

-}
-- semantic domain
type T_ConsList_Slide = (FocusDoc) ->
                        (Int) ->
                        (Int) ->
                        ([Int]) ->
                        (([PathDoc],[PathDoc],[PathDoc])) ->
                        (FiniteMap String (PathDoc, String)) ->
                        (FiniteMap String (PathDoc, String)) ->
                        ( (Int),([Presentation]),([Presentation]),([Presentation]),([Presentation]),(ConsList_Slide),(FiniteMap String (PathDoc, String)))
-- cata
sem_ConsList_Slide :: (ConsList_Slide) ->
                      (T_ConsList_Slide)
sem_ConsList_Slide ((Cons_Slide (_head) (_tail))) =
    (sem_ConsList_Slide_Cons_Slide ((sem_Slide (_head))) ((sem_ConsList_Slide (_tail))))
sem_ConsList_Slide ((Nil_Slide )) =
    (sem_ConsList_Slide_Nil_Slide )
sem_ConsList_Slide_Cons_Slide :: (T_Slide) ->
                                 (T_ConsList_Slide) ->
                                 (T_ConsList_Slide)
sem_ConsList_Slide_Cons_Slide (_head) (_tail) =
    \ _lhs_focusD
      _lhs_ix
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                Cons_Slide _head_self _tail_self
            ( _head_pIdC,_head_pres,_head_pres2,_head_presTree,_head_presXML,_head_self,_head_varsInScopeAtFocus) =
                (_head (_lhs_focusD) (_lhs_ix) (_lhs_pIdC + 30) (_lhs_path++[_lhs_ix]) (_lhs_ranges) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus))
            ( _tail_pIdC,_tail_press,_tail_press2,_tail_pressTree,_tail_pressXML,_tail_self,_tail_varsInScopeAtFocus) =
                (_tail (_lhs_focusD) (_lhs_ix + 1) (_head_pIdC) (_lhs_path) (_lhs_ranges) (_lhs_varsInScope) (_head_varsInScopeAtFocus))
        in  ( _tail_pIdC,_head_pres : _tail_press,_head_pres2 : _tail_press2,_head_presTree : _tail_pressTree,_head_presXML : _tail_pressXML,_self,_tail_varsInScopeAtFocus)
sem_ConsList_Slide_Nil_Slide :: (T_ConsList_Slide)
sem_ConsList_Slide_Nil_Slide  =
    \ _lhs_focusD
      _lhs_ix
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                Nil_Slide
        in  ( _lhs_pIdC,[],[],[],[],_self,_lhs_varsInScopeAtFocus)
-- Decl --------------------------------------------------------
{-
   inherited attributes:
      env                  : Bindings
      errs                 : [HeliumMessage]
      focusD               : FocusDoc
      ix                   : Int
      level                : Int
      path                 : [Int]
      ranges               : ([PathDoc],[PathDoc],[PathDoc])
      topLevelEnv          : [(String, String)]
      typeEnv              : [(PathDoc,String)]
      varsInScope          : FiniteMap String (PathDoc, String)

   chained attributes:
      col                  : Int
      layoutMap            : LayoutMap
      newlines             : Int
      pIdC                 : Int
      spaces               : Int
      varsInScopeAtFocus   : FiniteMap String (PathDoc, String)

   synthesised attributes:
      dcl                  : Binding
      declaredVars         : [(String,(PathDoc,String))]
      idsPres              : Presentation
      pres                 : Presentation
      presTree             : Presentation
      presXML              : Presentation
      self                 : SELF
      typeStr              : Maybe String

-}
{-
   local variables for Decl.BoardDecl:
      typeStr
      self

-}
{-
   local variables for Decl.Decl:
      typeStr
      self

-}
{-
   local variables for Decl.HoleDecl:
      typeStr
      self

-}
{-
   local variables for Decl.PPPresentationDecl:
      typeStr
      self

-}
{-
   local variables for Decl.ParseErrDecl:
      typeStr
      self

-}
-- semantic domain
type T_Decl = (Int) ->
              (Bindings) ->
              ([HeliumMessage]) ->
              (FocusDoc) ->
              (Int) ->
              (LayoutMap) ->
              (Int) ->
              (Int) ->
              (Int) ->
              ([Int]) ->
              (([PathDoc],[PathDoc],[PathDoc])) ->
              (Int) ->
              ([(String, String)]) ->
              ([(PathDoc,String)]) ->
              (FiniteMap String (PathDoc, String)) ->
              (FiniteMap String (PathDoc, String)) ->
              ( (Int),(Binding),([(String,(PathDoc,String))]),(Presentation),(LayoutMap),(Int),(Int),(Presentation),(Presentation),(Presentation),(Decl),(Int),(Maybe String),(FiniteMap String (PathDoc, String)))
-- cata
sem_Decl :: (Decl) ->
            (T_Decl)
sem_Decl ((BoardDecl (_idD) (_idP0) (_idP1) (_board))) =
    (sem_Decl_BoardDecl (_idD) (_idP0) (_idP1) ((sem_Board (_board))))
sem_Decl ((Decl (_idD) (_idP0) (_idP1) (_idP2) (_idP3) (_expanded) (_autoLayout) (_ident) (_exp))) =
    (sem_Decl_Decl (_idD) (_idP0) (_idP1) (_idP2) (_idP3) (_expanded) (_autoLayout) ((sem_Ident (_ident))) ((sem_Exp (_exp))))
sem_Decl ((HoleDecl )) =
    (sem_Decl_HoleDecl )
sem_Decl ((PPPresentationDecl (_idD) (_idP0) (_idP1) (_pPPresentation))) =
    (sem_Decl_PPPresentationDecl (_idD) (_idP0) (_idP1) ((sem_PPPresentation (_pPPresentation))))
sem_Decl ((ParseErrDecl (_node) (_presentation))) =
    (sem_Decl_ParseErrDecl (_node) (_presentation))
sem_Decl_BoardDecl :: (IDD) ->
                      (IDP) ->
                      (IDP) ->
                      (T_Board) ->
                      (T_Decl)
sem_Decl_BoardDecl (_idD) (_idP0) (_idP1) (_board) =
    \ _lhs_col
      _lhs_env
      _lhs_errs
      _lhs_focusD
      _lhs_ix
      _lhs_layoutMap
      _lhs_level
      _lhs_newlines
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_spaces
      _lhs_topLevelEnv
      _lhs_typeEnv
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                BoardDecl _idD _idP0 _idP1 _board_self
            (_typeStr) =
                Nothing
            ( _board_pIdC,_board_pres,_board_presTree,_board_presXML,_board_self) =
                (_board (_lhs_focusD) (_lhs_ix) (_lhs_pIdC + 2) (_lhs_path++[0]))
        in  ( _lhs_col
             ,("XXXXXX", ErrVal)
             ,[]
             ,loc (BoardDeclNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
                row' [ text "board;" ]
             ,_lhs_layoutMap
             ,_lhs_newlines
             ,_board_pIdC
             ,loc (DeclNode _self _lhs_path) $ parsing $ presentFocus _lhs_focusD _lhs_path $
                row' [text' (mkIDP _idP0 _lhs_pIdC 0) "Chess: ", _board_pres]
             ,presentElementTree _lhs_focusD (BoardDeclNode _self _lhs_path) _lhs_path "BoardDecl" [ _board_presTree ]
             ,presentElementXML _lhs_focusD (BoardDeclNode _self _lhs_path) _lhs_path "BoardDecl" [ _board_presXML ]
             ,_self
             ,_lhs_spaces
             ,_typeStr
             ,_lhs_varsInScopeAtFocus
             )
sem_Decl_Decl :: (IDD) ->
                 (IDP) ->
                 (IDP) ->
                 (IDP) ->
                 (IDP) ->
                 (Bool) ->
                 (Bool) ->
                 (T_Ident) ->
                 (T_Exp) ->
                 (T_Decl)
sem_Decl_Decl (_idD) (_idP0) (_idP1) (_idP2) (_idP3) (_expanded) (_autoLayout) (_ident) (_exp) =
    \ _lhs_col
      _lhs_env
      _lhs_errs
      _lhs_focusD
      _lhs_ix
      _lhs_layoutMap
      _lhs_level
      _lhs_newlines
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_spaces
      _lhs_topLevelEnv
      _lhs_typeEnv
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                Decl _idD _idP0 _idP1 _idP2 _idP3 _expanded _autoLayout _ident_self _exp_self
            (_typeStr) =
                case lookup (strFromIdent _ident_self) _lhs_topLevelEnv of
                  Nothing -> Nothing
                  Just tp -> Just $ strFromIdent _ident_self ++ " :: "++ tp
            ( _ident_col,_ident_firstToken,_ident_idsPres,_ident_layoutMap,_ident_newlines,_ident_pIdC,_ident_pres,_ident_presTree,_ident_presXML,_ident_self,_ident_spaces,_ident_str,_ident_varsInScopeAtFocus) =
                (_ident (_lhs_col) (_lhs_focusD) (_lhs_ix) (addListToFM _lhs_layoutMap [(_idP0, (0,1)), (_idP1, (0,0))]) (_lhs_level) (_lhs_newlines) (_lhs_pIdC + 4) (_lhs_path++[2]) (_lhs_ranges) (_lhs_spaces) (_lhs_varsInScope) (if (PathD _lhs_path) == _lhs_focusD then _lhs_varsInScope else _lhs_varsInScopeAtFocus))
            ( _exp_col,_exp_lamBody,_exp_layoutMap,_exp_newlines,_exp_pIdC,_exp_pres,_exp_presTree,_exp_presXML,_exp_self,_exp_spaces,_exp_substitute,_exp_type,_exp_val,_exp_varsInScopeAtFocus) =
                (_exp (_ident_col+2+1) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_ix) (_ident_layoutMap) (_lhs_level) (0) (_ident_pIdC) (_lhs_path++[3]) (_lhs_ranges) (1) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_ident_varsInScopeAtFocus))
        in  ( _lhs_col
             ,(_ident_str, _exp_val)
             ,[(strFromIdent _ident_self, (PathD (_lhs_path++[0]), _exp_type))]
             ,loc (DeclNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
                row' [ text "'", _ident_idsPres, text' NoIDP "';" ]
             ,let lm = if _autoLayout || _lhs_level /= 0 then _exp_layoutMap else _lhs_layoutMap
              in if _idP2 /= NoIDP || _lhs_level /= 0 then lm
                 else case lookupFM lm (_ident_firstToken) of
                        Just (nwln,sp) -> addListToFM lm [ (mkIDP _idP2 _lhs_pIdC 2,(nwln,sp))
                                                                     , (_ident_firstToken, (1,sp)) ]
                        _        -> addToFM lm (mkIDP _idP2 _lhs_pIdC 2) (1,0)
             ,1
             ,_exp_pIdC
             ,loc (DeclNode _self _lhs_path) $ parsing $ presentFocus _lhs_focusD _lhs_path $
                squiggleRanges _lhs_ranges _lhs_path $
                  (row' $
                     (if _lhs_level == 0
                      then let sigIDP    = mkIDP _idP2 _lhs_pIdC 2
                               autoLStr = if _autoLayout then "             {auto layout}" else ""
                           in  case _typeStr of
                                 Nothing ->
                                    case _exp_val of
                                            ErrVal -> [ StructuralP sigIDP $ row'
                                                         [text' NoIDP ("-- No value"++autoLStr)]
                                                           `withbgColor` lightGrey
                                                      ]
                                            v      -> [ StructuralP sigIDP $ row'
                                                         [text' NoIDP ("-- Value: " ++ show _exp_val++autoLStr )]
                                                           `withbgColor` lightGrey
                                                      ]
                                 Just tpstr ->
                                   [  StructuralP sigIDP . row' $
                                        [ typeD NoIDP (tpstr)
                                        , text " "
                                        , case _exp_val of
                                            ErrVal -> row' [text' NoIDP ("-- No value"++autoLStr)]
                                                               `withbgColor` lightGrey
                                            v      -> row' [ text' NoIDP ("-- Value: " ++ show _exp_val++autoLStr)]
                                                               `withbgColor` lightGrey
                                        ]
                                   ]
                      else [empty])
                        ++
                           [ _ident_pres, key (mkIDP _idP0 _lhs_pIdC 0) "="]
                        ++ (if _expanded then
                              [ _exp_pres,  sep (mkIDP _idP1 _lhs_pIdC 1) ";"
                              ] else [text " ", box (text "...") `withColor` black `withbgColor` yellow
                                                                 `withMouseDown` expand _lhs_path _self])
                       ) `addPopupItems`  [ if _expanded then ( "Collapse: "++strFromIdent _ident_self, toggleExpanded _lhs_path _self)
                                                         else ( "Expand: "++strFromIdent _ident_self, toggleExpanded _lhs_path _self)]
                         `addPopupItems`  if _lhs_level == 0 then [ if _autoLayout then ( "Disable Auto Layout", toggleAutoLayout _lhs_path _self)
                                                                                   else ( "Enable Auto Layout", toggleAutoLayout _lhs_path _self) ]
                                                             else []
             ,presentElementTree _lhs_focusD (DeclNode _self _lhs_path) _lhs_path "Decl" [ presentPrimTreeBool _expanded, presentPrimTreeBool _autoLayout, _ident_presTree, _exp_presTree ]
             ,presentElementXML _lhs_focusD (DeclNode _self _lhs_path) _lhs_path "Decl" [ presentPrimXMLBool _expanded, presentPrimXMLBool _autoLayout, _ident_presXML, _exp_presXML ]
             ,_self
             ,_lhs_col
             ,_typeStr
             ,_exp_varsInScopeAtFocus
             )
sem_Decl_HoleDecl :: (T_Decl)
sem_Decl_HoleDecl  =
    \ _lhs_col
      _lhs_env
      _lhs_errs
      _lhs_focusD
      _lhs_ix
      _lhs_layoutMap
      _lhs_level
      _lhs_newlines
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_spaces
      _lhs_topLevelEnv
      _lhs_typeEnv
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                HoleDecl
            (_typeStr) =
                Nothing
        in  ( _lhs_col,("XXXXXX", ErrVal),[],presHole _lhs_focusD "Decl" (HoleDeclNode _self _lhs_path) _lhs_path,_lhs_layoutMap,_lhs_newlines,_lhs_pIdC,presHole _lhs_focusD "Decl" (HoleDeclNode _self _lhs_path) _lhs_path,presHole _lhs_focusD "Decl" (HoleDeclNode _self _lhs_path) _lhs_path,presHole _lhs_focusD "Decl" (HoleDeclNode _self _lhs_path) _lhs_path,_self,_lhs_spaces,_typeStr,_lhs_varsInScopeAtFocus)
sem_Decl_PPPresentationDecl :: (IDD) ->
                               (IDP) ->
                               (IDP) ->
                               (T_PPPresentation) ->
                               (T_Decl)
sem_Decl_PPPresentationDecl (_idD) (_idP0) (_idP1) (_pPPresentation) =
    \ _lhs_col
      _lhs_env
      _lhs_errs
      _lhs_focusD
      _lhs_ix
      _lhs_layoutMap
      _lhs_level
      _lhs_newlines
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_spaces
      _lhs_topLevelEnv
      _lhs_typeEnv
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                PPPresentationDecl _idD _idP0 _idP1 _pPPresentation_self
            (_typeStr) =
                Nothing
            ( _pPPresentation_pIdC,_pPPresentation_pres,_pPPresentation_presTree,_pPPresentation_presXML,_pPPresentation_self,_pPPresentation_varsInScopeAtFocus) =
                (_pPPresentation (_lhs_focusD) (_lhs_ix) (_lhs_pIdC + 2) (_lhs_path++[0]) (_lhs_ranges) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus))
        in  ( _lhs_col
             ,("XXXXXX", ErrVal)
             ,[]
             ,loc (PPPresentationDeclNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
                row' [ text "slides;" ]
             ,_lhs_layoutMap
             ,_lhs_newlines
             ,_pPPresentation_pIdC
             ,loc (PPPresentationDeclNode _self _lhs_path) $ parsing $ presentFocus _lhs_focusD _lhs_path $
                row' [ text' (mkIDP _idP0 _lhs_pIdC 0) "PPT: ", _pPPresentation_pres ]
             ,presentElementTree _lhs_focusD (PPPresentationDeclNode _self _lhs_path) _lhs_path "PPPresentationDecl" [ _pPPresentation_presTree ]
             ,presentElementXML _lhs_focusD (PPPresentationDeclNode _self _lhs_path) _lhs_path "PPPresentationDecl" [ _pPPresentation_presXML ]
             ,_self
             ,_lhs_spaces
             ,_typeStr
             ,_pPPresentation_varsInScopeAtFocus
             )
sem_Decl_ParseErrDecl :: (Node) ->
                         (Presentation) ->
                         (T_Decl)
sem_Decl_ParseErrDecl (_node) (_presentation) =
    \ _lhs_col
      _lhs_env
      _lhs_errs
      _lhs_focusD
      _lhs_ix
      _lhs_layoutMap
      _lhs_level
      _lhs_newlines
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_spaces
      _lhs_topLevelEnv
      _lhs_typeEnv
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                ParseErrDecl _node _presentation
            (_typeStr) =
                Nothing
        in  ( _lhs_col,("XXXXXX", ErrVal),[],presParseErr _node _presentation,_lhs_layoutMap,_lhs_newlines,_lhs_pIdC,presParseErr _node _presentation,presParseErr _node _presentation,presParseErr _node _presentation,_self,_lhs_spaces,_typeStr,_lhs_varsInScopeAtFocus)
-- EnrichedDoc -------------------------------------------------
{-
   inherited attributes:
      focusD               : FocusDoc

   chained attributes:
      layoutMap            : LayoutMap
      pIdC                 : Int

   synthesised attributes:
      pres                 : Presentation
      self                 : SELF

-}
{-
   local variables for EnrichedDoc.HoleEnrichedDoc:
      self

-}
{-
   local variables for EnrichedDoc.ParseErrEnrichedDoc:
      self

-}
{-
   local variables for EnrichedDoc.RootEnr:
      varsInScope
      topLevelEnv
      typeEnv
      errs
      self

-}
-- semantic domain
type T_EnrichedDoc = (FocusDoc) ->
                     (LayoutMap) ->
                     (Int) ->
                     ( (LayoutMap),(Int),(Presentation),(EnrichedDoc))
-- cata
sem_EnrichedDoc :: (EnrichedDoc) ->
                   (T_EnrichedDoc)
sem_EnrichedDoc ((HoleEnrichedDoc )) =
    (sem_EnrichedDoc_HoleEnrichedDoc )
sem_EnrichedDoc ((ParseErrEnrichedDoc (_node) (_presentation))) =
    (sem_EnrichedDoc_ParseErrEnrichedDoc (_node) (_presentation))
sem_EnrichedDoc ((RootEnr (_id) (_idP) (_idListDecls) (_decls) (_heliumTypeInfo) (_document))) =
    (sem_EnrichedDoc_RootEnr (_id) (_idP) ((sem_List_Decl (_idListDecls))) ((sem_List_Decl (_decls))) (_heliumTypeInfo) (_document))
sem_EnrichedDoc_HoleEnrichedDoc :: (T_EnrichedDoc)
sem_EnrichedDoc_HoleEnrichedDoc  =
    \ _lhs_focusD
      _lhs_layoutMap
      _lhs_pIdC ->
        let (_self) =
                HoleEnrichedDoc
        in  ( _lhs_layoutMap,_lhs_pIdC,presHole _lhs_focusD "EnrichedDoc" (HoleEnrichedDocNode _self []) [],_self)
sem_EnrichedDoc_ParseErrEnrichedDoc :: (Node) ->
                                       (Presentation) ->
                                       (T_EnrichedDoc)
sem_EnrichedDoc_ParseErrEnrichedDoc (_node) (_presentation) =
    \ _lhs_focusD
      _lhs_layoutMap
      _lhs_pIdC ->
        let (_self) =
                ParseErrEnrichedDoc _node _presentation
        in  ( _lhs_layoutMap,_lhs_pIdC,presParseErr _node _presentation,_self)
sem_EnrichedDoc_RootEnr :: (IDD) ->
                           (IDP) ->
                           (T_List_Decl) ->
                           (T_List_Decl) ->
                           (HeliumTypeInfo) ->
                           (Document) ->
                           (T_EnrichedDoc)
sem_EnrichedDoc_RootEnr (_id) (_idP) (_idListDecls) (_decls) (_heliumTypeInfo) (_document) =
    \ _lhs_focusD
      _lhs_layoutMap
      _lhs_pIdC ->
        let (_self) =
                RootEnr _id _idP _idListDecls_self _decls_self _heliumTypeInfo _document
            (_errs) =
                let (errs, typeEnv, topLevelEnv) = _heliumTypeInfo in errs
            (_typeEnv) =
                let (errs, typeEnv, topLevelEnv) = _heliumTypeInfo in topLevelEnv
            (_topLevelEnv) =
                let (errs, typeEnv, topLevelEnv) = _heliumTypeInfo in typeEnv
            (_varsInScope) =
                listToFM _decls_declaredVars
            ( _idListDecls_col,_idListDecls_dcls,_idListDecls_declaredVars,_idListDecls_idsPres,_idListDecls_layoutMap,_idListDecls_newlines,_idListDecls_pIdC,_idListDecls_parseErrs,_idListDecls_pres,_idListDecls_presTree,_idListDecls_presXML,_idListDecls_press,_idListDecls_self,_idListDecls_spaces,_idListDecls_varsInScopeAtFocus) =
                (_idListDecls (0) ([]) ([]) (_lhs_focusD) (_lhs_layoutMap) (0) (0) (_lhs_pIdC + 4) ([]) (([],[],[])) (0) (_topLevelEnv) (_typeEnv) (_varsInScope) (emptyFM))
            ( _decls_col,_decls_dcls,_decls_declaredVars,_decls_idsPres,_decls_layoutMap,_decls_newlines,_decls_pIdC,_decls_parseErrs,_decls_pres,_decls_presTree,_decls_presXML,_decls_press,_decls_self,_decls_spaces,_decls_varsInScopeAtFocus) =
                (_decls (0)
                        (_decls_dcls)
                        (_errs)
                        (_lhs_focusD)
                        (_lhs_layoutMap)
                        (0)
                        (1)
                        (_idListDecls_pIdC)
                        ([])
                        ((\(l1,l2,l3)->(concat l1, concat l2, concat l3)) . unzip3
                         $ map pthFrmMsg _errs)
                        (0)
                        (_topLevelEnv)
                        (_typeEnv)
                        (_varsInScope)
                        (emptyFM))
        in  ( _decls_layoutMap
             ,_decls_pIdC
             ,loc (RootDocNode _document []) $
              loc (RootEnrNode _self []) $ structural $
                col [ row' [ hSpace 3
                           , text $ "Document focus: "++show _lhs_focusD
                           , typeD NoIDP $ ( case lookup _lhs_focusD _typeEnv of
                                              Nothing -> ""
                                              Just tp -> " :: "++tp)
                                            ++ replicate 80 ' '
                           ]
                    , vSpace 4
                    , hLine
                    , row' [ hSpace 3
                           , text "Top level identifiers:"
                           , row[ text " ", _idListDecls_idsPres] `withFontSize` 10
                           ]
                    , vSpace 4
                    , structural $ row [ hSpace 3, box $ row [  hSpace 3, _decls_presTree, text "   ", vLine, text "   ", _decls_presXML `withFont'` ("Courier New",8), hSpace 3]]
                    , vSpace 14
                    , row' [ hSpace 3, key NoIDP "module ", bold $ text "Main" , key NoIDP " where"]
                    , row' [ hSpace 3, _decls_pres ]
                    , vSpace 10
                    , hLine
                    , vSpace 4
                    , let errs = if null _decls_parseErrs then _errs else map toMessage _decls_parseErrs
                      in  col' (map presMessage errs ++ [empty]) `withFontSize` 12
                    , vSpace 10
                    , hLine
                    , vSpace 4
                    , text "Variables in scope:"
                    , col [ typeD NoIDP (var++" :: "++tpStr) `link` pth
                          | (var,(pth,tpStr)) <- fmToList _decls_varsInScopeAtFocus ]
                    ]
                  `withFont'` ("Courier New",14)
             ,_self
             )
-- Exp ---------------------------------------------------------
{-
   inherited attributes:
      env                  : Bindings
      errs                 : [HeliumMessage]
      focusD               : FocusDoc
      ix                   : Int
      level                : Int
      path                 : [Int]
      ranges               : ([PathDoc],[PathDoc],[PathDoc])
      topLevelEnv          : [(String, String)]
      typeEnv              : [(PathDoc,String)]
      varsInScope          : FiniteMap String (PathDoc, String)

   chained attributes:
      col                  : Int
      layoutMap            : LayoutMap
      newlines             : Int
      pIdC                 : Int
      spaces               : Int
      varsInScopeAtFocus   : FiniteMap String (PathDoc, String)

   synthesised attributes:
      lamBody              : ([(String, Exp)] -> Exp)
      pres                 : Presentation
      presTree             : Presentation
      presXML              : Presentation
      self                 : SELF
      substitute           : ( [(String, Exp)] -> Exp )
      type                 : String
      val                  : Value

-}
{-
   local variables for Exp.AppExp:
      substitute
      reductionEdit
      type
      self

-}
{-
   local variables for Exp.BoolExp:
      substitute
      reductionEdit
      type
      self

-}
{-
   local variables for Exp.CaseExp:
      substitute
      reductionEdit
      type
      self

-}
{-
   local variables for Exp.DivExp:
      substitute
      reductionEdit
      type
      self

-}
{-
   local variables for Exp.HoleExp:
      substitute
      type
      self

-}
{-
   local variables for Exp.IdentExp:
      substitute
      reductionEdit
      type
      self

-}
{-
   local variables for Exp.IfExp:
      substitute
      reductionEdit
      type
      self

-}
{-
   local variables for Exp.IntExp:
      substitute
      reductionEdit
      type
      self

-}
{-
   local variables for Exp.LamExp:
      substitute
      reductionEdit
      type
      self

-}
{-
   local variables for Exp.LetExp:
      substitute
      reductionEdit
      type
      varsInScope
      self

-}
{-
   local variables for Exp.ListExp:
      substitute
      reductionEdit
      type
      self

-}
{-
   local variables for Exp.ParenExp:
      substitute
      reductionEdit
      type
      self

-}
{-
   local variables for Exp.ParseErrExp:
      substitute
      type
      self

-}
{-
   local variables for Exp.PlusExp:
      substitute
      reductionEdit
      type
      self

-}
{-
   local variables for Exp.PowerExp:
      substitute
      reductionEdit
      type
      self

-}
{-
   local variables for Exp.ProductExp:
      substitute
      reductionEdit
      type
      self

-}
{-
   local variables for Exp.TimesExp:
      substitute
      reductionEdit
      type
      self

-}
-- semantic domain
type T_Exp = (Int) ->
             (Bindings) ->
             ([HeliumMessage]) ->
             (FocusDoc) ->
             (Int) ->
             (LayoutMap) ->
             (Int) ->
             (Int) ->
             (Int) ->
             ([Int]) ->
             (([PathDoc],[PathDoc],[PathDoc])) ->
             (Int) ->
             ([(String, String)]) ->
             ([(PathDoc,String)]) ->
             (FiniteMap String (PathDoc, String)) ->
             (FiniteMap String (PathDoc, String)) ->
             ( (Int),(([(String, Exp)] -> Exp)),(LayoutMap),(Int),(Int),(Presentation),(Presentation),(Presentation),(Exp),(Int),(( [(String, Exp)] -> Exp )),(String),(Value),(FiniteMap String (PathDoc, String)))
-- cata
sem_Exp :: (Exp) ->
           (T_Exp)
sem_Exp ((AppExp (_idD) (_exp1) (_exp2))) =
    (sem_Exp_AppExp (_idD) ((sem_Exp (_exp1))) ((sem_Exp (_exp2))))
sem_Exp ((BoolExp (_idD) (_idP0) (_bool))) =
    (sem_Exp_BoolExp (_idD) (_idP0) (_bool))
sem_Exp ((CaseExp (_idD) (_idP0) (_idP1) (_exp) (_alts))) =
    (sem_Exp_CaseExp (_idD) (_idP0) (_idP1) ((sem_Exp (_exp))) ((sem_List_Alt (_alts))))
sem_Exp ((DivExp (_idD) (_idP0) (_exp1) (_exp2))) =
    (sem_Exp_DivExp (_idD) (_idP0) ((sem_Exp (_exp1))) ((sem_Exp (_exp2))))
sem_Exp ((HoleExp )) =
    (sem_Exp_HoleExp )
sem_Exp ((IdentExp (_idd) (_ident))) =
    (sem_Exp_IdentExp (_idd) ((sem_Ident (_ident))))
sem_Exp ((IfExp (_idD) (_idP0) (_idP1) (_idP2) (_exp1) (_exp2) (_exp3))) =
    (sem_Exp_IfExp (_idD) (_idP0) (_idP1) (_idP2) ((sem_Exp (_exp1))) ((sem_Exp (_exp2))) ((sem_Exp (_exp3))))
sem_Exp ((IntExp (_idD) (_idP0) (_int))) =
    (sem_Exp_IntExp (_idD) (_idP0) (_int))
sem_Exp ((LamExp (_idD) (_idP0) (_idP1) (_ident) (_exp))) =
    (sem_Exp_LamExp (_idD) (_idP0) (_idP1) ((sem_Ident (_ident))) ((sem_Exp (_exp))))
sem_Exp ((LetExp (_idD) (_idP0) (_idP1) (_decls) (_exp))) =
    (sem_Exp_LetExp (_idD) (_idP0) (_idP1) ((sem_List_Decl (_decls))) ((sem_Exp (_exp))))
sem_Exp ((ListExp (_idD) (_idP0) (_idP1) (_ids) (_exps))) =
    (sem_Exp_ListExp (_idD) (_idP0) (_idP1) (_ids) ((sem_List_Exp (_exps))))
sem_Exp ((ParenExp (_idD) (_idP0) (_idP1) (_exp))) =
    (sem_Exp_ParenExp (_idD) (_idP0) (_idP1) ((sem_Exp (_exp))))
sem_Exp ((ParseErrExp (_node) (_presentation))) =
    (sem_Exp_ParseErrExp (_node) (_presentation))
sem_Exp ((PlusExp (_idD) (_idP0) (_exp1) (_exp2))) =
    (sem_Exp_PlusExp (_idD) (_idP0) ((sem_Exp (_exp1))) ((sem_Exp (_exp2))))
sem_Exp ((PowerExp (_idD) (_idP0) (_exp1) (_exp2))) =
    (sem_Exp_PowerExp (_idD) (_idP0) ((sem_Exp (_exp1))) ((sem_Exp (_exp2))))
sem_Exp ((ProductExp (_idD) (_idP0) (_idP1) (_ids) (_exps))) =
    (sem_Exp_ProductExp (_idD) (_idP0) (_idP1) (_ids) ((sem_List_Exp (_exps))))
sem_Exp ((TimesExp (_idD) (_idP0) (_exp1) (_exp2))) =
    (sem_Exp_TimesExp (_idD) (_idP0) ((sem_Exp (_exp1))) ((sem_Exp (_exp2))))
sem_Exp_AppExp :: (IDD) ->
                  (T_Exp) ->
                  (T_Exp) ->
                  (T_Exp)
sem_Exp_AppExp (_idD) (_exp1) (_exp2) =
    \ _lhs_col
      _lhs_env
      _lhs_errs
      _lhs_focusD
      _lhs_ix
      _lhs_layoutMap
      _lhs_level
      _lhs_newlines
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_spaces
      _lhs_topLevelEnv
      _lhs_typeEnv
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                AppExp _idD _exp1_self _exp2_self
            (_type) =
                lookupType _lhs_typeEnv _lhs_path
            (_reductionEdit) =
                case removeParens _exp1_self of
                        LamExp _ _ _ ident exp -> [ ("Beta reduce",
                                                     pasteExp _lhs_path
                                                              (ensureParens (_exp1_lamBody [(strFromIdent ident, _exp2_self)] ))
                                                    )
                                                  ]
                        _                      -> []
            (_substitute) =
                \substs -> AppExp _idD (_exp1_substitute substs) (_exp2_substitute substs)
            ( _exp1_col,_exp1_lamBody,_exp1_layoutMap,_exp1_newlines,_exp1_pIdC,_exp1_pres,_exp1_presTree,_exp1_presXML,_exp1_self,_exp1_spaces,_exp1_substitute,_exp1_type,_exp1_val,_exp1_varsInScopeAtFocus) =
                (_exp1 (_lhs_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_ix) (_lhs_layoutMap) (_lhs_level) (_lhs_newlines) (_lhs_pIdC + 0) (_lhs_path++[0]) (_lhs_ranges) (_lhs_spaces) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (if (PathD _lhs_path) == _lhs_focusD then _lhs_varsInScope else _lhs_varsInScopeAtFocus))
            ( _exp2_col,_exp2_lamBody,_exp2_layoutMap,_exp2_newlines,_exp2_pIdC,_exp2_pres,_exp2_presTree,_exp2_presXML,_exp2_self,_exp2_spaces,_exp2_substitute,_exp2_type,_exp2_val,_exp2_varsInScopeAtFocus) =
                (_exp2 (_exp1_col+1) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_ix) (_exp1_layoutMap) (_lhs_level) (0) (_exp1_pIdC) (_lhs_path++[1]) (_lhs_ranges) (1) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_exp1_varsInScopeAtFocus))
        in  ( _lhs_col
             ,_substitute
             ,_exp2_layoutMap
             ,_exp2_newlines
             ,_exp2_pIdC
             ,loc (AppExpNode _self _lhs_path) $ parsing $ presentFocus _lhs_focusD _lhs_path $
                squiggleRanges _lhs_ranges _lhs_path $ addReductionPopupItems _reductionEdit $
                row' [_exp1_pres, _exp2_pres]
             ,presentElementTree _lhs_focusD (AppExpNode _self _lhs_path) _lhs_path "AppExp" [ _exp1_presTree, _exp2_presTree ]
             ,presentElementXML _lhs_focusD (AppExpNode _self _lhs_path) _lhs_path "AppExp" [ _exp1_presXML, _exp2_presXML ]
             ,_self
             ,_exp2_spaces
             ,_substitute
             ,_type
             ,case _exp1_val of LamVal f -> f _exp2_val
                                _        -> ErrVal
             ,_exp2_varsInScopeAtFocus
             )
sem_Exp_BoolExp :: (IDD) ->
                   (IDP) ->
                   (Bool) ->
                   (T_Exp)
sem_Exp_BoolExp (_idD) (_idP0) (_bool) =
    \ _lhs_col
      _lhs_env
      _lhs_errs
      _lhs_focusD
      _lhs_ix
      _lhs_layoutMap
      _lhs_level
      _lhs_newlines
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_spaces
      _lhs_topLevelEnv
      _lhs_typeEnv
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                BoolExp _idD _idP0 _bool
            (_type) =
                lookupType _lhs_typeEnv _lhs_path
            (_reductionEdit) =
                []
            (_substitute) =
                \substs -> _self
        in  ( _lhs_col
             ,_substitute
             ,addToFM _lhs_layoutMap _idP0 (_lhs_newlines,_lhs_spaces)
             ,_lhs_newlines
             ,_lhs_pIdC
             ,loc (BoolExpNode _self _lhs_path) $ parsing $ presentFocus _lhs_focusD _lhs_path $
                squiggleRanges _lhs_ranges _lhs_path $ addReductionPopupItems _reductionEdit $
                row' [cons (mkIDP _idP0 _lhs_pIdC 0) (show _bool), text' NoIDP ""]
             ,presentElementTree _lhs_focusD (BoolExpNode _self _lhs_path) _lhs_path "BoolExp" [ presentPrimTreeBool _bool ]
             ,presentElementXML _lhs_focusD (BoolExpNode _self _lhs_path) _lhs_path "BoolExp" [ presentPrimXMLBool _bool ]
             ,_self
             ,_lhs_spaces
             ,_substitute
             ,_type
             ,BoolVal _bool
             ,if (PathD _lhs_path) == _lhs_focusD then _lhs_varsInScope else _lhs_varsInScopeAtFocus
             )
sem_Exp_CaseExp :: (IDD) ->
                   (IDP) ->
                   (IDP) ->
                   (T_Exp) ->
                   (T_List_Alt) ->
                   (T_Exp)
sem_Exp_CaseExp (_idD) (_idP0) (_idP1) (_exp) (_alts) =
    \ _lhs_col
      _lhs_env
      _lhs_errs
      _lhs_focusD
      _lhs_ix
      _lhs_layoutMap
      _lhs_level
      _lhs_newlines
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_spaces
      _lhs_topLevelEnv
      _lhs_typeEnv
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                CaseExp _idD _idP0 _idP1 _exp_self _alts_self
            (_type) =
                lookupType _lhs_typeEnv _lhs_path
            (_reductionEdit) =
                []
            (_substitute) =
                \substs -> _self
            ( _exp_col,_exp_lamBody,_exp_layoutMap,_exp_newlines,_exp_pIdC,_exp_pres,_exp_presTree,_exp_presXML,_exp_self,_exp_spaces,_exp_substitute,_exp_type,_exp_val,_exp_varsInScopeAtFocus) =
                (_exp (_lhs_col + 5)
                      (_lhs_env)
                      (_lhs_errs)
                      (_lhs_focusD)
                      (_lhs_ix)
                      (addListToFM _lhs_layoutMap
                           [ (_idP0, (_lhs_newlines,_lhs_spaces))
                           , (_idP1, (0,1)) ])
                      (_lhs_level)
                      (0)
                      (_lhs_pIdC + 2)
                      (_lhs_path++[0])
                      (_lhs_ranges)
                      (1)
                      (_lhs_topLevelEnv)
                      (_lhs_typeEnv)
                      (_lhs_varsInScope)
                      (_lhs_varsInScopeAtFocus))
            ( _alts_alts,_alts_col,_alts_layoutMap,_alts_maxLHSLength,_alts_newlines,_alts_pIdC,_alts_presTree,_alts_presXML,_alts_press,_alts_self,_alts_spaces,_alts_varsInScopeAtFocus) =
                (_alts (_lhs_col + 2) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_exp_layoutMap) (_lhs_level) (1) (_exp_pIdC) (_lhs_path++[1]) (_lhs_ranges) (_lhs_col + 2) (_lhs_topLevelEnv) (_alts_maxLHSLength) (_lhs_typeEnv) (_lhs_varsInScope) (if (PathD _lhs_path) == _lhs_focusD then _lhs_varsInScope else _lhs_varsInScopeAtFocus))
        in  ( _alts_col
             ,_substitute
             ,_alts_layoutMap
             ,_alts_newlines
             ,_alts_pIdC
             ,loc (CaseExpNode _self _lhs_path) $ parsing $ presentFocus _lhs_focusD _lhs_path $
                squiggleRanges _lhs_ranges _lhs_path $ addReductionPopupItems _reductionEdit $
                row' [ key (mkIDP _idP0 _lhs_pIdC 0) "case"
                     , _exp_pres
                     , key (mkIDP _idP1 _lhs_pIdC 1) "of"
                     , loc (List_AltNode _alts_self []                ) $ parsing $ presentFocus _lhs_focusD []                $ row _alts_press
                     ]
             ,presentElementTree _lhs_focusD (CaseExpNode _self _lhs_path) _lhs_path "CaseExp" [ _exp_presTree, _alts_presTree ]
             ,presentElementXML _lhs_focusD (CaseExpNode _self _lhs_path) _lhs_path "CaseExp" [ _exp_presXML, _alts_presXML ]
             ,_self
             ,_alts_spaces
             ,_substitute
             ,_type
             ,case lookup "a" _alts_alts of {Just v -> v; Nothing -> ErrVal}
             ,_alts_varsInScopeAtFocus
             )
sem_Exp_DivExp :: (IDD) ->
                  (IDP) ->
                  (T_Exp) ->
                  (T_Exp) ->
                  (T_Exp)
sem_Exp_DivExp (_idD) (_idP0) (_exp1) (_exp2) =
    \ _lhs_col
      _lhs_env
      _lhs_errs
      _lhs_focusD
      _lhs_ix
      _lhs_layoutMap
      _lhs_level
      _lhs_newlines
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_spaces
      _lhs_topLevelEnv
      _lhs_typeEnv
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                DivExp _idD _idP0 _exp1_self _exp2_self
            (_type) =
                lookupType _lhs_typeEnv _lhs_path
            (_reductionEdit) =
                case (removeParens _exp1_self, removeParens _exp2_self) of
                       (IntExp idd1 idp1 int1, IntExp _ _ int2 ) -> [ ("Reduce primitive div" ,  pasteExp _lhs_path (IntExp idd1 idp1 (int1 `div` int2)))]
                       _                                         -> []
            (_substitute) =
                \substs -> DivExp _idD _idP0 (_exp1_substitute substs) (_exp2_substitute substs)
            ( _exp1_col,_exp1_lamBody,_exp1_layoutMap,_exp1_newlines,_exp1_pIdC,_exp1_pres,_exp1_presTree,_exp1_presXML,_exp1_self,_exp1_spaces,_exp1_substitute,_exp1_type,_exp1_val,_exp1_varsInScopeAtFocus) =
                (_exp1 (0) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_ix) (addToFM _lhs_layoutMap _idP0 (0,0)) (_lhs_level) (0) (_lhs_pIdC + 1) (_lhs_path++[0]) (_lhs_ranges) (0) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (if (PathD _lhs_path) == _lhs_focusD then _lhs_varsInScope else _lhs_varsInScopeAtFocus))
            ( _exp2_col,_exp2_lamBody,_exp2_layoutMap,_exp2_newlines,_exp2_pIdC,_exp2_pres,_exp2_presTree,_exp2_presXML,_exp2_self,_exp2_spaces,_exp2_substitute,_exp2_type,_exp2_val,_exp2_varsInScopeAtFocus) =
                (_exp2 (0) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_ix) (_exp1_layoutMap) (_lhs_level) (0) (_exp1_pIdC) (_lhs_path++[1]) (_lhs_ranges) (0) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_exp1_varsInScopeAtFocus))
        in  ( _exp1_col
             ,_substitute
             ,_exp2_layoutMap
             ,_exp2_newlines
             ,_exp2_pIdC
             ,loc (DivExpNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
                squiggleRanges _lhs_ranges _lhs_path $ addReductionPopupItems _reductionEdit $
                frac _exp1_pres _exp2_pres
             ,presentElementTree _lhs_focusD (DivExpNode _self _lhs_path) _lhs_path "DivExp" [ _exp1_presTree, _exp2_presTree ]
             ,presentElementXML _lhs_focusD (DivExpNode _self _lhs_path) _lhs_path "DivExp" [ _exp1_presXML, _exp2_presXML ]
             ,_self
             ,_exp2_spaces
             ,_substitute
             ,_type
             ,evaluateIntOp div _exp1_val _exp2_val
             ,_exp2_varsInScopeAtFocus
             )
sem_Exp_HoleExp :: (T_Exp)
sem_Exp_HoleExp  =
    \ _lhs_col
      _lhs_env
      _lhs_errs
      _lhs_focusD
      _lhs_ix
      _lhs_layoutMap
      _lhs_level
      _lhs_newlines
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_spaces
      _lhs_topLevelEnv
      _lhs_typeEnv
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                HoleExp
            (_type) =
                "<Hole>"
            (_substitute) =
                \substs -> _self
        in  ( _lhs_col,_substitute,_lhs_layoutMap,_lhs_newlines,_lhs_pIdC,presHole _lhs_focusD "Exp" (HoleExpNode _self _lhs_path) _lhs_path,presHole _lhs_focusD "Exp" (HoleExpNode _self _lhs_path) _lhs_path,presHole _lhs_focusD "Exp" (HoleExpNode _self _lhs_path) _lhs_path,_self,_lhs_spaces,_substitute,_type,ErrVal,_lhs_varsInScopeAtFocus)
sem_Exp_IdentExp :: (IDD) ->
                    (T_Ident) ->
                    (T_Exp)
sem_Exp_IdentExp (_idd) (_ident) =
    \ _lhs_col
      _lhs_env
      _lhs_errs
      _lhs_focusD
      _lhs_ix
      _lhs_layoutMap
      _lhs_level
      _lhs_newlines
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_spaces
      _lhs_topLevelEnv
      _lhs_typeEnv
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                IdentExp _idd _ident_self
            (_type) =
                lookupType _lhs_typeEnv _lhs_path
            (_reductionEdit) =
                case lookupFM  _lhs_varsInScope (strFromIdent _ident_self) of
                  Nothing      -> []
                  Just (PathD pth@(_:_),_) ->
                    [( "Replace by definition"
                     , \(DocumentLevel d path cl) ->
                       case selectD (init pth) d of
                         (Clip_Decl (Decl idD idP0 idP1 idP2 idP3 _ _ _ exp)) ->
                               let (DocumentLevel d' _ _) =
                                     editPasteD (DocumentLevel d (PathD _lhs_path) (Clip_Exp ( setIDPExp (idP0FromIdent _ident_self) $ ensureParens exp)))
                               in  (DocumentLevel d' path cl)
                         _ -> (DocumentLevel d path cl)
                     )]
            (_substitute) =
                \substs -> case lookup (strFromIdent _ident_self) substs of
                                   Just exp -> exp
                                   Nothing  -> _self
            ( _ident_col,_ident_firstToken,_ident_idsPres,_ident_layoutMap,_ident_newlines,_ident_pIdC,_ident_pres,_ident_presTree,_ident_presXML,_ident_self,_ident_spaces,_ident_str,_ident_varsInScopeAtFocus) =
                (_ident (_lhs_col) (_lhs_focusD) (_lhs_ix) (_lhs_layoutMap) (_lhs_level) (_lhs_newlines) (_lhs_pIdC + 0) (_lhs_path++[0]) (_lhs_ranges) (_lhs_spaces) (_lhs_varsInScope) (if (PathD _lhs_path) == _lhs_focusD then _lhs_varsInScope else _lhs_varsInScopeAtFocus))
        in  ( _ident_col
             ,_substitute
             ,_ident_layoutMap
             ,_ident_newlines
             ,_ident_pIdC
             ,loc (IdentExpNode _self _lhs_path) $ parsing $ presentFocus _lhs_focusD _lhs_path $
                squiggleRanges _lhs_ranges _lhs_path $ addReductionPopupItems _reductionEdit $
                  _ident_pres
                    `addPopupItems`
                    [( "Jump to declaration of "++show (strFromIdent _ident_self),
                          navigateTo $ case lookupFM  _lhs_varsInScope (strFromIdent _ident_self) of
                                         Nothing      -> NoPathD
                                         Just (pth,_) -> pth)]
             ,presentElementTree _lhs_focusD (IdentExpNode _self _lhs_path) _lhs_path "IdentExp" [ _ident_presTree ]
             ,presentElementXML _lhs_focusD (IdentExpNode _self _lhs_path) _lhs_path "IdentExp" [ _ident_presXML ]
             ,_self
             ,_ident_spaces
             ,_substitute
             ,_type
             ,case lookup _ident_str _lhs_env of { Just v -> v; Nothing -> ErrVal }
             ,_ident_varsInScopeAtFocus
             )
sem_Exp_IfExp :: (IDD) ->
                 (IDP) ->
                 (IDP) ->
                 (IDP) ->
                 (T_Exp) ->
                 (T_Exp) ->
                 (T_Exp) ->
                 (T_Exp)
sem_Exp_IfExp (_idD) (_idP0) (_idP1) (_idP2) (_exp1) (_exp2) (_exp3) =
    \ _lhs_col
      _lhs_env
      _lhs_errs
      _lhs_focusD
      _lhs_ix
      _lhs_layoutMap
      _lhs_level
      _lhs_newlines
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_spaces
      _lhs_topLevelEnv
      _lhs_typeEnv
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                IfExp _idD _idP0 _idP1 _idP2 _exp1_self _exp2_self _exp3_self
            (_type) =
                lookupType _lhs_typeEnv _lhs_path
            (_reductionEdit) =
                case removeParens _exp1_self of
                       BoolExp _ _ bool -> [ ("Reduce primitive if" , pasteExp _lhs_path (if bool then setIDPExp _idP0 _exp2_self
                                                                                 else setIDPExp _idP0 _exp3_self))]
                       _                                         -> []
            (_substitute) =
                \substs -> IfExp _idD _idP0 _idP1 _idP2 (_exp1_substitute substs) (_exp2_substitute substs) (_exp3_substitute substs)
            ( _exp1_col,_exp1_lamBody,_exp1_layoutMap,_exp1_newlines,_exp1_pIdC,_exp1_pres,_exp1_presTree,_exp1_presXML,_exp1_self,_exp1_spaces,_exp1_substitute,_exp1_type,_exp1_val,_exp1_varsInScopeAtFocus) =
                (_exp1 (_lhs_col + 2+1)
                       (_lhs_env)
                       (_lhs_errs)
                       (_lhs_focusD)
                       (_lhs_ix)
                       (addListToFM _lhs_layoutMap
                          [ (_idP0, (_lhs_newlines,_lhs_spaces))
                          , (_idP1, (1,_lhs_col))
                          , (_idP2, (1,_lhs_col)) ])
                       (_lhs_level)
                       (0)
                       (_lhs_pIdC + 3)
                       (_lhs_path++[0])
                       (_lhs_ranges)
                       (1)
                       (_lhs_topLevelEnv)
                       (_lhs_typeEnv)
                       (_lhs_varsInScope)
                       (if (PathD _lhs_path) == _lhs_focusD then _lhs_varsInScope else _lhs_varsInScopeAtFocus))
            ( _exp2_col,_exp2_lamBody,_exp2_layoutMap,_exp2_newlines,_exp2_pIdC,_exp2_pres,_exp2_presTree,_exp2_presXML,_exp2_self,_exp2_spaces,_exp2_substitute,_exp2_type,_exp2_val,_exp2_varsInScopeAtFocus) =
                (_exp2 (_lhs_col + 4+1) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_ix) (_exp1_layoutMap) (_lhs_level) (0) (_exp1_pIdC) (_lhs_path++[1]) (_lhs_ranges) (1) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_exp1_varsInScopeAtFocus))
            ( _exp3_col,_exp3_lamBody,_exp3_layoutMap,_exp3_newlines,_exp3_pIdC,_exp3_pres,_exp3_presTree,_exp3_presXML,_exp3_self,_exp3_spaces,_exp3_substitute,_exp3_type,_exp3_val,_exp3_varsInScopeAtFocus) =
                (_exp3 (_lhs_col + 4+1) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_ix) (_exp2_layoutMap) (_lhs_level) (0) (_exp2_pIdC) (_lhs_path++[2]) (_lhs_ranges) (1) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_exp2_varsInScopeAtFocus))
        in  ( _exp3_col
             ,_substitute
             ,_exp3_layoutMap
             ,_exp3_newlines
             ,_exp3_pIdC
             ,loc (IfExpNode _self _lhs_path) $ parsing $ presentFocus _lhs_focusD _lhs_path $
                    squiggleRanges _lhs_ranges _lhs_path $ addReductionPopupItems _reductionEdit $
                row'  $ [ key (mkIDP _idP0 _lhs_pIdC 0) "if",   _exp1_pres
                            , key (mkIDP _idP1 _lhs_pIdC 1) "then", _exp2_pres
                            , key (mkIDP _idP2 _lhs_pIdC 2) "else", _exp3_pres ]
             ,presentElementTree _lhs_focusD (IfExpNode _self _lhs_path) _lhs_path "IfExp" [ _exp1_presTree, _exp2_presTree, _exp3_presTree ]
             ,presentElementXML _lhs_focusD (IfExpNode _self _lhs_path) _lhs_path "IfExp" [ _exp1_presXML, _exp2_presXML, _exp3_presXML ]
             ,_self
             ,_exp3_spaces
             ,_substitute
             ,_type
             ,case _exp1_val of BoolVal b -> if b then _exp2_val else _exp3_val
                                _         -> ErrVal
             ,_exp3_varsInScopeAtFocus
             )
sem_Exp_IntExp :: (IDD) ->
                  (IDP) ->
                  (Int) ->
                  (T_Exp)
sem_Exp_IntExp (_idD) (_idP0) (_int) =
    \ _lhs_col
      _lhs_env
      _lhs_errs
      _lhs_focusD
      _lhs_ix
      _lhs_layoutMap
      _lhs_level
      _lhs_newlines
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_spaces
      _lhs_topLevelEnv
      _lhs_typeEnv
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                IntExp _idD _idP0 _int
            (_type) =
                lookupType _lhs_typeEnv _lhs_path
            (_reductionEdit) =
                []
            (_substitute) =
                \substs -> _self
        in  ( _lhs_col+length (show _int)
             ,_substitute
             ,addToFM _lhs_layoutMap _idP0 (_lhs_newlines,_lhs_spaces)
             ,_lhs_newlines
             ,_lhs_pIdC
             ,loc (IntExpNode _self _lhs_path) $ parsing $ presentFocus _lhs_focusD _lhs_path $
                squiggleRanges _lhs_ranges _lhs_path $ addReductionPopupItems _reductionEdit $
                row' [cons (mkIDP _idP0 _lhs_pIdC 0) (show _int), text' NoIDP ""]
             ,presentElementTree _lhs_focusD (IntExpNode _self _lhs_path) _lhs_path "IntExp" [ presentPrimTreeInt _int ]
             ,presentElementXML _lhs_focusD (IntExpNode _self _lhs_path) _lhs_path "IntExp" [ presentPrimXMLInt _int ]
             ,_self
             ,_lhs_spaces
             ,_substitute
             ,_type
             ,IntVal _int
             ,if (PathD _lhs_path) == _lhs_focusD then _lhs_varsInScope else _lhs_varsInScopeAtFocus
             )
sem_Exp_LamExp :: (IDD) ->
                  (IDP) ->
                  (IDP) ->
                  (T_Ident) ->
                  (T_Exp) ->
                  (T_Exp)
sem_Exp_LamExp (_idD) (_idP0) (_idP1) (_ident) (_exp) =
    \ _lhs_col
      _lhs_env
      _lhs_errs
      _lhs_focusD
      _lhs_ix
      _lhs_layoutMap
      _lhs_level
      _lhs_newlines
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_spaces
      _lhs_topLevelEnv
      _lhs_typeEnv
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                LamExp _idD _idP0 _idP1 _ident_self _exp_self
            (_type) =
                lookupType _lhs_typeEnv _lhs_path
            (_reductionEdit) =
                []
            (_substitute) =
                \substs -> LamExp _idD _idP0 _idP1 _ident_self (_exp_substitute
                                                                 (filter (\(str,_) -> str /= strFromIdent _ident_self)
                                                                         substs))
            ( _ident_col,_ident_firstToken,_ident_idsPres,_ident_layoutMap,_ident_newlines,_ident_pIdC,_ident_pres,_ident_presTree,_ident_presXML,_ident_self,_ident_spaces,_ident_str,_ident_varsInScopeAtFocus) =
                (_ident (_lhs_col + 1)
                        (_lhs_focusD)
                        (_lhs_ix)
                        (addListToFM _lhs_layoutMap
                           [ (_idP0, (_lhs_newlines,_lhs_spaces))
                           , (_idP1, (0,1)) ])
                        (_lhs_level)
                        (0)
                        (_lhs_pIdC + 2)
                        (_lhs_path++[0])
                        (_lhs_ranges)
                        (0)
                        (_lhs_varsInScope)
                        (if (PathD _lhs_path) == _lhs_focusD then _lhs_varsInScope else _lhs_varsInScopeAtFocus))
            ( _exp_col,_exp_lamBody,_exp_layoutMap,_exp_newlines,_exp_pIdC,_exp_pres,_exp_presTree,_exp_presXML,_exp_self,_exp_spaces,_exp_substitute,_exp_type,_exp_val,_exp_varsInScopeAtFocus) =
                (_exp (_ident_col + 3)
                      (_lhs_env)
                      (_lhs_errs)
                      (_lhs_focusD)
                      (_lhs_ix)
                      (_ident_layoutMap)
                      (_lhs_level)
                      (0)
                      (_ident_pIdC)
                      (_lhs_path++[1])
                      (_lhs_ranges)
                      (1)
                      (_lhs_topLevelEnv)
                      (_lhs_typeEnv)
                      (addToFM _lhs_varsInScope (strFromIdent _ident_self)
                                                (PathD $ (_lhs_path++[0]), _exp_type))
                      (_ident_varsInScopeAtFocus))
        in  ( _exp_col
             ,_exp_substitute
             ,_exp_layoutMap
             ,_exp_newlines
             ,_exp_pIdC
             ,loc (LamExpNode _self _lhs_path) $ parsing $ presentFocus _lhs_focusD _lhs_path $
                squiggleRanges _lhs_ranges _lhs_path $ addReductionPopupItems _reductionEdit $
                row' [
                       key (mkIDP _idP0 _lhs_pIdC 0) "\\"
                     , _ident_pres
                     , text' (mkIDP _idP1 _lhs_pIdC 1) ""
                       , key NoIDP "®"    `withFontFam` "symbol"
                     , _exp_pres ]
             ,presentElementTree _lhs_focusD (LamExpNode _self _lhs_path) _lhs_path "LamExp" [ _ident_presTree, _exp_presTree ]
             ,presentElementXML _lhs_focusD (LamExpNode _self _lhs_path) _lhs_path "LamExp" [ _ident_presXML, _exp_presXML ]
             ,_self
             ,_exp_spaces
             ,_substitute
             ,_type
             ,LamVal (\arg ->
                       let (_,_,_,_,_,_,_,_,_,_,_,_,v,_) =
                             _exp undefined ((_ident_str, arg): _lhs_env) undefined undefined undefined undefined undefined undefined undefined undefined undefined undefined undefined undefined undefined undefined
                       in  v)
             ,_exp_varsInScopeAtFocus
             )
sem_Exp_LetExp :: (IDD) ->
                  (IDP) ->
                  (IDP) ->
                  (T_List_Decl) ->
                  (T_Exp) ->
                  (T_Exp)
sem_Exp_LetExp (_idD) (_idP0) (_idP1) (_decls) (_exp) =
    \ _lhs_col
      _lhs_env
      _lhs_errs
      _lhs_focusD
      _lhs_ix
      _lhs_layoutMap
      _lhs_level
      _lhs_newlines
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_spaces
      _lhs_topLevelEnv
      _lhs_typeEnv
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                LetExp _idD _idP0 _idP1 _decls_self _exp_self
            (_varsInScope) =
                addListToFM _lhs_varsInScope _decls_declaredVars
            (_type) =
                lookupType _lhs_typeEnv _lhs_path
            (_reductionEdit) =
                []
            (_substitute) =
                \substs -> _self
            ( _decls_col,_decls_dcls,_decls_declaredVars,_decls_idsPres,_decls_layoutMap,_decls_newlines,_decls_pIdC,_decls_parseErrs,_decls_pres,_decls_presTree,_decls_presXML,_decls_press,_decls_self,_decls_spaces,_decls_varsInScopeAtFocus) =
                (_decls (_lhs_col + 3+1)
                        (_lhs_env)
                        (_lhs_errs)
                        (_lhs_focusD)
                        (addListToFM _lhs_layoutMap
                           [ (_idP0, (_lhs_newlines,_lhs_spaces))
                           , (_idP1, (1,_lhs_col))])
                        (_lhs_level + 1)
                        (0)
                        (_lhs_pIdC + 2)
                        (_lhs_path++[0])
                        (_lhs_ranges)
                        (1)
                        (_lhs_topLevelEnv)
                        (_lhs_typeEnv)
                        (_varsInScope)
                        (if (PathD _lhs_path) == _lhs_focusD then _lhs_varsInScope else _lhs_varsInScopeAtFocus))
            ( _exp_col,_exp_lamBody,_exp_layoutMap,_exp_newlines,_exp_pIdC,_exp_pres,_exp_presTree,_exp_presXML,_exp_self,_exp_spaces,_exp_substitute,_exp_type,_exp_val,_exp_varsInScopeAtFocus) =
                (_exp (_lhs_col + 3+1) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_ix) (_decls_layoutMap) (_lhs_level) (0) (_decls_pIdC) (_lhs_path++[1]) (_lhs_ranges) (2) (_lhs_topLevelEnv) (_lhs_typeEnv) (_varsInScope) (_decls_varsInScopeAtFocus))
        in  ( _exp_col
             ,_substitute
             ,_exp_layoutMap
             ,_exp_newlines
             ,_exp_pIdC
             ,loc (CaseExpNode _self _lhs_path) $ parsing $ presentFocus _lhs_focusD _lhs_path $
                squiggleRanges _lhs_ranges _lhs_path $ addReductionPopupItems _reductionEdit $
                row' [ key (mkIDP _idP0 _lhs_pIdC 0) "let"
                     , loc (List_DeclNode _decls_self []               ) $ parsing $ presentFocus _lhs_focusD []                 $ row _decls_press
                     , key (mkIDP _idP1 _lhs_pIdC 1) "in", _exp_pres ]
             ,presentElementTree _lhs_focusD (LetExpNode _self _lhs_path) _lhs_path "LetExp" [ _decls_presTree, _exp_presTree ]
             ,presentElementXML _lhs_focusD (LetExpNode _self _lhs_path) _lhs_path "LetExp" [ _decls_presXML, _exp_presXML ]
             ,_self
             ,_exp_spaces
             ,_substitute
             ,_type
             ,let (_,_,_,_,_,_,_,_,_,_,_,_,v,_) =
                    _exp undefined (_decls_dcls ++ _lhs_env) undefined undefined undefined undefined undefined undefined undefined undefined undefined undefined undefined undefined undefined undefined
              in  v
             ,_exp_varsInScopeAtFocus
             )
sem_Exp_ListExp :: (IDD) ->
                   (IDP) ->
                   (IDP) ->
                   ([IDP]) ->
                   (T_List_Exp) ->
                   (T_Exp)
sem_Exp_ListExp (_idD) (_idP0) (_idP1) (_ids) (_exps) =
    \ _lhs_col
      _lhs_env
      _lhs_errs
      _lhs_focusD
      _lhs_ix
      _lhs_layoutMap
      _lhs_level
      _lhs_newlines
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_spaces
      _lhs_topLevelEnv
      _lhs_typeEnv
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                ListExp _idD _idP0 _idP1 _ids _exps_self
            (_type) =
                lookupType _lhs_typeEnv _lhs_path
            (_reductionEdit) =
                []
            (_substitute) =
                \substs -> _self
            ( _exps_col,_exps_layoutMap,_exps_newlines,_exps_pIdC,_exps_presTree,_exps_presXML,_exps_press,_exps_self,_exps_spaces,_exps_vals,_exps_varsInScopeAtFocus) =
                (_exps (_lhs_col + 1+1)
                       (_lhs_env)
                       (_lhs_errs)
                       (_lhs_focusD)
                       (addListToFM _lhs_layoutMap
                          [ (_idP0, (_lhs_newlines,_lhs_spaces))
                          , (_idP1, (0,1)) ])
                       (_lhs_level)
                       (0)
                       (_lhs_pIdC + 3)
                       (_lhs_path++[0])
                       (_lhs_ranges)
                       (1)
                       (_lhs_topLevelEnv)
                       (_lhs_typeEnv)
                       (_lhs_varsInScope)
                       (if (PathD _lhs_path) == _lhs_focusD then _lhs_varsInScope else _lhs_varsInScopeAtFocus))
        in  ( _exps_col + 1+1
             ,_substitute
             ,_exps_layoutMap
             ,0
             ,_exps_pIdC
             ,loc (ListExpNode _self _lhs_path) $ parsing $ presentFocus _lhs_focusD _lhs_path $
                squiggleRanges _lhs_ranges _lhs_path $ addReductionPopupItems _reductionEdit $
                row' $    [sep (mkIDP _idP0 _lhs_pIdC 0) "["]
                       ++ let xps = _exps_press
                              sps = map (\id -> sep id ",") (_ids++ map IDP [_lhs_pIdC .. ] )
                          in (if null xps
                              then []
                              else head xps : concat [ [s,e] | (s,e) <- zip sps (tail xps)])
                       ++ [sep (mkIDP _idP1 _lhs_pIdC 1) "]"]
             ,presentElementTree _lhs_focusD (ListExpNode _self _lhs_path) _lhs_path "ListExp" [ _exps_presTree ]
             ,presentElementXML _lhs_focusD (ListExpNode _self _lhs_path) _lhs_path "ListExp" [ _exps_presXML ]
             ,_self
             ,0
             ,_substitute
             ,_type
             ,ListVal _exps_vals
             ,_exps_varsInScopeAtFocus
             )
sem_Exp_ParenExp :: (IDD) ->
                    (IDP) ->
                    (IDP) ->
                    (T_Exp) ->
                    (T_Exp)
sem_Exp_ParenExp (_idD) (_idP0) (_idP1) (_exp) =
    \ _lhs_col
      _lhs_env
      _lhs_errs
      _lhs_focusD
      _lhs_ix
      _lhs_layoutMap
      _lhs_level
      _lhs_newlines
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_spaces
      _lhs_topLevelEnv
      _lhs_typeEnv
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                ParenExp _idD _idP0 _idP1 _exp_self
            (_type) =
                lookupType _lhs_typeEnv _lhs_path
            (_reductionEdit) =
                []
            (_substitute) =
                \substs -> ParenExp _idD _idP0 _idP1 (_exp_substitute substs)
            ( _exp_col,_exp_lamBody,_exp_layoutMap,_exp_newlines,_exp_pIdC,_exp_pres,_exp_presTree,_exp_presXML,_exp_self,_exp_spaces,_exp_substitute,_exp_type,_exp_val,_exp_varsInScopeAtFocus) =
                (_exp (_lhs_col + 1+1)
                      (_lhs_env)
                      (_lhs_errs)
                      (_lhs_focusD)
                      (_lhs_ix)
                      (addListToFM _lhs_layoutMap
                         [ (_idP0, (_lhs_newlines,_lhs_spaces))
                         , (_idP1, (0,1)) ])
                      (_lhs_level)
                      (0)
                      (_lhs_pIdC + 2)
                      (_lhs_path++[0])
                      (_lhs_ranges)
                      (1)
                      (_lhs_topLevelEnv)
                      (_lhs_typeEnv)
                      (_lhs_varsInScope)
                      (if (PathD _lhs_path) == _lhs_focusD then _lhs_varsInScope else _lhs_varsInScopeAtFocus))
        in  ( _exp_col + 1+1
             ,_exp_lamBody
             ,_exp_layoutMap
             ,0
             ,_exp_pIdC
             ,loc (ParenExpNode _self _lhs_path) $ parsing $ presentFocus _lhs_focusD _lhs_path $
                squiggleRanges _lhs_ranges _lhs_path $ addReductionPopupItems _reductionEdit $
                row'  [sep (mkIDP _idP0 _lhs_pIdC 0) "(", _exp_pres , sep (mkIDP _idP1 _lhs_pIdC 1) ")"]
             ,presentElementTree _lhs_focusD (ParenExpNode _self _lhs_path) _lhs_path "ParenExp" [ _exp_presTree ]
             ,presentElementXML _lhs_focusD (ParenExpNode _self _lhs_path) _lhs_path "ParenExp" [ _exp_presXML ]
             ,_self
             ,0
             ,_substitute
             ,_type
             ,_exp_val
             ,_exp_varsInScopeAtFocus
             )
sem_Exp_ParseErrExp :: (Node) ->
                       (Presentation) ->
                       (T_Exp)
sem_Exp_ParseErrExp (_node) (_presentation) =
    \ _lhs_col
      _lhs_env
      _lhs_errs
      _lhs_focusD
      _lhs_ix
      _lhs_layoutMap
      _lhs_level
      _lhs_newlines
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_spaces
      _lhs_topLevelEnv
      _lhs_typeEnv
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                ParseErrExp _node _presentation
            (_type) =
                "<ParseErr>"
            (_substitute) =
                \substs -> _self
        in  ( _lhs_col,_substitute,_lhs_layoutMap,_lhs_newlines,_lhs_pIdC,presParseErr _node _presentation,presParseErr _node _presentation,presParseErr _node _presentation,_self,_lhs_spaces,_substitute,_type,ErrVal,_lhs_varsInScopeAtFocus)
sem_Exp_PlusExp :: (IDD) ->
                   (IDP) ->
                   (T_Exp) ->
                   (T_Exp) ->
                   (T_Exp)
sem_Exp_PlusExp (_idD) (_idP0) (_exp1) (_exp2) =
    \ _lhs_col
      _lhs_env
      _lhs_errs
      _lhs_focusD
      _lhs_ix
      _lhs_layoutMap
      _lhs_level
      _lhs_newlines
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_spaces
      _lhs_topLevelEnv
      _lhs_typeEnv
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                PlusExp _idD _idP0 _exp1_self _exp2_self
            (_type) =
                lookupType _lhs_typeEnv _lhs_path
            (_reductionEdit) =
                case (removeParens _exp1_self, removeParens _exp2_self) of
                       (IntExp idd1 idp1 int1, IntExp _ _ int2 ) -> [ ("Reduce primitive (+)" , pasteExp _lhs_path (IntExp idd1 idp1 (int1+int2)))]
                       _                                         -> []
            (_substitute) =
                \substs -> PlusExp _idD _idP0 (_exp1_substitute substs) (_exp2_substitute substs)
            ( _exp1_col,_exp1_lamBody,_exp1_layoutMap,_exp1_newlines,_exp1_pIdC,_exp1_pres,_exp1_presTree,_exp1_presXML,_exp1_self,_exp1_spaces,_exp1_substitute,_exp1_type,_exp1_val,_exp1_varsInScopeAtFocus) =
                (_exp1 (_lhs_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_ix) (addToFM _lhs_layoutMap _idP0 (0,1)) (_lhs_level) (_lhs_newlines) (_lhs_pIdC + 1) (_lhs_path++[0]) (_lhs_ranges) (_lhs_spaces) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (if (PathD _lhs_path) == _lhs_focusD then _lhs_varsInScope else _lhs_varsInScopeAtFocus))
            ( _exp2_col,_exp2_lamBody,_exp2_layoutMap,_exp2_newlines,_exp2_pIdC,_exp2_pres,_exp2_presTree,_exp2_presXML,_exp2_self,_exp2_spaces,_exp2_substitute,_exp2_type,_exp2_val,_exp2_varsInScopeAtFocus) =
                (_exp2 (_exp1_col + 3) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_ix) (_exp1_layoutMap) (_lhs_level) (0) (_exp1_pIdC) (_lhs_path++[1]) (_lhs_ranges) (1) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_exp1_varsInScopeAtFocus))
        in  ( _exp2_col
             ,_substitute
             ,_exp2_layoutMap
             ,_exp2_newlines
             ,_exp2_pIdC
             ,loc (PlusExpNode _self _lhs_path) $ parsing $ presentFocus _lhs_focusD _lhs_path $
                squiggleRanges _lhs_ranges _lhs_path $ addReductionPopupItems _reductionEdit $
                row' [_exp1_pres , op (mkIDP _idP0 _lhs_pIdC 0) "+", _exp2_pres]
             ,presentElementTree _lhs_focusD (PlusExpNode _self _lhs_path) _lhs_path "PlusExp" [ _exp1_presTree, _exp2_presTree ]
             ,presentElementXML _lhs_focusD (PlusExpNode _self _lhs_path) _lhs_path "PlusExp" [ _exp1_presXML, _exp2_presXML ]
             ,_self
             ,_exp2_spaces
             ,_substitute
             ,_type
             ,evaluateIntOp (+) _exp1_val _exp2_val
             ,_exp2_varsInScopeAtFocus
             )
sem_Exp_PowerExp :: (IDD) ->
                    (IDP) ->
                    (T_Exp) ->
                    (T_Exp) ->
                    (T_Exp)
sem_Exp_PowerExp (_idD) (_idP0) (_exp1) (_exp2) =
    \ _lhs_col
      _lhs_env
      _lhs_errs
      _lhs_focusD
      _lhs_ix
      _lhs_layoutMap
      _lhs_level
      _lhs_newlines
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_spaces
      _lhs_topLevelEnv
      _lhs_typeEnv
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                PowerExp _idD _idP0 _exp1_self _exp2_self
            (_type) =
                lookupType _lhs_typeEnv _lhs_path
            (_reductionEdit) =
                case (removeParens _exp1_self, removeParens _exp2_self) of
                       (IntExp idd1 idp1 int1, IntExp _ _ int2 ) -> [ ("Reduce primitive (^)" , pasteExp _lhs_path (IntExp idd1 idp1 (int1^int2)))]
                       _                                         -> []
            (_substitute) =
                \substs -> PowerExp _idD _idP0 (_exp1_substitute substs) (_exp2_substitute substs)
            ( _exp1_col,_exp1_lamBody,_exp1_layoutMap,_exp1_newlines,_exp1_pIdC,_exp1_pres,_exp1_presTree,_exp1_presXML,_exp1_self,_exp1_spaces,_exp1_substitute,_exp1_type,_exp1_val,_exp1_varsInScopeAtFocus) =
                (_exp1 (_lhs_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_ix) (addToFM _lhs_layoutMap _idP0 (0,0)) (_lhs_level) (_lhs_newlines) (_lhs_pIdC + 1) (_lhs_path++[0]) (_lhs_ranges) (_lhs_spaces) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (if (PathD _lhs_path) == _lhs_focusD then _lhs_varsInScope else _lhs_varsInScopeAtFocus))
            ( _exp2_col,_exp2_lamBody,_exp2_layoutMap,_exp2_newlines,_exp2_pIdC,_exp2_pres,_exp2_presTree,_exp2_presXML,_exp2_self,_exp2_spaces,_exp2_substitute,_exp2_type,_exp2_val,_exp2_varsInScopeAtFocus) =
                (_exp2 (0) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_ix) (_exp1_layoutMap) (_lhs_level) (0) (_exp1_pIdC) (_lhs_path++[1]) (_lhs_ranges) (0) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_exp1_varsInScopeAtFocus))
        in  ( _exp2_col
             ,_substitute
             ,_exp2_layoutMap
             ,_exp2_newlines
             ,_exp2_pIdC
             ,loc (PowerExpNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
                squiggleRanges _lhs_ranges _lhs_path $ addReductionPopupItems _reductionEdit $
                power _exp1_pres _exp2_pres
             ,presentElementTree _lhs_focusD (PowerExpNode _self _lhs_path) _lhs_path "PowerExp" [ _exp1_presTree, _exp2_presTree ]
             ,presentElementXML _lhs_focusD (PowerExpNode _self _lhs_path) _lhs_path "PowerExp" [ _exp1_presXML, _exp2_presXML ]
             ,_self
             ,_exp2_spaces
             ,_substitute
             ,_type
             ,evaluateIntOp (^) _exp1_val _exp2_val
             ,_exp2_varsInScopeAtFocus
             )
sem_Exp_ProductExp :: (IDD) ->
                      (IDP) ->
                      (IDP) ->
                      ([IDP]) ->
                      (T_List_Exp) ->
                      (T_Exp)
sem_Exp_ProductExp (_idD) (_idP0) (_idP1) (_ids) (_exps) =
    \ _lhs_col
      _lhs_env
      _lhs_errs
      _lhs_focusD
      _lhs_ix
      _lhs_layoutMap
      _lhs_level
      _lhs_newlines
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_spaces
      _lhs_topLevelEnv
      _lhs_typeEnv
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                ProductExp _idD _idP0 _idP1 _ids _exps_self
            (_type) =
                lookupType _lhs_typeEnv _lhs_path
            (_reductionEdit) =
                []
            (_substitute) =
                \substs -> _self
            ( _exps_col,_exps_layoutMap,_exps_newlines,_exps_pIdC,_exps_presTree,_exps_presXML,_exps_press,_exps_self,_exps_spaces,_exps_vals,_exps_varsInScopeAtFocus) =
                (_exps (_lhs_col + 1+1)
                       (_lhs_env)
                       (_lhs_errs)
                       (_lhs_focusD)
                       (addListToFM _lhs_layoutMap
                          [ (_idP0, (_lhs_newlines,_lhs_spaces))
                          , (_idP1, (0,1)) ])
                       (_lhs_level)
                       (0)
                       (_lhs_pIdC + 3)
                       (_lhs_path++[0])
                       (_lhs_ranges)
                       (1)
                       (_lhs_topLevelEnv)
                       (_lhs_typeEnv)
                       (_lhs_varsInScope)
                       (if (PathD _lhs_path) == _lhs_focusD then _lhs_varsInScope else _lhs_varsInScopeAtFocus))
        in  ( _exps_col + 1+1
             ,_substitute
             ,_exps_layoutMap
             ,0
             ,_exps_pIdC
             ,loc (ProductExpNode _self _lhs_path) $ parsing $ presentFocus _lhs_focusD _lhs_path $
                squiggleRanges _lhs_ranges _lhs_path $ addReductionPopupItems _reductionEdit $
                row' $    [sep (mkIDP _idP0 _lhs_pIdC 0) "("]
                       ++ let xps = _exps_press
                              sps = map (\id -> sep id ",") (_ids++ map IDP [_lhs_pIdC .. ] )
                          in  if null xps
                              then []
                              else head xps : concat [ [s,e] | (s,e) <- zip sps (tail xps)]
                       ++ [sep (mkIDP _idP1 _lhs_pIdC 1) ")"]
             ,presentElementTree _lhs_focusD (ProductExpNode _self _lhs_path) _lhs_path "ProductExp" [ _exps_presTree ]
             ,presentElementXML _lhs_focusD (ProductExpNode _self _lhs_path) _lhs_path "ProductExp" [ _exps_presXML ]
             ,_self
             ,0
             ,_substitute
             ,_type
             ,ProdVal _exps_vals
             ,_exps_varsInScopeAtFocus
             )
sem_Exp_TimesExp :: (IDD) ->
                    (IDP) ->
                    (T_Exp) ->
                    (T_Exp) ->
                    (T_Exp)
sem_Exp_TimesExp (_idD) (_idP0) (_exp1) (_exp2) =
    \ _lhs_col
      _lhs_env
      _lhs_errs
      _lhs_focusD
      _lhs_ix
      _lhs_layoutMap
      _lhs_level
      _lhs_newlines
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_spaces
      _lhs_topLevelEnv
      _lhs_typeEnv
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                TimesExp _idD _idP0 _exp1_self _exp2_self
            (_type) =
                lookupType _lhs_typeEnv _lhs_path
            (_reductionEdit) =
                case (removeParens _exp1_self, removeParens _exp2_self) of
                       (IntExp idd1 idp1 int1, IntExp _ _ int2 ) -> [ ("Reduce primitive (*)" , pasteExp _lhs_path (IntExp idd1 idp1 (int1*int2)))]
                       _                                         -> []
            (_substitute) =
                \substs -> TimesExp _idD _idP0 (_exp1_substitute substs) (_exp2_substitute substs)
            ( _exp1_col,_exp1_lamBody,_exp1_layoutMap,_exp1_newlines,_exp1_pIdC,_exp1_pres,_exp1_presTree,_exp1_presXML,_exp1_self,_exp1_spaces,_exp1_substitute,_exp1_type,_exp1_val,_exp1_varsInScopeAtFocus) =
                (_exp1 (_lhs_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_ix) (addToFM _lhs_layoutMap _idP0 (0,1)) (_lhs_level) (_lhs_newlines) (_lhs_pIdC + 1) (_lhs_path++[0]) (_lhs_ranges) (_lhs_spaces) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (if (PathD _lhs_path) == _lhs_focusD then _lhs_varsInScope else _lhs_varsInScopeAtFocus))
            ( _exp2_col,_exp2_lamBody,_exp2_layoutMap,_exp2_newlines,_exp2_pIdC,_exp2_pres,_exp2_presTree,_exp2_presXML,_exp2_self,_exp2_spaces,_exp2_substitute,_exp2_type,_exp2_val,_exp2_varsInScopeAtFocus) =
                (_exp2 (_exp1_col + 3) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_ix) (_exp1_layoutMap) (_lhs_level) (0) (_exp1_pIdC) (_lhs_path++[1]) (_lhs_ranges) (1) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_exp1_varsInScopeAtFocus))
        in  ( _exp2_col
             ,_substitute
             ,_exp2_layoutMap
             ,_exp2_newlines
             ,_exp2_pIdC
             ,loc (TimesExpNode _self _lhs_path) $ parsing $ presentFocus _lhs_focusD _lhs_path $
                squiggleRanges _lhs_ranges _lhs_path $ addReductionPopupItems _reductionEdit $
                row' [_exp1_pres , op (mkIDP _idP0 _lhs_pIdC 0) "*", _exp2_pres]
             ,presentElementTree _lhs_focusD (TimesExpNode _self _lhs_path) _lhs_path "TimesExp" [ _exp1_presTree, _exp2_presTree ]
             ,presentElementXML _lhs_focusD (TimesExpNode _self _lhs_path) _lhs_path "TimesExp" [ _exp1_presXML, _exp2_presXML ]
             ,_self
             ,_exp2_spaces
             ,_substitute
             ,_type
             ,evaluateIntOp (*) _exp1_val _exp2_val
             ,_exp2_varsInScopeAtFocus
             )
-- Ident -------------------------------------------------------
{-
   inherited attributes:
      focusD               : FocusDoc
      ix                   : Int
      level                : Int
      path                 : [Int]
      ranges               : ([PathDoc],[PathDoc],[PathDoc])
      varsInScope          : FiniteMap String (PathDoc, String)

   chained attributes:
      col                  : Int
      layoutMap            : LayoutMap
      newlines             : Int
      pIdC                 : Int
      spaces               : Int
      varsInScopeAtFocus   : FiniteMap String (PathDoc, String)

   synthesised attributes:
      firstToken           : IDP
      idsPres              : Presentation
      pres                 : Presentation
      presTree             : Presentation
      presXML              : Presentation
      self                 : SELF
      str                  : String

-}
{-
   local variables for Ident.HoleIdent:
      self

-}
{-
   local variables for Ident.Ident:
      self

-}
{-
   local variables for Ident.ParseErrIdent:
      self

-}
-- semantic domain
type T_Ident = (Int) ->
               (FocusDoc) ->
               (Int) ->
               (LayoutMap) ->
               (Int) ->
               (Int) ->
               (Int) ->
               ([Int]) ->
               (([PathDoc],[PathDoc],[PathDoc])) ->
               (Int) ->
               (FiniteMap String (PathDoc, String)) ->
               (FiniteMap String (PathDoc, String)) ->
               ( (Int),(IDP),(Presentation),(LayoutMap),(Int),(Int),(Presentation),(Presentation),(Presentation),(Ident),(Int),(String),(FiniteMap String (PathDoc, String)))
-- cata
sem_Ident :: (Ident) ->
             (T_Ident)
sem_Ident ((HoleIdent )) =
    (sem_Ident_HoleIdent )
sem_Ident ((Ident (_idD) (_idP0) (_idP1) (_string))) =
    (sem_Ident_Ident (_idD) (_idP0) (_idP1) (_string))
sem_Ident ((ParseErrIdent (_node) (_presentation))) =
    (sem_Ident_ParseErrIdent (_node) (_presentation))
sem_Ident_HoleIdent :: (T_Ident)
sem_Ident_HoleIdent  =
    \ _lhs_col
      _lhs_focusD
      _lhs_ix
      _lhs_layoutMap
      _lhs_level
      _lhs_newlines
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_spaces
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                HoleIdent
        in  ( _lhs_col,NoIDP,presHole _lhs_focusD "Ident" (HoleIdentNode _self _lhs_path) _lhs_path,_lhs_layoutMap,_lhs_newlines,_lhs_pIdC,presHole _lhs_focusD "Ident" (HoleIdentNode _self _lhs_path) _lhs_path,presHole _lhs_focusD "Ident" (HoleIdentNode _self _lhs_path) _lhs_path,presHole _lhs_focusD "Ident" (HoleIdentNode _self _lhs_path) _lhs_path,_self,_lhs_spaces,"",_lhs_varsInScopeAtFocus)
sem_Ident_Ident :: (IDD) ->
                   (IDP) ->
                   (IDP) ->
                   (String) ->
                   (T_Ident)
sem_Ident_Ident (_idD) (_idP0) (_idP1) (_string) =
    \ _lhs_col
      _lhs_focusD
      _lhs_ix
      _lhs_layoutMap
      _lhs_level
      _lhs_newlines
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_spaces
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                Ident _idD _idP0 _idP1 _string
        in  ( _lhs_col+length _string
             ,_idP0
             ,loc (IdentNode _self _lhs_path) $ parsing $ presentFocus _lhs_focusD _lhs_path $
                row' [ text _string ]
             ,addToFM _lhs_layoutMap _idP0 (_lhs_newlines,_lhs_spaces)
             ,_lhs_newlines
             ,_lhs_pIdC
             ,loc (IdentNode _self _lhs_path) $ parsing $ presentFocus _lhs_focusD _lhs_path $
                squiggleRanges _lhs_ranges _lhs_path $
                row' [text' (mkIDP _idP0 _lhs_pIdC 0) _string, text' NoIDP ""]
             ,presentElementTree _lhs_focusD (IdentNode _self _lhs_path) _lhs_path "Ident" [ presentPrimTreeString _string ]
             ,presentElementXML _lhs_focusD (IdentNode _self _lhs_path) _lhs_path "Ident" [ presentPrimXMLString _string ]
             ,_self
             ,_lhs_spaces
             ,_string
             ,if (PathD _lhs_path) == _lhs_focusD then _lhs_varsInScope else _lhs_varsInScopeAtFocus
             )
sem_Ident_ParseErrIdent :: (Node) ->
                           (Presentation) ->
                           (T_Ident)
sem_Ident_ParseErrIdent (_node) (_presentation) =
    \ _lhs_col
      _lhs_focusD
      _lhs_ix
      _lhs_layoutMap
      _lhs_level
      _lhs_newlines
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_spaces
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                ParseErrIdent _node _presentation
        in  ( _lhs_col,NoIDP,presParseErr _node _presentation,_lhs_layoutMap,_lhs_newlines,_lhs_pIdC,presParseErr _node _presentation,presParseErr _node _presentation,presParseErr _node _presentation,_self,_lhs_spaces,"",_lhs_varsInScopeAtFocus)
-- Item --------------------------------------------------------
{-
   inherited attributes:
      focusD               : FocusDoc
      ix                   : Int
      listType             : ListType
      path                 : [Int]
      ranges               : ([PathDoc],[PathDoc],[PathDoc])
      varsInScope          : FiniteMap String (PathDoc, String)

   chained attributes:
      pIdC                 : Int
      varsInScopeAtFocus   : FiniteMap String (PathDoc, String)

   synthesised attributes:
      pres                 : Presentation
      pres2                : Presentation
      presTree             : Presentation
      presXML              : Presentation
      self                 : SELF

-}
{-
   local variables for Item.HeliumItem:
      self

-}
{-
   local variables for Item.HoleItem:
      self

-}
{-
   local variables for Item.ListItem:
      self

-}
{-
   local variables for Item.ParseErrItem:
      self

-}
{-
   local variables for Item.StringItem:
      self

-}
-- semantic domain
type T_Item = (FocusDoc) ->
              (Int) ->
              (ListType) ->
              (Int) ->
              ([Int]) ->
              (([PathDoc],[PathDoc],[PathDoc])) ->
              (FiniteMap String (PathDoc, String)) ->
              (FiniteMap String (PathDoc, String)) ->
              ( (Int),(Presentation),(Presentation),(Presentation),(Presentation),(Item),(FiniteMap String (PathDoc, String)))
-- cata
sem_Item :: (Item) ->
            (T_Item)
sem_Item ((HeliumItem (_idd) (_exp))) =
    (sem_Item_HeliumItem (_idd) ((sem_Exp (_exp))))
sem_Item ((HoleItem )) =
    (sem_Item_HoleItem )
sem_Item ((ListItem (_idd) (_itemList))) =
    (sem_Item_ListItem (_idd) ((sem_ItemList (_itemList))))
sem_Item ((ParseErrItem (_node) (_presentation))) =
    (sem_Item_ParseErrItem (_node) (_presentation))
sem_Item ((StringItem (_idd) (_string))) =
    (sem_Item_StringItem (_idd) ((sem_String_ (_string))))
sem_Item_HeliumItem :: (IDD) ->
                       (T_Exp) ->
                       (T_Item)
sem_Item_HeliumItem (_idd) (_exp) =
    \ _lhs_focusD
      _lhs_ix
      _lhs_listType
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                HeliumItem _idd _exp_self
            ( _exp_col,_exp_lamBody,_exp_layoutMap,_exp_newlines,_exp_pIdC,_exp_pres,_exp_presTree,_exp_presXML,_exp_self,_exp_spaces,_exp_substitute,_exp_type,_exp_val,_exp_varsInScopeAtFocus) =
                (_exp (0) ([]) ([]) (_lhs_focusD) (_lhs_ix) (emptyFM) (0) (0) (_lhs_pIdC + 0) (_lhs_path++[0]) (_lhs_ranges) (0) ([]) ([]) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus))
        in  ( _exp_pIdC
             ,loc (HeliumItemNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
                col' [ text' NoIDP "HeliumItem $"
                     , row [text' NoIDP "  ", _exp_pres]
                     ]
             ,loc (HeliumItemNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
                row' [itemStart _lhs_ix _lhs_listType, _exp_pres
                                                          `withColor` black
                                                          `withbgColor` white
                                                          `withFontFam` "Courier New" ]
             ,presentElementTree _lhs_focusD (HeliumItemNode _self _lhs_path) _lhs_path "HeliumItem" [ _exp_presTree ]
             ,presentElementXML _lhs_focusD (HeliumItemNode _self _lhs_path) _lhs_path "HeliumItem" [ _exp_presXML ]
             ,_self
             ,_exp_varsInScopeAtFocus
             )
sem_Item_HoleItem :: (T_Item)
sem_Item_HoleItem  =
    \ _lhs_focusD
      _lhs_ix
      _lhs_listType
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                HoleItem
        in  ( _lhs_pIdC,presHole _lhs_focusD "Item" (HoleItemNode _self _lhs_path) _lhs_path,presHole _lhs_focusD "Item" (HoleItemNode _self _lhs_path) _lhs_path,presHole _lhs_focusD "Item" (HoleItemNode _self _lhs_path) _lhs_path,presHole _lhs_focusD "Item" (HoleItemNode _self _lhs_path) _lhs_path,_self,_lhs_varsInScopeAtFocus)
sem_Item_ListItem :: (IDD) ->
                     (T_ItemList) ->
                     (T_Item)
sem_Item_ListItem (_idd) (_itemList) =
    \ _lhs_focusD
      _lhs_ix
      _lhs_listType
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                ListItem _idd _itemList_self
            ( _itemList_pIdC,_itemList_pres,_itemList_pres2,_itemList_presTree,_itemList_presXML,_itemList_self,_itemList_varsInScopeAtFocus) =
                (_itemList (_lhs_focusD) (_lhs_ix) (_lhs_pIdC + 0) (_lhs_path++[0]) (_lhs_ranges) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus))
        in  ( _itemList_pIdC
             ,loc (ListItemNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
                col' [ text' NoIDP "ListItem $"
                     , row [text' NoIDP "  ", _itemList_pres]
                     ]
             ,loc (ListItemNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
                row' [ text "   ",
                       _itemList_pres2
                                   `withFontSize_` (\fs -> if fs > 5 then fs * 80 `div` 100 else fs)
                     ]
             ,presentElementTree _lhs_focusD (ListItemNode _self _lhs_path) _lhs_path "ListItem" [ _itemList_presTree ]
             ,presentElementXML _lhs_focusD (ListItemNode _self _lhs_path) _lhs_path "ListItem" [ _itemList_presXML ]
             ,_self
             ,_itemList_varsInScopeAtFocus
             )
sem_Item_ParseErrItem :: (Node) ->
                         (Presentation) ->
                         (T_Item)
sem_Item_ParseErrItem (_node) (_presentation) =
    \ _lhs_focusD
      _lhs_ix
      _lhs_listType
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                ParseErrItem _node _presentation
        in  ( _lhs_pIdC,presParseErr _node _presentation,presParseErr _node _presentation,presParseErr _node _presentation,presParseErr _node _presentation,_self,_lhs_varsInScopeAtFocus)
sem_Item_StringItem :: (IDD) ->
                       (T_String_) ->
                       (T_Item)
sem_Item_StringItem (_idd) (_string) =
    \ _lhs_focusD
      _lhs_ix
      _lhs_listType
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                StringItem _idd _string_self
            ( _string_pIdC,_string_pres,_string_pres2,_string_presTree,_string_presXML,_string_self) =
                (_string (_lhs_focusD) (_lhs_ix) (_lhs_pIdC + 0) (_lhs_path++[0]))
        in  ( _string_pIdC
             ,loc (StringItemNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
                 row' [ text' NoIDP "StringItem ", _string_pres ]
             ,loc (StringItemNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
                row' [itemStart _lhs_ix _lhs_listType, _string_pres2]
             ,presentElementTree _lhs_focusD (StringItemNode _self _lhs_path) _lhs_path "StringItem" [ _string_presTree ]
             ,presentElementXML _lhs_focusD (StringItemNode _self _lhs_path) _lhs_path "StringItem" [ _string_presXML ]
             ,_self
             ,_lhs_varsInScopeAtFocus
             )
-- ItemList ----------------------------------------------------
{-
   inherited attributes:
      focusD               : FocusDoc
      ix                   : Int
      path                 : [Int]
      ranges               : ([PathDoc],[PathDoc],[PathDoc])
      varsInScope          : FiniteMap String (PathDoc, String)

   chained attributes:
      pIdC                 : Int
      varsInScopeAtFocus   : FiniteMap String (PathDoc, String)

   synthesised attributes:
      pres                 : Presentation
      pres2                : Presentation
      presTree             : Presentation
      presXML              : Presentation
      self                 : SELF

-}
{-
   local variables for ItemList.HoleItemList:
      self

-}
{-
   local variables for ItemList.ItemList:
      self

-}
{-
   local variables for ItemList.ParseErrItemList:
      self

-}
-- semantic domain
type T_ItemList = (FocusDoc) ->
                  (Int) ->
                  (Int) ->
                  ([Int]) ->
                  (([PathDoc],[PathDoc],[PathDoc])) ->
                  (FiniteMap String (PathDoc, String)) ->
                  (FiniteMap String (PathDoc, String)) ->
                  ( (Int),(Presentation),(Presentation),(Presentation),(Presentation),(ItemList),(FiniteMap String (PathDoc, String)))
-- cata
sem_ItemList :: (ItemList) ->
                (T_ItemList)
sem_ItemList ((HoleItemList )) =
    (sem_ItemList_HoleItemList )
sem_ItemList ((ItemList (_idd) (_listType) (_items))) =
    (sem_ItemList_ItemList (_idd) ((sem_ListType (_listType))) ((sem_List_Item (_items))))
sem_ItemList ((ParseErrItemList (_node) (_presentation))) =
    (sem_ItemList_ParseErrItemList (_node) (_presentation))
sem_ItemList_HoleItemList :: (T_ItemList)
sem_ItemList_HoleItemList  =
    \ _lhs_focusD
      _lhs_ix
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                HoleItemList
        in  ( _lhs_pIdC,presHole _lhs_focusD "ItemList" (HoleItemListNode _self _lhs_path) _lhs_path,presHole _lhs_focusD "ItemList" (HoleItemListNode _self _lhs_path) _lhs_path,presHole _lhs_focusD "ItemList" (HoleItemListNode _self _lhs_path) _lhs_path,presHole _lhs_focusD "ItemList" (HoleItemListNode _self _lhs_path) _lhs_path,_self,_lhs_varsInScopeAtFocus)
sem_ItemList_ItemList :: (IDD) ->
                         (T_ListType) ->
                         (T_List_Item) ->
                         (T_ItemList)
sem_ItemList_ItemList (_idd) (_listType) (_items) =
    \ _lhs_focusD
      _lhs_ix
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                ItemList _idd _listType_self _items_self
            ( _listType_pIdC,_listType_pres,_listType_pres2,_listType_presTree,_listType_presXML,_listType_self,_listType_varsInScopeAtFocus) =
                (_listType (_lhs_focusD) (_lhs_ix) (_lhs_pIdC + 0) (_lhs_path++[0]) (_lhs_ranges) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus))
            ( _items_pIdC,_items_pres,_items_pres2,_items_presTree,_items_presXML,_items_press,_items_press2,_items_self,_items_varsInScopeAtFocus) =
                (_items (_lhs_focusD) (_listType_self) (_listType_pIdC) (_lhs_path++[1]) (_lhs_ranges) (_lhs_varsInScope) (_listType_varsInScopeAtFocus))
        in  ( _items_pIdC
             ,loc (ItemListNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
                col' [ row' [ text' NoIDP "ItemList ", _listType_pres, text' NoIDP " $"]
                     , _items_pres
                  ]
             ,loc (ItemListNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
                row' [
                       _listType_pres2
                     , _items_pres2
                     ]
             ,presentElementTree _lhs_focusD (ItemListNode _self _lhs_path) _lhs_path "ItemList" [ _listType_presTree, _items_presTree ]
             ,presentElementXML _lhs_focusD (ItemListNode _self _lhs_path) _lhs_path "ItemList" [ _listType_presXML, _items_presXML ]
             ,_self
             ,_items_varsInScopeAtFocus
             )
sem_ItemList_ParseErrItemList :: (Node) ->
                                 (Presentation) ->
                                 (T_ItemList)
sem_ItemList_ParseErrItemList (_node) (_presentation) =
    \ _lhs_focusD
      _lhs_ix
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                ParseErrItemList _node _presentation
        in  ( _lhs_pIdC,presParseErr _node _presentation,presParseErr _node _presentation,presParseErr _node _presentation,presParseErr _node _presentation,_self,_lhs_varsInScopeAtFocus)
-- ListType ----------------------------------------------------
{-
   inherited attributes:
      focusD               : FocusDoc
      ix                   : Int
      path                 : [Int]
      ranges               : ([PathDoc],[PathDoc],[PathDoc])
      varsInScope          : FiniteMap String (PathDoc, String)

   chained attributes:
      pIdC                 : Int
      varsInScopeAtFocus   : FiniteMap String (PathDoc, String)

   synthesised attributes:
      pres                 : Presentation
      pres2                : Presentation
      presTree             : Presentation
      presXML              : Presentation
      self                 : SELF

-}
{-
   local variables for ListType.Alpha:
      self

-}
{-
   local variables for ListType.Bullet:
      self

-}
{-
   local variables for ListType.HoleListType:
      self

-}
{-
   local variables for ListType.Number:
      self

-}
{-
   local variables for ListType.ParseErrListType:
      self

-}
-- semantic domain
type T_ListType = (FocusDoc) ->
                  (Int) ->
                  (Int) ->
                  ([Int]) ->
                  (([PathDoc],[PathDoc],[PathDoc])) ->
                  (FiniteMap String (PathDoc, String)) ->
                  (FiniteMap String (PathDoc, String)) ->
                  ( (Int),(Presentation),(Presentation),(Presentation),(Presentation),(ListType),(FiniteMap String (PathDoc, String)))
-- cata
sem_ListType :: (ListType) ->
                (T_ListType)
sem_ListType ((Alpha (_idd))) =
    (sem_ListType_Alpha (_idd))
sem_ListType ((Bullet (_idd))) =
    (sem_ListType_Bullet (_idd))
sem_ListType ((HoleListType )) =
    (sem_ListType_HoleListType )
sem_ListType ((Number (_idd))) =
    (sem_ListType_Number (_idd))
sem_ListType ((ParseErrListType (_node) (_presentation))) =
    (sem_ListType_ParseErrListType (_node) (_presentation))
sem_ListType_Alpha :: (IDD) ->
                      (T_ListType)
sem_ListType_Alpha (_idd) =
    \ _lhs_focusD
      _lhs_ix
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                Alpha _idd
        in  ( _lhs_pIdC
             ,loc (AlphaNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
                text' NoIDP "Alpha"
             ,loc (AlphaNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
               empty
             ,presentElementTree _lhs_focusD (AlphaNode _self _lhs_path) _lhs_path "Alpha" [  ]
             ,presentElementXML _lhs_focusD (AlphaNode _self _lhs_path) _lhs_path "Alpha" [  ]
             ,_self
             ,_lhs_varsInScopeAtFocus
             )
sem_ListType_Bullet :: (IDD) ->
                       (T_ListType)
sem_ListType_Bullet (_idd) =
    \ _lhs_focusD
      _lhs_ix
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                Bullet _idd
        in  ( _lhs_pIdC
             ,loc (BulletNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
                text' NoIDP "Bullet"
             ,loc (BulletNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
               empty
             ,presentElementTree _lhs_focusD (BulletNode _self _lhs_path) _lhs_path "Bullet" [  ]
             ,presentElementXML _lhs_focusD (BulletNode _self _lhs_path) _lhs_path "Bullet" [  ]
             ,_self
             ,_lhs_varsInScopeAtFocus
             )
sem_ListType_HoleListType :: (T_ListType)
sem_ListType_HoleListType  =
    \ _lhs_focusD
      _lhs_ix
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                HoleListType
        in  ( _lhs_pIdC,presHole _lhs_focusD "ListType" (HoleListTypeNode _self _lhs_path) _lhs_path,presHole _lhs_focusD "ListType" (HoleListTypeNode _self _lhs_path) _lhs_path,presHole _lhs_focusD "ListType" (HoleListTypeNode _self _lhs_path) _lhs_path,presHole _lhs_focusD "ListType" (HoleListTypeNode _self _lhs_path) _lhs_path,_self,_lhs_varsInScopeAtFocus)
sem_ListType_Number :: (IDD) ->
                       (T_ListType)
sem_ListType_Number (_idd) =
    \ _lhs_focusD
      _lhs_ix
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                Number _idd
        in  ( _lhs_pIdC
             ,loc (NumberNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
                text' NoIDP "Number"
             ,loc (NumberNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
               empty
             ,presentElementTree _lhs_focusD (NumberNode _self _lhs_path) _lhs_path "Number" [  ]
             ,presentElementXML _lhs_focusD (NumberNode _self _lhs_path) _lhs_path "Number" [  ]
             ,_self
             ,_lhs_varsInScopeAtFocus
             )
sem_ListType_ParseErrListType :: (Node) ->
                                 (Presentation) ->
                                 (T_ListType)
sem_ListType_ParseErrListType (_node) (_presentation) =
    \ _lhs_focusD
      _lhs_ix
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                ParseErrListType _node _presentation
        in  ( _lhs_pIdC,presParseErr _node _presentation,presParseErr _node _presentation,presParseErr _node _presentation,presParseErr _node _presentation,_self,_lhs_varsInScopeAtFocus)
-- List_Alt ----------------------------------------------------
{-
   inherited attributes:
      env                  : Bindings
      errs                 : [HeliumMessage]
      focusD               : FocusDoc
      level                : Int
      path                 : [Int]
      ranges               : ([PathDoc],[PathDoc],[PathDoc])
      topLevelEnv          : [(String, String)]
      totalMaxLHSLength    : Int
      typeEnv              : [(PathDoc,String)]
      varsInScope          : FiniteMap String (PathDoc, String)

   chained attributes:
      col                  : Int
      layoutMap            : LayoutMap
      newlines             : Int
      pIdC                 : Int
      spaces               : Int
      varsInScopeAtFocus   : FiniteMap String (PathDoc, String)

   synthesised attributes:
      alts                 : Bindings
      maxLHSLength         : Int
      presTree             : Presentation
      presXML              : Presentation
      press                : [Presentation]
      self                 : SELF

-}
{-
   local variables for List_Alt.HoleList_Alt:
      self

-}
{-
   local variables for List_Alt.List_Alt:
      self

-}
{-
   local variables for List_Alt.ParseErrList_Alt:
      self

-}
-- semantic domain
type T_List_Alt = (Int) ->
                  (Bindings) ->
                  ([HeliumMessage]) ->
                  (FocusDoc) ->
                  (LayoutMap) ->
                  (Int) ->
                  (Int) ->
                  (Int) ->
                  ([Int]) ->
                  (([PathDoc],[PathDoc],[PathDoc])) ->
                  (Int) ->
                  ([(String, String)]) ->
                  (Int) ->
                  ([(PathDoc,String)]) ->
                  (FiniteMap String (PathDoc, String)) ->
                  (FiniteMap String (PathDoc, String)) ->
                  ( (Bindings),(Int),(LayoutMap),(Int),(Int),(Int),(Presentation),(Presentation),([Presentation]),(List_Alt),(Int),(FiniteMap String (PathDoc, String)))
-- cata
sem_List_Alt :: (List_Alt) ->
                (T_List_Alt)
sem_List_Alt ((HoleList_Alt )) =
    (sem_List_Alt_HoleList_Alt )
sem_List_Alt ((List_Alt (_idd) (_elts))) =
    (sem_List_Alt_List_Alt (_idd) ((sem_ConsList_Alt (_elts))))
sem_List_Alt ((ParseErrList_Alt (_node) (_presentation))) =
    (sem_List_Alt_ParseErrList_Alt (_node) (_presentation))
sem_List_Alt_HoleList_Alt :: (T_List_Alt)
sem_List_Alt_HoleList_Alt  =
    \ _lhs_col
      _lhs_env
      _lhs_errs
      _lhs_focusD
      _lhs_layoutMap
      _lhs_level
      _lhs_newlines
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_spaces
      _lhs_topLevelEnv
      _lhs_totalMaxLHSLength
      _lhs_typeEnv
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                HoleList_Alt
        in  ( []
             ,_lhs_col
             ,_lhs_layoutMap
             ,0
             ,_lhs_newlines
             ,_lhs_pIdC
             ,loc (List_AltNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
                presHole _lhs_focusD "List_Alt" (HoleList_AltNode _self _lhs_path) _lhs_path
             ,loc (List_AltNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
              presHole _lhs_focusD "List_Alt" (HoleList_AltNode _self _lhs_path) _lhs_path
             ,[]
             ,_self
             ,_lhs_spaces
             ,_lhs_varsInScopeAtFocus
             )
sem_List_Alt_List_Alt :: (IDD) ->
                         (T_ConsList_Alt) ->
                         (T_List_Alt)
sem_List_Alt_List_Alt (_idd) (_elts) =
    \ _lhs_col
      _lhs_env
      _lhs_errs
      _lhs_focusD
      _lhs_layoutMap
      _lhs_level
      _lhs_newlines
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_spaces
      _lhs_topLevelEnv
      _lhs_totalMaxLHSLength
      _lhs_typeEnv
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                List_Alt _idd _elts_self
            ( _elts_alts,_elts_col,_elts_layoutMap,_elts_maxLHSLength,_elts_newlines,_elts_pIdC,_elts_press,_elts_pressTree,_elts_pressXML,_elts_self,_elts_spaces,_elts_varsInScopeAtFocus) =
                (_elts (_lhs_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (0) (_lhs_layoutMap) (_lhs_level) (_lhs_newlines) (_lhs_pIdC + 100) (_lhs_path) (_lhs_ranges) (_lhs_spaces) (_lhs_topLevelEnv) (_lhs_totalMaxLHSLength) (_lhs_typeEnv) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus))
        in  ( _elts_alts
             ,_elts_col
             ,_elts_layoutMap
             ,_elts_maxLHSLength
             ,_elts_newlines
             ,_elts_pIdC
             ,loc (List_AltNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
                col _elts_pressTree
             ,loc (List_AltNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
              col _elts_pressXML
             ,map ( loc (List_AltNode _self _lhs_path)
                  . presentFocus _lhs_focusD _lhs_path )
                  _elts_press
             ,_self
             ,_elts_spaces
             ,_elts_varsInScopeAtFocus
             )
sem_List_Alt_ParseErrList_Alt :: (Node) ->
                                 (Presentation) ->
                                 (T_List_Alt)
sem_List_Alt_ParseErrList_Alt (_node) (_presentation) =
    \ _lhs_col
      _lhs_env
      _lhs_errs
      _lhs_focusD
      _lhs_layoutMap
      _lhs_level
      _lhs_newlines
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_spaces
      _lhs_topLevelEnv
      _lhs_totalMaxLHSLength
      _lhs_typeEnv
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                ParseErrList_Alt _node _presentation
        in  ( []
             ,_lhs_col
             ,_lhs_layoutMap
             ,0
             ,_lhs_newlines
             ,_lhs_pIdC
             ,loc (List_AltNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
                presParseErr _node _presentation
             ,loc (List_AltNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
              presParseErr _node _presentation
             ,[ presParseErr _node _presentation ]
             ,_self
             ,_lhs_spaces
             ,_lhs_varsInScopeAtFocus
             )
-- List_Decl ---------------------------------------------------
{-
   inherited attributes:
      env                  : Bindings
      errs                 : [HeliumMessage]
      focusD               : FocusDoc
      level                : Int
      path                 : [Int]
      ranges               : ([PathDoc],[PathDoc],[PathDoc])
      topLevelEnv          : [(String, String)]
      typeEnv              : [(PathDoc,String)]
      varsInScope          : FiniteMap String (PathDoc, String)

   chained attributes:
      col                  : Int
      layoutMap            : LayoutMap
      newlines             : Int
      pIdC                 : Int
      spaces               : Int
      varsInScopeAtFocus   : FiniteMap String (PathDoc, String)

   synthesised attributes:
      dcls                 : Bindings
      declaredVars         : [(String,(PathDoc,String))]
      idsPres              : Presentation
      parseErrs            : [String]
      pres                 : Presentation
      presTree             : Presentation
      presXML              : Presentation
      press                : [Presentation]
      self                 : SELF

-}
{-
   local variables for List_Decl.HoleList_Decl:
      self

-}
{-
   local variables for List_Decl.List_Decl:
      self

-}
{-
   local variables for List_Decl.ParseErrList_Decl:
      self

-}
-- semantic domain
type T_List_Decl = (Int) ->
                   (Bindings) ->
                   ([HeliumMessage]) ->
                   (FocusDoc) ->
                   (LayoutMap) ->
                   (Int) ->
                   (Int) ->
                   (Int) ->
                   ([Int]) ->
                   (([PathDoc],[PathDoc],[PathDoc])) ->
                   (Int) ->
                   ([(String, String)]) ->
                   ([(PathDoc,String)]) ->
                   (FiniteMap String (PathDoc, String)) ->
                   (FiniteMap String (PathDoc, String)) ->
                   ( (Int),(Bindings),([(String,(PathDoc,String))]),(Presentation),(LayoutMap),(Int),(Int),([String]),(Presentation),(Presentation),(Presentation),([Presentation]),(List_Decl),(Int),(FiniteMap String (PathDoc, String)))
-- cata
sem_List_Decl :: (List_Decl) ->
                 (T_List_Decl)
sem_List_Decl ((HoleList_Decl )) =
    (sem_List_Decl_HoleList_Decl )
sem_List_Decl ((List_Decl (_idd) (_elts))) =
    (sem_List_Decl_List_Decl (_idd) ((sem_ConsList_Decl (_elts))))
sem_List_Decl ((ParseErrList_Decl (_node) (_presentation))) =
    (sem_List_Decl_ParseErrList_Decl (_node) (_presentation))
sem_List_Decl_HoleList_Decl :: (T_List_Decl)
sem_List_Decl_HoleList_Decl  =
    \ _lhs_col
      _lhs_env
      _lhs_errs
      _lhs_focusD
      _lhs_layoutMap
      _lhs_level
      _lhs_newlines
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_spaces
      _lhs_topLevelEnv
      _lhs_typeEnv
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                HoleList_Decl
        in  ( _lhs_col
             ,[]
             ,[]
             ,presHole _lhs_focusD "Decls" (HoleList_DeclNode _self _lhs_path) _lhs_path
             ,_lhs_layoutMap
             ,_lhs_newlines
             ,_lhs_pIdC
             ,[]
             ,loc (List_DeclNode _self _lhs_path) $ parsing $ presentFocus _lhs_focusD _lhs_path $
                presHole _lhs_focusD "Decls" (HoleList_DeclNode _self _lhs_path) _lhs_path
             ,loc (List_DeclNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
                presHole _lhs_focusD "List_Decl" (HoleList_DeclNode _self _lhs_path) _lhs_path
             ,loc (List_DeclNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
              presHole _lhs_focusD "List_Decl" (HoleList_DeclNode _self _lhs_path) _lhs_path
             ,[]
             ,_self
             ,_lhs_spaces
             ,_lhs_varsInScopeAtFocus
             )
sem_List_Decl_List_Decl :: (IDD) ->
                           (T_ConsList_Decl) ->
                           (T_List_Decl)
sem_List_Decl_List_Decl (_idd) (_elts) =
    \ _lhs_col
      _lhs_env
      _lhs_errs
      _lhs_focusD
      _lhs_layoutMap
      _lhs_level
      _lhs_newlines
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_spaces
      _lhs_topLevelEnv
      _lhs_typeEnv
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                List_Decl _idd _elts_self
            ( _elts_col,_elts_dcls,_elts_declaredVars,_elts_idsPres,_elts_layoutMap,_elts_newlines,_elts_pIdC,_elts_parseErrs,_elts_press,_elts_pressTree,_elts_pressXML,_elts_self,_elts_spaces,_elts_varsInScopeAtFocus) =
                (_elts (_lhs_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (0) (_lhs_layoutMap) (_lhs_level) (_lhs_newlines) (_lhs_pIdC + 100) (_lhs_path) (_lhs_ranges) (_lhs_spaces) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus))
        in  ( _elts_col
             ,_elts_dcls
             ,_elts_declaredVars
             ,loc (List_DeclNode _self _lhs_path) $ parsing $ presentFocus _lhs_focusD _lhs_path $
              _elts_idsPres
             ,_elts_layoutMap
             ,_elts_newlines
             ,_elts_pIdC
             ,_elts_parseErrs
             ,loc (List_DeclNode _self _lhs_path) $ parsing $ presentFocus _lhs_focusD _lhs_path $
                row _elts_press
             ,loc (List_DeclNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
                col _elts_pressTree
             ,loc (List_DeclNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
              col _elts_pressXML
             ,map ( loc (List_DeclNode _self _lhs_path)
                  . presentFocus _lhs_focusD _lhs_path )
                  _elts_press
             ,_self
             ,_elts_spaces
             ,_elts_varsInScopeAtFocus
             )
sem_List_Decl_ParseErrList_Decl :: (Node) ->
                                   (Presentation) ->
                                   (T_List_Decl)
sem_List_Decl_ParseErrList_Decl (_node) (_presentation) =
    \ _lhs_col
      _lhs_env
      _lhs_errs
      _lhs_focusD
      _lhs_layoutMap
      _lhs_level
      _lhs_newlines
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_spaces
      _lhs_topLevelEnv
      _lhs_typeEnv
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                ParseErrList_Decl _node _presentation
        in  ( _lhs_col
             ,[]
             ,[]
             ,empty
             ,_lhs_layoutMap
             ,_lhs_newlines
             ,_lhs_pIdC
             ,[]
             ,loc (List_DeclNode _self _lhs_path) $ parsing $ presentFocus _lhs_focusD _lhs_path $
                presParseErr _node _presentation
             ,loc (List_DeclNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
                presParseErr _node _presentation
             ,loc (List_DeclNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
              presParseErr _node _presentation
             ,[ presParseErr _node _presentation ]
             ,_self
             ,_lhs_spaces
             ,_lhs_varsInScopeAtFocus
             )
-- List_Exp ----------------------------------------------------
{-
   inherited attributes:
      env                  : Bindings
      errs                 : [HeliumMessage]
      focusD               : FocusDoc
      level                : Int
      path                 : [Int]
      ranges               : ([PathDoc],[PathDoc],[PathDoc])
      topLevelEnv          : [(String, String)]
      typeEnv              : [(PathDoc,String)]
      varsInScope          : FiniteMap String (PathDoc, String)

   chained attributes:
      col                  : Int
      layoutMap            : LayoutMap
      newlines             : Int
      pIdC                 : Int
      spaces               : Int
      varsInScopeAtFocus   : FiniteMap String (PathDoc, String)

   synthesised attributes:
      presTree             : Presentation
      presXML              : Presentation
      press                : [Presentation]
      self                 : SELF
      vals                 : [Value]

-}
{-
   local variables for List_Exp.HoleList_Exp:
      self

-}
{-
   local variables for List_Exp.List_Exp:
      self

-}
{-
   local variables for List_Exp.ParseErrList_Exp:
      self

-}
-- semantic domain
type T_List_Exp = (Int) ->
                  (Bindings) ->
                  ([HeliumMessage]) ->
                  (FocusDoc) ->
                  (LayoutMap) ->
                  (Int) ->
                  (Int) ->
                  (Int) ->
                  ([Int]) ->
                  (([PathDoc],[PathDoc],[PathDoc])) ->
                  (Int) ->
                  ([(String, String)]) ->
                  ([(PathDoc,String)]) ->
                  (FiniteMap String (PathDoc, String)) ->
                  (FiniteMap String (PathDoc, String)) ->
                  ( (Int),(LayoutMap),(Int),(Int),(Presentation),(Presentation),([Presentation]),(List_Exp),(Int),([Value]),(FiniteMap String (PathDoc, String)))
-- cata
sem_List_Exp :: (List_Exp) ->
                (T_List_Exp)
sem_List_Exp ((HoleList_Exp )) =
    (sem_List_Exp_HoleList_Exp )
sem_List_Exp ((List_Exp (_idd) (_elts))) =
    (sem_List_Exp_List_Exp (_idd) ((sem_ConsList_Exp (_elts))))
sem_List_Exp ((ParseErrList_Exp (_node) (_presentation))) =
    (sem_List_Exp_ParseErrList_Exp (_node) (_presentation))
sem_List_Exp_HoleList_Exp :: (T_List_Exp)
sem_List_Exp_HoleList_Exp  =
    \ _lhs_col
      _lhs_env
      _lhs_errs
      _lhs_focusD
      _lhs_layoutMap
      _lhs_level
      _lhs_newlines
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_spaces
      _lhs_topLevelEnv
      _lhs_typeEnv
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                HoleList_Exp
        in  ( _lhs_col
             ,_lhs_layoutMap
             ,_lhs_newlines
             ,_lhs_pIdC
             ,loc (List_ExpNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
                presHole _lhs_focusD "List_Exp" (HoleList_ExpNode _self _lhs_path) _lhs_path
             ,loc (List_ExpNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
              presHole _lhs_focusD "List_Exp" (HoleList_ExpNode _self _lhs_path) _lhs_path
             ,[]
             ,_self
             ,_lhs_spaces
             ,[]
             ,_lhs_varsInScopeAtFocus
             )
sem_List_Exp_List_Exp :: (IDD) ->
                         (T_ConsList_Exp) ->
                         (T_List_Exp)
sem_List_Exp_List_Exp (_idd) (_elts) =
    \ _lhs_col
      _lhs_env
      _lhs_errs
      _lhs_focusD
      _lhs_layoutMap
      _lhs_level
      _lhs_newlines
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_spaces
      _lhs_topLevelEnv
      _lhs_typeEnv
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                List_Exp _idd _elts_self
            ( _elts_col,_elts_layoutMap,_elts_newlines,_elts_pIdC,_elts_press,_elts_pressTree,_elts_pressXML,_elts_self,_elts_spaces,_elts_vals,_elts_varsInScopeAtFocus) =
                (_elts (_lhs_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (0) (_lhs_layoutMap) (_lhs_level) (_lhs_newlines) (_lhs_pIdC + 100) (_lhs_path) (_lhs_ranges) (_lhs_spaces) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus))
        in  ( _elts_col
             ,_elts_layoutMap
             ,_elts_newlines
             ,_elts_pIdC
             ,loc (List_ExpNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
                col _elts_pressTree
             ,loc (List_ExpNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
              col _elts_pressXML
             ,map ( loc (List_ExpNode _self _lhs_path)
                  . presentFocus _lhs_focusD _lhs_path )
                  _elts_press
             ,_self
             ,_elts_spaces
             ,_elts_vals
             ,_elts_varsInScopeAtFocus
             )
sem_List_Exp_ParseErrList_Exp :: (Node) ->
                                 (Presentation) ->
                                 (T_List_Exp)
sem_List_Exp_ParseErrList_Exp (_node) (_presentation) =
    \ _lhs_col
      _lhs_env
      _lhs_errs
      _lhs_focusD
      _lhs_layoutMap
      _lhs_level
      _lhs_newlines
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_spaces
      _lhs_topLevelEnv
      _lhs_typeEnv
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                ParseErrList_Exp _node _presentation
        in  ( _lhs_col
             ,_lhs_layoutMap
             ,_lhs_newlines
             ,_lhs_pIdC
             ,loc (List_ExpNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
                presParseErr _node _presentation
             ,loc (List_ExpNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
              presParseErr _node _presentation
             ,[ presParseErr _node _presentation ]
             ,_self
             ,_lhs_spaces
             ,[]
             ,_lhs_varsInScopeAtFocus
             )
-- List_Item ---------------------------------------------------
{-
   inherited attributes:
      focusD               : FocusDoc
      listType             : ListType
      path                 : [Int]
      ranges               : ([PathDoc],[PathDoc],[PathDoc])
      varsInScope          : FiniteMap String (PathDoc, String)

   chained attributes:
      pIdC                 : Int
      varsInScopeAtFocus   : FiniteMap String (PathDoc, String)

   synthesised attributes:
      pres                 : Presentation
      pres2                : Presentation
      presTree             : Presentation
      presXML              : Presentation
      press                : [Presentation]
      press2               : [Presentation]
      self                 : SELF

-}
{-
   local variables for List_Item.HoleList_Item:
      self

-}
{-
   local variables for List_Item.List_Item:
      self

-}
{-
   local variables for List_Item.ParseErrList_Item:
      self

-}
-- semantic domain
type T_List_Item = (FocusDoc) ->
                   (ListType) ->
                   (Int) ->
                   ([Int]) ->
                   (([PathDoc],[PathDoc],[PathDoc])) ->
                   (FiniteMap String (PathDoc, String)) ->
                   (FiniteMap String (PathDoc, String)) ->
                   ( (Int),(Presentation),(Presentation),(Presentation),(Presentation),([Presentation]),([Presentation]),(List_Item),(FiniteMap String (PathDoc, String)))
-- cata
sem_List_Item :: (List_Item) ->
                 (T_List_Item)
sem_List_Item ((HoleList_Item )) =
    (sem_List_Item_HoleList_Item )
sem_List_Item ((List_Item (_idd) (_elts))) =
    (sem_List_Item_List_Item (_idd) ((sem_ConsList_Item (_elts))))
sem_List_Item ((ParseErrList_Item (_node) (_presentation))) =
    (sem_List_Item_ParseErrList_Item (_node) (_presentation))
sem_List_Item_HoleList_Item :: (T_List_Item)
sem_List_Item_HoleList_Item  =
    \ _lhs_focusD
      _lhs_listType
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                HoleList_Item
        in  ( _lhs_pIdC
             ,loc (List_ItemNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
                presHole _lhs_focusD "Items" (HoleList_ItemNode _self _lhs_path) _lhs_path
             ,loc (List_ItemNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
               presHole _lhs_focusD "Items" (HoleList_ItemNode _self _lhs_path) _lhs_path
             ,loc (List_ItemNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
                presHole _lhs_focusD "List_Item" (HoleList_ItemNode _self _lhs_path) _lhs_path
             ,loc (List_ItemNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
              presHole _lhs_focusD "List_Item" (HoleList_ItemNode _self _lhs_path) _lhs_path
             ,[]
             ,[presHole _lhs_focusD "Items" (HoleList_ItemNode _self _lhs_path) _lhs_path]
             ,_self
             ,_lhs_varsInScopeAtFocus
             )
sem_List_Item_List_Item :: (IDD) ->
                           (T_ConsList_Item) ->
                           (T_List_Item)
sem_List_Item_List_Item (_idd) (_elts) =
    \ _lhs_focusD
      _lhs_listType
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                List_Item _idd _elts_self
            ( _elts_pIdC,_elts_press,_elts_press2,_elts_pressTree,_elts_pressXML,_elts_self,_elts_varsInScopeAtFocus) =
                (_elts (_lhs_focusD) (0) (_lhs_listType) (_lhs_pIdC + 100) (_lhs_path) (_lhs_ranges) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus))
        in  ( _elts_pIdC
             ,loc (List_ItemNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
                presentList _elts_press
             ,loc (List_ItemNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
               col' _elts_press2
             ,loc (List_ItemNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
                col _elts_pressTree
             ,loc (List_ItemNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
              col _elts_pressXML
             ,map ( loc (List_ItemNode _self _lhs_path)
                  . presentFocus _lhs_focusD _lhs_path )
                  _elts_press
             ,_elts_press2
             ,_self
             ,_elts_varsInScopeAtFocus
             )
sem_List_Item_ParseErrList_Item :: (Node) ->
                                   (Presentation) ->
                                   (T_List_Item)
sem_List_Item_ParseErrList_Item (_node) (_presentation) =
    \ _lhs_focusD
      _lhs_listType
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                ParseErrList_Item _node _presentation
        in  ( _lhs_pIdC
             ,loc (List_ItemNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
                presParseErr _node _presentation
             ,loc (List_ItemNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
               presParseErr _node _presentation
             ,loc (List_ItemNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
                presParseErr _node _presentation
             ,loc (List_ItemNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
              presParseErr _node _presentation
             ,[ presParseErr _node _presentation ]
             ,[presParseErr _node _presentation]
             ,_self
             ,_lhs_varsInScopeAtFocus
             )
-- List_Slide --------------------------------------------------
{-
   inherited attributes:
      focusD               : FocusDoc
      path                 : [Int]
      ranges               : ([PathDoc],[PathDoc],[PathDoc])
      varsInScope          : FiniteMap String (PathDoc, String)

   chained attributes:
      pIdC                 : Int
      varsInScopeAtFocus   : FiniteMap String (PathDoc, String)

   synthesised attributes:
      pres                 : Presentation
      pres2                : Presentation
      presTree             : Presentation
      presXML              : Presentation
      press                : [Presentation]
      press2               : [Presentation]
      self                 : SELF

-}
{-
   local variables for List_Slide.HoleList_Slide:
      self

-}
{-
   local variables for List_Slide.List_Slide:
      self

-}
{-
   local variables for List_Slide.ParseErrList_Slide:
      self

-}
-- semantic domain
type T_List_Slide = (FocusDoc) ->
                    (Int) ->
                    ([Int]) ->
                    (([PathDoc],[PathDoc],[PathDoc])) ->
                    (FiniteMap String (PathDoc, String)) ->
                    (FiniteMap String (PathDoc, String)) ->
                    ( (Int),(Presentation),(Presentation),(Presentation),(Presentation),([Presentation]),([Presentation]),(List_Slide),(FiniteMap String (PathDoc, String)))
-- cata
sem_List_Slide :: (List_Slide) ->
                  (T_List_Slide)
sem_List_Slide ((HoleList_Slide )) =
    (sem_List_Slide_HoleList_Slide )
sem_List_Slide ((List_Slide (_idd) (_elts))) =
    (sem_List_Slide_List_Slide (_idd) ((sem_ConsList_Slide (_elts))))
sem_List_Slide ((ParseErrList_Slide (_node) (_presentation))) =
    (sem_List_Slide_ParseErrList_Slide (_node) (_presentation))
sem_List_Slide_HoleList_Slide :: (T_List_Slide)
sem_List_Slide_HoleList_Slide  =
    \ _lhs_focusD
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                HoleList_Slide
        in  ( _lhs_pIdC
             ,loc (List_SlideNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
                presHole _lhs_focusD "Slides" (HoleList_SlideNode _self _lhs_path) _lhs_path
             ,loc (List_SlideNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
               presHole _lhs_focusD "Slides" (HoleList_SlideNode _self _lhs_path) _lhs_path
             ,loc (List_SlideNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
                presHole _lhs_focusD "List_Slide" (HoleList_SlideNode _self _lhs_path) _lhs_path
             ,loc (List_SlideNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
              presHole _lhs_focusD "List_Slide" (HoleList_SlideNode _self _lhs_path) _lhs_path
             ,[]
             ,[presHole _lhs_focusD "Slides" (HoleList_SlideNode _self _lhs_path) _lhs_path]
             ,_self
             ,_lhs_varsInScopeAtFocus
             )
sem_List_Slide_List_Slide :: (IDD) ->
                             (T_ConsList_Slide) ->
                             (T_List_Slide)
sem_List_Slide_List_Slide (_idd) (_elts) =
    \ _lhs_focusD
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                List_Slide _idd _elts_self
            ( _elts_pIdC,_elts_press,_elts_press2,_elts_pressTree,_elts_pressXML,_elts_self,_elts_varsInScopeAtFocus) =
                (_elts (_lhs_focusD) (0) (_lhs_pIdC + 100) (_lhs_path) (_lhs_ranges) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus))
        in  ( _elts_pIdC
             ,loc (List_SlideNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
                presentList _elts_press
             ,loc (List_SlideNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
               col' $ intersperse (col' [vSpace 4, hLine, vSpace 4]) _elts_press2
             ,loc (List_SlideNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
                col _elts_pressTree
             ,loc (List_SlideNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
              col _elts_pressXML
             ,map ( loc (List_SlideNode _self _lhs_path)
                  . presentFocus _lhs_focusD _lhs_path )
                  _elts_press
             ,_elts_press2
             ,_self
             ,_elts_varsInScopeAtFocus
             )
sem_List_Slide_ParseErrList_Slide :: (Node) ->
                                     (Presentation) ->
                                     (T_List_Slide)
sem_List_Slide_ParseErrList_Slide (_node) (_presentation) =
    \ _lhs_focusD
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                ParseErrList_Slide _node _presentation
        in  ( _lhs_pIdC
             ,loc (List_SlideNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
                presParseErr _node _presentation
             ,loc (List_SlideNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
               presParseErr _node _presentation
             ,loc (List_SlideNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
                presParseErr _node _presentation
             ,loc (List_SlideNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
              presParseErr _node _presentation
             ,[ presParseErr _node _presentation ]
             ,[presParseErr _node _presentation]
             ,_self
             ,_lhs_varsInScopeAtFocus
             )
-- PPPresentation ----------------------------------------------
{-
   inherited attributes:
      focusD               : FocusDoc
      ix                   : Int
      path                 : [Int]
      ranges               : ([PathDoc],[PathDoc],[PathDoc])
      varsInScope          : FiniteMap String (PathDoc, String)

   chained attributes:
      pIdC                 : Int
      varsInScopeAtFocus   : FiniteMap String (PathDoc, String)

   synthesised attributes:
      pres                 : Presentation
      presTree             : Presentation
      presXML              : Presentation
      self                 : SELF

-}
{-
   local variables for PPPresentation.HolePPPresentation:
      self

-}
{-
   local variables for PPPresentation.PPPresentation:
      self

-}
{-
   local variables for PPPresentation.ParseErrPPPresentation:
      self

-}
-- semantic domain
type T_PPPresentation = (FocusDoc) ->
                        (Int) ->
                        (Int) ->
                        ([Int]) ->
                        (([PathDoc],[PathDoc],[PathDoc])) ->
                        (FiniteMap String (PathDoc, String)) ->
                        (FiniteMap String (PathDoc, String)) ->
                        ( (Int),(Presentation),(Presentation),(Presentation),(PPPresentation),(FiniteMap String (PathDoc, String)))
-- cata
sem_PPPresentation :: (PPPresentation) ->
                      (T_PPPresentation)
sem_PPPresentation ((HolePPPresentation )) =
    (sem_PPPresentation_HolePPPresentation )
sem_PPPresentation ((PPPresentation (_idd) (_viewType) (_slides))) =
    (sem_PPPresentation_PPPresentation (_idd) (_viewType) ((sem_List_Slide (_slides))))
sem_PPPresentation ((ParseErrPPPresentation (_node) (_presentation))) =
    (sem_PPPresentation_ParseErrPPPresentation (_node) (_presentation))
sem_PPPresentation_HolePPPresentation :: (T_PPPresentation)
sem_PPPresentation_HolePPPresentation  =
    \ _lhs_focusD
      _lhs_ix
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                HolePPPresentation
        in  ( _lhs_pIdC,presHole _lhs_focusD "PPPresentation" (HolePPPresentationNode _self _lhs_path) _lhs_path,presHole _lhs_focusD "PPPresentation" (HolePPPresentationNode _self _lhs_path) _lhs_path,presHole _lhs_focusD "PPPresentation" (HolePPPresentationNode _self _lhs_path) _lhs_path,_self,_lhs_varsInScopeAtFocus)
sem_PPPresentation_PPPresentation :: (IDD) ->
                                     (Bool) ->
                                     (T_List_Slide) ->
                                     (T_PPPresentation)
sem_PPPresentation_PPPresentation (_idd) (_viewType) (_slides) =
    \ _lhs_focusD
      _lhs_ix
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                PPPresentation _idd _viewType _slides_self
            ( _slides_pIdC,_slides_pres,_slides_pres2,_slides_presTree,_slides_presXML,_slides_press,_slides_press2,_slides_self,_slides_varsInScopeAtFocus) =
                (_slides (_lhs_focusD) (_lhs_pIdC + 0) (_lhs_path++[1]) (_lhs_ranges) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus))
        in  ( _slides_pIdC
             ,loc (PPPresentationNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
                 col' $ [ row' [ text' NoIDP "View type: "
                             ,  if _viewType
                                then (box $ text' NoIDP $ "Edit view") `addPopupItems` [("Change to presentation view",toggleViewType _lhs_path _self)]
                                else (box $ text' NoIDP $"Presentation view") `addPopupItems` [("Change to edit view",toggleViewType _lhs_path _self)]
                              ]
                      , vSpace 10
                      ] ++
                        if _viewType
                        then
                          [ row' [ text' NoIDP "pres ",key NoIDP "=",text' NoIDP " Presentation ", text' NoIDP " $"]
                          , row' [ text' NoIDP "         ", _slides_pres]
                          ]
                        else
                          [ _slides_pres2
                          ]
             ,presentElementTree _lhs_focusD (PPPresentationNode _self _lhs_path) _lhs_path "PPPresentation" [ presentPrimTreeBool _viewType, _slides_presTree ]
             ,presentElementXML _lhs_focusD (PPPresentationNode _self _lhs_path) _lhs_path "PPPresentation" [ presentPrimXMLBool _viewType, _slides_presXML ]
             ,_self
             ,_slides_varsInScopeAtFocus
             )
sem_PPPresentation_ParseErrPPPresentation :: (Node) ->
                                             (Presentation) ->
                                             (T_PPPresentation)
sem_PPPresentation_ParseErrPPPresentation (_node) (_presentation) =
    \ _lhs_focusD
      _lhs_ix
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                ParseErrPPPresentation _node _presentation
        in  ( _lhs_pIdC,presParseErr _node _presentation,presParseErr _node _presentation,presParseErr _node _presentation,_self,_lhs_varsInScopeAtFocus)
-- Slide -------------------------------------------------------
{-
   inherited attributes:
      focusD               : FocusDoc
      ix                   : Int
      path                 : [Int]
      ranges               : ([PathDoc],[PathDoc],[PathDoc])
      varsInScope          : FiniteMap String (PathDoc, String)

   chained attributes:
      pIdC                 : Int
      varsInScopeAtFocus   : FiniteMap String (PathDoc, String)

   synthesised attributes:
      pres                 : Presentation
      pres2                : Presentation
      presTree             : Presentation
      presXML              : Presentation
      self                 : SELF

-}
{-
   local variables for Slide.HoleSlide:
      self

-}
{-
   local variables for Slide.ParseErrSlide:
      self

-}
{-
   local variables for Slide.Slide:
      self

-}
-- semantic domain
type T_Slide = (FocusDoc) ->
               (Int) ->
               (Int) ->
               ([Int]) ->
               (([PathDoc],[PathDoc],[PathDoc])) ->
               (FiniteMap String (PathDoc, String)) ->
               (FiniteMap String (PathDoc, String)) ->
               ( (Int),(Presentation),(Presentation),(Presentation),(Presentation),(Slide),(FiniteMap String (PathDoc, String)))
-- cata
sem_Slide :: (Slide) ->
             (T_Slide)
sem_Slide ((HoleSlide )) =
    (sem_Slide_HoleSlide )
sem_Slide ((ParseErrSlide (_node) (_presentation))) =
    (sem_Slide_ParseErrSlide (_node) (_presentation))
sem_Slide ((Slide (_idd) (_title) (_itemList))) =
    (sem_Slide_Slide (_idd) ((sem_String_ (_title))) ((sem_ItemList (_itemList))))
sem_Slide_HoleSlide :: (T_Slide)
sem_Slide_HoleSlide  =
    \ _lhs_focusD
      _lhs_ix
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                HoleSlide
        in  ( _lhs_pIdC,presHole _lhs_focusD "Slide" (HoleSlideNode _self _lhs_path) _lhs_path,presHole _lhs_focusD "Slide" (HoleSlideNode _self _lhs_path) _lhs_path,presHole _lhs_focusD "Slide" (HoleSlideNode _self _lhs_path) _lhs_path,presHole _lhs_focusD "Slide" (HoleSlideNode _self _lhs_path) _lhs_path,_self,_lhs_varsInScopeAtFocus)
sem_Slide_ParseErrSlide :: (Node) ->
                           (Presentation) ->
                           (T_Slide)
sem_Slide_ParseErrSlide (_node) (_presentation) =
    \ _lhs_focusD
      _lhs_ix
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                ParseErrSlide _node _presentation
        in  ( _lhs_pIdC,presParseErr _node _presentation,presParseErr _node _presentation,presParseErr _node _presentation,presParseErr _node _presentation,_self,_lhs_varsInScopeAtFocus)
sem_Slide_Slide :: (IDD) ->
                   (T_String_) ->
                   (T_ItemList) ->
                   (T_Slide)
sem_Slide_Slide (_idd) (_title) (_itemList) =
    \ _lhs_focusD
      _lhs_ix
      _lhs_pIdC
      _lhs_path
      _lhs_ranges
      _lhs_varsInScope
      _lhs_varsInScopeAtFocus ->
        let (_self) =
                Slide _idd _title_self _itemList_self
            ( _title_pIdC,_title_pres,_title_pres2,_title_presTree,_title_presXML,_title_self) =
                (_title (_lhs_focusD) (_lhs_ix) (_lhs_pIdC + 0) (_lhs_path++[0]))
            ( _itemList_pIdC,_itemList_pres,_itemList_pres2,_itemList_presTree,_itemList_presXML,_itemList_self,_itemList_varsInScopeAtFocus) =
                (_itemList (_lhs_focusD) (_lhs_ix) (_title_pIdC) (_lhs_path++[1]) (_lhs_ranges) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus))
        in  ( _itemList_pIdC
             ,loc (SlideNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
                col' [ row' [ text' NoIDP "Slide ", _title_pres, text' NoIDP " $"]
                     , row' [ text' NoIDP "  ", _itemList_pres ]
                     ]
             ,loc (SlideNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
                 slide _title_pres2
                       _itemList_pres2
             ,presentElementTree _lhs_focusD (SlideNode _self _lhs_path) _lhs_path "Slide" [ _title_presTree, _itemList_presTree ]
             ,presentElementXML _lhs_focusD (SlideNode _self _lhs_path) _lhs_path "Slide" [ _title_presXML, _itemList_presXML ]
             ,_self
             ,_itemList_varsInScopeAtFocus
             )
-- String_ -----------------------------------------------------
{-
   inherited attributes:
      focusD               : FocusDoc
      ix                   : Int
      path                 : [Int]

   chained attributes:
      pIdC                 : Int

   synthesised attributes:
      pres                 : Presentation
      pres2                : Presentation
      presTree             : Presentation
      presXML              : Presentation
      self                 : SELF

-}
{-
   local variables for String_.HoleString_:
      self

-}
{-
   local variables for String_.ParseErrString_:
      self

-}
{-
   local variables for String_.String_:
      self

-}
-- semantic domain
type T_String_ = (FocusDoc) ->
                 (Int) ->
                 (Int) ->
                 ([Int]) ->
                 ( (Int),(Presentation),(Presentation),(Presentation),(Presentation),(String_))
-- cata
sem_String_ :: (String_) ->
               (T_String_)
sem_String_ ((HoleString_ )) =
    (sem_String__HoleString_ )
sem_String_ ((ParseErrString_ (_node) (_presentation))) =
    (sem_String__ParseErrString_ (_node) (_presentation))
sem_String_ ((String_ (_idd) (_string))) =
    (sem_String__String_ (_idd) (_string))
sem_String__HoleString_ :: (T_String_)
sem_String__HoleString_  =
    \ _lhs_focusD
      _lhs_ix
      _lhs_pIdC
      _lhs_path ->
        let (_self) =
                HoleString_
        in  ( _lhs_pIdC,presHole _lhs_focusD "String_" (HoleString_Node _self _lhs_path) _lhs_path,presHole _lhs_focusD "String_" (HoleString_Node _self _lhs_path) _lhs_path,presHole _lhs_focusD "String_" (HoleString_Node _self _lhs_path) _lhs_path,presHole _lhs_focusD "String_" (HoleString_Node _self _lhs_path) _lhs_path,_self)
sem_String__ParseErrString_ :: (Node) ->
                               (Presentation) ->
                               (T_String_)
sem_String__ParseErrString_ (_node) (_presentation) =
    \ _lhs_focusD
      _lhs_ix
      _lhs_pIdC
      _lhs_path ->
        let (_self) =
                ParseErrString_ _node _presentation
        in  ( _lhs_pIdC,presParseErr _node _presentation,presParseErr _node _presentation,presParseErr _node _presentation,presParseErr _node _presentation,_self)
sem_String__String_ :: (IDD) ->
                       (String) ->
                       (T_String_)
sem_String__String_ (_idd) (_string) =
    \ _lhs_focusD
      _lhs_ix
      _lhs_pIdC
      _lhs_path ->
        let (_self) =
                String_ _idd _string
        in  ( _lhs_pIdC
             ,row' [ text' NoIDP "\""
                   , loc (String_Node _self _lhs_path) $ parsing $ presentFocus _lhs_focusD _lhs_path $
                       row' [text' NoIDP _string, text' NoIDP ""]
                   , text' NoIDP "\""
                   ] `withColor` darkViolet
             ,loc (String_Node _self _lhs_path) $ parsing $ presentFocus _lhs_focusD _lhs_path $
                 row' [text' NoIDP _string, text' NoIDP ""]
             ,presentElementTree _lhs_focusD (String_Node _self _lhs_path) _lhs_path "String_" [ presentPrimTreeString _string ]
             ,presentElementXML _lhs_focusD (String_Node _self _lhs_path) _lhs_path "String_" [ presentPrimXMLString _string ]
             ,_self
             )

