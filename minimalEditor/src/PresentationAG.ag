imports
{
import CommonTypes
import PresLayerTypes
import PresLayerUtils

import XprezLib
import XLatex hiding (bold)

import DocumentEdit

import List
import qualified Data.Map as Map
import Data.Map (Map)


import DocTypes (DocumentLevel (..))
import DocTypes_Generated
import DocUtils_Generated
import DocumentEdit_Generated

presHole focus typeStr nd pth = loc nd $
  structural $ row [text $ "{"++typeStr++"}"] `withColor` black `withbgColor` yellow `withFontFam` ("Courier New")

presParseErr pres =
  loc NoNode $ parsing $ pres `withbgColor` whiteSmoke

presentFocus NoPathD     path pres = pres
presentFocus (PathD pth) path pres = if pth==path then pres `withbgColor` focusCol else pres

focusCol = lightBlue

}

INCLUDE "PresentationAG_Generated.ag"



ATTR EnrichedDoc [ | layoutMap : LayoutMap | ]

SEM EnrichedDoc
  | RootEnr
      lhs.pres = loc (RootDocNode @document []) $  --HACK!! top level loc needs to be a ref to the document
                                                        -- it is used by mkPopupMenuXY in Renderer.
                                                        -- A better implementation of popups will create the menu in
                                                        -- the higher layers. Although it is still a bit unclear where
                 loc (RootEnrNode @self []) $ structural $
                   @root.pres

SEM Root
  | Root
      lhs.pres = loc (RootNode @self []) $ structural $ presentFocus @lhs.focusD @lhs.path $
                     col [ text "Root", @tree.pres, @graph.pres ]
                     
SEM Tree
  | Bin
      lhs.pres = loc (BinNode @self @lhs.path) $ parsing $ presentFocus @lhs.focusD @lhs.path $
                     row [ text $ "(", @left.pres, text " Bin ", @right.pres, text ")" ]
  | Leaf
      lhs.pres = loc (LeafNode @self @lhs.path) $ parsing $ presentFocus @lhs.focusD @lhs.path $
                     row [text $ "Leaf", text ""]
                     
                     
SEM Graph
  | Graph
      lhs.pres = loc (GraphNode @self @lhs.path) $ structural $ presentFocus @lhs.focusD @lhs.path $
                     GraphP NoIDP 400 200 [] @vertices.press
      edges.vertices = @vertices.vertices
      
SEM Vertex [ || vertex : {(Int, Int, Int)} ] 
  | Vertex
      lhs.pres = VertexP NoIDP (\a -> (0,0)) $
                   colR 1 [ rowR 1 [glue, ellipse 35 35 `withfColor` (200, 255, 255), glue]
                          , vSpace 4 `withHStretch` True
                          , row [glue, boxed 
                                          (row [ hSpace 3, text @name.str `withFont'` ("Arial", 10), hSpace 3])
                                            `withbgColor` (236, 236, 169)
                                , glue] 
                          ]
      lhs.vertex = (@id.int, @x.int, @y.int)
  | HoleVertex
      lhs.vertex = (-1,0,0)
  | ParseErrVertex
      lhs.vertex = (-1,0,0)

SEM List_Vertex [ || vertices : {Map Int (Int,Int)} ] 
  | HoleList_Vertex
      lhs.vertices = Map.empty
  | ParseErrList_Vertex
      lhs.vertices = Map.empty
SEM ConsList_Vertex [ || vertices : {Map Int (Int,Int)} ] 
  | Cons_Vertex
      lhs.vertices = let (i,x,y) = @head.vertex in Map.insert i (x, y) @tail.vertices
  | Nil_Vertex
      lhs.vertices = Map.empty

SEM List_Edge [ vertices : {Map Int (Int,Int)} || ]
SEM ConsList_Edge [ vertices : {Map Int (Int,Int)} || ]
SEM Edge [ vertices : {Map Int (Int,Int)} || ]
  | Edge
      lhs.pres = let (x1,y1) = maybe (0,0) id  (Map.lookup @from.int @lhs.vertices)
                     (x2,y2) = maybe (0,0) id  (Map.lookup @to.int @lhs.vertices)
                     [(leftx,lefty),(rightx,righty)] = sort [(x1,y1),(x2,y2)]
                 in  if lefty < righty then
                       offset (x1+17) (y1+17) $ poly [(0.0,0.0), (1.0,1.0)] `withSize` (rightx-leftx,righty-lefty)
                     else
                       offset (x1+17) (y2+17) $ poly [(0.0,1.0), (1.0,0.0)] `withSize` (rightx-leftx,lefty-righty)
{
offset :: Int -> Int -> Xprez doc node clip -> Xprez doc node clip
offset x y pres = col [ empty `withHeight` y, row [ empty `withWidth` x, pres ]]
}                            
                   