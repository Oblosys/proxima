imports
{
import CommonTypes hiding (Dirty (..))
import PresLayerTypes
import PresLayerUtils

import XprezLib
import XLatex hiding (bold)

import DocumentEdit

import List
import Maybe
import qualified Data.Map as Map
import Data.Map (Map)


import DocTypes (DocumentLevel (..))
import DocTypes_Generated
import DocUtils_Generated
import DocumentEdit_Generated

presHole focus typeStr nd pth = loc nd $
  structural $ row [text $ "{"++typeStr++"}"] `withColor` black `withbgColor` yellow `withFontFam` ("Courier New")

presParseErr pres =
  loc NoNode $ parsing $ pres `withbgColor` whiteSmoke

presentFocus NoPathD     path pres = pres
presentFocus (PathD pth) path pres = if pth==path then pres `withbgColor` focusCol else pres

focusCol = lightBlue

}

INCLUDE "PresentationAG_Generated.ag"



ATTR EnrichedDoc [ | layoutMap : LayoutMap | ]

SEM EnrichedDoc
  | RootEnr
      lhs.pres = loc (RootDocNode @document []) $  --HACK!! top level loc needs to be a ref to the document
                                                        -- it is used by mkPopupMenuXY in Renderer.
                                                        -- A better implementation of popups will create the menu in
                                                        -- the higher layers. Although it is still a bit unclear where
                 loc (RootEnrNode @self []) $ structural $
                   @root.pres

SEM Root
  | Root
      lhs.pres = loc (RootNode @self []) $ structural $ presentFocus @lhs.focusD @lhs.path $
                     col $ [ -- empty `withHeight` 300 
                     --      , mkTreeLeaf False $ text "Bla" 
                     {-      , boxed $ row [ text "blap" `withFontSize` 100, colR 1 [ poly [] `withbgColor` red
                                                                               , text "blap"
                                                                               , poly [] `withbgColor` blue
                                                                               ] `withHRef` (10)
                                         ] -}
                           {-, overlay [ row [rect 100 10] `withbgColor` red `withRef` (45,10) 
                                                   , rect 10 100
                                                   ] -}
                                {- , boxed $ overlay [ rect 100 10  `withRef` (45,10)
                                                   , rect 10 100
                                                   ]  -}  
                         {-  , boxed $ overlay [ col [text "O" ]
                                             , col[ text "+"]
                                                `withRef` (20,40)
                                             ] 
                           -}      
                           -- , col $ replicate 15 $ row $ replicate 20 $ text "bla"
                            @graph.pres
                           --, @tree.pres
                           --, parsing $ formatter $ replicate 50 $ text "bla"
                           , col @sections.press
                           --, parsing $ formatter $ map (text.(++" ").show) [100..149] 
                           
                          -- , col $ replicate 4 $ col $ replicate 20 $ text "84792873498237498274987239487923874928" `withbgColor` green
                           --, col $ map row $ divide 3 @sections.press
                           {-, row [ (boxed $ text "Add view") `withMouseDown` insertNewSection @lhs.path
                                 , text " "
                                 , (boxed $ text "Remove view") `withMouseDown` removeLastSection @lhs.path 
                                 ]
                           -}
                           ] 
{
divide n [] = []
divide n xs = let (h,t) = splitAt n xs
              in  h : divide n t
}
                           
SEM List_Paragraph [ || pres:Presentation_Doc_Node_Clip ]
  | List_Paragraph
      lhs.pres = loc (List_ParagraphNode @self @lhs.path) $ parsing $
                     col $ if null @elts.press then [formatter [text " "]] else @elts.press
                     -- formatter [text ""] prevents the column from getting height 0 when empty
SEM Paragraph
  | Paragraph
      lhs.pres = loc (ParagraphNode @self @lhs.path) $ parsing $ presentFocus @lhs.focusD @lhs.path $
                     col $ [ formatter @words.press ]

SEM Word [ || ]
  | Word
      lhs.pres = loc (WordNode @self @lhs.path) $ parsing $ presentFocus @lhs.focusD @lhs.path $
                     row [ @word.pres, text " " ]
SEM Tree
  | Bin
      lhs.pres = loc (BinNode @self @lhs.path) $ parsing $ presentFocus @lhs.focusD @lhs.path $
                     row [ text $ "(", @left.pres, text " Bin ", @right.pres, text ")" ]
  | Leaf
      lhs.pres = loc (LeafNode @self @lhs.path) $ parsing $ presentFocus @lhs.focusD @lhs.path $
                     row [text $ "Leaf", text ""]
                     
SEM Section
  | Section
      lhs.pres = loc (SectionNode @self @lhs.path) $ structural $ presentFocus @lhs.focusD @lhs.path $
                     col $ [ @paragraphs.pres `withFontSize` 12  `withWidth` 800 
                           , @subgraph.pres
                           ]
SEM Graph
  | Graph
      lhs.pres = loc (GraphNode @self @lhs.path) $ structural $ presentFocus @lhs.focusD @lhs.path $
                     row [ hSpace 5
                         , boxed $ graph 400 300 @edges.edges @vertices.press
                         ]
      
SEM Vertex [ || ] 
  | Vertex
      loc.pres = loc (VertexNode @self @lhs.path) $ structural $
                   vertex @id.int @x.int @y.int (\a -> (round $ 9*cos a , round $ -9*sin a )) $
                     col [ rowR 1 [glue, hRefHalf $ ellipse 18 18 Solid `withRef` (9,9) `withfColor` (200, 255, 255) , glue]
                         , vSpace 4 `withHStretch` True
                         , rowR 1 [glue, hRefHalf $ boxed 
                                            (row [ hSpace 3
                                                 , parsing $ text (@name.str) `withFont'` ("Arial", 6)
                                                 , hSpace 3
                                                 ])
                                              `withbgColor` (236, 236, 169)
                                  , glue]
                         ]


SEM Subgraph [ vertexIDs : {[Int]} vertexNames : {[String]} edges : {[(Int, Int)]} || ] 
  | Subgraph
      lhs.pres = let subVertices = filter (`elem` @lhs.vertexIDs) (fst . unzip $ @vertices.vertexIDNames)
                     -- only present vertices that are in the supergraph
                     subEdges = [ (fromV,toV) | (fromV, toV) <- @lhs.edges, fromV `elem` subVertices && toV `elem` subVertices]
                 in  loc (SubgraphNode @self @lhs.path) $ structural $ presentFocus @lhs.focusD @lhs.path $
                       (boxed $ graph 100 100 subEdges @vertices.press
                     `addPopupItems` [ ("Add node " ++ show name, pasteInSubgraph @lhs.path id name @self)
                                     | (name,id) <- zip @lhs.vertexNames @lhs.vertexIDs
                                     , id `notElem` (fst . unzip $ @vertices.vertexIDNames)
                                     ])

SEM Root
  | Root
      (sections.vertexIDs, sections.vertexNames) = unzip @graph.vertexIDNames
      sections.edges = @graph.edges
      
ATTR Graph [ || vertexIDNames : {[(Int, String)]} edges : {[(Int, Int)]} ]
-- attributes come from vertices and edges by copy rule

ATTR List_Section [ vertexIDs : {[Int]} vertexNames : {[String]} edges : {[(Int, Int)]} || ] 
ATTR ConsList_Section [ vertexIDs : {[Int]} vertexNames : {[String]} edges : {[(Int, Int)]} || ] 
ATTR Section [ vertexIDs : {[Int]} vertexNames : {[String]} edges : {[(Int, Int)]} || ] 

SEM Edge [ || edge : {Maybe (Int,Int)} ]    
  | Edge
      lhs.edge = Just (@from.int, @to.int)
  | HoleEdge
      lhs.edge = Nothing
  | ParseErrEdge
      lhs.edge = Nothing

SEM List_Edge [ || edges : {[(Int,Int)]} ] 
  | List_Edge
      lhs.edges = catMaybes @elts.edges
  | HoleList_Edge
      lhs.edges = []
  | ParseErrList_Edge
      lhs.edges = []
      
SEM ConsList_Edge [ || edges : {[Maybe (Int,Int)]} ] 
  | Cons_Edge
      lhs.edges = @head.edge : @tail.edges
  | Nil_Edge
      lhs.edges = []

SEM Vertex [ || vertexIDName : {Maybe (Int,String)} ]    
  | Vertex
      lhs.vertexIDName = Just (@id.int, @name.str)
  | HoleVertex
      lhs.vertexIDName = Nothing
  | ParseErrVertex
      lhs.vertexIDName = Nothing

SEM List_Vertex [ || vertexIDNames : {[(Int,String)]} ] 
  | List_Vertex
      lhs.vertexIDNames = catMaybes @elts.vertexIDNames
  | HoleList_Vertex
      lhs.vertexIDNames = []
  | ParseErrList_Vertex
      lhs.vertexIDNames = []
      
SEM ConsList_Vertex [ || vertexIDNames : {[Maybe (Int, String)]} ] 
  | Cons_Vertex
      lhs.vertexIDNames = @head.vertexIDName : @tail.vertexIDNames
  | Nil_Vertex
      lhs.vertexIDNames = []

{
pasteInSubgraph :: [Int] -> Int -> String -> Subgraph -> UpdateDoc Document clip
pasteInSubgraph pth id name subgraph =
  let subgraph' = 
        case subgraph of
        Subgraph idd d vs es -> Subgraph idd d (toList_Vertex $ Vertex NoIDD  (String_ NoIDD name) (Int_ NoIDD id) (Int_ NoIDD 20) (Int_ NoIDD 20) : fromList_Vertex vs) es
        _                    -> subgraph
  in \(DocumentLevel d path cl) ->
        let (DocumentLevel d' _ _) = editPasteD (DocumentLevel d (PathD pth)
                                                (Clip_Subgraph subgraph')
                                                )
        in  (DocumentLevel d' path cl)

insertNewSection :: [Int] -> UpdateDoc Document clip
insertNewSection pth =
  let section = Section NoIDD
                  (List_Paragraph NoIDD Nil_Paragraph) 
                  (Subgraph NoIDD (Dirty NoIDD) (List_Vertex NoIDD (Nil_Vertex)) (List_Edge NoIDD (Nil_Edge)))
  in  \(DocumentLevel d path cl) ->
        let (Clip_List_Section sectionlist) = select (pth++[2]) d -- nasty: Root tr(0) gr(1) sections(2)
            clipsectionlist' = insertList (length $ fromList_Section sectionlist) (Clip_Section section) sectionlist
            (DocumentLevel d' _ _) = editPasteD (DocumentLevel d (PathD (pth++[2]))
                                                (clipsectionlist')
                                                )
        in  (DocumentLevel d' path cl)

removeLastSection :: [Int] -> UpdateDoc Document clip
removeLastSection pth =
   \(DocumentLevel d path cl) ->
      let (Clip_List_Section sectionlist) = select (pth++[2]) d -- nasty: Root tr(0) gr(1) sections(2)
          clipsectionlist' = removeList (length (fromList_Section sectionlist) - 1) sectionlist
          (DocumentLevel d' _ _) = editPasteD (DocumentLevel d (PathD (pth++[2]))
                                              (clipsectionlist')
                                              )
      in  (DocumentLevel d' path cl)
}