imports
{
import CommonTypes
import PresLayerTypes
import PresLayerUtils

import XprezLib
import XLatex hiding (bold)

import DocumentEdit

import List
import Maybe
import qualified Data.Map as Map
import Data.Map (Map)


import DocTypes (DocumentLevel (..))
import DocTypes_Generated
import DocUtils_Generated
import DocumentEdit_Generated

presHole focus typeStr nd pth = loc nd $
  structural $ row [text $ "{"++typeStr++"}"] `withColor` black `withbgColor` yellow `withFontFam` ("Courier New")

presParseErr pres =
  loc NoNode $ parsing $ pres `withbgColor` whiteSmoke

presentFocus NoPathD     path pres = pres
presentFocus (PathD pth) path pres = if pth==path then pres `withbgColor` focusCol else pres

focusCol = lightBlue

}

INCLUDE "PresentationAG_Generated.ag"



ATTR EnrichedDoc [ | layoutMap : LayoutMap | ]

SEM EnrichedDoc
  | RootEnr
      lhs.pres = loc (RootDocNode @document []) $  --HACK!! top level loc needs to be a ref to the document
                                                        -- it is used by mkPopupMenuXY in Renderer.
                                                        -- A better implementation of popups will create the menu in
                                                        -- the higher layers. Although it is still a bit unclear where
                 loc (RootEnrNode @self []) $ structural $
                   @root.pres

SEM Root
  | Root
      lhs.pres = loc (RootNode @self []) $ structural $ presentFocus @lhs.focusD @lhs.path $
                     col [ bold $ text "Root"
                         , row [ @graph.pres, @graph.pres ]
                         , @tree.pres
                         , @subGraph.pres
                         ]

SEM Tree
  | Bin
      lhs.pres = loc (BinNode @self @lhs.path) $ parsing $ presentFocus @lhs.focusD @lhs.path $
                     row [ text $ "(", @left.pres, text " Bin ", @right.pres, text ")" ]
  | Leaf
      lhs.pres = loc (LeafNode @self @lhs.path) $ parsing $ presentFocus @lhs.focusD @lhs.path $
                     row [text $ "Leaf", text ""]
                     
                     
SEM Graph
  | Graph
      lhs.pres = loc (GraphNode @self @lhs.path) $ structural $ presentFocus @lhs.focusD @lhs.path $
                     row [ hSpace 5,
                           boxed $ graph 400 400 @edges.edges @vertices.press
                         ]
      
SEM Vertex [ || ] 
  | Vertex
      loc.pres = loc (VertexNode @self @lhs.path) $ structural $
                   vertex @id.int @x.int @y.int (\a -> (round $ 17*cos a -1, round $ -17*sin a -1)) $
                     col [ rowR 1 [glue, ellipse 36 36 `withRef` (18,18) `withfColor` (200, 255, 255) , glue]
                         , vSpace 4 `withHStretch` True
                         , rowR 1 [glue, boxed 
                                            (row [ hSpace 3, text (@name.str++(" <"++show @id.int++">")) `withFont'` ("Arial", 10), hSpace 3])
                                              `withbgColor` (236, 236, 169)
                                  , glue]
                         ]

SEM Root
  | Root
      (subGraph.vertexIDs, subGraph.vertexNames) = unzip @graph.vertexIDNames
      subGraph.edges = @graph.edges
      
ATTR Graph [ || vertexIDNames : {[(Int, String)]} edges : {[(Int, Int)]} ]
 
SEM SubGraph [ vertexIDs : {[Int]} vertexNames : {[String]} edges : {[(Int, Int)]} || ] 
  | SubGraph
      lhs.pres = let subVertices = filter (`elem` @lhs.vertexIDs) (fst . unzip $ @vertices.vertexIDNames)
                     -- only present vertices that are in the supergraph
                     subEdges = [ (fromV,toV) | (fromV, toV) <- @lhs.edges, fromV `elem` subVertices && toV `elem` subVertices]
                 in  loc (SubGraphNode @self @lhs.path) $ structural $ presentFocus @lhs.focusD @lhs.path $
                       (boxed $ graph 300 300 subEdges @vertices.press
                     `addPopupItems` [ ("Add node " ++ show name, pasteSubGraph @lhs.path id name @self)
                                     | (name,id) <- zip @lhs.vertexNames @lhs.vertexIDs
                                     , id `notElem` (fst . unzip $ @vertices.vertexIDNames)
                                     ])

SEM Edge [ || edge : {Maybe (Int,Int)} ]    
  | Edge
      lhs.edge = Just (@from.int, @to.int)
  | HoleEdge
      lhs.edge = Nothing
  | ParseErrEdge
      lhs.edge = Nothing

SEM List_Edge [ || edges : {[(Int,Int)]} ] 
  | List_Edge
      lhs.edges = catMaybes @elts.edges
  | HoleList_Edge
      lhs.edges = []
  | ParseErrList_Edge
      lhs.edges = []
      
SEM ConsList_Edge [ || edges : {[Maybe (Int,Int)]} ] 
  | Cons_Edge
      lhs.edges = @head.edge : @tail.edges
  | Nil_Edge
      lhs.edges = []

SEM Vertex [ || vertexIDName : {Maybe (Int,String)} ]    
  | Vertex
      lhs.vertexIDName = Just (@id.int, @name.str)
  | HoleVertex
      lhs.vertexIDName = Nothing
  | ParseErrVertex
      lhs.vertexIDName = Nothing

SEM List_Vertex [ || vertexIDNames : {[(Int,String)]} ] 
  | List_Vertex
      lhs.vertexIDNames = catMaybes @elts.vertexIDNames
  | HoleList_Vertex
      lhs.vertexIDNames = []
  | ParseErrList_Vertex
      lhs.vertexIDNames = []
      
SEM ConsList_Vertex [ || vertexIDNames : {[Maybe (Int, String)]} ] 
  | Cons_Vertex
      lhs.vertexIDNames = @head.vertexIDName : @tail.vertexIDNames
  | Nil_Vertex
      lhs.vertexIDNames = []

{
pasteSubGraph :: [Int] -> Int -> String -> SubGraph -> UpdateDoc Document clip
pasteSubGraph pth id name subgraph =
  let subgraph' = 
        case subgraph of
        SubGraph idd vs es -> SubGraph idd (toList_Vertex $ Vertex NoIDD  (String_ NoIDD name) (Int_ NoIDD id) (Int_ NoIDD 20) (Int_ NoIDD 20) : fromList_Vertex vs) es
        _                  -> subgraph
  in \(DocumentLevel d path cl) ->
        let (DocumentLevel d' _ _) = editPasteD (DocumentLevel d (PathD pth)
                                                (Clip_SubGraph subgraph')
                                                )
        in  (DocumentLevel d' path cl)

toList_Vertex vs = List_Vertex NoIDD (toConsList_Vertex vs)

fromList_Vertex (List_Vertex _ vs) = fromConsList_Vertex vs
fromList_Vertex _                  = []

}