<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
	  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- v1

IE problems
-SVG support
-use str.charAt(i) instead of str[i]
-offsetLeft, etc.?
-getElementsByClassName()      (see http://forums.devshed.com/javascript-development-115/javascript-get-all-elements-of-class-abc-24349.html)

-->
<html xml:lang="en" lang="en" xmlns="http://www.w3.org/1999/xhtml">


<head>
<meta name="viewport" content="width=device-width; initial-scale=1.0; maximum-scale=1.0; user-scalable=0;" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black" />
<link rel="apple-touch-startup-image" href="etc/Uncle-Oblomov-startup.png"/>
<title>Proxima 2.0</title>


<style>
<![CDATA[

/* Context menu Script- (c) Dynamic Drive (www.dynamicdrive.com) Last updated: 01/08/22
For full source code and Terms Of Use, visit http://www.dynamicdrive.com */
.skin0{
position:absolute;
border:2px solid black;
background-color:menu;
font-family:Verdana;
line-height:22px;
cursor:default;
font-size:20px;
z-index:100;
visibility:hidden;
}

.menuItem{
padding-left:10px;
padding-right:10px;
}
]]>
</style>


<!-- <script type="text/javascript" src="img/jquery-1.3.2.js"></script> -->
<!-- JQuery gives an error with xml pages (div.style is undefined), which also disables Firebug.
-->
<script type="text/javascript">
<![CDATA[


var xmlhttp;
var mouseDown = false;
var commandQueue = '';
var currentRequestId = 0;

var sessionId;
var responseId;
var sessionType; // 'primary' or 'secondary'
var nrOfSessions;
var browserIsSafari;

function init()
{
  var ua = navigator.userAgent.toLowerCase();
  browserIsSafari = ua.indexOf('safari/') != -1;

 
  if (ua.indexOf('iphone') != -1)
  { rootTableElt = document.getElementById('rootTable');
    rootTableElt.cellPadding = '0px';

    buttonBarElt = document.getElementById('buttonBar');
    buttonBarElt.parentNode.removeChild( buttonBarElt );

    // use the iPhoneStatusElt at the bottom right corner as status
    iPhoneStatusElt = document.getElementById('iPhoneStatus');
    iPhoneStatusElt.id='status';
    iPhoneStatusElt.style.visibility="visible";

    iPhoneKeyboardButtonElt = document.getElementById('iPhoneKeyboardButton');
    iPhoneKeyboardButtonElt.style.visibility="visible";

    proximaElt = document.getElementById('proxima');
    proximaElt.style.border = '0px';
    proximaElt.style.width = '320px';
    proximaElt.style.height = '460px'; // 416 is without button and menu bar 356 is without button bar 334 is with


//    window.scrollTo(0, 1);


  //  setTimeout(proximaElt.addEventListener('touchmove', function(event) {  
  //  event.preventDefault(); // the default behaviour is scrolling  
  //  }),1000);

}
  
  addKeyboardListeners();

  // context menus
  ie5=document.all&&document.getElementById;
  ns6=document.getElementById&&!document.all;
  menuobj=document.getElementById("contextMenu");
  menuobj.style.display='';
  //


  refresh();
}

function addKeyboardListeners()
{   if (document.addEventListener)
    {
       document.addEventListener("keydown",keydown,false);
       document.addEventListener("keyup",keyup,false);
       document.addEventListener("keypress",keypress,false);
    }
    else if (document.attachEvent) // IE7
    {
       document.attachEvent("onkeydown", keydown);
       document.attachEvent("onkeyup", keyup);
       document.attachEvent("onkeypress", keypress);
    }
    else
    {
       document.onkeydown= keydown;
       document.onkeyup= keyup;
       document.onkeypress= keypress;
    }
}

function removeKeyboardListeners()
{ if (document.addEventListener)
    { document.removeEventListener("keydown",keydown,false);
      document.removeEventListener("keyup",keyup,false);
      document.removeEventListener("keypress",keypress,false);
    }
    else if (document.attachEvent) // IE7
    { document.detachEvent("onkeydown", keydown);
      document.detachEvent("onkeyup", keyup);
      document.detachEvent("onkeypress", keypress);
    }
    else // TODO: don't know if this works:
    { document.onkeydown = "return false";
      document.onkeyup = "return false";
      document.onkeypress = "return false";
    } 
}

// Font queries
 
var beginRange = 32;
var endRange = 255;
  
function initFont()
{ var fontElt = document.getElementById('font');
  fontElt.innerHTML='';
  var lines = '<div id=\'lines\' style=\'position:absolute;"\'>';
  for (var c=beginRange; c<=endRange; c++)
  { var ch = c == 38 ? '&amp;' 
           : c == 60 ? '&lt;' 
           : c == 62 ? '&gt;' : String.fromCharCode(c);
    lines = lines + '<div style=\'position:absolute\'>'+replicate(1000,ch)+'</div>';
  }
  lines += '</div><div id="enclosing" style="position:absolute"><span id="text">X</span><span id="baseline" style="height:0px;font-size:0px">baseline</span></div>';
  fontElt.innerHTML=lines;
}

function queryFont(fontFamily, fontSize, isBold, isItalic)
{ //debugAdd('Font query: '+fontFamily+fontSize+isBold+isItalic);
  initFont(); // firefox does not update bounding divs on style update, so we need to init every time :-(
  
  var fontElt = document.getElementById('font');
  fontElt.style.fontFamily = fontFamily;
  fontElt.style.fontSize = fontSize+'pt';
  fontElt.style.fontWeight = isBold ? "bold" : "normal"
  fontElt.style.fontStyle = isItalic ? "italic" : "normal"

  var enclosing = document.getElementById('enclosing');
  var baselineElt = document.getElementById('baseline');
  var font = document.getElementById('text');
  var height = font.offsetHeight;
  var baseline = baselineElt.offsetTop - font.offsetTop;

  var metrics = '((\\"'+fontFamily+'\\",'+fontSize+','+
                (isBold ? 'True' : 'False') +',' + 
                (isItalic ? 'True' : 'False') + 
                '),('+height + ',' + baseline + ',';
  var linesElt = fontElt.childNodes[0];
  var widths = '%5b'; // escaped '['
  for (var childNr = 0; childNr <= endRange - beginRange; childNr++)
  { var line = linesElt.childNodes[childNr];
    widths += (childNr == 0 ? '' : ',') + (line.clientWidth);
  }
  widths += '%5d'; // escaped ']'
  metrics += widths + '))';
  return metrics;
}

function replicate(i,c)
{ var str = '';
  while (i-- > 0)
    str = str + c;
  return str;
}


// Context menu's

var ie5;
var ns6;
var menuobj;

function contextHandler(e)
{ var screenX = ie5 ? event.clientX
                    : e.clientX;
  var screenY = ie5 ? event.clientY
                    : e.clientY;

  var coords = getMouseCoordsWithinTarget(e, document.getElementById('proxima')); 

  // menu is not on proxima element, so position is absolute to window
  // however, proxima needs the position relative to the proxima element
  
  sendCommand('ContextMenuRequest(('+coords.x+','+coords.y+'),('+screenX+','+screenY+'));');
  return false; // disable normal context menu
}


function highlightie5(e)
{ var firingobj=ie5? event.srcElement : e.target;
  if ( firingobj.className=="menuItem" ||
       ns6 && firingobj.parentNode.className=="menuItem")
  { if (ns6 && firingobj.parentNode.className=="menuItem") 
      firingobj=firingobj.parentNode; //up one node
    firingobj.style.backgroundColor="highlight";
    firingobj.style.color="white";
  }
}

function lowlightie5(e)
{ var firingobj=ie5? event.srcElement : e.target;
  if ( firingobj.className=="menuItem" ||
       ns6 && firingobj.parentNode.className=="menuItem")
  { if (ns6 && firingobj.parentNode.className=="menuItem") 
      firingobj=firingobj.parentNode; //up one node
    firingobj.style.backgroundColor="";
    firingobj.style.color="black";
  }
}

function jumptoie5(e)
{ var firingobj=ie5? event.srcElement : e.target;
  if( firingobj.className=="menuItem" ||
      ns6 && firingobj.parentNode.className=="menuItem" )
  { if (ns6&&firingobj.parentNode.className=="menuItem") 
      firingobj=firingobj.parentNode;
    else
    { var selectedItemNr = firingobj.getAttribute("item");
      sendCommand('ContextMenuSelect('+selectedItemNr+');');     
      menuobj.style.visibility="hidden";
    }
  }
}

function showMenuXY(x,y)
{ // Find out how close the mouse is to the corner of the window
  var rightedge=ie5 ? document.body.clientWidth-x
                    : window.innerWidth-x;
  var bottomedge = ie5 ? document.body.clientHeight-y
                       : window.innerHeight-y;
  
  // if the horizontal distance isn't enough to accomodate the width of the context menu
  var left, top;
  
  if (rightedge < menuobj.offsetWidth)
    // move the horizontal position of the menu to the left by it's width
    left= ie5 ? document.body.scrollLeft+x-menuobj.offsetWidth 
                            : window.pageXOffset+x-menuobj.offsetWidth;
  else
    //position the horizontal position of the menu where the mouse was clicked
    left = ie5 ? document.body.scrollLeft+x 
                             : window.pageXOffset+x;

  // same concept with the vertical position
  if (bottomedge < menuobj.offsetHeight)
    top=ie5 ? document.body.scrollTop+y-menuobj.offsetHeight 
                          : window.pageYOffset+y-menuobj.offsetHeight
  else
    top=ie5 ? document.body.scrollTop+y 
                          : window.pageYOffset+y

  menuobj.style.left = left + 'px';
  menuobj.style.top = top + 'px';
  
  menuobj.style.visibility="visible";
}


function hidemenuie5(e)
{ menuobj.style.visibility="hidden";
}




// end Context menu's






function sendCommand(commandStr)
{ if (commandQueue == "")
    prependSetViewedAreaCommand(); // every set of commands is prepended with the viewed area

  commandQueue = commandQueue + commandStr;

  if ( xmlhttp && xmlhttp.readyState != 0 && xmlhttp.readyState != 4)
    return; // if xmlhttp exists and was initialized and not ready, we return
            // TODO: can readyState == 0 happen?  
             
xmlhttp=null;
if (window.XMLHttpRequest)
  { // code for Firefox, Opera, IE7, etc.
    xmlhttp=new XMLHttpRequest();
  }
else if (window.ActiveXObject)
  { // code for IE6, IE5
    xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
  }
if (xmlhttp!=null)
  { 
    { xmlhttp.onreadystatechange=state_Change;
      xmlhttp.open("GET",'handle?commands=Commands '+ currentRequestId +' "'+commandQueue+'"',true);
      xmlhttp.send(null);     // commands are terminated by semicolons

      if (document.getElementById('status'))
        switch(sessionType)
        { case 'primary':
            document.getElementById('status').innerHTML = '<img src="etc/statusBlue.jpg"/>';
            break;

          case 'secondary':
            document.getElementById('status').innerHTML = '<img src="etc/statusOrange.jpg"/>';
            break;

          default:
            document.getElementById('status').innerHTML = '<img src="etc/statusWhite.jpg"/>';

      }



      stopAutoRefreshTimer();
      
      currentRequestId++;
//      debugAdd('incremented currentRequestId: ' + currentRequestId);
      moveCurrentPredictiveInsertsToSent();
      commandQueue = '';
    }
  }
else
  { alert("Your browser does not support XMLHTTP.");
  }
}

function state_Change()
{
if (xmlhttp.readyState==4)
  {// 4 = "loaded"
  if (xmlhttp.status==200)
    {// 200 = "OK"
    
    var newRendering = document.getElementById('newRendering');
    newRendering.innerHTML=xmlhttp.responseText;
    
    removeAllPredictiveInserts();
    clearSentPredictiveUpdates();

    var updates = document.getElementById('updates');
    // getElementById seems to trigger parsing the responseText
    // after this, firstChild has a value, while it is null before
                // newRendering.firstChild;

    sessionId = updates.getAttribute('sessionId');
    responseId = updates.getAttribute('responseId');
    sessionType = updates.getAttribute('sessionType');
    nrOfSessions = updates.getAttribute('nrOfSessions');
    if (document.getElementById('sessionInfo'))
    { document.getElementById('sessionInfo').innerHTML =
           'Session id: ' + sessionId + ':' + responseId + ' '  +
           (sessionType == 'primary' ? 'Editable' : 'Non-editable') + ' ' +
           'Nr of sessions:' + nrOfSessions;
    }

    if (commandQueue != '')
    { //debugAdd('sending queue');
      sendCommand('');
    }
    else
      if (sessionType == 'primary')
      { if (document.getElementById('status'))
          document.getElementById('status').innerHTML = '<img src="etc/statusGreen.jpg"/>';
        stopAutoRefreshTimer(); // in case it was started
        startExpirationTimer()
      }
      else  
      { if (document.getElementById('status'))
          document.getElementById('status').innerHTML = '<img src="etc/statusRed.jpg"/>';
        startAutoRefreshTimer();
      }   
    

   
    while (updates.firstChild)
    { updateTree( updates.firstChild );
      updates.removeChild(updates.firstChild);
    }
    reApplySentPredictiveInserts();

    //var renderArea = document.getElementById('renderArea');
    //renderArea.removeChild( document.getElementById('root') ); //old rendering

    //var xmlRoot = xmlhttp.responseXML.firstChild;
    
    
    //renderingRoot = document.getElementById('root');
    //newRendering.removeChild( renderingRoot );
    
    //renderArea.appendChild( renderingRoot );
    
    //while (renderArea.firstChild) {
    //  renderArea.removeChild(renderArea.firstChild);
    //}
    //
    // getElementById does not seem to work for dynamically added XML nodes.
    

    
   }
  else
    {
    debug("Problem retrieving data:" + xmlhttp.statusText);
//    if (document.getElementById('status'))
//        document.getElementById('status').innerHTML='Server not available.';
    }
  }
}
var theOp ;
function updateTree(update)
{ var op = update.getAttribute('op');
  theOp = op;
 /*
  if (op == 'add')
  { var parentId = update.getAttribute('parentId');
    var newChild = update.firstChild;
    var parent = document.getElementById(parentId);
    parent.appendChild( newChild );
//    debug('add to '+parentId+' '+newChild.getAttribute('Id'));
  }    
  else if (op == 'remove')
  { var parentId = update.getAttribute('parentId');
    var targetId = update.getAttribute('targetId');
    var parent = document.getElementById(parentId);
    if (parent==null)
    { debug('parent '+parentId+' is null');
      return;
    }
    
    var target = document.getElementById(targetId);
    parent.removeChild( target );
//    debug('remove '+targetId+' from '+parentId);
  } 
  else 
  */
  if (op == 'replace')
  { var path = update.childNodes[0];
    var newChild = update.childNodes[1];
    
    var oldChild = select(path, document.getElementById('proxima'));
    
    var parent = oldChild.parentNode;
    
    parent.replaceChild(newChild,oldChild);
      
//    debug('replace '+targetId+' at '+parentId+' by '+newChild.getAttribute('Id'));
  } else if (op == 'move')
  { var path = update.childNodes[0];
    var node = select(path, document.getElementById('proxima'));

    var renderingElt = document.getElementById('proxima').childNodes[0];
    // this is the rendering div (which has a variable id)

    node.style.left = node.offsetLeft +  parseInt( update.getAttribute('x') )+'px';
    node.style.top = node.offsetTop + parseInt( update.getAttribute('y') )+'px';
    node.style.width = node.offsetWidth + parseInt( update.getAttribute('w') )+'px';
    node.style.height = node.offsetHeight + parseInt( update.getAttribute('h') )+'px';
      
    if (node != renderingElt) // for the rendering root, don't move siblings
    { node = node.nextSibling;
      while (node) // move the node and all it's siblings in the row/column
      { node.style.left = node.offsetLeft +  parseInt( update.getAttribute('x') )+'px';
        node.style.top = node.offsetTop + parseInt( update.getAttribute('y') )+'px';
        node = node.nextSibling;
      }
    }
//    debugAdd('move');
  } else if (op == 'insert')
  { var path = update.childNodes[0];
    var parentNode = select(path, document.getElementById('proxima'));
    var pos = parseInt(update.getAttribute('pos'));
    var nr = parseInt(update.getAttribute('nr'));
  
    var nextChild = parentNode.childNodes[pos];

    // insert nr dummy divs at position pos (in case parent has no elements, and no nextChild, we append the elements)
    // when parent is non-empty dummies are inserted in reverse order, but since they are identical, this is no problem.
    // when parent is empty, dummies are inserted in normal order because nextChild is not updated and we keep on appending.
    for(var i = 0; i < nr; i++)
    { var dummy = document.createElement('div');
      if (nextChild)
        parentNode.insertBefore(dummy, nextChild);
      else
        parentNode.appendChild(dummy);
    }
//    debugAdd('insert '+pos+ ' '+nr);
  } else if (op == 'delete')
  { var path = update.childNodes[0];
    var parentNode = select(path, document.getElementById('proxima'));
    var pos = parseInt(update.getAttribute('pos'));
    var nr = parseInt(update.getAttribute('nr'));

    for(var i = 0; i < nr; i++)
      parentNode.removeChild(parentNode.childNodes[pos]); // after remove, the next child to remove will also be at pos
//    debugAdd('delete '+pos+ ' '+nr);
  } else if (op == 'contextMenu')
  { var screenX = update.getAttribute('screenX');
    var screenY = update.getAttribute('screenY');
    
    removeChildrenById('contextMenu');
    
    while (update.firstChild)
    { var item = update.firstChild;
      update.removeChild(update.firstChild);
      menuobj.appendChild( item );
    } // using appendChild directly also seems to remove the child from update
      // but maybe this is not the same for all browsers
    
    showMenuXY(screenX,screenY);
    
  }
  else if (op == 'metricsQuery')
  { var family = update.getAttribute('family');
    var size = update.getAttribute('size');
    var isBold = update.getAttribute('isBold') == 'True';
    var isItalic = update.getAttribute('isItalic') == 'True';
    //alert(family+size+isBold+isItalic);    
    // strange: allowing this alert screws up the rendering!
    
    var metrics = queryFont(family,size,isBold,isItalic);
    //debugAdd('query is Metrics'+metrics+';');
    sendCommand('Metrics'+metrics+';');
  }
  else if (op == 'setViewedArea')
  { var x = update.getAttribute('x');
    var y = update.getAttribute('y');
    var w = update.getAttribute('w');
    var h = update.getAttribute('h');

    setViewedAreaClient(x,y,w,h);    
  }
  
  else if (op == 'refresh')
  { refresh(); // this is triggered at the end of a set of font queries
  }
  else if (op == 'clear')
  { clearRendering();
  }
  else if (op == 'alert')
  { alert (update.getAttribute('text'));
  }
  else if (op == 'setFocusedId')
  { var path = update.childNodes[0];
    focusedElt = select(path, document.getElementById('proxima'));
    focusIndex = update.getAttribute('index');
  }
  else alert ('Unknown command: '+op); 
}

function select(path, node)
{ var step = path.firstChild;
  if (!step)
    return node;
  else
    { path.removeChild(step);
      var childNr = parseInt( step.getAttribute('childNr') ); 
      if (node)
      { var child = node.childNodes[childNr];
        return (select (path, child));
      }
      //else alert ('incorrect path at op: '+theOp);
    }
}

function debug(message)
{
    document.getElementById('debugMessage').innerHTML=message;
}

function debugAdd(message)
{
    debug (message + '<br></br>' + document.getElementById('debugMessage').innerHTML);
}

function setStatus(message)
{
  if (document.getElementById('status'))
    document.getElementById('status').innerHTML=message;
}


var expirationTimer;
var sessionExpirationTime = 60; // make sure this is equal to sessionExpirationTime in GUIServer.hs

function startExpirationTimer()
{ if (expirationTimer)
    clearTimeout(expirationTimer);

  expirationTimer = setTimeout('turnOffStatusLight()',sessionExpirationTime * 1000 - 2000);
// The -2000 is because response from server is not immediate, so the timer is always started a bit
// too late. The session will show to expire up to 2 seconds before it does on the server. (which is not a problem)
}

function turnOffStatusLight()
{ if (document.getElementById('status'))
    document.getElementById('status').innerHTML = '<img src="etc/statusGrey.jpg"/>';
  sessionType = '';
  clearTimeout(expirationTimer);
}

var autoRefreshTimer;

function startAutoRefreshTimer()
{ if (autoRefreshTimer)
    clearTimeout(autoRefreshTimer);
  autoRefreshTimer = setTimeout('autoRefresh()',5 * 1000);
}

function stopAutoRefreshTimer()
{  clearTimeout(autoRefreshTimer);
}

function autoRefresh()
{ sendCommand('Rearrange;');
}

function clearRendering()
{ var renderingElt = document.getElementById('proxima').childNodes[0];
    // this is the rendering div (which has a variable id)
  removeChildren(renderingElt);
  removeChildrenById('-2');  // -2 is the focus
  removeChildrenById('newRendering');
  removeChildrenById('contextMenu');
}

function refresh()
{ sendCommand('Rearrange;');
}

function removeChildrenById(parentId)
{ removeChildren(document.getElementById(parentId));
}

function removeChildren(parent)
{ while (parent.firstChild)
    parent.removeChild(parent.firstChild);
}

function keypress(e)
{
  if (!e) e= event;
   var keyCode =  (e.keyCode != 0) ? e.keyCode : e.charCode
   // keyCode is 0 on Firefox
   
  //alert('Key is '+keyCode +',' + e.charCode);

  if (keyCode==116 && e.charCode==0) // F5
  { sendCommand('Rearrange;');
    return false;
  }

  if (keyCode==102 && e.ctrlKey) // ctrl-f
  { var answer=prompt("Enter search term.");
// todo: escape answer string
   if (answer) sendCommand('Find \\"'+answer+'\\";');
    return false;
  }
  if (keyCode==98 && e.ctrlKey) // ctrl-b
  { sendCommand('EditStyle SetBold;');
    return false;
  }
 if (keyCode==66 && e.ctrlKey) // ctrl-B
  { sendCommand('EditStyle ClearBold;');
    return false;
  }
  if (keyCode==105 && e.ctrlKey) // ctrl-i
  { sendCommand('EditStyle SetItalic;');
    return false;
  }
  if (keyCode==73 && e.ctrlKey) // ctrl-I
  { sendCommand('EditStyle ClearItalic;');
    return false;
  }
  if (keyCode==48 && e.ctrlKey) // ctrl-0
  { sendCommand('EditStyle (SetColor (0,0,0));');
    return false;
  }
  if (keyCode==49 && e.ctrlKey) // ctrl-1
  { sendCommand('EditStyle (SetColor (255,0,0));');
    return false;
  }
  if (keyCode==50 && e.ctrlKey) // ctrl-2
  { sendCommand('EditStyle (SetColor (0,0,255));');
    return false;
  }

  if (e.which != 0 && keyCode != 8 && keyCode != 13)
  { if (!(e.ctrlKey || e.altKey || e.metaKey))
      insertCharPredictively( String.fromCharCode(keyCode) );
    sendCommand('Chr('+keyCode+','+showModifiers(e)+');');
  }
// maybe also check alt, ctrl and  other keys, they seem to generate press events now
   
   if (e.preventDefault) e.preventDefault();
   if (e.stopPropagation) e.stopPropagation();

   return false;
}

function hasNoKeyPress(keyCode)
{
   return keyCode == 13 || keyCode == 8 || keyCode == 46 ||
          keyCode >= 37 && keyCode <= 40||
          keyCode >= 112 && keyCode <= 123;

}


function keydown(e)
{ if (!e) e = event;
  if (e.keyCode==116)
    return true; // don't handle F5 here, it is handled in keypress()
// todo prevent ctrl f and other keys bound in keyPress from sending Key events here.

  if (e.keyCode==127) // backspace on iPhone is 127
  {  sendCommand('Key(8,'+showModifiers(e)+');');
     if (e.preventDefault) e.preventDefault();
     if (e.stopPropagation) e.stopPropagation();
     return false; // false, so no keyPress event is generated
  }

  if (hasNoKeyPress(e.keyCode) || e.ctrlKey || e.altKey || e.metaKey)
   {
     sendCommand('Key('+e.keyCode+','+showModifiers(e)+');');
     if (e.preventDefault) e.preventDefault();
     if (e.stopPropagation) e.stopPropagation();
     return false; // false, so no keyPress event is generated
   }
   return true;
}
/* for preventing default behavior: (unclear whether or how this works)     
     if (e.preventDefault) e.preventDefault();
     if (e.stopPropagation) e.stopPropagation();
*/

function keyup(e)
{
}

var scrollInProgress = false;

function mouseHandler(str,e) 
{ if (e.button != 0) return true;  // only handle left button here
  var proxima = document.getElementById('proxima');

  var coords = getMouseCoordsWithinTarget(e,proxima);
  var posx = coords.x;
  var posy = coords.y;
  
  /* We don't use scroll events, because setting scrollLeft and scrollTop also fires these events, and
     it does not seem possible to disable the handler temporarily */
  if (scrollInProgress)
  { if (str == 'U' || (str == 'M' && browserIsSafari) )

    // Safari does not trigger the up event when dragging in the scroll bar. Instead, it fires a move event.
    // But since it only fires one move, at the release of the mouse, we can use it instead of an up event.

    { scrollInProgress = false;
      prependSetViewedAreaCommand();
      // there already is one at the start of the command queue (added by sendCommand), but put the most recent one just in case
      sendCommand('Redraw;');

      return true;
    }
    else if (str == 'M')
    { if (commandQueue == "")
      // there commandQueue is empty, so viewed area command will be prepended by sendCommand
      sendCommand('Redraw;'); // during scroll, only update if no other commands in queue, to prevent flooding
      return true;
    }
    // mouse down cannot occur
  }

  if ( (posx - proxima.scrollLeft) > proxima.clientWidth || (posy - proxima.scrollTop) > proxima.clientHeight )
    // we're on a scroll bar (either dragging or on a button), so set viewed area on mouse up.
  { if (str == 'D')
      scrollInProgress = true;
    return true;
  }

//  setStatus( 'dragState is '+dragState + ' origin(' + mouseDownPos.x + ',' + mouseDownPos.y + ') offset(' + dragOffset.x + ',' + dragOffset.y + ')' );

  
  switch(dragState)
  { case 0: // no button down
      if (str == 'D')
      { dragState = 1;
        mouseDownPos = { x: posx, y: posy };

        draggable = getDraggable(mouseDownPos.x, mouseDownPos.y);
        if ( !draggable )
        { sendMouseCommand('MouseDown', mouseDownPos.x, mouseDownPos.y, e);                     
        }
      } // all other mouse actions are ignored when button was not down
      break;

    case 1: // button down, no drag
      if (str =='U')
      { sendCommand( (draggable ? mkMouseCommand('MouseDown', mouseDownPos.x, mouseDownPos.y, e) : '') +
                    // if there's a draggable, the mouse down was not yet sent
                    mkMouseCommand('MouseUp', posx, posy, e)   );
        draggable = null;
        dragState = 0;
      }
      else if (str == 'M')
      { if ( draggable )
        { draggedElementClone = cloneObject(draggable);

          draggableDims = getElementDimensions( draggable );
          var proximaDims = getElementDimensions( proxima );

          dragOffset = { x: mouseDownPos.x + proximaDims.x - draggableDims.x
                       , y: mouseDownPos.y + proximaDims.y - draggableDims.y
                       }
          draggedElementClone.style.left = posx-dragOffset.x +'px';
          draggedElementClone.style.top = posy-dragOffset.y +'px';

          sendMouseCommand('MouseDragStart', posx, posy, e);
          dragState = 2;
        }
        else
        { sendMouseCommand('MouseMove', posx, posy, e);
          dragState = 3;
        }
      } // ignore mouse down (should not occur)
      break;

    case 2: // drag in progress
      if ( str == 'U' )
      { sendMouseCommand('MouseDrop', posx, posy, e);
        draggedElementClone.parentNode.removeChild(draggedElementClone);
        draggedElementClone = null;
        draggable = null;
        dragState = 0;
      }
      else if ( str == 'M' )
      { draggedElementClone.style.left = posx-dragOffset.x +'px';
        draggedElementClone.style.top = posy-dragOffset.y +'px';
      } // ignore mouse down (should not occur)
      break;

    case 3: // dragging on non-dragsource (e.g. extending focus)
      if ( str == 'U' )
      { sendMouseCommand('MouseUp', posx, posy, e);
        dragState = 0;
      }
      else if ( str == 'M' )
      { sendMouseCommand('MouseMove', posx, posy, e);
      } // ignore mouse down (should not occur)
      break;
  }

  return false; // don't let browser handle mouse events
}

function sendMouseCommand(mouseCommand, x, y, e)
{ sendCommand( mkMouseCommand(mouseCommand,x,y, e) );
}

function mkMouseCommand(mouseCommand, x, y, e)
{ return 'Mouse '+mouseCommand+'(' + x + ',' + y + ',' + showModifiers(e) + ');';
}

var ie=document.all;
var nn6=document.getElementById&&!document.all;
var dragState = 0;

var mouseDownPos = { x:0, y: 0};
var dragOffset = { x: 0, y: 0 };
var draggable;
var draggedElementClone; // the clone that is moved on drag

/*
Cannot use element in mouse event because the focus div catches all events
Cannot use JQuery because it somehow fails for xhtml docs 
*/

function getDraggable(x,y)
{ 
//  var allDraggables = $('.Draggable');

  var allDraggables = document.getElementsByClassName('Draggable');
//  alert('draggables '+showElementsDimensions(allDraggables));
  return getContainingElement(x,y,allDraggables);
}


function cloneObject( obj ) {
    var clone = obj.cloneNode(true);
    clone.style.position = 'absolute';
    clone.id = 'draggedObject';

    var parent = document.getElementById('draggedElementCloneParent');

    parent.parentNode.appendChild(clone);
    return clone;
}


/* Precondition: elts are given depth first, so by going from n-1 to 0, we get the deepest
*/
function getContainingElement(x,y,elts)
{ var proxima = document.getElementById('proxima');
  var proximaDims = getElementDimensions( proxima );

  var elt;
  for (var i=elts.length-1; i >= 0 && !elt; i--)
    if (within(x + proximaDims.x, y + proximaDims.y, getElementDimensions(elts[i])))
      elt=elts[i];
    // x & y are relative to Proxima element and dimensions of the elements are not, so we add
    // the proxima x & y

  return elt;
}

function within(x,y, dims)
{ return x >= dims.x && y >= dims.y && x < dims.x+dims.w && y < dims.y+dims.h;
}

function getElementDimensions( elt )
{ var CalculatedTotalOffsetLeft = 0;
  var CalculatedTotalOffsetTop = 0 ;

  var Element = elt;
  while (Element.offsetParent)
  { CalculatedTotalOffsetLeft += Element.offsetLeft ;     
    CalculatedTotalOffsetTop += Element.offsetTop ;
    Element = Element.offsetParent ;
  }
  var dimensions = { x: CalculatedTotalOffsetLeft
                   , y: CalculatedTotalOffsetTop
                   , w: elt.offsetWidth
                   , h: elt.offsetHeight
                   };
  return dimensions;
}

function showElementsDimensions( elts )
{ var str = '';
  for (var i = 0; i < elts.length; i++)
  { str += elts[i] + showElementDimensions(elts[i])+'\n'; 
  }
  return str;
}

function showElementDimensions( elt )
{ var dim = getElementDimensions( elt );
  return '(('+dim.x+','+dim.y+'):('+dim.w+'x'+dim.h+'))';
}
                

function getMouseCoordsWithinTarget(event,Element)
{
  var scrollLeft = Element.scrollLeft;
  var scrollTop = Element.scrollTop;
  
        var coords = { x: 0, y: 0};

        if(!event) // then we have a non-DOM (probably IE) browser
        {
                event = window.event;
                coords.x = event.offsetX;
                coords.y = event.offsetY;
        }
        else       // we assume DOM modeled javascript
        {
                var CalculatedTotalOffsetLeft = 0;
                var CalculatedTotalOffsetTop = 0 ;

                while (Element.offsetParent)
                {
                        CalculatedTotalOffsetLeft += Element.offsetLeft ;     
                        CalculatedTotalOffsetTop += Element.offsetTop ;
                        Element = Element.offsetParent ;
                }

                coords.x = event.pageX - CalculatedTotalOffsetLeft + scrollLeft;
                coords.y = event.pageY - CalculatedTotalOffsetTop + scrollTop;
        }

        return coords;
}

function showModifiers(e )
{ return '(' + (e.shiftKey?'True':'False') + ',' +
               (e.ctrlKey?'True':'False') + ',' +
               (e.altKey?'True':'False') + ')'
}

// set the viewed area at server side according to size and scroll position of proxima
// element
function prependSetViewedAreaCommand()
{ var proxima = document.getElementById('proxima');
  commandQueue = commandQueue + 'SetViewedArea((' + proxima.scrollLeft + ',' + proxima.scrollTop +
                 '),(' + proxima.clientWidth + ',' + proxima.clientHeight + '));';
}

// scroll proxima element to show the viewed area
function setViewedAreaClient(x,y,w,h)
{ var proxima = document.getElementById('proxima');

  proxima.scrollLeft = x;
  proxima.scrollTop = y;
  internalScrollEvent = true
}

function downloadDocument()
{ location.href = 'Document.xml';
}

function uploadDocument()
{ removeKeyboardListeners();
  // disable keyboard, because the text field with a cursor suggests keys should go there
  // even while this field is not editable.

  // Keeping mouse events does not seem to be confusing.
  var uploadDialog = document.getElementById('uploadDialog');
  // setting visibility does not seem to work (text border and buttons still show),
  // so we keep the div at -2000px and move it to 200px to show it.
  uploadDialog.style.left = '200px';
}

function cancelUploadDocument()
{ addKeyboardListeners();
  var uploadDialog = document.getElementById('uploadDialog');
  uploadDialog.style.left = '-2000px';
}


var focusedElt; // string element that has the focus (used for predictive char rendering)
var focusIndex; // the index in the focused string

var currentPredictiveInserts = null; // inserts corresponding to the set of commands that will be sent to the server next

var sentPredictiveInserts = null;  // inserts corresponding to set of commands that were already sent to the server

var focusedEltOriginalText = null;



function removeAllPredictiveInserts()
{ if (focusedElt && focusedElt.childNodes[0] && focusedEltOriginalText)
    focusedElt.childNodes[0].textContent=focusedEltOriginalText;
    
  removePredictiveInserts( currentPredictiveInserts );
  removePredictiveInserts( sentPredictiveInserts );
}

function pause(milliseconds) {
	var dt = new Date();
	while ((new Date()) - dt <= milliseconds) { /* Do nothing */ }
}

function removePredictiveInserts(predictiveInserts)
{ if (predictiveInserts)
  { 
//alert( 'done: ' + sentPredictiveInserts.element.childNodes[0].textContent);
    for (var j=0; j < predictiveInserts.affectedElts.length; j++)
      predictiveInserts.affectedElts[j].element.style.left = predictiveInserts.affectedElts[j].originalLeft;
  }
}

function moveCurrentPredictiveInsertsToSent()
{ sentPredictiveInserts = currentPredictiveInserts;
  currentPredictiveInserts = null;
}

function clearSentPredictiveUpdates()
{ sentPredictiveInserts = null;
}

/* Re-apply the predictive inserts for requests that are currently being sent to the server
*/
function reApplySentPredictiveInserts()
{ if (focusedElt && focusedElt.childNodes[0])
  { focusedEltOriginalText = focusedElt.childNodes[0].textContent;
// messy: create an insert that does only this without registering stuff

    var w = focusedElt.clientWidth;


    if (sentPredictiveInserts)
    { //insertCharPredictively('X');
      for (var i=0; i < sentPredictiveInserts.chars.length; i++)
      {  var textNode = focusedElt.childNodes[0];
         textNode.insertData(focusIndex,sentPredictiveInserts.chars.charAt(i));
         focusIndex++;
      //insertCharPredictively(sentPredictiveInserts.chars.charAt(i));
      }
      //insertCharPredictively('X');
    
      var increase = focusedElt.clientWidth - w;

      var focusRenderingElt = document.getElementById('-2');
      focusRenderingElt.style.left = parseInt(focusRenderingElt.style.left) + increase  + 'px';

      var renderingElt = document.getElementById('proxima').childNodes[0]; // this is the rendering div (which has a variable id)
      var parent = focusedElt.parentNode;
      var elt = focusedElt;

      while ( parent != renderingElt && parent.getAttribute('class') != 'Column' )
      { var n = elt.nextSibling;
        while ( n )
        { // NOTE: why do we need to do this again (otherwise during long insert, sometimes too much right shift)    
          sentPredictiveInserts.affectedElts.push({element: n, originalLeft: n.style.left});
          n.style.left = parseInt(n.style.left) + increase + 'px';
          n = n.nextSibling;
        }
        elt = parent;
        parent = parent.parentNode;
      }
    }
  }
}
// todo: instead of not doing predictive inserts when focusedElt.childNodes[0] == null, we could
//       simply insert a textnode in this case. The parent seems to be there.
// todo: fix annoying bug that disables keyboard sometimes. (seems to be a firefox problem)
// todo: need to tag the text area, so we don't move above it (as is a problem in the decl. form)
//       this is now solved by stopping at columns

function insertCharPredictively(char)
{ if (focusedElt == null || focusedElt.childNodes[0] == null) return;

  var isNewPredictiveSession;

if ( currentPredictiveInserts )
    isNewPredictiveSession = false;
  else
  { isNewPredictiveSession = true
    currentPredictiveInserts = { requestId: currentRequestId, chars : '', element: focusedElt,
                                 affectedElts: new Array() };
  }

  currentPredictiveInserts.chars += char; // record the inserted char

  var w = focusedElt.clientWidth;
  var textNode = focusedElt.childNodes[0];
  textNode.insertData(focusIndex,char);
  focusIndex++;
  var increase = focusedElt.clientWidth - w;


  var focusRenderingElt = document.getElementById('-2');
  focusRenderingElt.style.left = parseInt(focusRenderingElt.style.left) + increase  + 'px';

  var renderingElt = document.getElementById('proxima').childNodes[0]; // this is the rendering div (which has a variable id)
  var parent = focusedElt.parentNode;
  var elt = focusedElt;

  while ( parent != renderingElt && parent.getAttribute('class') != 'Column' )
  { var n = elt.nextSibling;
    while ( n )
    { if (isNewPredictiveSession) // only at the first char insert, store the original positions of moved siblings
        currentPredictiveInserts.affectedElts.push({element: n, originalLeft: n.style.left});
      n.style.left = parseInt(n.style.left) + increase + 'px';
      n = n.nextSibling;
    }
    elt = parent;
    parent = parent.parentNode;
  }
}


function activateIPhoneKeyboard()
{ keyboardElt = document.getElementById('keyboardInput');
  keyboardElt.value = 'zaa';
  keyboardElt.focus();
  window.scrollTo(0, -480);
}

function orientationHandler()
{ if (window.orientation == 0 || window.orientation == 180)
  { proximaElt.style.width = '320px';
    proximaElt.style.height = '460px'; // 416 is without button and menu bar 356 is without button bar 334 is with
  }
  else
  { proximaElt.style.width = '480px';
    proximaElt.style.height = '300px'; // 416 is without button and menu bar 356 is without button bar 334 is with
  }

  refresh();
}

var touchAndHoldTimer;
var touchStartX;
var touchStartY;

function touchStartHandler(event)
{ clearTimeout(touchAndHoldTimer);
  touchStartX = event.touches[0].pageX;
  touchStartY = event.touches[0].pageY;
  touchAndHoldTimer = setTimeout('touchBasedContextMenu()',500);
  return true;
}

function touchMoveHandler(event)
{ if (event.touches[0].pageX-touchStartX  > 5 || event.touches[0].pageY-touchStartY > 5)
    clearTimeout(touchAndHoldTimer);
  else
  { touchStartX = event.touches[0].pageX;
    touchStartY = event.touches[0].pageY;
  }
}

function touchEndHandler(event)
{ clearTimeout(touchAndHoldTimer);
}

function touchBasedContextMenu()
{   sendCommand('ContextMenuRequest(('+touchStartX+','+touchStartY+'),('+touchStartX+','+touchStartY+'));');

}
/*
*/

function test()
{ alert(document.cookie);

}

]]></script>
</head>
<body onload="init()" onorientationchange="orientationHandler()"
                      ontouchstart="touchStartHandler(event)"
                      ontouchmove="touchMoveHandler(event)"
                      ontouchend="touchEndHandler(event)" 
                      leftmargin="0px" topmargin="0px" marginwidth="0px" marginheight="0px"> 
<!-- resize can be caught on body with onresize=... but it generates many events -->

<!-- <div style="position: absolute; border: 1px solid red; left:254px; top: 154px; width: 492px; height: 292px;"></div> -->
<!-- to show reduced viewed area 1000x600 with scrolling leaves a viewed area of ((246,146),(492,292)) to this we add 8 is added to left and top to account for margin above and left of proxima elt -->
<table id="rootTable" cellpadding="4" style="width: 100%; border-collapse: collapse; margin: 0px;  marginwidth: 0px">
<tr><td>
<div id="proxima" style="position: relative; border: 1px solid black; width: 100%; height: 620px; overflow:scroll; font-size : 18px; font-family: monospace; line-height: 0px;white-space:pre"
     onmousedown="hidemenuie5(event);return mouseHandler('D',event)"
     onmouseup="return mouseHandler('U',event)"
     onclick="return mouseHandler('C',event)"
     onmousemove="return mouseHandler('M',event)"
     oncontextmenu="return contextHandler(event)">
<div id="rendering"></div>
<div id="-2"></div>  <!-- -2 is the focus -->
<div id="newRendering" style='visibility: hidden; position: absolute; left: 0px; top: 0px;' ></div>
<div id="draggedElementCloneParent" style="visibility: hidden: position: absolute;"></div>
<div id="iPhoneStatus" style='visibility: hidden; position: absolute; right: 0px; bottom: 0px;'><img src="etc/statusGrey.jpg"/></div>
<div id="iPhoneKeyboardButton" style='visibility: hidden; position: absolute; left: 0px; bottom: 0px;'><img  onclick="activateIPhoneKeyboard ();" src="etc/keyboard.jpg"/></div>
</div>
<div id="uploadDialog" style='position: absolute; left:-2000px; top:200px;width:400px;height:120px; border: 2px solid black; background-color:white'>
<form action="upload" enctype="multipart/form-data" method="post">
<p/>
<center> Please select the document xml file to upload.
<p/>
<input type="file" name="documentFile" size="40"/>
<p/>
<input type="submit" value="Upload"/>&nbsp;&nbsp;&nbsp;<input type="button" value="Cancel" onclick="cancelUploadDocument();"/></center>

</form>
</div>
 <!-- relative to parent. Important: parent needs style = 'position: relative' -->
<div id='font' style='visibility:hidden;white-space: pre'></div>
<div id="contextMenu" class="skin0" onmouseover="return highlightie5(event)" onmouseout="lowlightie5(event)" onclick="jumptoie5(event)"></div>
</td></tr>

<div id="iPhoneKeyboard" style=' position: absolute; left: -500px; bottom: 0px;'><input onkeydown="iPhoneKeyHandler();" type="text" id="keyboardInput" autocapitalize="off"/></div>

<tr id="buttonBar"><td>
<table cellspacing="0" width="100%">
<tr>
<td><button onclick="downloadDocument();">Download</button></td>
<td><button onclick="uploadDocument();">Upload</button></td>
<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><button onclick="window.open('http://www.cs.uu.nl/wiki/bin/view/Proxima/ProximaUserManual');">User&nbsp;Manual</button>
</td>
<!-- <td><button onclick="sendCommand('ClearMetrics;')">Reload&nbsp;Font&nbsp;Metrics</button></td> --><!-- with normal space button text gets line breaks -->
<!-- <td><button onclick="test();">Test</button></td> -->

<td width="100%"></td>
<td><div id="status"><img src="etc/statusGrey.jpg"/></div></td>
</tr>
</table>
</td></tr>

</table>
<!-- <div style="visibility:hidden" id="sessionInfo"></div>
<div id="debugMessage"></div> -->
</body></html>







