<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
	  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- v1

IE problems
-SVG support
-use str.charAt(i) instead of str[i]
-offsetLeft, etc.?
-getElementsByClassName()      (see http://forums.devshed.com/javascript-development-115/javascript-get-all-elements-of-class-abc-24349.html)

-->
<html xml:lang="en" lang="en" xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>Proxima 2.0</title>


<style>
<![CDATA[

/* Context menu Script- (c) Dynamic Drive (www.dynamicdrive.com) Last updated: 01/08/22
For full source code and Terms Of Use, visit http://www.dynamicdrive.com */
.skin0{
position:absolute;
border:2px solid black;
background-color:menu;
font-family:Verdana;
line-height:14px;
cursor:default;
font-size:10px;
z-index:100;
visibility:hidden;
}

.menuItem{
padding-left:10px;
padding-right:10px;
}
]]>
</style>


<!-- <script type="text/javascript" src="img/jquery-1.3.2.js"></script> -->
<!-- JQuery gives an error with xml pages (div.style is undefined), which also disables Firebug.
-->
<script type="text/javascript">
<![CDATA[


var xmlhttp;
var mouseDown = false;
var commandQueue = '';
var currentRequestId = 0;

var sessionId;
var responseId;
var sessionType; // 'primary' or 'secondary'
var nrOfSessions;


function init()
{
    addKeyboardListeners();

  // context menus
  ie5=document.all&&document.getElementById;
  ns6=document.getElementById&&!document.all;
  menuobj=document.getElementById("contextMenu");
  menuobj.style.display='';
  //


//    setRefreshTimer(10);
    refresh();
   setViewedAreaServer();
    loadXMLDoc('Key(116,(False,False,False));'); // put this one in refresh?
}

function addKeyboardListeners()
{   if (document.addEventListener)
    {
       document.addEventListener("keydown",keydown,false);
       document.addEventListener("keyup",keyup,false);
       document.addEventListener("keypress",keypress,false);
    }
    else if (document.attachEvent) // IE7
    {
       document.attachEvent("onkeydown", keydown);
       document.attachEvent("onkeyup", keyup);
       document.attachEvent("onkeypress", keypress);
    }
    else
    {
       document.onkeydown= keydown;
       document.onkeyup= keyup;
       document.onkeypress= keypress;
    }
}

function removeKeyboardListeners()
{ if (document.addEventListener)
    { document.removeEventListener("keydown",keydown,false);
      document.removeEventListener("keyup",keyup,false);
      document.removeEventListener("keypress",keypress,false);
    }
    else if (document.attachEvent) // IE7
    { document.detachEvent("onkeydown", keydown);
      document.detachEvent("onkeyup", keyup);
      document.detachEvent("onkeypress", keypress);
    }
    else // TODO: don't know if this works:
    { document.onkeydown = "return false";
      document.onkeyup = "return false";
      document.onkeypress = "return false";
    } 
}

// Font queries
 
var beginRange = 32;
var endRange = 255;
  
function initFont()
{ var fontElt = document.getElementById('font');
  fontElt.innerHTML='';
  var lines = '<div id=\'lines\' style=\'position:absolute;"\'>';
  for (var c=beginRange; c<=endRange; c++)
  { var ch = c == 38 ? '&amp;' 
           : c == 60 ? '&lt;' 
           : c == 62 ? '&gt;' : String.fromCharCode(c);
    lines = lines + '<div style=\'position:absolute\'>'+replicate(1000,ch)+'</div>';
  }
  lines += '</div><div id="enclosing" style="position:absolute"><span id="text">X</span><span id="baseline" style="height:0px;font-size:0px">baseline</span></div>';
  fontElt.innerHTML=lines;
}

function queryFont(fontFamily, fontSize, isBold, isItalic)
{ //debugAdd('Font query: '+fontFamily+fontSize+isBold+isItalic);
  initFont(); // firefox does not update bounding divs on style update, so we need to init every time :-(
  
  var fontElt = document.getElementById('font');
  fontElt.style.fontFamily = fontFamily;
  fontElt.style.fontSize = fontSize+'pt';
  fontElt.style.fontWeight = isBold ? "bold" : "normal"
  fontElt.style.fontStyle = isItalic ? "italic" : "normal"

  var enclosing = document.getElementById('enclosing');
  var baselineElt = document.getElementById('baseline');
  var font = document.getElementById('text');
  var height = font.offsetHeight;
  var baseline = baselineElt.offsetTop - font.offsetTop;

  var metrics = '((\\"'+fontFamily+'\\",'+fontSize+','+
                (isBold ? 'True' : 'False') +',' + 
                (isItalic ? 'True' : 'False') + 
                '),('+height + ',' + baseline + ',';
  var linesElt = fontElt.childNodes[0];
  var widths = '%5b'; // escaped '['
  for (var childNr = 0; childNr <= endRange - beginRange; childNr++)
  { var line = linesElt.childNodes[childNr];
    widths += (childNr == 0 ? '' : ',') + (line.clientWidth);
  }
  widths += '%5d'; // escaped ']'
  metrics += widths + '))';
  return metrics;
}

function replicate(i,c)
{ var str = '';
  while (i-- > 0)
    str = str + c;
  return str;
}


// Context menu's

var ie5;
var ns6;
var menuobj;

function contextHandler(e)
{ var screenX = ie5 ? event.clientX
                    : e.clientX;
  var screenY = ie5 ? event.clientY
                    : e.clientY;

  var coords = getMouseCoordsWithinTarget(e, document.getElementById('proxima')); 

  // menu is not on proxima element, so position is absolute to window
  // however, proxima needs the position relative to the proxima element
  
  loadXMLDoc('ContextMenuRequest(('+coords.x+','+coords.y+'),('+screenX+','+screenY+'));');
  return false; // disable normal context menu
}


function highlightie5(e)
{ var firingobj=ie5? event.srcElement : e.target;
  if ( firingobj.className=="menuItem" ||
       ns6 && firingobj.parentNode.className=="menuItem")
  { if (ns6 && firingobj.parentNode.className=="menuItem") 
      firingobj=firingobj.parentNode; //up one node
    firingobj.style.backgroundColor="highlight";
    firingobj.style.color="white";
  }
}

function lowlightie5(e)
{ var firingobj=ie5? event.srcElement : e.target;
  if ( firingobj.className=="menuItem" ||
       ns6 && firingobj.parentNode.className=="menuItem")
  { if (ns6 && firingobj.parentNode.className=="menuItem") 
      firingobj=firingobj.parentNode; //up one node
    firingobj.style.backgroundColor="";
    firingobj.style.color="black";
  }
}

function jumptoie5(e)
{ var firingobj=ie5? event.srcElement : e.target;
  if( firingobj.className=="menuItem" ||
      ns6 && firingobj.parentNode.className=="menuItem" )
  { if (ns6&&firingobj.parentNode.className=="menuItem") 
      firingobj=firingobj.parentNode;
    else
    { var selectedItemNr = firingobj.getAttribute("item");
      loadXMLDoc('ContextMenuSelect('+selectedItemNr+');');     
      menuobj.style.visibility="hidden";
    }
  }
}

function showMenuXY(x,y)
{ // Find out how close the mouse is to the corner of the window
  var rightedge=ie5 ? document.body.clientWidth-x
                    : window.innerWidth-x;
  var bottomedge = ie5 ? document.body.clientHeight-y
                       : window.innerHeight-y;
  
  // if the horizontal distance isn't enough to accomodate the width of the context menu
  var left, top;
  
  if (rightedge < menuobj.offsetWidth)
    // move the horizontal position of the menu to the left by it's width
    left= ie5 ? document.body.scrollLeft+x-menuobj.offsetWidth 
                            : window.pageXOffset+x-menuobj.offsetWidth;
  else
    //position the horizontal position of the menu where the mouse was clicked
    left = ie5 ? document.body.scrollLeft+x 
                             : window.pageXOffset+x;

  // same concept with the vertical position
  if (bottomedge < menuobj.offsetHeight)
    top=ie5 ? document.body.scrollTop+y-menuobj.offsetHeight 
                          : window.pageYOffset+y-menuobj.offsetHeight
  else
    top=ie5 ? document.body.scrollTop+y 
                          : window.pageYOffset+y

  menuobj.style.left = left + 'px';
  menuobj.style.top = top + 'px';
  
  menuobj.style.visibility="visible";
}


function hidemenuie5(e)
{ menuobj.style.visibility="hidden";
}




// end Context menu's






function loadXMLDoc(url)
{ commandQueue = commandQueue + url;

  if ( xmlhttp && xmlhttp.readyState != 0 && xmlhttp.readyState != 4)
    return; // if xmlhttp exists and was initialized and not ready, we return
            // TODO: can readyState == 0 happen?  
             
xmlhttp=null;
if (window.XMLHttpRequest)
  { // code for Firefox, Opera, IE7, etc.
    xmlhttp=new XMLHttpRequest();
  }
else if (window.ActiveXObject)
  { // code for IE6, IE5
    xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
  }
if (xmlhttp!=null)
  { 
    { xmlhttp.onreadystatechange=state_Change;
      xmlhttp.open("GET",'handle?commands=Commands '+ currentRequestId +' "'+commandQueue+'"',true);
      xmlhttp.send(null);     // commands are terminated by semicolons
      if (sessionType == 'primary')
        document.getElementById('status').innerHTML = '<img src="etc/statusBlue.jpg"/>';
      else
        document.getElementById('status').innerHTML = '<img src="etc/statusRed.jpg"/>';

      currentRequestId++;
//      debugAdd('incremented currentRequestId: ' + currentRequestId);
      moveCurrentPredictiveInsertsToSent();
      commandQueue = '';
    }
  }
else
  { alert("Your browser does not support XMLHTTP.");
  }
}

function state_Change()
{
if (xmlhttp.readyState==4)
  {// 4 = "loaded"
  if (xmlhttp.status==200)
    {// 200 = "OK"
    
    var newRendering = document.getElementById('newRendering');
    newRendering.innerHTML=xmlhttp.responseText;
    
    removeAllPredictiveInserts();
    clearSentPredictiveUpdates();
      
    if (commandQueue != '')
    { //debugAdd('sending queue');
      loadXMLDoc('');
    }
    else
      if (sessionType == 'primary')
        document.getElementById('status').innerHTML = '<img src="etc/statusGreen.jpg"/>';
      else
        document.getElementById('status').innerHTML = '<img src="etc/statusRed.jpg"/>';
    
    var focus = document.getElementById('focus');
    
    
    var updates = document.getElementById('updates');
    // getElementById seems to trigger parsing the responseText
    // after this, firstChild has a value, while it is null before
                // newRendering.firstChild;

    sessionId = updates.getAttribute('sessionId');
    responseId = updates.getAttribute('responseId');
    sessionType = updates.getAttribute('sessionType');
    nrOfSessions = updates.getAttribute('nrOfSessions');
    document.getElementById('sessionInfo').innerHTML =
      'Session id: ' + sessionId + ':' + responseId + ' '  +
      (sessionType == 'primary' ? 'Editable' : 'Non-editable') + ' ' +
      'Nr of sessions:' + nrOfSessions;

   
    while (updates.firstChild)
    { updateTree( updates.firstChild );
      updates.removeChild(updates.firstChild);
    }
    reApplySentPredictiveInserts();

    //var renderArea = document.getElementById('renderArea');
    //renderArea.removeChild( document.getElementById('root') ); //old rendering

    //var xmlRoot = xmlhttp.responseXML.firstChild;
    
    
    //renderingRoot = document.getElementById('root');
    //newRendering.removeChild( renderingRoot );
    
    //renderArea.appendChild( renderingRoot );
    
    //while (renderArea.firstChild) {
    //  renderArea.removeChild(renderArea.firstChild);
    //}
    //
    // getElementById does not seem to work for dynamically added XML nodes.
    

    
    //var status = xmlRoot.getAttribute("status");
    //if (status !='')
    //  document.getElementById('status').innerHTML = status;
    }
  else
    {
    debug("Problem retrieving data:" + xmlhttp.statusText);
//    document.getElementById('status').innerHTML='Server not available.';
    }
  }
}
var theOp ;
function updateTree(update)
{ var op = update.getAttribute('op');
  theOp = op;
 /*
  if (op == 'add')
  { var parentId = update.getAttribute('parentId');
    var newChild = update.firstChild;
    var parent = document.getElementById(parentId);
    parent.appendChild( newChild );
//    debug('add to '+parentId+' '+newChild.getAttribute('Id'));
  }    
  else if (op == 'remove')
  { var parentId = update.getAttribute('parentId');
    var targetId = update.getAttribute('targetId');
    var parent = document.getElementById(parentId);
    if (parent==null)
    { debug('parent '+parentId+' is null');
      return;
    }
    
    var target = document.getElementById(targetId);
    parent.removeChild( target );
//    debug('remove '+targetId+' from '+parentId);
  } 
  else 
  */
  if (op == 'replace')
  { var path = update.childNodes[0];
    var newChild = update.childNodes[1];
    
    var oldChild = select(path, document.getElementById('proxima'));
    
    var parent = oldChild.parentNode;
    
    parent.replaceChild(newChild,oldChild);
      
//    debug('replace '+targetId+' at '+parentId+' by '+newChild.getAttribute('Id'));
  } else if (op == 'move')
  { var path = update.childNodes[0];
    var node = select(path, document.getElementById('proxima'));

    var renderingElt = document.getElementById('proxima').childNodes[0];
    // this is the rendering div (which has a variable id)

    node.style.left = node.offsetLeft +  parseInt( update.getAttribute('x') )+'px';
    node.style.top = node.offsetTop + parseInt( update.getAttribute('y') )+'px';
    node.style.width = node.offsetWidth + parseInt( update.getAttribute('w') )+'px';
    node.style.height = node.offsetHeight + parseInt( update.getAttribute('h') )+'px';
      
    if (node != renderingElt) // for the rendering root, don't move siblings
    { node = node.nextSibling;
      while (node) // move the node and all it's siblings in the row/column
      { node.style.left = node.offsetLeft +  parseInt( update.getAttribute('x') )+'px';
        node.style.top = node.offsetTop + parseInt( update.getAttribute('y') )+'px';
        node = node.nextSibling;
      }
    }
//    debugAdd('move');
  } else if (op == 'insert')
  { var path = update.childNodes[0];
    var parentNode = select(path, document.getElementById('proxima'));
    var pos = parseInt(update.getAttribute('pos'));
    var nr = parseInt(update.getAttribute('nr'));
  
    var nextChild = parentNode.childNodes[pos];

    // insert nr dummy divs at position pos (in case parent has no elements, and no nextChild, we append the elements)
    // when parent is non-empty dummies are inserted in reverse order, but since they are identical, this is no problem.
    // when parent is empty, dummies are inserted in normal order because nextChild is not updated and we keep on appending.
    for(var i = 0; i < nr; i++)
    { var dummy = document.createElement('div');
      if (nextChild)
        parentNode.insertBefore(dummy, nextChild);
      else
        parentNode.appendChild(dummy);
    }
//    debugAdd('insert '+pos+ ' '+nr);
  } else if (op == 'delete')
  { var path = update.childNodes[0];
    var parentNode = select(path, document.getElementById('proxima'));
    var pos = parseInt(update.getAttribute('pos'));
    var nr = parseInt(update.getAttribute('nr'));

    for(var i = 0; i < nr; i++)
      parentNode.removeChild(parentNode.childNodes[pos]); // after remove, the next child to remove will also be at pos
//    debugAdd('delete '+pos+ ' '+nr);
  } else if (op == 'contextMenu')
  { var screenX = update.getAttribute('screenX');
    var screenY = update.getAttribute('screenY');
    
    removeChildren('contextMenu');
    
    while (update.firstChild)
    { var item = update.firstChild;
      update.removeChild(update.firstChild);
      menuobj.appendChild( item );
    } // using appendChild directly also seems to remove the child from update
      // but maybe this is not the same for all browsers
    
    showMenuXY(screenX,screenY);
    
  }
  else if (op == 'metricsQuery')
  { var family = update.getAttribute('family');
    var size = update.getAttribute('size');
    var isBold = update.getAttribute('isBold') == 'True';
    var isItalic = update.getAttribute('isItalic') == 'True';
    //alert(family+size+isBold+isItalic);    
    // strange: allowing this alert screws up the rendering!
    
    var metrics = queryFont(family,size,isBold,isItalic);
    //debugAdd('query is Metrics'+metrics+';');
    loadXMLDoc('Metrics'+metrics+';');
  }
  else if (op == 'setViewedArea')
  { var x = update.getAttribute('x');
    var y = update.getAttribute('y');
    var w = update.getAttribute('w');
    var h = update.getAttribute('h');

    setViewedAreaClient(x,y,w,h);    
  }
  
  else if (op == 'refresh')
  { refresh();
    loadXMLDoc('Key(116,(False,False,False));'); // put this one in refresh?
  }
  else if (op == 'alert')
  { alert (update.getAttribute('text'));
  }
  else if (op == 'setFocusedId')
  { var path = update.childNodes[0];
    focusedElt = select(path, document.getElementById('proxima'));
    focusIndex = update.getAttribute('index');
  }
  else alert ('Unknown command: '+op); 
}

function select(path, node)
{ var step = path.firstChild;
  if (!step)
    return node;
  else
    { path.removeChild(step);
      var childNr = parseInt( step.getAttribute('childNr') ); 
      if (node)
      { var child = node.childNodes[childNr];
        return (select (path, child));
      }
      else alert ('incorrect path at op: '+theOp);
    }
}

function debug(message)
{
    document.getElementById('debugMessage').innerHTML=message;
}

function debugAdd(message)
{
    debug (message + '<br></br>' + document.getElementById('debugMessage').innerHTML);
}

function setStatus(message)
{
    document.getElementById('status').innerHTML=message;
}


function refresh()
{ removeChildren('rendering');
  removeChildren('focus');
  removeChildren('newRendering');
  removeChildren('contextMenu');
}

function removeChildren(parentId)
{ var parent = document.getElementById(parentId);
    while (parent.firstChild)
      parent.removeChild(parent.firstChild);
}

function keypress(e)
{
  if (!e) e= event;
   var keyCode =  (e.keyCode != 0) ? e.keyCode : e.charCode
   // keyCode is 0 on Firefox
   
//  debugAdd('Key is '+keyCode +',' + e.charCode);
  if (keyCode==102 && e.ctrlKey) // ctrl-f
  { var answer=prompt("Enter search term.");
// todo: escape answer string
   if (answer) loadXMLDoc('Find "'+answer+'";');
    return false;
  }
  if (keyCode==98 && e.ctrlKey) // ctrl-b
  { loadXMLDoc('EditStyle SetBold;');
    return false;
  }
 if (keyCode==66 && e.ctrlKey) // ctrl-B
  { loadXMLDoc('EditStyle ClearBold;');
    return false;
  }
  if (keyCode==105 && e.ctrlKey) // ctrl-i
  { loadXMLDoc('EditStyle SetItalic;');
    return false;
  }
  if (keyCode==73 && e.ctrlKey) // ctrl-I
  { loadXMLDoc('EditStyle ClearItalic;');
    return false;
  }
  if (keyCode==48 && e.ctrlKey) // ctrl-0
  { loadXMLDoc('EditStyle (SetColor (0,0,0));');
    return false;
  }
  if (keyCode==49 && e.ctrlKey) // ctrl-1
  { loadXMLDoc('EditStyle (SetColor (255,0,0));');
    return false;
  }
  if (keyCode==50 && e.ctrlKey) // ctrl-2
  { loadXMLDoc('EditStyle (SetColor (0,0,255));');
    return false;
  }

  if (e.which != 0 && keyCode != 8 && keyCode != 13)
  { if (!(e.ctrlKey || e.altKey || e.metaKey))
      insertCharPredictively( String.fromCharCode(keyCode) );
    loadXMLDoc('Chr('+keyCode+','+showModifiers(e)+');');
  }
// maybe also check alt, ctrl and  other keys, they seem to generate press events now
   
   if (e.preventDefault) e.preventDefault();
   if (e.stopPropagation) e.stopPropagation();

   return false;
}

function hasNoKeyPress(keyCode)
{
   return keyCode == 13 || keyCode == 8 || keyCode == 46 ||
          keyCode >= 37 && keyCode <= 40||
          keyCode >= 112 && keyCode <= 123;

}


function keydown(e)
{  if (!e) e = event;
   if (e.keyCode==116)
     refresh();
 
   if (hasNoKeyPress(e.keyCode) || e.ctrlKey || e.altKey || e.metaKey)
   {
     loadXMLDoc('Key('+e.keyCode+','+showModifiers(e)+');');
     if (e.preventDefault) e.preventDefault();
     if (e.stopPropagation) e.stopPropagation();
     return false; // false, so no keyPress event is generated
   }
   return true;
}
/* for preventing default behavior: (unclear whether or how this works)     
     if (e.preventDefault) e.preventDefault();
     if (e.stopPropagation) e.stopPropagation();
*/

function keyup(e)
{
}

function ignore(e)
{
   if (e.preventDefault) e.preventDefault();
   if (e.stopPropagation) e.stopPropagation();

   return false;
}

var scrollInProgress = false;

function mouseHandler(str,e) 
{ if (e.button != 0) return true;  // only handle left button here

  var proxima = document.getElementById('proxima');

  var coords = getMouseCoordsWithinTarget(e,proxima);
  var posx = coords.x;
  var posy = coords.y;
  
  /* We don't use scroll events, because setting scrollLeft and scrollTop also fires these events, and
     it does not seem possible to disable the handler temporarily */
  if (scrollInProgress)
  { if (str == 'U')
    { scrollInProgress = false;
      setViewedAreaServer();
      return true;
    }
    else if (str == 'M')
    { if (commandQueue == "")
        setViewedAreaServer(); // during scroll, only update if no other commands in queue, to prevent flooding
      return true;
    }
    // mouse down cannot occur
  }

  if ( (posx - proxima.scrollLeft) > proxima.clientWidth || (posy - proxima.scrollTop) > proxima.clientHeight )
    // we're on a scroll bar (either dragging or on a button), so set viewed area on mouse up.
  { if (str == 'D')
      scrollInProgress = true;
    return true;
  }

//  setStatus( 'dragState is '+dragState + ' origin(' + mouseDownPos.x + ',' + mouseDownPos.y + ') offset(' + dragOffset.x + ',' + dragOffset.y + ')' );

  
  switch(dragState)
  { case 0: // no button down
      if (str == 'D')
      { dragState = 1;
        mouseDownPos = { x: posx, y: posy };

        draggable = getDraggable(mouseDownPos.x, mouseDownPos.y);
        if ( !draggable )
        { sendMouseCommand('MouseDown', mouseDownPos.x, mouseDownPos.y, e);                     
        }
      } // all other mouse actions are ignored when button was not down
      break;

    case 1: // button down, no drag
      if (str =='U')
      { loadXMLDoc( (draggable ? mkMouseCommand('MouseDown', mouseDownPos.x, mouseDownPos.y, e) : '') +
                    // if there's a draggable, the mouse down was not yet sent
                    mkMouseCommand('MouseUp', posx, posy, e)   );
        draggable = null;
        dragState = 0;
      }
      else if (str == 'M')
      { if ( draggable )
        { draggedElementClone = cloneObject(draggable);

          draggableDims = getElementDimensions( draggable );
          var proximaDims = getElementDimensions( proxima );

          dragOffset = { x: mouseDownPos.x + proximaDims.x - draggableDims.x
                       , y: mouseDownPos.y + proximaDims.y - draggableDims.y
                       }
          draggedElementClone.style.left = posx-dragOffset.x +'px';
          draggedElementClone.style.top = posy-dragOffset.y +'px';

          sendMouseCommand('MouseDragStart', posx, posy, e);
          dragState = 2;
        }
        else
        { sendMouseCommand('MouseMove', posx, posy, e);
          dragState = 3;
        }
      } // ignore mouse down (should not occur)
      break;

    case 2: // drag in progress
      if ( str == 'U' )
      { sendMouseCommand('MouseDrop', posx, posy, e);
        draggedElementClone.parentNode.removeChild(draggedElementClone);
        draggedElementClone = null;
        draggable = null;
        dragState = 0;
      }
      else if ( str == 'M' )
      { draggedElementClone.style.left = posx-dragOffset.x +'px';
        draggedElementClone.style.top = posy-dragOffset.y +'px';
      } // ignore mouse down (should not occur)
      break;

    case 3: // dragging on non-dragsource (e.g. extending focus)
      if ( str == 'U' )
      { sendMouseCommand('MouseUp', posx, posy, e);
        dragState = 0;
      }
      else if ( str == 'M' )
      { sendMouseCommand('MouseMove', posx, posy, e);
      } // ignore mouse down (should not occur)
      break;
  }

  return false; // don't let browser handle mouse events
}

function sendMouseCommand(mouseCommand, x, y, e)
{ loadXMLDoc( mkMouseCommand(mouseCommand,x,y, e) );
}

function mkMouseCommand(mouseCommand, x, y, e)
{ return 'Mouse '+mouseCommand+'(' + x + ',' + y + ',' + showModifiers(e) + ');';
}

var ie=document.all;
var nn6=document.getElementById&&!document.all;
var dragState = 0;

var mouseDownPos = { x:0, y: 0};
var dragOffset = { x: 0, y: 0 };
var draggable;
var draggedElementClone; // the clone that is moved on drag

/*
Cannot use element in mouse event because the focus div catches all events
Cannot use JQuery because it somehow fails for xhtml docs 
*/

function getDraggable(x,y)
{ 
//  var allDraggables = $('.Draggable');

  var allDraggables = document.getElementsByClassName('Draggable');
//  alert('draggables '+showElementsDimensions(allDraggables));
  return getContainingElement(x,y,allDraggables);
}


function cloneObject( obj ) {
    var clone = obj.cloneNode(true);
    clone.style.position = 'absolute';
    clone.id = 'draggedObject';

    var parent = document.getElementById('draggedElementCloneParent');

    parent.parentNode.appendChild(clone);
    return clone;
}


/* Precondition: elts are given depth first, so by going from n-1 to 0, we get the deepest
*/
function getContainingElement(x,y,elts)
{ var proxima = document.getElementById('proxima');
  var proximaDims = getElementDimensions( proxima );

  var elt;
  for (var i=elts.length-1; i >= 0 && !elt; i--)
    if (within(x + proximaDims.x, y + proximaDims.y, getElementDimensions(elts[i])))
      elt=elts[i];
    // x & y are relative to Proxima element and dimensions of the elements are not, so we add
    // the proxima x & y

  return elt;
}

function within(x,y, dims)
{ return x >= dims.x && y >= dims.y && x < dims.x+dims.w && y < dims.y+dims.h;
}

function getElementDimensions( elt )
{ var CalculatedTotalOffsetLeft = 0;
  var CalculatedTotalOffsetTop = 0 ;

  var Element = elt;
  while (Element.offsetParent)
  { CalculatedTotalOffsetLeft += Element.offsetLeft ;     
    CalculatedTotalOffsetTop += Element.offsetTop ;
    Element = Element.offsetParent ;
  }
  var dimensions = { x: CalculatedTotalOffsetLeft
                   , y: CalculatedTotalOffsetTop
                   , w: elt.offsetWidth
                   , h: elt.offsetHeight
                   };
  return dimensions;
}

function showElementsDimensions( elts )
{ var str = '';
  for (var i = 0; i < elts.length; i++)
  { str += elts[i] + showElementDimensions(elts[i])+'\n'; 
  }
  return str;
}

function showElementDimensions( elt )
{ var dim = getElementDimensions( elt );
  return '(('+dim.x+','+dim.y+'):('+dim.w+'x'+dim.h+'))';
}
                

function getMouseCoordsWithinTarget(event,Element)
{
  var scrollLeft = Element.scrollLeft;
  var scrollTop = Element.scrollTop;
  
        var coords = { x: 0, y: 0};

        if(!event) // then we have a non-DOM (probably IE) browser
        {
                event = window.event;
                coords.x = event.offsetX;
                coords.y = event.offsetY;
        }
        else       // we assume DOM modeled javascript
        {
                var CalculatedTotalOffsetLeft = 0;
                var CalculatedTotalOffsetTop = 0 ;

                while (Element.offsetParent)
                {
                        CalculatedTotalOffsetLeft += Element.offsetLeft ;     
                        CalculatedTotalOffsetTop += Element.offsetTop ;
                        Element = Element.offsetParent ;
                }

                coords.x = event.pageX - CalculatedTotalOffsetLeft + scrollLeft;
                coords.y = event.pageY - CalculatedTotalOffsetTop + scrollTop;
        }

        return coords;
}

function showModifiers(e )
{ return '(' + (e.shiftKey?'True':'False') + ',' +
               (e.ctrlKey?'True':'False') + ',' +
               (e.altKey?'True':'False') + ')'
}

// set the viewed area at server side according to size and scroll position of proxima
// element
function setViewedAreaServer()
{ var proxima = document.getElementById('proxima');
//    debug('scroll '+ proxima.scrollLeft + ',' +proxima.scrollTop); 
  loadXMLDoc('SetViewedArea((' + proxima.scrollLeft + ',' + proxima.scrollTop +
              '),(' + proxima.clientWidth + ',' + proxima.clientHeight + '));');
}

// scroll proxima element to show the viewed area
function setViewedAreaClient(x,y,w,h)
{ var proxima = document.getElementById('proxima');

  proxima.scrollLeft = x;
  proxima.scrollTop = y;
  internalScrollEvent = true
}

function downloadDocument()
{ location.href = 'Document.xml';
}

function uploadDocument()
{ removeKeyboardListeners();
  // disable keyboard, because the text field with a cursor suggests keys should go there
  // even while this field is not editable.

  // Keeping mouse events does not seem to be confusing.
  var uploadDialog = document.getElementById('uploadDialog');
  // setting visibility does not seem to work (text border and buttons still show),
  // so we keep the div at -2000px and move it to 200px to show it.
  uploadDialog.style.left = '200px';
}

function cancelUploadDocument()
{ addKeyboardListeners();
  var uploadDialog = document.getElementById('uploadDialog');
  uploadDialog.style.left = '-2000px';
}


var focusedElt; // string element that has the focus (used for predictive char rendering)
var focusIndex; // the index in the focused string

var currentPredictiveInserts = null; // inserts corresponding to the set of commands that will be sent to the server next

var sentPredictiveInserts = null;  // inserts corresponding to set of commands that were already sent to the server

var focusedEltOriginalText = null;



function removeAllPredictiveInserts()
{ if (focusedElt && focusedElt.childNodes[0] && focusedEltOriginalText)
    focusedElt.childNodes[0].textContent=focusedEltOriginalText;
    
  removePredictiveInserts( currentPredictiveInserts );
  removePredictiveInserts( sentPredictiveInserts );
}

function pause(milliseconds) {
	var dt = new Date();
	while ((new Date()) - dt <= milliseconds) { /* Do nothing */ }
}

function removePredictiveInserts(predictiveInserts)
{ if (predictiveInserts)
  { 
//alert( 'done: ' + sentPredictiveInserts.element.childNodes[0].textContent);
    for (var j=0; j < predictiveInserts.affectedElts.length; j++)
      predictiveInserts.affectedElts[j].element.style.left = predictiveInserts.affectedElts[j].originalLeft;
  }
}

function moveCurrentPredictiveInsertsToSent()
{ sentPredictiveInserts = currentPredictiveInserts;
  currentPredictiveInserts = null;
}

function clearSentPredictiveUpdates()
{ sentPredictiveInserts = null;
}

/* Re-apply the predictive inserts for requests that are currently being sent to the server
*/
function reApplySentPredictiveInserts()
{ if (focusedElt && focusedElt.childNodes[0])
  { focusedEltOriginalText = focusedElt.childNodes[0].textContent;
// messy: create an insert that does only this without registering stuff

    var w = focusedElt.clientWidth;


    if (sentPredictiveInserts)
    { //insertCharPredictively('X');
      for (var i=0; i < sentPredictiveInserts.chars.length; i++)
      {  var textNode = focusedElt.childNodes[0];
         textNode.insertData(focusIndex,sentPredictiveInserts.chars.charAt(i));
         focusIndex++;
      //insertCharPredictively(sentPredictiveInserts.chars.charAt(i));
      }
      //insertCharPredictively('X');
    
      var increase = focusedElt.clientWidth - w;

      var focusRenderingElt = document.getElementById('-2');
      focusRenderingElt.style.left = parseInt(focusRenderingElt.style.left) + increase  + 'px';

      var renderingElt = document.getElementById('proxima').childNodes[0]; // this is the rendering div (which has a variable id)
      var parent = focusedElt.parentNode;
      var elt = focusedElt;

      while ( parent != renderingElt && parent.getAttribute('class') != 'Column' )
      { var n = elt.nextSibling;
        while ( n )
        { // NOTE: why do we need to do this again (otherwise during long insert, sometimes too much right shift)    
          sentPredictiveInserts.affectedElts.push({element: n, originalLeft: n.style.left});
          n.style.left = parseInt(n.style.left) + increase + 'px';
          n = n.nextSibling;
        }
        elt = parent;
        parent = parent.parentNode;
      }
    }
  }
}
// todo: instead of not doing predictive inserts when focusedElt.childNodes[0] == null, we could
//       simply insert a textnode in this case. The parent seems to be there.
// todo: fix annoying bug that disables keyboard sometimes. (seems to be a firefox problem)
// todo: need to tag the text area, so we don't move above it (as is a problem in the decl. form)
//       this is now solved by stopping at columns
// does not take into account non-editable
// modified strings are not reset yet. Usually this will be done by next rendering
// except when insert does not change the string with focus (as in non-editable)

// one time there was a textNode undefined problem, while all calls to insertChar were commented out..
// and also insert did not work on new lines. maybe this can occur again, what happens if there is no element at the focus?
// todo affectedElts maybe original elts?

function insertCharPredictively(char)
{ if (focusedElt == null || focusedElt.childNodes[0] == null) return;

  var isNewPredictiveSession;

if ( currentPredictiveInserts )
    isNewPredictiveSession = false;
  else
  { isNewPredictiveSession = true
    currentPredictiveInserts = { requestId: currentRequestId, chars : '', element: focusedElt,
                                 affectedElts: new Array() };
  }

  currentPredictiveInserts.chars += char; // record the inserted char

  var w = focusedElt.clientWidth;
  var textNode = focusedElt.childNodes[0];
  textNode.insertData(focusIndex,char);
  focusIndex++;
  var increase = focusedElt.clientWidth - w;


  var focusRenderingElt = document.getElementById('-2');
  focusRenderingElt.style.left = parseInt(focusRenderingElt.style.left) + increase  + 'px';

  var renderingElt = document.getElementById('proxima').childNodes[0]; // this is the rendering div (which has a variable id)
  var parent = focusedElt.parentNode;
  var elt = focusedElt;

  while ( parent != renderingElt && parent.getAttribute('class') != 'Column' )
  { var n = elt.nextSibling;
    while ( n )
    { if (isNewPredictiveSession) // only at the first char insert, store the original positions of moved siblings
        currentPredictiveInserts.affectedElts.push({element: n, originalLeft: n.style.left});
      n.style.left = parseInt(n.style.left) + increase + 'px';
      n = n.nextSibling;
    }
    elt = parent;
    parent = parent.parentNode;
  }
}


function test(char)
{
  insertCharPredictively('A');
  loadXMLDoc('Chr(65,(False,False,False));');
}
]]></script>
</head>
<body onload="init()">
<!-- <div id="status" style="border: 1px solid black; height: 22px; width: 1000px; font-size : 18px; font-family: monospace; line-height: 20px;" ></div> -->

<!-- <div style="position: absolute; border: 1px solid red; left:254px; top: 154px; width: 492px; height: 292px;"></div> -->
<!-- to show reduced viewed area 1000x600 with scrolling leaves a viewed area of ((246,146),(492,292)) to this we add 8 is added to left and top to account for margin above and left of proxima elt -->
<table cellpadding="0">
<tr><td>
<div id="proxima" style="position: relative; border: 1px solid black; width: 770px; height: 435px; overflow:auto; font-size : 18px; font-family: monospace; line-height: 0px;white-space:pre"
     onmousedown="hidemenuie5(event);return mouseHandler('D',event)"
     onmouseup="return mouseHandler('U',event)"
     onclick="return mouseHandler('C',event)"
     onmousemove="return mouseHandler('M',event)"
     oncontextmenu="return contextHandler(event)"
><div id="rendering" 
     ></div><div id="focus"></div><div id="newRendering" style='position: absolute; left: 1000px; top: 0px;' ></div>
     <div id="draggedElementCloneParent" style="position: relative; height: 10000px; width: 10000px;"></div>
</div>
<div id="uploadDialog" style='position: absolute; left:-2000px; top:200px;width:400px;height:120px; border: 2px solid black; background-color:white'>
<form action="upload" enctype="multipart/form-data" method="post">
<p/>
<center> Please select the document xml file to upload.
<p/>
<input type="file" name="documentFile" size="40"/>
<p/>
<input type="submit" value="Upload"/>&nbsp;&nbsp;&nbsp;<input type="button" value="Cancel" onclick="cancelUploadDocument();"/></center>

</form>
</div>
 <!-- relative to parent. Important: parent needs style = 'position: relative' -->
<div id='font' style='visibility:hidden;white-space: pre'></div>
<div id="contextMenu" class="skin0" onmouseover="return highlightie5(event)" onmouseout="lowlightie5(event)" onclick="jumptoie5(event)"></div>
</td></tr>
<tr><td>
<table cellspacing="0" width="100%">
<tr>
<td><button onclick="downloadDocument();">Download</button></td>
<td><button onclick="uploadDocument();">Upload</button></td>
<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td><button onclick="loadXMLDoc('ClearMetrics;Key(116,(False,False,False));');window.location.reload( true)">Reload&nbsp;Font&nbsp;Metrics</button></td> <!-- with normal space button text gets line breaks -->
<!-- <td><button onclick="test('X');">Test</button></td> -->
<td width="100%"></td>
<td><div id="status"></div></td>
</tr>
</table>
</td></tr></table>
<div style="visibility:hidden" id="sessionInfo"></div>
<div id="debugMessage"></div>
</body></html>






<!-- font positioning goes wrong: text is drawn at half-height ref at top of div box
<div style='position:absolute;left:20px;top:10px;width:463px;height:29px;font-family:"Times New Roman";font-size:19pt;background-color:rgb(120,120,120);'>B</div>
-->
<!-- weird rendering when line-height /= 0px
<div style='position: absolute; left:0px; top:0px;width:40px;height:40px;'>
<svg width='100%' height='100%' version='1.1' xmlns='http://www.w3.org/2000/svg'>
<polygon points='1,1 40,1' style='fill:transparent; stroke:rgb(255,0,0);stroke-width:1'/>
<line x1='1' y1='1' x2='40' y2='' style='stroke:rgb(0,0,0);stroke-width:1'/>
</svg></div>
-->

<!--
<div style='position: absolute; left:0px; top:0px;width:17px;height:4px;'>
      <svg width='100%' height='100%' version='1.1' xmlns='http://www.w3.org/2000/svg'>
       <polygon points='0,0 14,0' style='fill:transparent; stroke:rgb(255,0,0);stroke-width:1'/>
      </svg>
</div>
-->
<!-- strange rendering of poly's when height is less than 4
  <div style='position: absolute; left:0px; top:0px;width:15px;height:21px;'>
     <div style='position: absolute; left:-1px; top:-1px;width:17px;height:4px;'>
      <svg width='100%' height='100%' version='1.1' xmlns='http://www.w3.org/2000/svg'>
       <polygon points='0,0 14,0' style='fill:transparent; stroke:rgb(255,0,0);stroke-width:1'/>
      </svg>
     </div>
   <div style='position: absolute; left:0px; top:1px;width:15px;height:19px;'>
     <div style='position: absolute; left:-1px; top:-1px;width:5px;height:21px;'>
      <svg width='100%' height='100%' version='1.1' xmlns='http://www.w3.org/2000/svg'>
       <polygon points='0,0 0,18' style='fill:transparent; stroke:rgb(0,0,0);stroke-width:1'/>
      </svg>
     </div>
    <div style='position:absolute;left:1px;top:0px;width:13px;height:19px;'>
      <div style='position:absolute;left:0px;top:9px;width:13px;height:19px;font-family:"Times New Roman";font-size:12pt;color:rgb(0,0,0);'>zu</div>
    </div>
     <div style='position: absolute; left:13px; top:-1px;width:5px;height:21px;'>
      <svg width='100%' height='100%' version='1.1' xmlns='http://www.w3.org/2000/svg'>
       <polygon points='0,0 0,18' style='fill:transparent; stroke:rgb(0,0,0);stroke-width:1'/>
      </svg>
     </div>
   </div>
    <div style='position: absolute; left:-1px; top:19px;width:17px;height:4px;'>
     <svg width='100%' height='100%' version='1.1' xmlns='http://www.w3.org/2000/svg'>
      <polygon points='0,0 14,0' style='fill:transparent; stroke:rgb(0,0,0);stroke-width:1'/>
     </svg>
    </div>
  </div>

-->













