<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
	  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- v1

IE problems
-SVN support
-use str.charAt(i) instead of str[i]
-getElementsByClassName()      (see http://forums.devshed.com/javascript-development-115/javascript-get-all-elements-of-class-abc-24349.html)

-->
<html xml:lang="en" lang="en" xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>Proxima 2.0</title>


<style>
<![CDATA[

/* Context menu Script- (c) Dynamic Drive (www.dynamicdrive.com) Last updated: 01/08/22
For full source code and Terms Of Use, visit http://www.dynamicdrive.com */
.skin0{
position:absolute;
border:2px solid black;
background-color:menu;
font-family:Verdana;
line-height:14px;
cursor:default;
font-size:10px;
z-index:100;
visibility:hidden;
}

.menuItem{
padding-left:10px;
padding-right:10px;
}
]]>
</style>


<!-- <script type="text/javascript" src="img/jquery-1.3.2.js"></script> -->
<!-- JQuery gives an error with xml pages (div.style is undefined), which also disables Firebug.
-->
<script type="text/javascript">
<![CDATA[


var xmlhttp;
var mouseDown = false;
var commandQueue = '';
var requestId = 0;

var focusedElement; // string element that has the focus (used for predictive char rendering)
var focusIndex;     // the index in the focused string


function init()
{
    addKeyboardListeners();

  // context menus
  ie5=document.all&&document.getElementById;
  ns6=document.getElementById&&!document.all;
  menuobj=document.getElementById("contextMenu");
  menuobj.style.display='';
  //


//    setRefreshTimer(10);
    refresh();
   setViewedAreaServer();
    loadXMLDoc('Key(116,(False,False,False));'); // put this one in refresh?
}

function addKeyboardListeners()
{   if (document.addEventListener)
    {
       document.addEventListener("keydown",keydown,false);
       document.addEventListener("keyup",keyup,false);
       document.addEventListener("keypress",keypress,false);
    }
    else if (document.attachEvent) // IE7
    {
       document.attachEvent("onkeydown", keydown);
       document.attachEvent("onkeyup", keyup);
       document.attachEvent("onkeypress", keypress);
    }
    else
    {
       document.onkeydown= keydown;
       document.onkeyup= keyup;
       document.onkeypress= keypress;
    }
}

function removeKeyboardListeners()
{ if (document.addEventListener)
    { document.removeEventListener("keydown",keydown,false);
      document.removeEventListener("keyup",keyup,false);
      document.removeEventListener("keypress",keypress,false);
    }
    else if (document.attachEvent) // IE7
    { document.detachEvent("onkeydown", keydown);
      document.detachEvent("onkeyup", keyup);
      document.detachEvent("onkeypress", keypress);
    }
    else // TODO: don't know if this works:
    { document.onkeydown = "return false";
      document.onkeyup = "return false";
      document.onkeypress = "return false";
    } 
}

// Font queries
 
var beginRange = 32;
var endRange = 255;
  
function initFont()
{ var fontElt = document.getElementById('font');
  fontElt.innerHTML='';
  var lines = '<div id=\'lines\' style=\'position:absolute;"\'>';
  for (var c=beginRange; c<=endRange; c++)
  { var ch = c == 38 ? '&amp;' 
           : c == 60 ? '&lt;' 
           : c == 62 ? '&gt;' : String.fromCharCode(c);
    lines = lines + '<div style=\'position:absolute\'>'+replicate(1000,ch)+'</div>';
  }
  lines += '</div><div id="enclosing" style="position:absolute"><span id="text">X</span><span id="baseline" style="height:0px;font-size:0px">baseline</span></div>';
  fontElt.innerHTML=lines;
}

function queryFont(fontFamily, fontSize, isBold, isItalic)
{ //debugAdd('Font query: '+fontFamily+fontSize+isBold+isItalic);
  initFont(); // firefox does not update bounding divs on style update, so we need to init every time :-(
  
  var fontElt = document.getElementById('font');
  fontElt.style.fontFamily = fontFamily;
  fontElt.style.fontSize = fontSize+'pt';
  fontElt.style.fontWeight = isBold ? "bold" : "normal"
  fontElt.style.fontStyle = isItalic ? "italic" : "normal"

  var enclosing = document.getElementById('enclosing');
  var baselineElt = document.getElementById('baseline');
  var font = document.getElementById('text');
  var height = font.offsetHeight;
  var baseline = baselineElt.offsetTop - font.offsetTop;

  var metrics = '((\\"'+fontFamily+'\\",'+fontSize+','+
                (isBold ? 'True' : 'False') +',' + 
                (isItalic ? 'True' : 'False') + 
                '),('+height + ',' + baseline + ',';
  var linesElt = fontElt.childNodes[0];
  var widths = '%5b'; // escaped '['
  for (var childNr = 0; childNr <= endRange - beginRange; childNr++)
  { var line = linesElt.childNodes[childNr];
    widths += (childNr == 0 ? '' : ',') + (line.clientWidth);
  }
  widths += '%5d'; // escaped ']'
  metrics += widths + '))';
  return metrics;
}

function replicate(i,c)
{ var str = '';
  while (i-- > 0)
    str = str + c;
  return str;
}


// Context menu's

var ie5;
var ns6;
var menuobj;

function contextHandler(e)
{ var screenX = ie5 ? event.clientX
                    : e.clientX;
  var screenY = ie5 ? event.clientY
                    : e.clientY;

  var coords = getMouseCoordsWithinTarget(e, document.getElementById('proxima')); 

  // menu is not on proxima element, so position is absolute to window
  // however, proxima needs the position relative to the proxima element
  
  loadXMLDoc('ContextMenuRequest(('+coords.x+','+coords.y+'),('+screenX+','+screenY+'));');
  return false; // disable normal context menu
}


function highlightie5(e)
{ var firingobj=ie5? event.srcElement : e.target;
  if ( firingobj.className=="menuItem" ||
       ns6 && firingobj.parentNode.className=="menuItem")
  { if (ns6 && firingobj.parentNode.className=="menuItem") 
      firingobj=firingobj.parentNode; //up one node
    firingobj.style.backgroundColor="highlight";
    firingobj.style.color="white";
  }
}

function lowlightie5(e)
{ var firingobj=ie5? event.srcElement : e.target;
  if ( firingobj.className=="menuItem" ||
       ns6 && firingobj.parentNode.className=="menuItem")
  { if (ns6 && firingobj.parentNode.className=="menuItem") 
      firingobj=firingobj.parentNode; //up one node
    firingobj.style.backgroundColor="";
    firingobj.style.color="black";
  }
}

function jumptoie5(e)
{ var firingobj=ie5? event.srcElement : e.target;
  if( firingobj.className=="menuItem" ||
      ns6 && firingobj.parentNode.className=="menuItem" )
  { if (ns6&&firingobj.parentNode.className=="menuItem") 
      firingobj=firingobj.parentNode;
    else
    { var selectedItemNr = firingobj.getAttribute("item");
      loadXMLDoc('ContextMenuSelect('+selectedItemNr+');');     
      menuobj.style.visibility="hidden";
    }
  }
}

function showMenuXY(x,y)
{ // Find out how close the mouse is to the corner of the window
  var rightedge=ie5 ? document.body.clientWidth-x
                    : window.innerWidth-x;
  var bottomedge = ie5 ? document.body.clientHeight-y
                       : window.innerHeight-y;
  
  // if the horizontal distance isn't enough to accomodate the width of the context menu
  var left, top;
  
  if (rightedge < menuobj.offsetWidth)
    // move the horizontal position of the menu to the left by it's width
    left= ie5 ? document.body.scrollLeft+x-menuobj.offsetWidth 
                            : window.pageXOffset+x-menuobj.offsetWidth;
  else
    //position the horizontal position of the menu where the mouse was clicked
    left = ie5 ? document.body.scrollLeft+x 
                             : window.pageXOffset+x;

  // same concept with the vertical position
  if (bottomedge < menuobj.offsetHeight)
    top=ie5 ? document.body.scrollTop+y-menuobj.offsetHeight 
                          : window.pageYOffset+y-menuobj.offsetHeight
  else
    top=ie5 ? document.body.scrollTop+y 
                          : window.pageYOffset+y

  menuobj.style.left = left + 'px';
  menuobj.style.top = top + 'px';
  
  menuobj.style.visibility="visible";
}


function hidemenuie5(e)
{ menuobj.style.visibility="hidden";
}




// end Context menu's






function loadXMLDoc(url)
{ commandQueue = commandQueue + url;

  if ( xmlhttp && xmlhttp.readyState != 0 && xmlhttp.readyState != 4)
    return; // if xmlhttp exists and was initialized and not ready, we return
            // TODO: can readyState == 0 happen?  
             
xmlhttp=null;
if (window.XMLHttpRequest)
  { // code for Firefox, Opera, IE7, etc.
    xmlhttp=new XMLHttpRequest();
  }
else if (window.ActiveXObject)
  { // code for IE6, IE5
    xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
  }
if (xmlhttp!=null)
  { 
    { xmlhttp.onreadystatechange=state_Change;
      xmlhttp.open("GET",'handle?commands=Commands '+ requestId +' "'+commandQueue+'"',true);
      xmlhttp.send(null);     // commands are terminated by semicolons
      requestId++;
      debugAdd('incremented requestId: ' + requestId);
      commandQueue = '';
    }
  }
else
  { alert("Your browser does not support XMLHTTP.");
  }
}

function state_Change()
{
if (xmlhttp.readyState==4)
  {// 4 = "loaded"
  if (xmlhttp.status==200)
    {// 200 = "OK"
    
    var newRendering = document.getElementById('newRendering');
    newRendering.innerHTML=xmlhttp.responseText;
    
    
    if (commandQueue != '')
    { //debugAdd('sending queue');
      loadXMLDoc('');
    }
    
    var focus = document.getElementById('focus');
    
    
    var updates = document.getElementById('updates');
    // getElementById seems to trigger parsing the responseText
    // after this, firstChild has a value, while it is null before
                // newRendering.firstChild;

    var sessionId = updates.getAttribute('sessionId');
    var responseId = updates.getAttribute('responseId');
    var sessionType = updates.getAttribute('sessionType');
    var nrOfSessions = updates.getAttribute('nrOfSessions');
    document.getElementById('sessionInfo').innerHTML =
      'Session id: ' + sessionId + '/' + responseId + ' '  +
      (sessionType == 'primary' ? 'Editable' : 'Non-editable') + ' ' +
      'Nr of sessions:' + nrOfSessions;

    while (updates.firstChild)
    { updateTree( updates.firstChild );
    ; updates.removeChild(updates.firstChild);
    }

    applyRemainingPredictiveInserts(responseId);
    //var renderArea = document.getElementById('renderArea');
    //renderArea.removeChild( document.getElementById('root') ); //old rendering

    //var xmlRoot = xmlhttp.responseXML.firstChild;
    
    
    //renderingRoot = document.getElementById('root');
    //newRendering.removeChild( renderingRoot );
    
    //renderArea.appendChild( renderingRoot );
    
    //while (renderArea.firstChild) {
    //  renderArea.removeChild(renderArea.firstChild);
    //}
    //
    // getElementById does not seem to work for dynamically added XML nodes.
    

    
    //var status = xmlRoot.getAttribute("status");
    //if (status !='')
    //  document.getElementById('status').innerHTML = status;
    }
  else
    {
    debug("Problem retrieving data:" + xmlhttp.statusText);
//    document.getElementById('status').innerHTML='Server not available.';
    }
  }
}

function updateTree(update)
{ var op = update.getAttribute('op');
 /*
  if (op === 'add')
  { var parentId = update.getAttribute('parentId');
    var newChild = update.firstChild;
    var parent = document.getElementById(parentId);
    parent.appendChild( newChild );
//    debug('add to '+parentId+' '+newChild.getAttribute('Id'));
  }    
  else if (op === 'remove')
  { var parentId = update.getAttribute('parentId');
    var targetId = update.getAttribute('targetId');
    var parent = document.getElementById(parentId);
    if (parent==null)
    { debug('parent '+parentId+' is null');
      return;
    }
    
    var target = document.getElementById(targetId);
    parent.removeChild( target );
//    debug('remove '+targetId+' from '+parentId);
  } 
  else 
  */
  if (op === 'replace')
  { var path = update.childNodes[0];
    var newChild = update.childNodes[1];
    
    var oldChild = select(path, document.getElementById('proxima'));
    
    var parent = oldChild.parentNode;
    
    parent.replaceChild(newChild,oldChild);
      
//    debug('replace '+targetId+' at '+parentId+' by '+newChild.getAttribute('Id'));
  } 
  else if (op == 'contextMenu')
  { var screenX = update.getAttribute('screenX');
    var screenY = update.getAttribute('screenY');
    
    removeChildren('contextMenu');
    
    while (update.firstChild)
    { var item = update.firstChild;
      update.removeChild(update.firstChild);
      menuobj.appendChild( item );
    } // using appendChild directly also seems to remove the child from update
      // but maybe this is not the same for all browsers
    
    showMenuXY(screenX,screenY);
    
  }
  else if (op == 'metricsQuery')
  { var family = update.getAttribute('family');
    var size = update.getAttribute('size');
    var isBold = update.getAttribute('isBold') == 'True';
    var isItalic = update.getAttribute('isItalic') == 'True';
    //alert(family+size+isBold+isItalic);    
    // strange: allowing this alert screws up the rendering!
    
    var metrics = queryFont(family,size,isBold,isItalic);
    //debugAdd('query is Metrics'+metrics+';');
    loadXMLDoc('Metrics'+metrics+';');
  }
  else if (op == 'setViewedArea')
  { var x = update.getAttribute('x');
    var y = update.getAttribute('y');
    var w = update.getAttribute('w');
    var h = update.getAttribute('h');

    setViewedAreaClient(x,y,w,h);    
  }
  
  else if (op == 'refresh')
  { refresh();
    loadXMLDoc('Key(116,(False,False,False));'); // put this one in refresh?
  }
  else if (op == 'alert')
  { alert (update.getAttribute('text'));
  }
  else if (op == 'setFocusedId')
  { var path = update.childNodes[0];
    focusedElt = select(path, document.getElementById('proxima'));
    focusIndex = update.getAttribute('index');
  }
  else alert ('Unknown command: '+op); 
}

function select(path, node)
{ var step = path.firstChild;
  if (!step)
    return node;
  else
    { path.removeChild(step);
      var childNr = parseInt( step.getAttribute('childNr') ); 
      var child = node.childNodes[childNr];
      return (select (path, child));
    }
}

function debug(message)
{
    document.getElementById('debugMessage').innerHTML=message;
}

function debugAdd(message)
{
    debug (message + '<br></br>' + document.getElementById('debugMessage').innerHTML);
}

function setStatus(message)
{
    document.getElementById('status').innerHTML=message;
}


function refresh()
{ removeChildren('rendering');
  removeChildren('focus');
  removeChildren('newRendering');
  removeChildren('contextMenu');
}

function removeChildren(parentId)
{ var parent = document.getElementById(parentId);
    while (parent.firstChild)
      parent.removeChild(parent.firstChild);
}

function keypress(e)
{
  if (!e) e= event;
   var keyCode =  (e.keyCode != 0) ? e.keyCode : e.charCode
   // keyCode is 0 on Firefox
   
//  debugAdd('Key is '+keyCode +',' + e.charCode);
  if (keyCode==102 && e.ctrlKey) // ctrl-f
  { var answer=prompt("Enter search term.");
// todo: escape answer string
   if (answer) loadXMLDoc('Find "'+answer+'";');
    return false;
  }
  if (keyCode==98 && e.ctrlKey) // ctrl-b
  { loadXMLDoc('SetStyle Bold;');
    return false;
  }
  if (keyCode==66 && e.ctrlKey) // ctrl-B
  { loadXMLDoc('ClearStyle Bold;');
    return false;
  }
  if (keyCode==105 && e.ctrlKey) // ctrl-i
  { loadXMLDoc('SetStyle Italic;');
    return false;
  }
  if (keyCode==73 && e.ctrlKey) // ctrl-I
  { loadXMLDoc('ClearStyle Italic;');
    return false;
  }
  if (keyCode==48 && e.ctrlKey) // ctrl-0
  { loadXMLDoc('SetStyle (Colored (0,0,0));');
    return false;
  }
  if (keyCode==49 && e.ctrlKey) // ctrl-1
  { loadXMLDoc('SetStyle (Colored (255,0,0));');
    return false;
  }
  if (keyCode==50 && e.ctrlKey) // ctrl-2
  { loadXMLDoc('SetStyle (Colored (0,0,255));');
    return false;
  }

  if (e.which != 0 && keyCode != 8 && keyCode != 13)
  { insertCharPredictively( String.fromCharCode(keyCode) );
    loadXMLDoc('Chr('+keyCode+','+showModifiers(e)+');');
  }
// ? is to prevent caching by IE 
// maybe also check alt, ctrl and  other keys, they seem to generate press events now
   
   if (e.preventDefault) e.preventDefault();
   if (e.stopPropagation) e.stopPropagation();

   return false;
}

function hasNoKeyPress(keyCode)
{
   return keyCode == 13 || keyCode == 8 || keyCode == 46 ||
          keyCode >= 37 && keyCode <= 40||
          keyCode >= 112 && keyCode <= 123;

}


function keydown(e)
{  if (!e) e = event;
   if (e.keyCode==116)
     refresh();
 
   if (hasNoKeyPress(e.keyCode) || e.ctrlKey || e.altKey || e.metaKey)
   {
     loadXMLDoc('Key('+e.keyCode+','+showModifiers(e)+');');
     if (e.preventDefault) e.preventDefault();
     if (e.stopPropagation) e.stopPropagation();
     return false; // false, so no keyPress event is generated
   }
   return true;
}
/* for preventing default behavior: (unclear whether or how this works)     
     if (e.preventDefault) e.preventDefault();
     if (e.stopPropagation) e.stopPropagation();
*/

function keyup(e)
{
}

function ignore(e)
{
   if (e.preventDefault) e.preventDefault();
   if (e.stopPropagation) e.stopPropagation();

   return false;
}

var scrollInProgress = false;

function mouseHandler(str,e) 
{ if (e.button != 0) return true;  // only handle left button here

  var proxima = document.getElementById('proxima');

  var coords = getMouseCoordsWithinTarget(e,proxima);
  var posx = coords.x;
  var posy = coords.y;
  
  /* We don't use scroll events, because setting scrollLeft and scrollTop also fires these events, and
     it does not seem possible to disable the handler temporarily */
  if (scrollInProgress)
  { if (str == 'U')
    { scrollInProgress = false;
      setViewedAreaServer();
      return true;
    }
    else if (str == 'M')
    { if (commandQueue == "")
        setViewedAreaServer(); // during scroll, only update if no other commands in queue, to prevent flooding
      return true;
    }
    // mouse down cannot occur
  }

  if ( (posx - proxima.scrollLeft) > proxima.clientWidth || (posy - proxima.scrollTop) > proxima.clientHeight )
    // we're on a scroll bar (either dragging or on a button), so set viewed area on mouse up.
  { if (str == 'D')
      scrollInProgress = true;
    return true;
  }

//  setStatus( 'dragState is '+dragState + ' origin(' + mouseDownPos.x + ',' + mouseDownPos.y + ') offset(' + dragOffset.x + ',' + dragOffset.y + ')' );

  
  switch(dragState)
  { case 0: // no button down
      if (str == 'D')
      { dragState = 1;
        mouseDownPos = { x: posx, y: posy };

        draggable = getDraggable(mouseDownPos.x, mouseDownPos.y);
        if ( !draggable )
        { sendMouseCommand('MouseDown', mouseDownPos.x, mouseDownPos.y, e);                     
        }
      } // all other mouse actions are ignored when button was not down
      break;

    case 1: // button down, no drag
      if (str =='U')
      { loadXMLDoc( (draggable ? mkMouseCommand('MouseDown', mouseDownPos.x, mouseDownPos.y, e) : '') +
                    // if there's a draggable, the mouse down was not yet sent
                    mkMouseCommand('MouseUp', posx, posy, e)   );
        draggable = null;
        dragState = 0;
      }
      else if (str == 'M')
      { if ( draggable )
        { draggedElementClone = cloneObject(draggable);

          draggableDims = getElementDimensions( draggable );
          var proximaDims = getElementDimensions( proxima );

          dragOffset = { x: mouseDownPos.x + proximaDims.x - draggableDims.x
                       , y: mouseDownPos.y + proximaDims.y - draggableDims.y
                       }
          draggedElementClone.style.left = posx-dragOffset.x +'px';
          draggedElementClone.style.top = posy-dragOffset.y +'px';

          sendMouseCommand('MouseDragStart', posx, posy, e);
          dragState = 2;
        }
        else
        { sendMouseCommand('MouseMove', posx, posy, e);
          dragState = 3;
        }
      } // ignore mouse down (should not occur)
      break;

    case 2: // drag in progress
      if ( str == 'U' )
      { sendMouseCommand('MouseDrop', posx, posy, e);
        draggedElementClone.parentNode.removeChild(draggedElementClone);
        draggedElementClone = null;
        draggable = null;
        dragState = 0;
      }
      else if ( str == 'M' )
      { draggedElementClone.style.left = posx-dragOffset.x +'px';
        draggedElementClone.style.top = posy-dragOffset.y +'px';
      } // ignore mouse down (should not occur)
      break;

    case 3: // dragging on non-dragsource (e.g. extending focus)
      if ( str == 'U' )
      { sendMouseCommand('MouseUp', posx, posy, e);
        dragState = 0;
      }
      else if ( str == 'M' )
      { sendMouseCommand('MouseMove', posx, posy, e);
      } // ignore mouse down (should not occur)
      break;
  }

  return false; // don't let browser handle mouse events
}

function sendMouseCommand(mouseCommand, x, y, e)
{ loadXMLDoc( mkMouseCommand(mouseCommand,x,y, e) );
}

function mkMouseCommand(mouseCommand, x, y, e)
{ return 'Mouse '+mouseCommand+'(' + x + ',' + y + ',' + showModifiers(e) + ');';
}

var ie=document.all;
var nn6=document.getElementById&&!document.all;
var dragState = 0;

var mouseDownPos = { x:0, y: 0};
var dragOffset = { x: 0, y: 0 };
var draggable;
var draggedElementClone; // the clone that is moved on drag

/*
Cannot use element in mouse event because the focus div catches all events
Cannot use JQuery because it somehow fails for xhtml docs 
*/

function getDraggable(x,y)
{ 
//  var allDraggables = $('.Draggable');

  var allDraggables = document.getElementsByClassName('Draggable');
//  alert('draggables '+showElementsDimensions(allDraggables));
  return getContainingElement(x,y,allDraggables);
}


function cloneObject( obj ) {
    var clone = obj.cloneNode(true);
    clone.style.position = 'absolute';
    clone.id = 'draggedObject';

    var parent = document.getElementById('draggedElementCloneParent');

    parent.parentNode.appendChild(clone);
    return clone;
}


/* Precondition: elts are given depth first, so by going from n-1 to 0, we get the deepest
*/
function getContainingElement(x,y,elts)
{ var proxima = document.getElementById('proxima');
  var proximaDims = getElementDimensions( proxima );

  var elt;
  for (var i=elts.length-1; i >= 0 && !elt; i--)
    if (within(x + proximaDims.x, y + proximaDims.y, getElementDimensions(elts[i])))
      elt=elts[i];
    // x & y are relative to Proxima element and dimensions of the elements are not, so we add
    // the proxima x & y

  return elt;
}

function within(x,y, dims)
{ return x >= dims.x && y >= dims.y && x < dims.x+dims.w && y < dims.y+dims.h;
}

function getElementDimensions( elt )
{ var CalculatedTotalOffsetLeft = 0;
  var CalculatedTotalOffsetTop = 0 ;

  var Element = elt;
  while (Element.offsetParent)
  { CalculatedTotalOffsetLeft += Element.offsetLeft ;     
    CalculatedTotalOffsetTop += Element.offsetTop ;
    Element = Element.offsetParent ;
  }
  var dimensions = { x: CalculatedTotalOffsetLeft
                   , y: CalculatedTotalOffsetTop
                   , w: elt.offsetWidth
                   , h: elt.offsetHeight
                   };
  return dimensions;
}

function showElementsDimensions( elts )
{ var str = '';
  for (var i = 0; i < elts.length; i++)
  { str += elts[i] + showElementDimensions(elts[i])+'\n'; 
  }
  return str;
}

function showElementDimensions( elt )
{ var dim = getElementDimensions( elt );
  return '(('+dim.x+','+dim.y+'):('+dim.w+'x'+dim.h+'))';
}
                

function getMouseCoordsWithinTarget(event,Element)
{
  var scrollLeft = Element.scrollLeft;
  var scrollTop = Element.scrollTop;
  
        var coords = { x: 0, y: 0};

        if(!event) // then we have a non-DOM (probably IE) browser
        {
                event = window.event;
                coords.x = event.offsetX;
                coords.y = event.offsetY;
        }
        else       // we assume DOM modeled javascript
        {
                var CalculatedTotalOffsetLeft = 0;
                var CalculatedTotalOffsetTop = 0 ;

                while (Element.offsetParent)
                {
                        CalculatedTotalOffsetLeft += Element.offsetLeft ;     
                        CalculatedTotalOffsetTop += Element.offsetTop ;
                        Element = Element.offsetParent ;
                }

                coords.x = event.pageX - CalculatedTotalOffsetLeft + scrollLeft;
                coords.y = event.pageY - CalculatedTotalOffsetTop + scrollTop;
        }

        return coords;
}

function showModifiers(e )
{ return '(' + (e.shiftKey?'True':'False') + ',' +
               (e.ctrlKey?'True':'False') + ',' +
               (e.altKey?'True':'False') + ')'
}

// set the viewed area at server side according to size and scroll position of proxima
// element
function setViewedAreaServer()
{ var proxima = document.getElementById('proxima');
//    debug('scroll '+ proxima.scrollLeft + ',' +proxima.scrollTop); 
  loadXMLDoc('SetViewedArea((' + proxima.scrollLeft + ',' + proxima.scrollTop +
              '),(' + proxima.clientWidth + ',' + proxima.clientHeight + '));');
}

// scroll proxima element to show the viewed area
function setViewedAreaClient(x,y,w,h)
{ var proxima = document.getElementById('proxima');

  proxima.scrollLeft = x;
  proxima.scrollTop = y;
  internalScrollEvent = true
}

function downloadDocument()
{ location.href = 'Document.xml';
}

function uploadDocument()
{ removeKeyboardListeners();
  // disable keyboard, because the text field with a cursor suggests keys should go there
  // even while this field is not editable.

  // Keeping mouse events does not seem to be confusing.
  var uploadDialog = document.getElementById('uploadDialog');
  // setting visibility does not seem to work (text border and buttons still show),
  // so we keep the div at -2000px and move it to 200px to show it.
  uploadDialog.style.left = '200px';
}

function cancelUploadDocument()
{ addKeyboardListeners();
  var uploadDialog = document.getElementById('uploadDialog');
  uploadDialog.style.left = '-2000px';
}

var predictiveInserts = new Array();

function registerPredictiveInsert(char)
{  debugAdd('register: requestId '+ requestId);
   predictiveInserts.push({ requestId: requestId, char: char, original: original }); 
}

/* Get rid of all predictive inserts for the current response (and also previous ones, but that should not happen)
   and reapply the predictive inserts for requests that are currently being sent to the server
*/
function applyRemainingPredictiveInserts(responseId)
{ while ( predictiveInserts.length > 0 && predictiveInserts[0].requestId <= responseId )
    predictiveInserts.shift();

  for (var i=0; i < predictiveInserts.length; i++)
  { debugAdd(responseId+' Applying: '+ predictiveInserts[i].requestId + ' ' +predictiveInserts[i].char );
    insertChar(predictiveInserts[i].char);
  }
}


function insertChar(char)
{ var w = focusedElt.clientWidth;
  var textNode = focusedElt.childNodes[0];
  textNode.insertData(focusIndex,char);
  focusIndex++;
  var increase = focusedElt.clientWidth - w;

  var proximaElt = document.getElementById('proxima');
  var parent = focusedElt.parentNode;
  var elt = focusedElt;

  var focusRenderingElt = document.getElementById('-2');
  focusRenderingElt.style.left = parseInt(focusRenderingElt.style.left) + increase  + 'px';

  while ( parent != proximaElt && parent.getAttribute('class') != 'Column' )
  { n = elt.nextSibling;
    while ( n )
    { n.style.left = parseInt(n.style.left) + increase + 'px';
      n = n.nextSibling;
    }
    elt = parent;
    parent = parent.parentNode;
  }
}

function insertCharPredictively(char)
{ insertChar(char);
  registerPredictiveInsert(char);

// todo: fix annoying bug that disables keyboard sometimes. (seems to be a firefox problem)
// todo: need to tag the text area, so we don't move above it (as is a problem in the decl. form)
// todo: when intermediate rendering results arrive during typing, remaining predictive chars need to be reapplied.
// does not take into account non-editable
// modified strings are not reset yet. Usually this will be done by next rendering
// except when insert does not change the string with focus (as in non-editable)

}

function test(char)
{ insertCharPredictively(char)
}
]]></script>
</head>
<body onload="init()">
<!-- <div id="status" style="border: 1px solid black; height: 22px; width: 1000px; font-size : 18px; font-family: monospace; line-height: 20px;" ></div> -->

<!-- <div style="position: absolute; border: 1px solid red; left:254px; top: 154px; width: 492px; height: 292px;"></div> -->
<!-- to show reduced viewed area 1000x600 with scrolling leaves a viewed area of ((246,146),(492,292)) to this we add 8 is added to left and top to account for margin above and left of proxima elt -->
<div id="proxima" style="position: relative; border: 1px solid black; width: 1000px; height: 600px; overflow:auto; font-size : 18px; font-family: monospace; line-height: 0px;white-space:pre"
     onmousedown="hidemenuie5(event);return mouseHandler('D',event)"
     onmouseup="return mouseHandler('U',event)"
     onclick="return mouseHandler('C',event)"
     onmousemove="return mouseHandler('M',event)"
     oncontextmenu="return contextHandler(event)"
><div id="rendering" 
     ></div><div id="focus"></div><div id="newRendering" style='position: absolute; left: 1000px; top: 0px;' ></div>
     <div id="draggedElementCloneParent" style="position: relative; height: 10000px; width: 10000px;"></div>
</div>
<div id="uploadDialog" style='position: absolute; left:-2000px; top:200px;width:400px;height:120px; border: 2px solid black; background-color:white'>
<form action="upload" enctype="multipart/form-data" method="post">
<p/>
<center> Please select the document xml file to upload.
<p/>
<input type="file" name="documentFile" size="40"/>
<p/>
<input type="submit" value="Upload"/>&nbsp;&nbsp;&nbsp;<input type="button" value="Cancel" onclick="cancelUploadDocument();"/></center>

</form>
</div>
 <!-- relative to parent. Important: parent needs style = 'position: relative' -->
<div id='font' style='visibility:hidden;white-space: pre'></div>
<div id="contextMenu" class="skin0" onmouseover="return highlightie5(event)" onmouseout="lowlightie5(event)" onclick="jumptoie5(event)"></div>
<button onclick="downloadDocument();">Download</button>
<button onclick="uploadDocument();">Upload</button>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<button onclick="loadXMLDoc('ClearMetrics;Key(116,(False,False,False));');window.location.reload( true)">Reload font metrics</button><div id="sessionInfo"></div>
<button onclick="test('X');">Test</button>


<div id="debugMessage"></div>
</body></html>






<!-- font positioning goes wrong: text is drawn at half-height ref at top of div box
<div style='position:absolute;left:20px;top:10px;width:463px;height:29px;font-family:"Times New Roman";font-size:19pt;background-color:rgb(120,120,120);'>B</div>
-->
<!-- weird rendering when line-height /= 0px
<div style='position: absolute; left:0px; top:0px;width:40px;height:40px;'>
<svg width='100%' height='100%' version='1.1' xmlns='http://www.w3.org/2000/svg'>
<polygon points='1,1 40,1' style='fill:transparent; stroke:rgb(255,0,0);stroke-width:1'/>
<line x1='1' y1='1' x2='40' y2='' style='stroke:rgb(0,0,0);stroke-width:1'/>
</svg></div>
-->

<!--
<div style='position: absolute; left:0px; top:0px;width:17px;height:4px;'>
      <svg width='100%' height='100%' version='1.1' xmlns='http://www.w3.org/2000/svg'>
       <polygon points='0,0 14,0' style='fill:transparent; stroke:rgb(255,0,0);stroke-width:1'/>
      </svg>
</div>
-->
<!-- strange rendering of poly's when height is less than 4
  <div style='position: absolute; left:0px; top:0px;width:15px;height:21px;'>
     <div style='position: absolute; left:-1px; top:-1px;width:17px;height:4px;'>
      <svg width='100%' height='100%' version='1.1' xmlns='http://www.w3.org/2000/svg'>
       <polygon points='0,0 14,0' style='fill:transparent; stroke:rgb(255,0,0);stroke-width:1'/>
      </svg>
     </div>
   <div style='position: absolute; left:0px; top:1px;width:15px;height:19px;'>
     <div style='position: absolute; left:-1px; top:-1px;width:5px;height:21px;'>
      <svg width='100%' height='100%' version='1.1' xmlns='http://www.w3.org/2000/svg'>
       <polygon points='0,0 0,18' style='fill:transparent; stroke:rgb(0,0,0);stroke-width:1'/>
      </svg>
     </div>
    <div style='position:absolute;left:1px;top:0px;width:13px;height:19px;'>
      <div style='position:absolute;left:0px;top:9px;width:13px;height:19px;font-family:"Times New Roman";font-size:12pt;color:rgb(0,0,0);'>zu</div>
    </div>
     <div style='position: absolute; left:13px; top:-1px;width:5px;height:21px;'>
      <svg width='100%' height='100%' version='1.1' xmlns='http://www.w3.org/2000/svg'>
       <polygon points='0,0 0,18' style='fill:transparent; stroke:rgb(0,0,0);stroke-width:1'/>
      </svg>
     </div>
   </div>
    <div style='position: absolute; left:-1px; top:19px;width:17px;height:4px;'>
     <svg width='100%' height='100%' version='1.1' xmlns='http://www.w3.org/2000/svg'>
      <polygon points='0,0 14,0' style='fill:transparent; stroke:rgb(0,0,0);stroke-width:1'/>
     </svg>
    </div>
  </div>

-->













