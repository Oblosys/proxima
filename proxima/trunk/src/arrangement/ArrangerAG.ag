imports
{

import CommonTypes
import ArrLayerTypes
import ArrLayerUtils
import FontLib
}



{
{-
TODO: 
- add check that graph only has vertex children

bug: boxed pres `withHRef` x  does not work for top and bottom line and background
- why does Empty.arrangement have 0 for x and y?



-}


{- for AlternativeP
selectFirstFit :: Int -> [ Int ] -> Int       
selectFirstFit availableWidth widths = 
  if null widths 
  then error "Alternative presentation has no alternatives"
  else select widths 0
 where
  select [_] n = n
  select (w:ws) n = if w <= availableWidth then n else select ws (n+1)

-- maybe nicer as synth attribute for presentationList

-}


{- for MatrixP
divide n [] = []
divide n xs = let (line, rest) = splitAt n xs in line : divide n rest

getRows n [] = []
getRows n xs = let (line, rest) = splitAt n xs in line : divide n rest

getCols n xs = foldr (zipWith (:)) (repeat []) (getRows n xs)
-}



-- for FormatterP
unfoldFormatter w ws presentations = 
 let breaks = firstFit w ws
     dividedPresentations = linesFromBreaks breaks presentations
     rows = -- map (\lst -> LayedOutRowP lst 100 32 (repeat (0,0))) presentationLists
         map (RowP NoIDP 0) dividedPresentations
     unfoldedList = ColP NoIDP 0 (rows)
 in  unfoldedList



-- just add words until line overflow
firstFit lineWidth widths = buildFFBreaks lineWidth 0 0 widths

buildFFBreaks _ pos _ [] = [] -- add a breakpoint after last word? prob. not, otherwise return [pos]
buildFFBreaks maxLength pos currentLength (width:widths) =
  let space = if currentLength == 0 then 0 else 0 -- hard coded minimum space, and widths must be >= 0 
      newLength = currentLength + space + width
  in if currentLength == 0 && width > maxLength
     then if null widths 
          then []
          else (pos+1) : buildFFBreaks maxLength pos 0 (widths)
     else if newLength <= maxLength
          then buildFFBreaks maxLength (pos+1) newLength widths
          else pos : buildFFBreaks maxLength (pos) 0 (width:widths)

linesFromBreaks :: [Int] -> [a] -> [[a]]
linesFromBreaks brks wrds = tolines' brks 0 wrds 
   where
   tolines' [] _ wrds = [wrds]
   tolines' (brk:brks) lastbrk wrds = take (brk-lastbrk) wrds :
                                      tolines' brks brk (drop (brk-lastbrk) wrds)




assign [] _ _ = []
assign (str:strs) (a:as) (o:os) = (if str then a else o) : assign strs as os


data Root doc node clip = Root (Presentation doc node clip)

type PresentationList doc node clip = [Presentation doc node clip]
                      
-- We don't want AG to generate the Presentation data types, so data type generation is turned off.
-- However, we do need Root and PresentationList
}

DATA Root 
  | Root presentation : Presentation 


DATA Presentation
  | EmptyP      id : IDP
  | StringP     id : IDP text : String
  | ImageP      id : IDP src : String
  | PolyP       id : IDP pointList : {[ (Float, Float) ]} lineWidth : Int
  | RectangleP  id : IDP w,h : Int lineWidth : Int
  | EllipseP	id : IDP w, h : Int lineWidth : Int
  | RowP        id : IDP hRefNr : Int presentationList : PresentationList
  | ColP        id : IDP vRefNr : Int presentationList : PresentationList
  | OverlayP    id : IDP              presentationList : PresentationList
  | GraphP      id : IDP d : Dirty w,h : Int edges : {[(Int,Int)]} presentationList : PresentationList 
  | VertexP     id : IDP i,x,y: Int outline : Outline child : Presentation
  | FormatterP  id : IDP presentationList : PresentationList
  | WithP       attrRule : AttrRule  child : Presentation
  | StructuralP id : IDP  child : Presentation
  | ParsingP    id : IDP  child : Presentation
  | LocatorP location : {node} child : Presentation
  | ArrangedP -- pres : Presentation

--  | TestPresentation id : IDP  area : Int color : Color
--  | MatrixPresentation id : IDP  m, n : Int presentationList : PresentationList
--  | LayedOutRowP id : IDP  presentationList : PresentationList w, h : Int offsets :  {[ (Int, Int) ]} -- optimization for laying out text
--  | AlternativePresentation id : IDP  presentationList : PresentationList



--  For each Nonterminal:
 -- add id propagation
 -- add formatter depth computation
 -- add attributed tree definition


TYPE PresentationList = [Presentation]


ATTR Root [ font : Font textColor : Color lineColor : Color fillColor : Color backgroundColor : Color
            focus : FocusPres
            mouseDown : {Maybe (UpdateDoc doc clip)}
            popupMenuItems : {[ PopupMenuItem ]}
          || maxFormatterDepth : Int  unfoldedTree : Presentation arrangement : {Arrangement node} ]
SEM Root
  | Root
      lhs.maxFormatterDepth = @presentation.maxFormatterDepth
      lhs.unfoldedTree  = @presentation.unfoldedTree
      lhs.arrangement   = @presentation.arrangement


-- Presentation Attribute Propagation in Presentation Tree
-- Root: copy rule

-- Optimize: maybe we only want to update the attrs that are set by the with rule? Or won't that improve much?

SEM Presentation [ font : Font textColor, lineColor, fillColor, backgroundColor : Color
            mouseDown : {Maybe (UpdateDoc doc clip)}
            popupMenuItems : {[ PopupMenuItem ]}
            | | ]
  | WithP
      loc.newAttrs   = @attrRule ( Inh @lhs.font 
                                      @lhs.textColor @lhs.lineColor @lhs.fillColor @lhs.backgroundColor
                                      @lhs.mouseDown @lhs.popupMenuItems
				      @lhs.assignedWidth @lhs.assignedHeight @lhs.assignedVRef @lhs.assignedHRef
				, Syn @child.vRef @child.hRef @child.minWidth @child.minHeight
				      @child.hStretch @child.vStretch
				      @child.finalWidth @child.finalHeight @child.finalVRef @child.finalHRef) 
				           -- no names because ag parser can't handle braces (now it can)
      loc.newSyn = fst @newAttrs
      loc.newInh = snd @newAttrs
      child.font = font @newSyn
      child.textColor = textColor @newSyn
      child.lineColor = lineColor @newSyn
      child.fillColor = fillColor @newSyn
      child.backgroundColor = backgroundColor @newSyn     
      child.mouseDown = mouseDown @newSyn
      child.popupMenuItems = popupMenuItems @newSyn
      child.assignedWidth = assignedWidth @newSyn
      child.assignedHeight = assignedHeight @newSyn
      child.assignedVRef = assignedVRef @newSyn
      child.assignedHRef = assignedHRef @newSyn
      lhs.vRef = vRef @newInh
      lhs.hRef = hRef @newInh
      lhs.minWidth = minWidth @newInh
      lhs.minHeight = minHeight @newInh
      lhs.hStretch = hStretch @newInh
      lhs.vStretch = vStretch @newInh
      lhs.finalWidth = finalWidth @newInh
      lhs.finalHeight = finalHeight @newInh
      lhs.finalVRef = finalVRef @newInh
      lhs.finalHRef = finalHRef @newInh

-- rest is taken care of by copy rule

ATTR PresentationList [  font : Font textColor, lineColor, fillColor, backgroundColor : Color 
                 mouseDown : {Maybe (UpdateDoc doc clip)} popupMenuItems : {[ PopupMenuItem ]} | | ]



-- Font Metrics

-- first, collect all used fonts. They can only change at a with node, so only one check.
-- This could be optimised by only checking with nodes that update the font, instead of e.g.
-- color

ATTR Root [ | allFonts : {[Font]} | ]
-- copy rule

SEM Presentation [ | allFonts : {[Font]} | ]
  | WithP
      child.allFonts = let syn = @newSyn
                       in  font syn : @lhs.allFonts

-- these are nubbed later. Maybe they should only be added if not present?

ATTR PresentationList [ | allFonts : {[Font]} | ] 

ATTR Root [ fontMetrics : FontMetrics | | ]

ATTR Presentation [ fontMetrics : FontMetrics | | ]
  
ATTR PresentationList [ fontMetrics : FontMetrics | | ]  -- copy Rule



-- Focus
--ATTR Presentation [ focus : FocusPres | | ]
-- need some way to represent focus in arrangement.
-- putting in overlays changes paths, and may have many consequences
-- probably best to have a focus attribute in each arr node, but this involves
-- changing many patterns in arrangement functions
-- In the future we probably want an info node with (ID Focus Dirty etc.)
-- maybe for now just fix markFocusArr and diffArr a bit.



-- formatterDepth and maxFormatterDepth definitions   

ATTR Presentation [ | | maxFormatterDepth : Int ]
SEM Presentation
  | EmptyP StringP RectangleP EllipseP ImageP PolyP
      lhs.maxFormatterDepth = 0
  | RowP ColP OverlayP GraphP
      lhs.maxFormatterDepth = maximum @presentationList.maxFormatterDepthList
  | FormatterP
      lhs.maxFormatterDepth = 1 + maximum @presentationList.maxFormatterDepthList
{-
  | TestPresentation 
      lhs.maxFormatterDepth = 0

  | MatrixPresentation 
      lhs.maxFormatterDepth = maximum @presentationList.maxFormatterDepthList
  | LayedOutRowP
      lhs.maxFormatterDepth = maximum @presentationList.maxFormatterDepthList
  | AlternativePresentation 
      lhs.maxFormatterDepth = maximum @presentationList.maxFormatterDepthList
-}
-- | VertexP       copy
-- | WithP       copy
-- | StructuralP copy
-- | ParsingP    copy
-- | LocatorP    copy

ATTR PresentationList [ | | maxFormatterDepthList : {[Int]} ]
SEM PresentationList
  | Nil 
      lhs.maxFormatterDepthList = [0] -- so we get no maximum []
  | Cons 
      lhs.maxFormatterDepthList = @hd.maxFormatterDepth : @tl.maxFormatterDepthList


-- Creating the unfoldedTree
ATTR Presentation [  | | unfoldedTree : Presentation ]
SEM Presentation
  | EmptyP 
      lhs.unfoldedTree = EmptyP @id 
  | StringP 
      lhs.unfoldedTree = StringP @id @text 
  | RectangleP    
      lhs.unfoldedTree = RectangleP @id @w @h @lineWidth
  | EllipseP    
      lhs.unfoldedTree = EllipseP @id @w @h @lineWidth
  | ImageP    
      lhs.unfoldedTree = ImageP @id @src
  | PolyP
      lhs.unfoldedTree = PolyP @id @pointList @lineWidth
  | RowP 
      lhs.unfoldedTree = RowP @id @hRefNr @presentationList.unfoldedTreeList
  | ColP 
      lhs.unfoldedTree = ColP @id @vRefNr @presentationList.unfoldedTreeList
  | OverlayP 
      lhs.unfoldedTree = OverlayP @id @presentationList.unfoldedTreeList
  | GraphP 
      lhs.unfoldedTree = GraphP @id @d @w @h @edges @presentationList.unfoldedTreeList
  | VertexP
      lhs.unfoldedTree = VertexP @id @i @x @y @outline @child.unfoldedTree
  | FormatterP
      lhs.unfoldedTree = unfoldFormatter @lhs.assignedWidth @presentationList.minWidthList @presentationList.unfoldedTreeList
{-
  | TestPresentation             
      lhs.unfoldedTree = TestPresentation @id @area @color
  | MatrixPresentation 
      lhs.unfoldedTree = MatrixPresentation @id @m @n @presentationList.unfoldedTreeList
  | LayedOutRowP 
      lhs.unfoldedTree = LayedOutRowP @id @presentationList.unfoldedTreeList @w @h @offsets
  | AlternativePresentation 
      lhs.unfoldedTree = AlternativePresentation @id @presentationList.unfoldedTreeList
-}
  | WithP
      lhs.unfoldedTree = WithP @attrRule @child.unfoldedTree
  | StructuralP
      lhs.unfoldedTree = StructuralP @id  @child.unfoldedTree
  | ParsingP
      lhs.unfoldedTree = ParsingP @id  @child.unfoldedTree
  | LocatorP
      lhs.unfoldedTree = LocatorP @location @child.unfoldedTree
-- bit of a hack, but the children are needed as values of type Presentation, so we can use unfoldedTreeList,
-- as there will not be any formatters inside anyway

ATTR PresentationList [  | |  unfoldedTreeList : {[Presentation]} ]
SEM PresentationList
  | Nil
      lhs.unfoldedTreeList = []
  | Cons 
      lhs.unfoldedTreeList = @hd.unfoldedTree : @tl.unfoldedTreeList



-- char width not ok for more complicated (overlapping) glyphs like ff ligature in tex. 
-- char height sometimes needed for individual characters

-- matrix does not work correctly yet: empty `withWidth` 50 `beside` matrix is problem
-- no stretch in matrix

-- row in row has problems with hRef
-- vRef and hRef updates do not work properly


-- ref and size as ag aspects:

SEM Presentation [ || minWidth, minHeight : Int hStretch, vStretch : Bool vRef, hRef : Int ]
  | *
      loc.minWidth : Int
      loc.minHeight : Int
      loc.hStretch : Bool
      loc.vStretch : Bool
      loc.vRef : Int
      loc.hRef : Int
      
  | EmptyP
      loc.minWidth = 0
      loc.minHeight = 0
      loc.hStretch = False
      loc.vStretch = False
      loc.vRef = 0
      loc.hRef = 0
  | StringP 
      loc.minWidth = textWidth @lhs.fontMetrics @lhs.font @text
      loc.minHeight = charHeight @lhs.fontMetrics @lhs.font
      loc.hStretch = False
      loc.vStretch = False
      loc.vRef = baseLine @lhs.fontMetrics @lhs.font
      loc.hRef = 0       
  | RectangleP EllipseP GraphP
      loc.minWidth = @w
      loc.minHeight = @h
      loc.hStretch = False
      loc.vStretch = False
      loc.vRef = 0
      loc.hRef = 0
  | ImageP PolyP
      loc.minWidth = 0
      loc.minHeight = 0
      loc.hStretch = True
      loc.vStretch = True
      loc.vRef = 0
      loc.hRef = 0
  | VertexP -- other attributes are not important, because Graph ignores them anyway.
      loc.hRef = @child.hRef - @x
      loc.vRef = @child.vRef - @y
  | RowP 
      loc.minTopHeight = if null @presentationList.vRefList then 0
                            else maximum @presentationList.vRefList
      loc.minBottomHeight = if null @presentationList.vRefList then 0
                            else maximum [ minHeight - vRef | (minHeight, vRef) <- zip @presentationList.minHeightList @presentationList.vRefList ]
      loc.minWidth = sum @presentationList.minWidthList
      loc.minHeight = @minTopHeight + @minBottomHeight
      loc.hStretch = or @presentationList.hStretchList
      loc.vStretch = not (null @presentationList.vStretchList) && and @presentationList.vStretchList
      loc.vRef = @minTopHeight
      loc.hRef = if null @presentationList.hRefList then 0
                 else sum (take @hRefNr @presentationList.minWidthList) + @presentationList.hRefList !! @hRefNr
  | ColP
      loc.minLeftWidth = if null @presentationList.hRefList then 0
                         else maximum @presentationList.hRefList
      loc.minRightWidth = if null @presentationList.hRefList then 0
                          else maximum [ minWidth - hRef | (minWidth, hRef) <- zip @presentationList.minWidthList @presentationList.hRefList ]
      loc.minWidth = @minLeftWidth + @minRightWidth 
      loc.minHeight = sum @presentationList.minHeightList
      loc.hStretch = not (null @presentationList.hStretchList) && and @presentationList.hStretchList
      loc.vStretch = or @presentationList.vStretchList
      loc.vRef = if null @presentationList.vRefList then 0
                 else sum (take @vRefNr @presentationList.minHeightList) + @presentationList.vRefList !! @vRefNr
      loc.hRef = @minLeftWidth
  | OverlayP 
      loc.minLeftWidth = maximum @presentationList.hRefList
      loc.minRightWidth = maximum [ minWidth - hRef | (minWidth, hRef) <- zip @presentationList.minWidthList @presentationList.hRefList ]
      loc.minWidth = @minLeftWidth + @minRightWidth 
      loc.minTopHeight = maximum @presentationList.vRefList 
      loc.minBottomHeight = maximum [ minHeight - vRef | (minHeight, vRef) <- zip @presentationList.minHeightList @presentationList.vRefList ]
      loc.minHeight = @minTopHeight + @minBottomHeight
      loc.hStretch = not (null @presentationList.hStretchList) && and @presentationList.hStretchList
      loc.vStretch = not (null @presentationList.vStretchList) && and @presentationList.vStretchList
      loc.vRef = @minTopHeight
      loc.hRef = @minLeftWidth
  | FormatterP
      loc.minWidth = 0
      loc.minHeight = 0
      loc.hStretch = True
      loc.vStretch = True
      loc.vRef = 0
      loc.hRef = 0

    {-  loc.topHeight = maximum @presentationList.vRefList
      loc.bottomHeight = maximum [ minHeight - vRef | (minHeight, vRef) <- zip @presentationList.minHeightList @presentationList.vRefList ]
      loc.leftWidth = maximum @presentationList.hRefList
      loc.rightWidth = maximum [ minWidth - hRef | (minWidth, hRef) <- zip @presentationList.minWidthList @presentationList.hRefList ]
      loc.minWidth = @leftWidth + @rightWidth 
      loc.minHeight = @topHeight + @bottomHeight
      loc.vRef = @topHeight
      loc.hRef = @leftWidth-}
{-
  | TestPresentation 
      loc.minWidth = error "not implemented"
      loc.minHeight = error "not implemented"
      loc.hStretch = error "not implemented" 
      loc.vStretch = error "not implemented" 
      loc.vRef = error "not implemented"
      loc.hRef = error "not implemented"

  | MatrixPresentation
      loc.rowTopHeights = map maximum (getRows @n @presentationList.vRefList)
      loc.rowBottomHeights = map (\minHghtsVRefs ->
                                   maximum [ minHeight - vRef | (minHeight, vRef) <- minHghtsVRefs ]
				 ) (getRows @n (zip @presentationList.minHeightList @presentationList.vRefList))
      loc.colLeftWidths = map maximum (getCols @n @presentationList.hRefList)
      loc.colRightWidths = map (\minWdthsHRefs ->
                                   maximum [ minWidth - hRef | (minWidth, hRef) <- minWdthsHRefs ]
				 ) (getCols @n (zip @presentationList.minWidthList @presentationList.hRefList))
      loc.rowHeights = zipWith (+) @rowTopHeights @rowBottomHeights
      loc.colWidths = zipWith (+) @colLeftWidths @colRightWidths
      loc.minWidth = sum @colLeftWidths + sum @colRightWidths
      loc.minHeight = sum @rowTopHeights + sum @rowBottomHeights
      loc.hStretch = False
      loc.vStretch = False
      loc.vRef = if null @presentationList.vRefList then 0
                else head @rowTopHeights
      loc.hRef = 0
  | LayedOutRowP 
      loc.minWidth = error "not implemented"
      loc.minHeight = error "not implemented"
      loc.hStretch = error "not implemented" 
      loc.vStretch = error "not implemented" 
      loc.vRef = error "not implemented"
      loc.hRef = error "not implemented"
  | AlternativePresentation 
      loc.minWidth = 0
      loc.minHeight = 0
      loc.hStretch = True
      loc.vStretch = True
      loc.vRef = 0
      loc.hRef = 0
-}
  | WithP
{-
      loc.wdth = 
      loc.minHeight = 
      loc.vRef = 
      loc.hRef = 
-}
ATTR PresentationList [  | |  minWidthList, minHeightList : {[Int]} vRefList, hRefList : {[Int]}
                       hStretchList, vStretchList : {[Bool]} ]
SEM PresentationList
  | Nil
      lhs.minWidthList = []
      lhs.minHeightList = []
      lhs.hStretchList = []
      lhs.vStretchList = []
      lhs.vRefList = []
      lhs.hRefList = []
  | Cons 
      lhs.minWidthList = @hd.minWidth : @tl.minWidthList
      lhs.minHeightList = @hd.minHeight : @tl.minHeightList
      lhs.hStretchList = @hd.hStretch : @tl.hStretchList
      lhs.vStretchList = @hd.vStretch : @tl.vStretchList
      lhs.vRefList = @hd.vRef : @tl.vRefList
      lhs.hRefList = @hd.hRef : @tl.hRefList




SEM Root
  | Root
      presentation.assignedWidth  = let (_,(screenWidth,_)) = @lhs.viewedArea
                                    in  if @presentation.hStretch && screenWidth >= @presentation.minWidth 
                                        then screenWidth else @presentation.minWidth
      presentation.assignedHeight = let (_,(_,screenHeight)) = @lhs.viewedArea
                                    in  if @presentation.vStretch && screenHeight >= @presentation.minHeight
                                    then screenHeight else @presentation.minHeight -- should be screenHeight
      presentation.assignedVRef = @presentation.vRef -- is ignored anyway 
      presentation.assignedHRef = @presentation.hRef 

SEM Presentation [ assignedWidth, assignedHeight, assignedVRef, assignedHRef : Int | | ]
  | RowP
      loc.assignedWidths = if @presentationList.hStretchList!! @hRefNr -- if Ref Object is stretch, all children get
                                 then assign @presentationList.hStretchList -- equal space           +1, because refobj is stretch too
                                               (repeat((@leftTotalSpace+ @rightTotalSpace)`div`(@leftHStretches+1+ @rightHStretches))
						
					       )
					       @presentationList.minWidthList
		                 else assign @presentationList.hStretchList
                                               (  replicate @hRefNr (@leftChildSpace) 
					       ++ [0] -- not used, since stretch for child nr @hRefNr is False 
					       ++ repeat @rightChildSpace
					       )
					       @presentationList.minWidthList
      presentationList.assignedWidthList    = @assignedWidths
      presentationList.assignedHRefList     = @presentationList.hRefList -- is not right, nested rows don't work now

      presentationList.assignedHeightList   = assign @presentationList.vStretchList
                                                (repeat @lhs.assignedHeight)
                                                @presentationList.minHeightList 
      presentationList.assignedVRefList     = assign @presentationList.vStretchList
                                                (repeat @vRef)--@lhs.assignedVRef)
                                                @presentationList.vRefList 

       -- width of stretching children should not be subtracted from available width
       -- for the moment this amount is added back to it as left and right corrections
      loc.stretchMinWidths = assign @presentationList.hStretchList @presentationList.minWidthList (repeat 0)
      -- this list contains the widths for the non stretchers, the other widths are 0

      loc.leftCorrection = sum (take @hRefNr @stretchMinWidths) 
                              + if @presentationList.hStretchList!! @hRefNr then @stretchMinWidths !! @hRefNr else 0
      loc.rightCorrection = sum (drop (@hRefNr+1) @stretchMinWidths)

      loc.leftTotalSpace = @lhs.assignedHRef - @hRef    + @leftCorrection
      loc.rightTotalSpace = @lhs.assignedWidth - @minWidth - @leftTotalSpace  + @rightCorrection
      loc.leftHStretches = length . filter (==True) . take @hRefNr $ @presentationList.hStretchList 
      loc.rightHStretches = length . filter (==True) . drop (@hRefNr+1) $ @presentationList.hStretchList 
      loc.leftChildSpace = round (fromIntegral @leftTotalSpace / fromIntegral @leftHStretches )
      loc.rightChildSpace = round (fromIntegral @rightTotalSpace / fromIntegral @rightHStretches )
 
       
      -- @lhs.assigned vs final????
  | ColP
      presentationList.assignedWidthList    = assign @presentationList.hStretchList
                                              (repeat @lhs.assignedWidth) @presentationList.minWidthList 
      -- in case of stretch, return composite's ref
      presentationList.assignedHRefList     = assign @presentationList.hStretchList
                                              (repeat @lhs.assignedHRef)
					      @presentationList.hRefList 
      loc.assignedHeights = if @presentationList.vStretchList!! @vRefNr -- if Ref Object is stretch, all children get
                            then assign @presentationList.vStretchList -- equal space           +1, because refobj is stretch too
                                               (repeat((@topTotalSpace+ @bottomTotalSpace)`div`(@topVStretches+1+ @bottomVStretches))
						
					       )
					       @presentationList.minHeightList
		            else assign @presentationList.vStretchList
                                               (  replicate @vRefNr (@topChildSpace) 
					       ++ [0] -- not used, since stretch for child nr @vRefNr is False 
					       ++ repeat @bottomChildSpace
					       )
					       @presentationList.minHeightList
      presentationList.assignedHeightList    = @assignedHeights
      presentationList.assignedVRefList     = {-debug Arr (  "assVRef:"++show @lhs.assignedVRef
						++ "VRef:"++ show @vRef
						++ "minHeight:"++show minHeight
						++ "assHeight:"++show @lhs.assignedHeight
						++ "topTotal:"++ show topTotalSpace
						++ "botTotal:"++ show bottomTotalSpace
						)-} @presentationList.vRefList -- is not right, nested cols don't work now

       -- width of stretching children should not be subtracted from available height
       -- for the moment this amount is added back to it as top and bottom corrections
      loc.stretchMinHeights = assign @presentationList.vStretchList @presentationList.minHeightList (repeat 0)
      -- this list contains the heights for the non stretchers, the other heights are 0

      loc.topCorrection = sum (take @vRefNr @stretchMinHeights) 
                              + if @presentationList.vStretchList!! @vRefNr then @stretchMinHeights !! @vRefNr else 0
      loc.bottomCorrection = sum (drop (@vRefNr+1) @stretchMinHeights)

      
      
      
      loc.topTotalSpace = @lhs.assignedVRef - @vRef  + @topCorrection     -- minTopHeight
      loc.bottomTotalSpace = @lhs.assignedHeight - @minHeight - @topTotalSpace   + @bottomCorrection
      loc.topVStretches = length . filter (==True) . take @vRefNr $ @presentationList.vStretchList 
      loc.bottomVStretches = length . filter (==True) . drop (@vRefNr+1) $ @presentationList.vStretchList 
      loc.topChildSpace = round (fromIntegral @topTotalSpace / fromIntegral @topVStretches )
      loc.bottomChildSpace = round (fromIntegral @bottomTotalSpace / fromIntegral @bottomVStretches )
  | OverlayP
      presentationList.assignedHeightList   = assign @presentationList.vStretchList
                                              (repeat @lhs.assignedHeight) @presentationList.minHeightList 
      presentationList.assignedVRefList     = assign @presentationList.vStretchList
                                              (repeat @lhs.assignedVRef) @presentationList.vRefList 
      presentationList.assignedWidthList    = assign @presentationList.hStretchList
                                              (repeat @lhs.assignedWidth) @presentationList.minWidthList 
      presentationList.assignedHRefList     = assign @presentationList.hStretchList
                                              (repeat @lhs.assignedHRef)  @presentationList.hRefList 
  | GraphP -- just use minSize and h/hRef for assigned Size and Ref. Stretching does not make sense in a GraphP
      presentationList.assignedHeightList = @presentationList.minHeightList 
      presentationList.assignedVRefList   = @presentationList.vRefList 
      presentationList.assignedWidthList  = @presentationList.minWidthList 
      presentationList.assignedHRefList   = @presentationList.hRefList 
  | VertexP
      child.assignedHeight                = @child.minHeight
      child.assignedWidth                 = @child.minWidth
      child.assignedHRef                  = @child.hRef
      child.assignedVRef                  = @child.vRef
  | FormatterP
      presentationList.assignedWidthList    = debug Err "ArrangerAG.assignedWidthList: FormatterP must be unfolded first" []
      presentationList.assignedHeightList   = debug Err "ArrangerAG.assignedHeightList: FormatterP must be unfolded first" []
      presentationList.assignedVRefList     = debug Err "ArrangerAG.assignedVRefList: FormatterP must be unfolded first" []
      presentationList.assignedHRefList     = debug Err "ArrangerAG.assignedHRefList: FormatterP must be unfolded first" []
{-
  | MatrixPresentation
-- is a lot more complicated than this
      presentationList.assignedHeightList    =assign @presentationList.vStretchList
                                              (concat. map (replicate @n)$ @rowHeights)
					      @presentationList.minHeightList 
      presentationList.assignedVRefList     = assign @presentationList.vStretchList
                                              (concat. map (replicate @n)$ @rowTopHeights) --(repeat @lhs.assignedVRef)
					      @presentationList.vRefList 
      presentationList.assignedWidthList    = assign @presentationList.hStretchList
                                              (concat . repeat $ @colWidths) 
					      @presentationList.minWidthList 
      presentationList.assignedHRefList     = assign @presentationList.hStretchList
                                              (concat . repeat $ @colLeftWidths) --(repeat @lhs.assignedHRef)
					      @presentationList.hRefList 
   --   presentationList.assignedWidthList    = @presentationList.minWidthList
 --     presentationList.assignedHeightList   = @presentationList.minHeightList
 --     presentationList.assignedVRefList     = @presentationList.vRefList
   --   presentationList.assignedHRefList     = @presentationList.hRefList
  | LayedOutRowP
      presentationList.assignedWidthList    = error "LayedOut row not implemented yet."
      presentationList.assignedHeightList    = error "LayedOut row not implemented yet."
      presentationList.assignedVRefList    = error "LayedOut row not implemented yet."
      presentationList.assignedHRefList    = error "LayedOut row not implemented yet."
  | AlternativePresentation
      presentationList.assignedWidthList    = repeat @lhs.assignedWidth
      presentationList.assignedHeightList    = repeat @lhs.assignedHeight
      presentationList.assignedVRefList     = repeat @lhs.assignedVRef
      presentationList.assignedHRefList     = repeat @lhs.assignedHRef
-}
--  | WithP

SEM PresentationList [ assignedWidthList, assignedHeightList, assignedVRefList, assignedHRefList : {[Int]} | | ]
  | Cons 
      hd.assignedWidth = head @lhs.assignedWidthList
      tl.assignedWidthList = tail @lhs.assignedWidthList
      hd.assignedHeight = head @lhs.assignedHeightList
      tl.assignedHeightList = tail @lhs.assignedHeightList
      hd.assignedVRef = head @lhs.assignedVRefList
      tl.assignedVRefList = tail @lhs.assignedVRefList
      hd.assignedHRef = head @lhs.assignedHRefList
      tl.assignedHRefList = tail @lhs.assignedHRefList


-- why do presentations need this value themselves? Poly & rect need it for scaling.
-- instead of sending back, maybe row and col can keep a local copy? or will this interfere
-- with top/bottom/etc-aligning? 
SEM Presentation [ || finalHeight, finalWidth, finalVRef, finalHRef : Int ]
  | *
      loc.finalWidth  : Int
      loc.finalHeight : Int
      loc.finalVRef   : Int
      loc.finalHRef   : Int
  | EmptyP
      loc.finalWidth  = @lhs.assignedWidth
      loc.finalHeight = @lhs.assignedHeight
      loc.finalVRef   = @lhs.assignedVRef
      loc.finalHRef   = @lhs.assignedHRef
  | StringP 
      loc.finalWidth  = @minWidth
      loc.finalHeight = @minHeight
      loc.finalVRef   = @lhs.assignedVRef
      loc.finalHRef   = @lhs.assignedHRef
  | RectangleP  
      loc.finalWidth  = @minWidth
      loc.finalHeight = @minHeight
      loc.finalVRef   = @lhs.assignedVRef
      loc.finalHRef   = @lhs.assignedHRef
  | EllipseP  
      loc.finalWidth  = @minWidth
      loc.finalHeight = @minHeight
      loc.finalVRef   = @lhs.assignedVRef
      loc.finalHRef   = @lhs.assignedHRef
  | ImageP  
      loc.finalWidth  = @lhs.assignedWidth
      loc.finalHeight = @lhs.assignedHeight
      loc.finalVRef   = @lhs.assignedVRef
      loc.finalHRef   = @lhs.assignedHRef
  | PolyP 
      loc.finalWidth  = @lhs.assignedWidth
      loc.finalHeight = @lhs.assignedHeight
      loc.finalVRef   = @lhs.assignedVRef
      loc.finalHRef   = @lhs.assignedHRef
  | RowP
      loc.finalWidth  = sum @presentationList.finalWidthList
      loc.finalHeight = @lhs.assignedHeight
      loc.finalVRef   = @lhs.assignedVRef
      loc.finalHRef   = @lhs.assignedHRef
                        {- the sum below does not work when hRef is modified by a with. 
                           It is as of yet unclear whether the simpler computation causes any problems
                        if null @presentationList.hRefList then 0
                        else if @presentationList.hStretchList!! @hRefNr then @lhs.assignedHRef
		                else sum (take @hRefNr @assignedWidths) + (@presentationList.hRefList !! @hRefNr)
		        -}
  | ColP
      loc.finalWidth  = @lhs.assignedWidth
      loc.finalHeight = sum @presentationList.finalHeightList --@lhs.assignedHeight
      loc.finalVRef   = @lhs.assignedVRef
                        {-
                        if null @presentationList.vRefList then 0
                        else if @presentationList.vStretchList!! @vRefNr then @lhs.assignedVRef
		             else sum (take @vRefNr @assignedHeights) + (@presentationList.vRefList !! @vRefNr)
		        -}
      loc.finalHRef   = @lhs.assignedHRef
  | OverlayP 
      loc.finalWidth  = @lhs.assignedWidth
      loc.finalHeight = @lhs.assignedHeight
      loc.finalVRef   = @lhs.assignedVRef
      loc.finalHRef   = @lhs.assignedHRef
  | GraphP
      loc.finalWidth  = @minWidth
      loc.finalHeight = @minHeight
      loc.finalVRef   = @lhs.assignedVRef
      loc.finalHRef   = @lhs.assignedHRef
  | VertexP
      loc.finalWidth  = @lhs.assignedWidth
      loc.finalHeight = @lhs.assignedHeight
      loc.finalVRef   = @lhs.assignedVRef
      loc.finalHRef   = @lhs.assignedHRef
  | FormatterP
      loc.finalWidth  = debug Err "ArrangerAG.finalWidth: FormatterP must be unfolded first" 0
      loc.finalHeight = debug Err "ArrangerAG.finalHeight: FormatterP must be unfolded first" 0
      loc.finalVRef   = debug Err "ArrangerAG.finalVRef: FormatterP must be unfolded first" 0
      loc.finalHRef   = debug Err "ArrangerAG.finalHRef: FormatterP must be unfolded first" 0
{-
  | TestPresentation 
      loc.finalWidth = error "not implemented"
      loc.finalHeight = error "not implemented"
      loc.finalVRef = error "not implemented"
      loc.finalHRef = error "not implemented"
  | MatrixPresentation
      loc.finalWidth = @lhs.assignedWidth
      loc.finalHeight = @lhs.assignedHeight
      loc.finalVRef = if null @presentationList.vRefList then 0 -- we need H/HRefNrs here, but there not in MatrixPresentation yet
                      else head @rowTopHeights
      loc.finalHRef = if null @presentationList.vRefList then 0
                      else head @colLeftWidths
  | LayedOutRowP 
      loc.finalWidth = error "not implemented"
      loc.finalHeight = error "not implemented"
      loc.finalVRef = error "not implemented"
      loc.finalHRef = error "not implemented"
  | AlternativePresentation 
      loc.finalWidth = @presentationList.finalWidthList !! @firstFit
      loc.finalHeight = @presentationList.finalHeightList !! @firstFit
      loc.finalVRef = @presentationList.finalVRefList !! @firstFit
      loc.finalHRef = @presentationList.finalHRefList !! @firstFit
      loc.firstFit = selectFirstFit @lhs.assignedWidth @presentationList.finalWidthList -- no HRefs (yet)
-}
  | WithP
{-
      loc.wdth = 
      loc.hght = 
      loc.vRef = 
      loc.hRef = 
-}


ATTR PresentationList [  | |  finalWidthList, finalHeightList, finalVRefList, finalHRefList : {[Int]} ]
SEM PresentationList
  | Nil
      lhs.finalWidthList  = []
      lhs.finalHeightList = []
      lhs.finalVRefList   = []
      lhs.finalHRefList   = []
  | Cons 
      lhs.finalWidthList  = @hd.finalWidth  : @tl.finalWidthList
      lhs.finalHeightList = @hd.finalHeight : @tl.finalHeightList
      lhs.finalVRefList   = @hd.finalVRef   : @tl.finalVRefList
      lhs.finalHRefList   = @hd.finalHRef   : @tl.finalHRefList


-- Viewed Area

-- propagated with copy rules
ATTR Root Presentation PresentationList [ viewedArea : Rectangle | | ]


-- Upper left corner of the arrangement. Used for determining whether arrangement is in view.
-- Note!! This absx & absy is not the same as the lux and luy in the renderer, which denote the upper
-- left corner of the parent arrangement. In the renderer, each presentation needs to add its own 
-- width and height to (lux,luy) to get its own upper left corner.
-- Also note that for vertices (absx,absy) is not position of the vertex, since for vertices
-- xList and yList are lists of 0's. 
ATTR Presentation PresentationList [ absx, absy : Int | | ]
SEM Root
  | Root 
      presentation.absx = 0
      presentation.absy = 0
      
SEM PresentationList
  | Cons 
      hd.absx = @lhs.absx + head @lhs.xList
      hd.absy = @lhs.absy + head @lhs.yList

      
-- lu attributes for all the other situations are handled by copy rules

-- Position calculation

SEM Root
  | Root 
      presentation.x = 0
      presentation.y = 0

ATTR Presentation [ x, y : Int | | ]
SEM Presentation
  | RowP
      presentationList.xList    = init.scanl (+) 0 $ @presentationList.finalWidthList
      presentationList.yList    = [ @finalVRef - cvRef | cvRef <- @presentationList.finalVRefList ]
  | ColP
      presentationList.xList    = [ @finalHRef - chRef | chRef <- @presentationList.finalHRefList ]
      presentationList.yList    = init.scanl (+) 0 $ @presentationList.finalHeightList
  | OverlayP
      presentationList.xList    = [ @finalHRef - chRef | chRef <- @presentationList.finalHRefList ]
      presentationList.yList    = [ @finalVRef - cvRef | cvRef <- @presentationList.finalVRefList ]
  | GraphP -- finalRefs are 0 for the GraphP
      presentationList.xList    = map (0-) @presentationList.finalHRefList
      presentationList.yList    = map (0-) @presentationList.finalVRefList
  | VertexP
      child.x                   = 0
      child.y                   = 0
  | FormatterP
      presentationList.xList    = debug Err "ArrangerAG.xList: FormatterP must be unfolded first" []
      presentationList.yList    = debug Err "ArrangerAG.yList: FormatterP must be unfolded first" []
{-
  | MatrixPresentation -- x and y are added to cumulative heights and widths
      loc.cumulativeColWidths = init. scanl (+) 0 $ @colWidths
      loc.cumulativeRowHeights = init. scanl (+) 0 $ @rowHeights
      loc.absoluteRowRefYs = zipWith (+) @cumulativeRowHeights @rowTopHeights
      loc.absoluteColRefXs = zipWith (+) @cumulativeColWidths @colLeftWidths 
      presentationList.xList    = zipWith (-) (concat . repeat $ @absoluteColRefXs) @presentationList.finalHRefList
      presentationList.yList    = zipWith (-) (concat . map (replicate @n) $ @absoluteRowRefYs) @presentationList.finalVRefList
  | LayedOutRowP
      presentationList.xList    = error "LayedOut row not implemented yet."
      presentationList.yList    = error "LayedOut row not implemented yet."
  | AlternativePresentation
      presentationList.xList    = repeat 0
      presentationList.yList    = repeat 0
-}

ATTR PresentationList [ xList, yList : {[Int]} | | ]
SEM PresentationList
  | Cons 
      hd.x = head @lhs.xList
      hd.y = head @lhs.yList
      tl.xList = tail @lhs.xList
      tl.yList = tail @lhs.yList







-- Creating the Arrangement

-- are the widths and heights really needed in the attributed tree?
-- yes, they define the area of the presentation, used for background coloring etc.


-- bit unclear what to do when href and vref are changed in with nodes  @finalVRef @finalHRef
-- for a child in a composite are not the same as the  @finalVRef @finalHRef at the with nodes
-- however in such a case we probably can't do it incrementally anyway

ATTR Presentation [  | | arrangement : {Arrangement node} ]
SEM Presentation
  | EmptyP
      lhs.arrangement = EmptyA (idAFromP @id) 0 0 0 0 0 0 transparent
  | StringP 
      lhs.arrangement = arrangeWhenViewed        @lhs.absx @lhs.absy @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lhs.viewedArea (idAFromP @id) $
                          StringA (idAFromP @id) @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @text @lhs.textColor @lhs.backgroundColor @lhs.font (cumulativeCharWidths @lhs.fontMetrics @lhs.font @text) -- expensive, but will be evaluated lazily
  | RectangleP
      lhs.arrangement = arrangeWhenViewed           @lhs.absx @lhs.absy @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lhs.viewedArea (idAFromP @id) $
                          RectangleA (idAFromP @id) @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lineWidth Solid @lhs.lineColor @lhs.fillColor
  | EllipseP
      lhs.arrangement = arrangeWhenViewed         @lhs.absx @lhs.absy @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lhs.viewedArea (idAFromP @id) $
                          EllipseA (idAFromP @id) @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lineWidth Solid @lhs.lineColor @lhs.fillColor
  | ImageP
      lhs.arrangement = arrangeWhenViewed       @lhs.absx @lhs.absy @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lhs.viewedArea (idAFromP @id) $
                          ImageA (idAFromP @id) @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @src Tile @lhs.lineColor @lhs.backgroundColor
  | PolyP      
      lhs.arrangement = arrangeWhenViewed                  @lhs.absx @lhs.absy @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lhs.viewedArea (idAFromP @id) $
                          let mkPoint (rx, ry) = ( round (rx * fromIntegral (@finalWidth-1))
			                                     , round (ry * fromIntegral (@finalHeight-1)) )
		                  in  PolyA (idAFromP @id) @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef (map mkPoint @pointList) @lineWidth @lhs.lineColor @lhs.backgroundColor
		      
{-
  | TestPresentation
      lhs.arrangement =  RectangleA (idAFromP @id) @lhs.x @lhs.y @finalWidth @finalHeight 0 Solid @lhs.lineColor @lhs.fillColor
-}
  | RowP 
      lhs.arrangement = {- debug Arr ( "rowattrs:"++show 
                                                  ( (@presentationList.minWidthList
						  , @presentationList.hRefList
						  , @presentationList.finalWidthList 
                                                  , @presentationList.finalHRefList )
                                                  , @lhs.assignedWidth
						  , leftCorrection
						  , rightCorrection
						  , assignedWidths 
						  ))$ -}
                        arrangeWhenViewed     @lhs.absx @lhs.absy @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lhs.viewedArea (idAFromP @id) $
                          RowA (idAFromP @id) @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lhs.backgroundColor @presentationList.arrangementList
  | ColP 
      lhs.arrangement = {- debug Arr ( "colattrs:"++show 
                                                  ( (@presentationList.minWidthList
						  , @presentationList.hRefList
						  , @presentationList.finalWidthList 
                                                  , @presentationList.finalHRefList )
                                                  , @lhs.assignedWidth
						  , assign @presentationList.hStretchList (repeat @lhs.assignedWidth) @presentationList.minWidthList 
					          ))$ -}
	                arrangeWhenViewed     @lhs.absx @lhs.absy @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lhs.viewedArea (idAFromP @id) $
                          ColA (idAFromP @id) @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lhs.backgroundColor @presentationList.arrangementList 
  | OverlayP 
      lhs.arrangement = arrangeWhenViewed         @lhs.absx @lhs.absy @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lhs.viewedArea (idAFromP @id) $
                          OverlayA (idAFromP @id) @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lhs.backgroundColor @presentationList.arrangementList
  | GraphP 
      lhs.arrangement = arrangeWhenViewed       @lhs.absx @lhs.absy @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lhs.viewedArea (idAFromP @id) $
                          GraphA (idAFromP @id) @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lhs.backgroundColor 
                                 (length @presentationList.vertices)
                                 ( @presentationList.arrangementList  ++
                                   mkEdges @edges @presentationList.vertices @lhs.lineColor )
                        -- All edges are arranged, even if the graph is partially in view.
                        -- This could be optimized further, but is probably not worth the effort.
    | VertexP
      lhs.arrangement = arrangeWhenViewed @lhs.absx @lhs.absy
                                         @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lhs.viewedArea (idAFromP @id) $
                          VertexA (idAFromP @id) @lhs.x @lhs.y 
                                  @finalWidth @finalHeight @finalHRef @finalVRef @lhs.backgroundColor 
                                  (\a -> let (x,y) = @outline a in (x+ @finalHRef,y+ @finalVRef)) @child.arrangement
  | FormatterP
      lhs.arrangement =  debug Err "ArrangerAG.arrangement: FormatterP must be unfolded first" $ EmptyA NoIDA 0 0 0 0 0 0 transparent
{-
  | LayedOutRowP 
      lhs.arrangement = RowA (idAFromP @id) @lhs.x @lhs.y @finalWidth @finalHeight @finalVRef @finalHRef @lhs.backgroundColor @presentationList.arrangementList
  | MatrixPresentation 
      lhs.arrangement = StringA NoID 0 40 0 0 0 0 ("unimplemented AttrPresentation MatrixPresentation") (0,0,0) defaultFont []
       -- MatrixPresentation (idAFromP @id) @presentationList.arrangementList @lhs.x @lhs.y finalWidth finalHeight @lhs.backgroundColor
  | AlternativePresentation -- remove the alternative presentation
      lhs.arrangement = @presentationList.arrangementList !! @firstFit 
   -- with node is removed by copy rule
-}
  | StructuralP 
      lhs.arrangement = StructuralA (idAFromP @id) @child.arrangement
  | ParsingP 
      lhs.arrangement = ParsingA (idAFromP @id) @child.arrangement
  | LocatorP 
      lhs.arrangement = LocatorA @location @child.arrangement
  | ArrangedP
      lhs.arrangement = --OverlayA NoIDA @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef red
                        --  [ setXYWHA 0 0 @finalWidth @finalHeight @lhs.oldArr 
                        --  ]
                        arrangeWhenViewed @lhs.absx @lhs.absy
                                          @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lhs.viewedArea NoIDA $
                          setXYWHA @lhs.x @lhs.y @finalWidth @finalHeight @lhs.oldArr 
 -- @finalVRef @finalHRef are taken from arrangedP


  | ArrangedP       -- not exactly clear how to assign these attributes using the old values
                          -- what if the AG computes a different value for the refs, reassign?
      loc.minWidth = @finalWidth
      loc.minHeight = @finalHeight
      loc.hStretch = False
      loc.vStretch = False
      loc.vRef = vRefA @lhs.oldArr
      loc.hRef = hRefA @lhs.oldArr
      loc.finalWidth  = widthA @lhs.oldArr
      loc.finalHeight = heightA @lhs.oldArr
      loc.finalVRef   = vRefA @lhs.oldArr
      loc.finalHRef   = hRefA @lhs.oldArr
      loc.unfoldedTree = ArrangedP  -- ?
      loc.maxFormatterDepth = 0     -- ?


ATTR Presentation [ || vertex : {(Int,Int,Int,Outline)} ]
SEM Presentation
  | VertexP
      lhs.vertex = (@i,@x,@y,@outline)
  | EmptyP
      lhs.vertex = showDebug' Err "Warning: graph presentation with non-vertex child:" (0,0,0,\_->(0,0))
  | StringP
      lhs.vertex = showDebug' Err "Warning: graph presentation with non-vertex child:" (0,0,0,\_->(0,0))
  | RectangleP
      lhs.vertex = showDebug' Err "Warning: graph presentation with non-vertex child:" (0,0,0,\_->(0,0))
  | EllipseP
      lhs.vertex = showDebug' Err "Warning: graph presentation with non-vertex child:" (0,0,0,\_->(0,0))
  | ImageP
      lhs.vertex = showDebug' Err "Warning: graph presentation with non-vertex child:" (0,0,0,\_->(0,0))
  | PolyP
      lhs.vertex = showDebug' Err "Warning: graph presentation with non-vertex child:" (0,0,0,\_->(0,0))
  | RowP
      lhs.vertex = showDebug' Err "Warning: graph presentation with non-vertex child:" (0,0,0,\_->(0,0))
  | ColP
      lhs.vertex = showDebug' Err "Warning: graph presentation with non-vertex child:" (0,0,0,\_->(0,0))
  | OverlayP
      lhs.vertex = showDebug' Err "Warning: graph presentation with non-vertex child:" (0,0,0,\_->(0,0))
  | GraphP
      lhs.vertex = showDebug' Err "Warning: graph presentation with non-vertex child:" (0,0,0,\_->(0,0))
  | ArrangedP
      lhs.vertex = showDebug' Err "Warning: graph presentation with non-vertex child:" (0,0,0,\_->(0,0))
  | FormatterP
      lhs.vertex = showDebug' Err "Warning: graph presentation with non-vertex child:" (0,0,0,\_->(0,0))


SEM PresentationList [ || vertices : {[(x,y,Outline)]} ]
  | Nil
      lhs.vertices = []
  | Cons 
      lhs.vertices = @hd.vertex : @tl.vertices
      
-- why the repeat Empties?
ATTR Root         [ oldArr : {Arrangement node}  | | ]

SEM Presentation  [ oldArr : {Arrangement node}   | | ]
  | RowP 
      presentationList.oldArrList = case @lhs.oldArr of
                                      RowA _ _ _ _ _ _ _ _ arrs -> arrs
                                      _                     -> repeat $ EmptyA NoIDA 0 0 0 0 0 0 transparent
  | ColP 
      presentationList.oldArrList = case @lhs.oldArr of 
                                      ColA _ _ _ _ _ _ _ _ arrs -> arrs
                                      _                     -> repeat $ EmptyA NoIDA 0 0 0 0 0 0 transparent
  | OverlayP 
      presentationList.oldArrList = case @lhs.oldArr of 
                                      OverlayA _ _ _ _ _ _ _ _ arrs -> arrs
                                      _                         -> repeat $ EmptyA NoIDA 0 0 0 0 0 0 transparent
  | GraphP 
      presentationList.oldArrList = case @lhs.oldArr of
                                      GraphA _ _ _ _ _ _ _ _ _ arrs -> arrs
                                      _                         -> repeat $ EmptyA NoIDA 0 0 0 0 0 0 transparent
  | VertexP 
      child.oldArr = case @lhs.oldArr of 
                       VertexA _ _ _ _ _ _ _ _ _ arr -> arr
                       _                             -> EmptyA NoIDA 0 0 0 0 0 0 transparent
  | StructuralP 
      child.oldArr = case @lhs.oldArr of
                       StructuralA _ arr -> arr
                       _                 -> EmptyA NoIDA 0 0 0 0 0 0 transparent
  | ParsingP 
      child.oldArr = case @lhs.oldArr of
                       ParsingA _ arr -> arr
                       _              -> EmptyA NoIDA 0 0 0 0 0 0 transparent
  | LocatorP 
      child.oldArr = case @lhs.oldArr of
                       LocatorA _ arr -> arr
                       _              -> EmptyA NoIDA 0 0 0 0 0 0 transparent
  | FormatterP
      presentationList.oldArrList = debug Err "ArrangerAG.oldArrList: FormatterP must be unfolded first" $
                                      repeat $ EmptyA NoIDA 0 0 0 0 0 0 transparent

SEM PresentationList [  oldArrList : {[Arrangement node]} | | ] --  diffTreeList : {[DiffTree]} | | ]
  | Cons 
      hd.oldArr     = head @lhs.oldArrList
      tl.oldArrList = tail @lhs.oldArrList
 
 
ATTR PresentationList [  | |  arrangementList : {[Arrangement node]} ]
SEM PresentationList
  | Nil
      lhs.arrangementList = []
  | Cons 
      lhs.arrangementList = @hd.arrangement : @tl.arrangementList
