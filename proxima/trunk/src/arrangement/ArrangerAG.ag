imports
{
import CommonTypes
import ArrLayerTypes
import ArrLayerUtils
import FontLib
}



{
{-
TODO: 
- add check that graph only has vertex children
- SWITCH href and vref!!! (also in presentation)
- check that using ref in StringA to retrieve the baseline during rendering does not cause any problems (when ref is changed by with nodes)

bug: in (rowR 1 [ glue, pres, glue ]) left glue gets width 0, even when put in an overlay. (apparent in Dazzle network view)
bug: hline and vline implemented with polys are rendered with incorrect white space in boxed primitive
bug: boxed pres `withHRef` x  does not work for top and bottom line and background
- why does Empty.arrangement have 0 for x and y?



-}


{- for AlternativeP
selectFirstFit :: Int -> [ Int ] -> Int       
selectFirstFit availableWidth widths = 
  if null widths 
  then error "Alternative presentation has no alternatives"
  else select widths 0
 where
  select [_] n = n
  select (w:ws) n = if w <= availableWidth then n else select ws (n+1)

-- maybe nicer as synth attribute for presentationList

-}


{- for MatrixP
divide n [] = []
divide n xs = let (line, rest) = splitAt n xs in line : divide n rest

getRows n [] = []
getRows n xs = let (line, rest) = splitAt n xs in line : divide n rest

getCols n xs = foldr (zipWith (:)) (repeat []) (getRows n xs)
-}



-- for FormatterP
unfoldFormatter w ws presentations = 
 let breaks = firstFit w ws
     dividedPresentations = linesFromBreaks breaks presentations
     rows = -- map (\lst -> LayedOutRowP lst 100 32 (repeat (0,0))) presentationLists
         map (RowP NoIDP 0) dividedPresentations
     unfoldedList = ColP NoIDP 0 (rows)
 in  unfoldedList



-- just add words until line overflow
firstFit lineWidth widths = buildFFBreaks lineWidth 0 0 widths

buildFFBreaks _ pos _ [] = [] -- add a breakpoint after last word? prob. not, otherwise return [pos]
buildFFBreaks maxLength pos currentLength (width:widths) =
  let space = if currentLength == 0 then 0 else 0 -- hard coded minimum space, and widths must be >= 0 
      newLength = currentLength + space + width
  in if currentLength == 0 && width > maxLength
     then if null widths 
          then []
          else (pos+1) : buildFFBreaks maxLength pos 0 (widths)
     else if newLength <= maxLength
          then buildFFBreaks maxLength (pos+1) newLength widths
          else pos : buildFFBreaks maxLength (pos) 0 (width:widths)

linesFromBreaks :: [Int] -> [a] -> [[a]]
linesFromBreaks brks wrds = tolines' brks 0 wrds 
   where
   tolines' [] _ wrds = [wrds]
   tolines' (brk:brks) lastbrk wrds = take (brk-lastbrk) wrds :
                                      tolines' brks brk (drop (brk-lastbrk) wrds)




assign [] _ _ = []
assign (str:strs) (a:as) (o:os) = (if str then a else o) : assign strs as os


data Root doc node clip = Root (Presentation doc node clip)

type PresentationList doc node clip = [Presentation doc node clip]
                      
-- We don't want AG to generate the Presentation data types, so data type generation is turned off.
-- However, we do need Root and PresentationList
}

DATA Root 
  | Root presentation : Presentation 


DATA Presentation
  | EmptyP      id : IDP
  | StringP     id : IDP text : String
  | ImageP      id : IDP src : String
  | PolyP       id : IDP pointList : {[ (Float, Float) ]} lineWidth : Int
  | RectangleP  id : IDP w,h : Int lineWidth : Int
  | EllipseP	id : IDP w, h : Int lineWidth : Int
  | RowP        id : IDP vRefNr : Int presentationList : PresentationList
  | ColP        id : IDP xRefNr : Int presentationList : PresentationList
  | OverlayP    id : IDP              presentationList : PresentationList
  | GraphP      id : IDP d : Dirty w,h : Int edges : {[(Int,Int)]} presentationList : PresentationList 
  | VertexP     id : IDP i,x,y: Int outline : Outline child : Presentation
  | FormatterP  id : IDP presentationList : PresentationList
  | WithP       attrRule : AttrRule  child : Presentation
  | StructuralP id : IDP  child : Presentation
  | ParsingP    id : IDP  child : Presentation
  | LocatorP location : {node} child : Presentation
  | ArrangedP -- pres : Presentation

--  | TestPresentation id : IDP  area : Int color : Color
--  | MatrixPresentation id : IDP  m, n : Int presentationList : PresentationList
--  | LayedOutRowP id : IDP  presentationList : PresentationList w, h : Int offsets :  {[ (Int, Int) ]} -- optimization for laying out text
--  | AlternativePresentation id : IDP  presentationList : PresentationList



--  For each Nonterminal:
 -- add id propagation
 -- add formatter depth computation
 -- add attributed tree definition


TYPE PresentationList = [Presentation]


ATTR Root [ font : Font textColor : Color lineColor : Color fillColor : Color backgroundColor : Color
            focus : FocusPres
            mouseDown : {Maybe (UpdateDoc doc clip)}
            popupMenuItems : {[ PopupMenuItem ]}
            screenWidth : Int  
          || maxFormatterDepth : Int  unfoldedTree : Presentation arrangement : {Arrangement node} ]
SEM Root
  | Root
      lhs.maxFormatterDepth = @presentation.maxFormatterDepth
      lhs.unfoldedTree  = @presentation.unfoldedTree
      lhs.arrangement   = @presentation.arrangement


-- Presentation Attribute Propagation in Presentation Tree
-- Root: copy rule

-- Optimize: maybe we only want to update the attrs that are set by the with rule? Or won't that improve much?

SEM Presentation [ font : Font textColor, lineColor, fillColor, backgroundColor : Color
            mouseDown : {Maybe (UpdateDoc doc clip)}
            popupMenuItems : {[ PopupMenuItem ]}
            | | ]
  | WithP
      loc.newAttrs   = @attrRule ( Inh @lhs.font 
                                      @lhs.textColor @lhs.lineColor @lhs.fillColor @lhs.backgroundColor
                                      @lhs.mouseDown @lhs.popupMenuItems
				      @lhs.assignedWidth @lhs.assignedHeight @lhs.assignedXRef @lhs.assignedVRef
				, Syn @child.xRef @child.vRef @child.minWidth @child.minHeight
				      @child.hStretch @child.vStretch
				      @child.finalWidth @child.finalHeight @child.finalXRef @child.finalVRef) 
				           -- no names because ag parser can't handle braces (now it can)
      loc.newSyn = fst @newAttrs
      loc.newInh = snd @newAttrs
      child.font = font @newSyn
      child.textColor = textColor @newSyn
      child.lineColor = lineColor @newSyn
      child.fillColor = fillColor @newSyn
      child.backgroundColor = backgroundColor @newSyn     
      child.mouseDown = mouseDown @newSyn
      child.popupMenuItems = popupMenuItems @newSyn
      child.assignedWidth = assignedWidth @newSyn
      child.assignedHeight = assignedHeight @newSyn
      child.assignedXRef = assignedXRef @newSyn
      child.assignedVRef = assignedVRef @newSyn
      lhs.xRef = xRef @newInh
      lhs.vRef = vRef @newInh
      lhs.minWidth = minWidth @newInh
      lhs.minHeight = minHeight @newInh
      lhs.hStretch = hStretch @newInh
      lhs.vStretch = vStretch @newInh
      lhs.finalWidth = finalWidth @newInh
      lhs.finalHeight = finalHeight @newInh
      lhs.finalXRef = finalXRef @newInh
      lhs.finalVRef = finalVRef @newInh

-- rest is taken care of by copy rule

ATTR PresentationList [  font : Font textColor, lineColor, fillColor, backgroundColor : Color 
                 mouseDown : {Maybe (UpdateDoc doc clip)} popupMenuItems : {[ PopupMenuItem ]} | | ]



-- Font Metrics

-- first, collect all used fonts. They can only change at a with node, so only one check.
-- This could be optimised by only checking with nodes that update the font, instead of e.g.
-- color

ATTR Root [ | allFonts : {[Font]} | ]
-- copy rule

SEM Presentation [ | allFonts : {[Font]} | ]
  | WithP
      child.allFonts = let syn = @newSyn
                       in  font syn : @lhs.allFonts

-- these are nubbed later. Maybe they should only be added if not present?

ATTR PresentationList [ | allFonts : {[Font]} | ] 

ATTR Root [ fontMetrics : FontMetrics | | ]

ATTR Presentation [ fontMetrics : FontMetrics | | ]
  
ATTR PresentationList [ fontMetrics : FontMetrics | | ]  -- copy Rule



-- Focus
--ATTR Presentation [ focus : FocusPres | | ]
-- need some way to represent focus in arrangement.
-- putting in overlays changes paths, and may have many consequences
-- probably best to have a focus attribute in each arr node, but this involves
-- changing many patterns in arrangement functions
-- In the future we probably want an info node with (ID Focus Dirty etc.)
-- maybe for now just fix markFocusArr and diffArr a bit.



-- formatterDepth and maxFormatterDepth definitions   

ATTR Presentation [ | | maxFormatterDepth : Int ]
SEM Presentation
  | EmptyP StringP RectangleP EllipseP ImageP PolyP
      lhs.maxFormatterDepth = 0
  | RowP ColP OverlayP GraphP
      lhs.maxFormatterDepth = maximum @presentationList.maxFormatterDepthList
  | FormatterP
      lhs.maxFormatterDepth = 1 + maximum @presentationList.maxFormatterDepthList
{-
  | TestPresentation 
      lhs.maxFormatterDepth = 0

  | MatrixPresentation 
      lhs.maxFormatterDepth = maximum @presentationList.maxFormatterDepthList
  | LayedOutRowP
      lhs.maxFormatterDepth = maximum @presentationList.maxFormatterDepthList
  | AlternativePresentation 
      lhs.maxFormatterDepth = maximum @presentationList.maxFormatterDepthList
-}
-- | VertexP       copy
-- | WithP       copy
-- | StructuralP copy
-- | ParsingP    copy
-- | LocatorP    copy

ATTR PresentationList [ | | maxFormatterDepthList : {[Int]} ]
SEM PresentationList
  | Nil 
      lhs.maxFormatterDepthList = [0] -- so we get no maximum []
  | Cons 
      lhs.maxFormatterDepthList = @hd.maxFormatterDepth : @tl.maxFormatterDepthList


-- Creating the unfoldedTree
ATTR Presentation [  | | unfoldedTree : Presentation ]
SEM Presentation
  | EmptyP 
      lhs.unfoldedTree = EmptyP @id 
  | StringP 
      lhs.unfoldedTree = StringP @id @text 
  | RectangleP    
      lhs.unfoldedTree = RectangleP @id @w @h @lineWidth
  | EllipseP    
      lhs.unfoldedTree = EllipseP @id @w @h @lineWidth
  | ImageP    
      lhs.unfoldedTree = ImageP @id @src
  | PolyP
      lhs.unfoldedTree = PolyP @id @pointList @lineWidth
  | RowP 
      lhs.unfoldedTree = RowP @id @vRefNr @presentationList.unfoldedTreeList
  | ColP 
      lhs.unfoldedTree = ColP @id @xRefNr @presentationList.unfoldedTreeList
  | OverlayP 
      lhs.unfoldedTree = OverlayP @id @presentationList.unfoldedTreeList
  | GraphP 
      lhs.unfoldedTree = GraphP @id @d @w @h @edges @presentationList.unfoldedTreeList
  | VertexP
      lhs.unfoldedTree = VertexP @id @i @x @y @outline @child.unfoldedTree
  | FormatterP
      lhs.unfoldedTree = unfoldFormatter @lhs.assignedWidth @presentationList.minWidthList @presentationList.unfoldedTreeList
{-
  | TestPresentation             
      lhs.unfoldedTree = TestPresentation @id @area @color
  | MatrixPresentation 
      lhs.unfoldedTree = MatrixPresentation @id @m @n @presentationList.unfoldedTreeList
  | LayedOutRowP 
      lhs.unfoldedTree = LayedOutRowP @id @presentationList.unfoldedTreeList @w @h @offsets
  | AlternativePresentation 
      lhs.unfoldedTree = AlternativePresentation @id @presentationList.unfoldedTreeList
-}
  | WithP
      lhs.unfoldedTree = WithP @attrRule @child.unfoldedTree
  | StructuralP
      lhs.unfoldedTree = StructuralP @id  @child.unfoldedTree
  | ParsingP
      lhs.unfoldedTree = ParsingP @id  @child.unfoldedTree
  | LocatorP
      lhs.unfoldedTree = LocatorP @location @child.unfoldedTree
-- bit of a hack, but the children are needed as values of type Presentation, so we can use unfoldedTreeList,
-- as there will not be any formatters inside anyway

ATTR PresentationList [  | |  unfoldedTreeList : {[Presentation]} ]
SEM PresentationList
  | Nil
      lhs.unfoldedTreeList = []
  | Cons 
      lhs.unfoldedTreeList = @hd.unfoldedTree : @tl.unfoldedTreeList



-- char width not ok for more complicated (overlapping) glyphs like ff ligature in tex. 
-- char height sometimes needed for individual characters

-- matrix does not work correctly yet: empty `withWidth` 50 `beside` matrix is problem
-- no stretch in matrix

-- row in row has problems with vRef
-- xRef and vRef updates do not work properly


-- ref and size as ag aspects:

SEM Presentation [ || minWidth, minHeight : Int hStretch, vStretch : Bool xRef, vRef : Int ]
  | *
      loc.minWidth : Int
      loc.minHeight : Int
      loc.hStretch : Bool
      loc.vStretch : Bool
      loc.xRef : Int
      loc.vRef : Int
      
  | EmptyP
      loc.minWidth = 0
      loc.minHeight = 0
      loc.hStretch = False
      loc.vStretch = False
      loc.xRef = 0
      loc.vRef = 0
  | StringP 
      loc.minWidth = textWidth @lhs.fontMetrics @lhs.font @text
      loc.minHeight = charHeight @lhs.fontMetrics @lhs.font
      loc.hStretch = False
      loc.vStretch = False
      loc.xRef = baseLine @lhs.fontMetrics @lhs.font
      loc.vRef = 0       
  | RectangleP EllipseP GraphP
      loc.minWidth = @w
      loc.minHeight = @h
      loc.hStretch = False
      loc.vStretch = False
      loc.xRef = 0
      loc.vRef = 0
  | ImageP PolyP
      loc.minWidth = 0
      loc.minHeight = 0
      loc.hStretch = True
      loc.vStretch = True
      loc.xRef = 0
      loc.vRef = 0
--  | VertexP copy all
  | RowP 
      loc.minTopHeight = if null @presentationList.xRefList then 0
                            else maximum @presentationList.xRefList
      loc.minBottomHeight = if null @presentationList.xRefList then 0
                            else maximum [ minHeight - xRef | (minHeight, xRef) <- zip @presentationList.minHeightList @presentationList.xRefList ]
      loc.minWidth = sum @presentationList.minWidthList
      loc.minHeight = @minTopHeight + @minBottomHeight
      loc.hStretch = or @presentationList.hStretchList
      loc.vStretch = not (null @presentationList.vStretchList) && and @presentationList.vStretchList
      loc.xRef = @minTopHeight
      loc.vRef = if null @presentationList.vRefList then 0
                 else sum (take @vRefNr @presentationList.minWidthList) + @presentationList.vRefList !! @vRefNr
  | ColP
      loc.minLeftWidth = if null @presentationList.vRefList then 0
                         else maximum @presentationList.vRefList
      loc.minRightWidth = if null @presentationList.vRefList then 0
                          else maximum [ minWidth - vRef | (minWidth, vRef) <- zip @presentationList.minWidthList @presentationList.vRefList ]
      loc.minWidth = @minLeftWidth + @minRightWidth 
      loc.minHeight = sum @presentationList.minHeightList
      loc.hStretch = not (null @presentationList.hStretchList) && and @presentationList.hStretchList
      loc.vStretch = or @presentationList.vStretchList
      loc.xRef = if null @presentationList.xRefList then 0
                 else sum (take @xRefNr @presentationList.minHeightList) + @presentationList.xRefList !! @xRefNr
      loc.vRef = @minLeftWidth
  | OverlayP 
      loc.minLeftWidth = maximum @presentationList.vRefList
      loc.minRightWidth = maximum [ minWidth - vRef | (minWidth, vRef) <- zip @presentationList.minWidthList @presentationList.vRefList ]
      loc.minWidth = @minLeftWidth + @minRightWidth 
      loc.minTopHeight = maximum @presentationList.xRefList 
      loc.minBottomHeight = maximum [ minHeight - xRef | (minHeight, xRef) <- zip @presentationList.minHeightList @presentationList.xRefList ]
      loc.minHeight = @minTopHeight + @minBottomHeight
      loc.hStretch = not (null @presentationList.hStretchList) && and @presentationList.hStretchList
      loc.vStretch = not (null @presentationList.vStretchList) && and @presentationList.vStretchList
      loc.xRef = @minTopHeight
      loc.vRef = @minLeftWidth
  | FormatterP
      loc.minWidth = 0
      loc.minHeight = 0
      loc.hStretch = True
      loc.vStretch = True
      loc.xRef = 0
      loc.vRef = 0

    {-  loc.topHeight = maximum @presentationList.xRefList
      loc.bottomHeight = maximum [ minHeight - xRef | (minHeight, xRef) <- zip @presentationList.minHeightList @presentationList.xRefList ]
      loc.leftWidth = maximum @presentationList.vRefList
      loc.rightWidth = maximum [ minWidth - vRef | (minWidth, vRef) <- zip @presentationList.minWidthList @presentationList.vRefList ]
      loc.minWidth = @leftWidth + @rightWidth 
      loc.minHeight = @topHeight + @bottomHeight
      loc.xRef = @topHeight
      loc.vRef = @leftWidth-}
{-
  | TestPresentation 
      loc.minWidth = error "not implemented"
      loc.minHeight = error "not implemented"
      loc.hStretch = error "not implemented" 
      loc.vStretch = error "not implemented" 
      loc.xRef = error "not implemented"
      loc.vRef = error "not implemented"

  | MatrixPresentation
      loc.rowTopHeights = map maximum (getRows @n @presentationList.xRefList)
      loc.rowBottomHeights = showDebug' Arr "rws:" $ map (\minHghtsXRefs ->
                                   maximum [ minHeight - xRef | (minHeight, xRef) <- minHghtsXRefs ]
				 ) (getRows @n (zip @presentationList.minHeightList @presentationList.xRefList))
      loc.colLeftWidths = map maximum (getCols @n @presentationList.vRefList)
      loc.colRightWidths = showDebug' Arr  "rws:" $ map (\minWdthsVRefs ->
                                   maximum [ minWidth - vRef | (minWidth, vRef) <- minWdthsVRefs ]
				 ) (getCols @n (zip @presentationList.minWidthList @presentationList.vRefList))
      loc.rowHeights = showDebug' Arr "rhgts:" $ zipWith (+) @rowTopHeights @rowBottomHeights
      loc.colWidths = showDebug' Arr "cwdths:" $ zipWith (+) @colLeftWidths @colRightWidths
      loc.minWidth = sum @colLeftWidths + sum @colRightWidths
      loc.minHeight = sum @rowTopHeights + sum @rowBottomHeights
      loc.hStretch = False
      loc.vStretch = False
      loc.xRef = if null @presentationList.xRefList then 0
                else head @rowTopHeights
      loc.vRef = 0
  | LayedOutRowP 
      loc.minWidth = error "not implemented"
      loc.minHeight = error "not implemented"
      loc.hStretch = error "not implemented" 
      loc.vStretch = error "not implemented" 
      loc.xRef = error "not implemented"
      loc.vRef = error "not implemented"
  | AlternativePresentation 
      loc.minWidth = 0
      loc.minHeight = 0
      loc.hStretch = True
      loc.vStretch = True
      loc.xRef = 0
      loc.vRef = 0
-}
  | WithP
{-
      loc.wdth = 
      loc.minHeight = 
      loc.xRef = 
      loc.vRef = 
-}
ATTR PresentationList [  | |  minWidthList, minHeightList : {[Int]} xRefList, vRefList : {[Int]}
                       hStretchList, vStretchList : {[Bool]} ]
SEM PresentationList
  | Nil
      lhs.minWidthList = []
      lhs.minHeightList = []
      lhs.hStretchList = []
      lhs.vStretchList = []
      lhs.xRefList = []
      lhs.vRefList = []
  | Cons 
      lhs.minWidthList = @hd.minWidth : @tl.minWidthList
      lhs.minHeightList = @hd.minHeight : @tl.minHeightList
      lhs.hStretchList = @hd.hStretch : @tl.hStretchList
      lhs.vStretchList = @hd.vStretch : @tl.vStretchList
      lhs.xRefList = @hd.xRef : @tl.xRefList
      lhs.vRefList = @hd.vRef : @tl.vRefList




SEM Root
  | Root -- if scr < min, assign min
      presentation.assignedWidth = if @presentation.hStretch then @lhs.screenWidth else @presentation.minWidth
      presentation.assignedHeight = if @presentation.vStretch then 800 else @presentation.minHeight -- should be screenHeight
      presentation.assignedXRef = @presentation.xRef -- is ignored anyway 
      presentation.assignedVRef = @presentation.vRef 

SEM Presentation [ assignedWidth, assignedHeight, assignedXRef, assignedVRef : Int | | ]
  | RowP
      loc.assignedWidths = if @presentationList.hStretchList!! @vRefNr -- if Ref Object is stretch, all children get
                                 then assign @presentationList.hStretchList -- equal space           +1, because refobj is stretch too
                                               (repeat((@leftTotalSpace+ @rightTotalSpace)`div`(@leftHStretches+1+ @rightHStretches))
						
					       )
					       @presentationList.minWidthList
		                 else assign @presentationList.hStretchList
                                               (  replicate @vRefNr (@leftChildSpace) 
					       ++ [0] -- not used
					       ++ repeat @rightChildSpace
					       )
					       @presentationList.minWidthList
      presentationList.assignedWidthList    = @assignedWidths
      presentationList.assignedVRefList     = @presentationList.vRefList -- is not right, nested rows don't work now

      presentationList.assignedHeightList   = assign @presentationList.vStretchList
                                              (repeat @lhs.assignedHeight) @presentationList.minHeightList 
      presentationList.assignedXRefList     = assign @presentationList.vStretchList
                                              (repeat @xRef)--@lhs.assignedXRef)
					                           @presentationList.xRefList 

       -- width of stretching children should not be subtracted from available width
       -- for the moment this amount is added back to it as left and right corrections
      loc.stretchMinWidths = assign @presentationList.hStretchList @presentationList.minWidthList (repeat 0)
      -- this list contains the widths for the non stretchers, the other widths are 0

      loc.leftCorrection = sum (take @vRefNr @stretchMinWidths) 
                              + if @presentationList.hStretchList!! @vRefNr then @stretchMinWidths !! @vRefNr else 0
      loc.rightCorrection = sum (drop (@vRefNr+1) @stretchMinWidths)

      loc.leftTotalSpace = @lhs.assignedVRef - @vRef    + @leftCorrection
      loc.rightTotalSpace = @lhs.assignedWidth - @minWidth - @leftTotalSpace  + @rightCorrection
      loc.leftHStretches = length . filter (==True) . take @vRefNr $ @presentationList.hStretchList 
      loc.rightHStretches = length . filter (==True) . drop (@vRefNr+1) $ @presentationList.hStretchList 
      loc.leftChildSpace = round (fromIntegral @leftTotalSpace / fromIntegral @leftHStretches )
      loc.rightChildSpace = round (fromIntegral @rightTotalSpace / fromIntegral @rightHStretches )
 
       
      -- @lhs.assigned vs final????
  | ColP
      presentationList.assignedWidthList    = assign @presentationList.hStretchList
                                              (repeat @lhs.assignedWidth) @presentationList.minWidthList 
      -- in case of stretch, return composite's ref
      presentationList.assignedVRefList     = assign @presentationList.hStretchList
                                              (repeat @lhs.assignedVRef)
					      @presentationList.vRefList 
      loc.assignedHeights = if @presentationList.vStretchList!! @xRefNr -- if Ref Object is stretch, all children get
                            then assign @presentationList.vStretchList -- equal space           +1, because refobj is stretch too
                                               (repeat((@topTotalSpace+ @bottomTotalSpace)`div`(@topVStretches+1+ @bottomVStretches))
						
					       )
					       @presentationList.minHeightList
		            else assign @presentationList.vStretchList
                                               (  replicate @xRefNr (@topChildSpace) 
					       ++ [0] -- not 0
					       ++ repeat @bottomChildSpace
					       )
					       @presentationList.minHeightList
      presentationList.assignedHeightList    = @assignedHeights
      presentationList.assignedXRefList     = {-debug Arr (  "assXRef:"++show @lhs.assignedXRef
						++ "XRef:"++ show @xRef
						++ "minHeight:"++show minHeight
						++ "assHeight:"++show @lhs.assignedHeight
						++ "topTotal:"++ show topTotalSpace
						++ "botTotal:"++ show bottomTotalSpace
						)-}  @presentationList.xRefList -- is not right, nested cols don't work now

       -- width of stretching children should not be subtracted from available height
       -- for the moment this amount is added back to it as top and bottom corrections
      loc.stretchMinHeights = assign @presentationList.vStretchList @presentationList.minHeightList (repeat 0)
      -- this list contains the heights for the non stretchers, the other heights are 0

      loc.topCorrection = sum (take @xRefNr @stretchMinHeights) 
                              + if @presentationList.vStretchList!! @xRefNr then @stretchMinHeights !! @xRefNr else 0
      loc.bottomCorrection = sum (drop (@xRefNr+1) @stretchMinHeights)

      
      
      
      loc.topTotalSpace = @lhs.assignedXRef - @xRef  + @topCorrection     -- minTopHeight
      loc.bottomTotalSpace = @lhs.assignedHeight - @minHeight - @topTotalSpace   + @bottomCorrection
      loc.topVStretches = length . filter (==True) . take @xRefNr $ @presentationList.vStretchList 
      loc.bottomVStretches = length . filter (==True) . drop (@xRefNr+1) $ @presentationList.vStretchList 
      loc.topChildSpace = round (fromIntegral @topTotalSpace / fromIntegral @topVStretches )
      loc.bottomChildSpace = round (fromIntegral @bottomTotalSpace / fromIntegral @bottomVStretches )
  | OverlayP
      presentationList.assignedHeightList   = assign @presentationList.vStretchList
                                              (repeat @lhs.assignedHeight) @presentationList.minHeightList 
      presentationList.assignedXRefList     = assign @presentationList.vStretchList
                                              (repeat @lhs.assignedXRef) @presentationList.xRefList 
      presentationList.assignedWidthList    = assign @presentationList.hStretchList
                                              (repeat @lhs.assignedWidth) @presentationList.minWidthList 
      presentationList.assignedVRefList     = assign @presentationList.hStretchList
                                              (repeat @lhs.assignedVRef) @presentationList.vRefList 
  | GraphP -- just use minSize and h/vRef for assigned Size and Ref. Stretching does not make sense in a GraphP
      presentationList.assignedHeightList = @presentationList.minHeightList 
      presentationList.assignedXRefList   = @presentationList.xRefList 
      presentationList.assignedWidthList  = @presentationList.minWidthList 
      presentationList.assignedVRefList   = @presentationList.vRefList 
  | FormatterP
      presentationList.assignedWidthList    = debug Err "FormatterP must be unfolded first" []
      presentationList.assignedHeightList   = debug Err "FormatterP must be unfolded first" []
      presentationList.assignedXRefList     = debug Err "FormatterP must be unfolded first" []
      presentationList.assignedVRefList     = debug Err "FormatterP must be unfolded first" []
{-
  | MatrixPresentation
-- is a lot more complicated than this
      presentationList.assignedHeightList    =assign @presentationList.vStretchList
                                              (concat. map (replicate @n)$ @rowHeights)
					      @presentationList.minHeightList 
      presentationList.assignedXRefList     = assign @presentationList.vStretchList
                                              (concat. map (replicate @n)$ @rowTopHeights) --(repeat @lhs.assignedXRef)
					      @presentationList.xRefList 
      presentationList.assignedWidthList    = assign @presentationList.hStretchList
                                              (concat . repeat $ @colWidths) 
					      @presentationList.minWidthList 
      presentationList.assignedVRefList     = assign @presentationList.hStretchList
                                              (concat . repeat $ @colLeftWidths) --(repeat @lhs.assignedVRef)
					      @presentationList.vRefList 
   --   presentationList.assignedWidthList    = @presentationList.minWidthList
 --     presentationList.assignedHeightList   = @presentationList.minHeightList
 --     presentationList.assignedXRefList     = @presentationList.xRefList
   --   presentationList.assignedVRefList     = @presentationList.vRefList
  | LayedOutRowP
      presentationList.assignedWidthList    = error "LayedOut row not implemented yet."
      presentationList.assignedHeightList    = error "LayedOut row not implemented yet."
      presentationList.assignedXRefList    = error "LayedOut row not implemented yet."
      presentationList.assignedVRefList    = error "LayedOut row not implemented yet."
  | AlternativePresentation
      presentationList.assignedWidthList    = repeat @lhs.assignedWidth
      presentationList.assignedHeightList    = repeat @lhs.assignedHeight
      presentationList.assignedXRefList     = repeat @lhs.assignedXRef
      presentationList.assignedVRefList     = repeat @lhs.assignedVRef
-}
--  | WithP

SEM PresentationList [ assignedWidthList, assignedHeightList, assignedXRefList, assignedVRefList : {[Int]} | | ]
  | Cons 
      hd.assignedWidth = head @lhs.assignedWidthList
      tl.assignedWidthList = tail @lhs.assignedWidthList
      hd.assignedHeight = head @lhs.assignedHeightList
      tl.assignedHeightList = tail @lhs.assignedHeightList
      hd.assignedXRef = head @lhs.assignedXRefList
      tl.assignedXRefList = tail @lhs.assignedXRefList
      hd.assignedVRef = head @lhs.assignedVRefList
      tl.assignedVRefList = tail @lhs.assignedVRefList


-- why do presentations need this value themselves? Poly & rect need it for scaling.
-- instead of sending back, maybe row and col can keep a local copy? or will this interfere
-- with top/bottom/etc-aligning? 
SEM Presentation [ || finalHeight, finalWidth, finalXRef, finalVRef : Int ]
  | *
      loc.finalWidth  : Int
      loc.finalHeight : Int
      loc.finalXRef   : Int
      loc.finalVRef   : Int
  | EmptyP
      loc.finalWidth  = @lhs.assignedWidth
      loc.finalHeight = @lhs.assignedHeight
      loc.finalXRef   = @lhs.assignedXRef
      loc.finalVRef   = @lhs.assignedVRef
  | StringP 
      loc.finalWidth  = @minWidth
      loc.finalHeight = @minHeight
      loc.finalXRef   = @lhs.assignedXRef
      loc.finalVRef   = @lhs.assignedVRef
  | RectangleP  
      loc.finalWidth  = @minWidth
      loc.finalHeight = @minHeight
      loc.finalXRef   = @lhs.assignedXRef
      loc.finalVRef   = @lhs.assignedVRef
  | EllipseP  
      loc.finalWidth  = @minWidth
      loc.finalHeight = @minHeight
      loc.finalXRef   = @lhs.assignedXRef
      loc.finalVRef   = @lhs.assignedVRef
  | ImageP  
      loc.finalWidth  = @lhs.assignedWidth
      loc.finalHeight = @lhs.assignedHeight
      loc.finalXRef   = @lhs.assignedXRef
      loc.finalVRef   = @lhs.assignedVRef
  | PolyP 
      loc.finalWidth  = @lhs.assignedWidth
      loc.finalHeight = @lhs.assignedHeight
      loc.finalXRef   = @lhs.assignedXRef
      loc.finalVRef   = @lhs.assignedVRef
  | RowP
      loc.finalWidth  =  sum @presentationList.finalWidthList
      loc.finalHeight = @lhs.assignedHeight
      loc.finalXRef   = @lhs.assignedXRef
      loc.finalVRef   = if null @presentationList.vRefList then 0
                        else if @presentationList.hStretchList!! @vRefNr then @lhs.assignedVRef
		                else sum (take @vRefNr @assignedWidths) + (@presentationList.vRefList !! @vRefNr)
  | ColP
      loc.finalWidth = @lhs.assignedWidth
      loc.finalHeight =  sum @presentationList.finalHeightList --@lhs.assignedHeight
      loc.finalXRef = if null @presentationList.xRefList then 0
                      else if @presentationList.vStretchList!! @xRefNr then @lhs.assignedXRef
		              else sum (take @xRefNr @assignedHeights) + (@presentationList.xRefList !! @xRefNr)
      loc.finalVRef = @lhs.assignedVRef
  | OverlayP 
      loc.finalWidth = @lhs.assignedWidth
      loc.finalHeight = @lhs.assignedHeight
      loc.finalXRef = @lhs.assignedXRef
      loc.finalVRef = @lhs.assignedVRef
  | GraphP
      loc.finalWidth  = @minWidth
      loc.finalHeight = @minHeight
      loc.finalXRef   = @lhs.assignedXRef
      loc.finalVRef   = @lhs.assignedVRef
  | VertexP
      loc.finalWidth  = @lhs.assignedWidth
      loc.finalHeight = @lhs.assignedHeight
      loc.finalXRef   = @lhs.assignedXRef
      loc.finalVRef   = @lhs.assignedVRef
  | FormatterP
      loc.finalWidth  = debug Err "FormatterP must be unfolded first" 0
      loc.finalHeight = debug Err "FormatterP must be unfolded first" 0
      loc.finalXRef   = debug Err "FormatterP must be unfolded first" 0
      loc.finalVRef   = debug Err "FormatterP must be unfolded first" 0
{-
  | TestPresentation 
      loc.finalWidth = error "not implemented"
      loc.finalHeight = error "not implemented"
      loc.finalXRef = error "not implemented"
      loc.finalVRef = error "not implemented"
  | MatrixPresentation
      loc.finalWidth = @lhs.assignedWidth
      loc.finalHeight = @lhs.assignedHeight
      loc.finalXRef = if null @presentationList.xRefList then 0 -- we need H/VRefNrs here, but there not in MatrixPresentation yet
                      else head @rowTopHeights
      loc.finalVRef = if null @presentationList.xRefList then 0
                      else head @colLeftWidths
  | LayedOutRowP 
      loc.finalWidth = error "not implemented"
      loc.finalHeight = error "not implemented"
      loc.finalXRef = error "not implemented"
      loc.finalVRef = error "not implemented"
  | AlternativePresentation 
      loc.finalWidth = @presentationList.finalWidthList !! @firstFit
      loc.finalHeight = @presentationList.finalHeightList !! @firstFit
      loc.finalXRef = @presentationList.finalXRefList !! @firstFit
      loc.finalVRef = @presentationList.finalVRefList !! @firstFit
      loc.firstFit = selectFirstFit @lhs.assignedWidth @presentationList.finalWidthList -- no VRefs (yet)
-}
  | WithP
{-
      loc.wdth = 
      loc.hght = 
      loc.xRef = 
      loc.vRef = 
-}


ATTR PresentationList [  | |  finalWidthList, finalHeightList, finalXRefList, finalVRefList : {[Int]} ]
SEM PresentationList
  | Nil
      lhs.finalWidthList  = []
      lhs.finalHeightList = []
      lhs.finalXRefList   = []
      lhs.finalVRefList   = []
  | Cons 
      lhs.finalWidthList  = @hd.finalWidth  : @tl.finalWidthList
      lhs.finalHeightList = @hd.finalHeight : @tl.finalHeightList
      lhs.finalXRefList   = @hd.finalXRef   : @tl.finalXRefList
      lhs.finalVRefList   = @hd.finalVRef   : @tl.finalVRefList


-- Viewed Area

-- propagated with copy rules
ATTR Root Presentation PresentationList [ viewedArea : Rectangle | | ]


-- Upper left corner of the arrangement. Used for determining whether arrangement is in view.

ATTR Presentation PresentationList [ lux, luy : Int | | ]
SEM Root
  | Root 
      presentation.lux = 0
      presentation.luy = 0
      
SEM PresentationList
  | Cons 
      hd.lux = @lhs.lux + head @lhs.xList
      hd.luy = @lhs.luy + head @lhs.yList

SEM Presentation
  | VertexP
      child.lux = @lhs.lux + @x - @finalVRef
      child.luy = @lhs.luy + @y - @finalXRef
      
-- lu attributes for all the other situations are handled by copy rules

-- Position calculation

SEM Root
  | Root 
      presentation.x = 0
      presentation.y = 0

ATTR Presentation [ x, y : Int | | ]
SEM Presentation
  | RowP
      presentationList.xList    = init.scanl (+) 0 $ @presentationList.finalWidthList
      presentationList.yList    = [ @finalXRef - cxRef | cxRef <- @presentationList.finalXRefList ]
  | ColP
      presentationList.xList    = [ @finalVRef - cvRef | cvRef <- @presentationList.finalVRefList ]
      presentationList.yList    = init.scanl (+) 0 $ @presentationList.finalHeightList
  | OverlayP
      presentationList.xList    = [ @finalVRef - cvRef | cvRef <- @presentationList.finalVRefList ]
      presentationList.yList    = [ @finalXRef - cxRef | cxRef <- @presentationList.finalXRefList ]
  | GraphP -- we could collect x and y's from vertices and send these back, but sending 0 down and letting
           -- the vertices add their own x and y to it is easier. (we use finalWidthList only for the nr of children)
      presentationList.xList    = replicate (length @presentationList.finalWidthList) 0
      presentationList.yList    = replicate (length @presentationList.finalWidthList) 0
  | VertexP
      child.x                   = 0
      child.y                   = 0
  | FormatterP
      presentationList.xList    = debug Err "FormatterP must be unfolded first" []
      presentationList.yList    = debug Err "FormatterP must be unfolded first" []
{-
  | MatrixPresentation -- x and y are added to cumulative heights and widths
      loc.cumulativeColWidths = init. scanl (+) 0 $ @colWidths
      loc.cumulativeRowHeights = init. scanl (+) 0 $ @rowHeights
      loc.absoluteRowRefYs = zipWith (+) @cumulativeRowHeights @rowTopHeights
      loc.absoluteColRefXs = zipWith (+) @cumulativeColWidths @colLeftWidths 
      presentationList.xList    = zipWith (-) (concat . repeat $ @absoluteColRefXs) @presentationList.finalVRefList
      presentationList.yList    = zipWith (-) (concat . map (replicate @n) $ @absoluteRowRefYs) @presentationList.finalXRefList
  | LayedOutRowP
      presentationList.xList    = error "LayedOut row not implemented yet."
      presentationList.yList    = error "LayedOut row not implemented yet."
  | AlternativePresentation
      presentationList.xList    = repeat 0
      presentationList.yList    = repeat 0
-}

ATTR PresentationList [ xList, yList : {[Int]} | | ]
SEM PresentationList
  | Cons 
      hd.x = head @lhs.xList
      hd.y = head @lhs.yList
      tl.xList = tail @lhs.xList
      tl.yList = tail @lhs.yList







-- Creating the Arrangement

-- are the widths and heights really needed in the attributed tree?
-- yes, they define the area of the presentation, used for background coloring etc.


-- bit unclear what to do when href and vref are changed in with nodes  @finalXRef @finalVRef
-- for a child in a composite are not the same as the  @finalXRef @finalVRef at the with nodes
-- however in such a case we probably can't do it incrementally anyway

-- for the position of VertexP we add the Vertex's own coordinates and subtract the refs
ATTR Presentation [  | | arrangement : {Arrangement node} ]
SEM Presentation
  | EmptyP
      lhs.arrangement = EmptyA (idAFromP @id) 0 0 0 0 0 0
  | StringP 
      lhs.arrangement = arrangeWhenViewed @lhs.lux @lhs.luy @finalWidth @finalHeight @lhs.viewedArea (idAFromP @id) $
                          StringA (idAFromP @id) @lhs.x @lhs.y @finalWidth @finalHeight @finalXRef @finalVRef @text @lhs.textColor @lhs.font (cumulativeCharWidths @lhs.fontMetrics @lhs.font @text) -- expensive, but will be evaluated lazily
  | RectangleP
      lhs.arrangement = arrangeWhenViewed @lhs.lux @lhs.luy @finalWidth @finalHeight @lhs.viewedArea (idAFromP @id) $
                          RectangleA (idAFromP @id) @lhs.x @lhs.y @finalWidth @finalHeight @finalXRef @finalVRef @lineWidth Solid @lhs.lineColor @lhs.fillColor
  | EllipseP
      lhs.arrangement = arrangeWhenViewed @lhs.lux @lhs.luy @finalWidth @finalHeight @lhs.viewedArea (idAFromP @id) $
                          EllipseA (idAFromP @id) @lhs.x @lhs.y @finalWidth @finalHeight @finalXRef @finalVRef @lineWidth Solid @lhs.lineColor @lhs.fillColor
  | ImageP
      lhs.arrangement = arrangeWhenViewed @lhs.lux @lhs.luy @finalWidth @finalHeight @lhs.viewedArea (idAFromP @id) $
                          ImageA (idAFromP @id) @lhs.x @lhs.y @finalWidth @finalHeight @finalXRef @finalVRef @src Tile @lhs.lineColor @lhs.backgroundColor
  | PolyP      
      lhs.arrangement = arrangeWhenViewed @lhs.lux @lhs.luy @finalWidth @finalHeight @lhs.viewedArea (idAFromP @id) $
                          let mkPoint (rx, ry) = ( round (rx * fromIntegral (@finalWidth-1))
			                                     , round (ry * fromIntegral (@finalHeight-1)) )
		                  in  PolyA (idAFromP @id) @lhs.x @lhs.y @finalWidth @finalHeight @finalXRef @finalVRef (map mkPoint @pointList) @lineWidth @lhs.lineColor @lhs.backgroundColor
		      
{-
  | TestPresentation
      lhs.arrangement =  RectangleA (idAFromP @id) @lhs.x @lhs.y @finalWidth @finalHeight 0 Solid @lhs.lineColor @lhs.fillColor
-}
  | RowP 
      lhs.arrangement = {- debug Arr ( "rowattrs:"++show 
                                                  ( (@presentationList.minWidthList
						  , @presentationList.vRefList
						  , @presentationList.finalWidthList 
                                                  , @presentationList.finalVRefList )
                                                  , @lhs.assignedWidth
						  , leftCorrection
						  , rightCorrection
						  , assignedWidths 
						  ))$ -}
					    arrangeWhenViewed @lhs.lux @lhs.luy @finalWidth @finalHeight @lhs.viewedArea (idAFromP @id) $
                          RowA (idAFromP @id) @lhs.x @lhs.y @finalWidth @finalHeight @finalXRef @finalVRef @lhs.backgroundColor @presentationList.arrangementList
  | ColP 
      lhs.arrangement = {- debug Arr ( "colattrs:"++show 
                                                  ( (@presentationList.minWidthList
						  , @presentationList.vRefList
						  , @presentationList.finalWidthList 
                                                  , @presentationList.finalVRefList )
                                                  , @lhs.assignedWidth
						  , assign @presentationList.hStretchList (repeat @lhs.assignedWidth) @presentationList.minWidthList 
					          ))$ -}
						arrangeWhenViewed @lhs.lux @lhs.luy @finalWidth @finalHeight @lhs.viewedArea (idAFromP @id) $
                          ColA (idAFromP @id) @lhs.x @lhs.y @finalWidth @finalHeight @finalXRef @finalVRef @lhs.backgroundColor @presentationList.arrangementList 
  | OverlayP 
      lhs.arrangement = arrangeWhenViewed @lhs.lux @lhs.luy @finalWidth @finalHeight @lhs.viewedArea (idAFromP @id) $
                          OverlayA (idAFromP @id) @lhs.x @lhs.y @finalWidth @finalHeight @finalXRef @finalVRef @lhs.backgroundColor @presentationList.arrangementList
  | GraphP 
      lhs.arrangement = arrangeWhenViewed @lhs.lux @lhs.luy @finalWidth @finalHeight @lhs.viewedArea (idAFromP @id) $
                          GraphA (idAFromP @id) @lhs.x @lhs.y @finalWidth @finalHeight @finalXRef @finalVRef @lhs.backgroundColor 
                                 (length @presentationList.vertices)
                                 ( @presentationList.arrangementList  ++
                                   mkEdges @edges @presentationList.vertices @lhs.lineColor )
  | VertexP
      lhs.arrangement = arrangeWhenViewed (@lhs.lux + @x - @finalVRef) (@lhs.luy + @y - @finalXRef) @finalWidth @finalHeight @lhs.viewedArea (idAFromP @id) $
                          VertexA (idAFromP @id) (@lhs.x + @x - @finalVRef) (@lhs.y + @y - @finalXRef)
                                  @finalWidth @finalHeight @finalXRef @finalVRef @lhs.backgroundColor 
                                  (\a -> let (x,y) = @outline a in (x+ @finalVRef,y+ @finalXRef)) @child.arrangement
  | FormatterP
      lhs.arrangement =  debug Err "FormatterP must be unfolded first" $ EmptyA NoIDA 0 0 0 0 0 0
{-
  | LayedOutRowP 
      lhs.arrangement = RowA (idAFromP @id) @lhs.x @lhs.y @finalWidth @finalHeight @finalXRef @finalVRef @lhs.backgroundColor @presentationList.arrangementList
  | MatrixPresentation 
      lhs.arrangement = StringA NoID 0 40 0 0 0 0 ("unimplemented AttrPresentation MatrixPresentation") (0,0,0) defaultFont []
       -- MatrixPresentation (idAFromP @id) @presentationList.arrangementList @lhs.x @lhs.y finalWidth finalHeight @lhs.backgroundColor
  | AlternativePresentation -- remove the alternative presentation
      lhs.arrangement = @presentationList.arrangementList !! @firstFit 
   -- with node is removed by copy rule
-}
  | StructuralP 
      lhs.arrangement = StructuralA (idAFromP @id) @child.arrangement
  | ParsingP 
      lhs.arrangement = ParsingA (idAFromP @id) @child.arrangement
  | LocatorP 
      lhs.arrangement = LocatorA @location @child.arrangement
  | ArrangedP
      lhs.arrangement = setXYWHA @lhs.x @lhs.y @finalWidth @finalHeight @lhs.oldArr --RectangleA NoIDA @lhs.x @lhs.y 10 10 1 Solid black yellow
 -- @finalXRef @finalVRef are taken from arrangedP


  | ArrangedP       -- not exactly clear how to assign these attributes using the old values
                          -- what if the AG computes a different value for the refs, reassign?
      loc.minWidth = @finalWidth
      loc.minHeight = @finalHeight
      loc.hStretch = False
      loc.vStretch = False
      loc.xRef = xRefA @lhs.oldArr
      loc.vRef = vRefA @lhs.oldArr
      loc.finalWidth  = widthA @lhs.oldArr
      loc.finalHeight = heightA @lhs.oldArr
      loc.finalXRef   = xRefA @lhs.oldArr
      loc.finalVRef   = vRefA @lhs.oldArr
      loc.unfoldedTree = ArrangedP  -- ?
      loc.maxFormatterDepth = 0     -- ?


ATTR Presentation [ || vertex : {(Int,Int,Int,Outline)} ]
SEM Presentation
  | VertexP
      lhs.vertex = (@i,@x,@y,@outline)
  | EmptyP
      lhs.vertex = showDebug' Err "Warning: graph presentation with non-vertex child:" (0,0,0,\_->(0,0))
  | StringP
      lhs.vertex = showDebug' Err "Warning: graph presentation with non-vertex child:" (0,0,0,\_->(0,0))
  | RectangleP
      lhs.vertex = showDebug' Err "Warning: graph presentation with non-vertex child:" (0,0,0,\_->(0,0))
  | EllipseP
      lhs.vertex = showDebug' Err "Warning: graph presentation with non-vertex child:" (0,0,0,\_->(0,0))
  | ImageP
      lhs.vertex = showDebug' Err "Warning: graph presentation with non-vertex child:" (0,0,0,\_->(0,0))
  | PolyP
      lhs.vertex = showDebug' Err "Warning: graph presentation with non-vertex child:" (0,0,0,\_->(0,0))
  | RowP
      lhs.vertex = showDebug' Err "Warning: graph presentation with non-vertex child:" (0,0,0,\_->(0,0))
  | ColP
      lhs.vertex = showDebug' Err "Warning: graph presentation with non-vertex child:" (0,0,0,\_->(0,0))
  | OverlayP
      lhs.vertex = showDebug' Err "Warning: graph presentation with non-vertex child:" (0,0,0,\_->(0,0))
  | GraphP
      lhs.vertex = showDebug' Err "Warning: graph presentation with non-vertex child:" (0,0,0,\_->(0,0))
  | ArrangedP
      lhs.vertex = showDebug' Err "Warning: graph presentation with non-vertex child:" (0,0,0,\_->(0,0))
  | FormatterP
      lhs.vertex = showDebug' Err "Warning: graph presentation with non-vertex child:" (0,0,0,\_->(0,0))


SEM PresentationList [ || vertices : {[(x,y,Outline)]} ]
  | Nil
      lhs.vertices = []
  | Cons 
      lhs.vertices = @hd.vertex : @tl.vertices
      
-- why the repeat Empties?
ATTR Root         [ oldArr : {Arrangement node}  | | ]

SEM Presentation  [ oldArr : {Arrangement node}   | | ]
  | RowP 
      presentationList.oldArrList = case @lhs.oldArr of
                                      RowA _ _ _ _ _ _ _ _ arrs -> arrs
                                      _                     -> repeat $ EmptyA NoIDA 0 0 0 0 0 0
  | ColP 
      presentationList.oldArrList = case @lhs.oldArr of 
                                      ColA _ _ _ _ _ _ _ _ arrs -> arrs
                                      _                     -> repeat $ EmptyA NoIDA 0 0 0 0 0 0
  | OverlayP 
      presentationList.oldArrList = case @lhs.oldArr of 
                                      OverlayA _ _ _ _ _ _ _ _ arrs -> arrs
                                      _                         -> repeat $ EmptyA NoIDA 0 0 0 0 0 0
  | GraphP 
      presentationList.oldArrList = case @lhs.oldArr of
                                      GraphA _ _ _ _ _ _ _ _ _ arrs -> arrs
                                      _                         -> repeat $ EmptyA NoIDA 0 0 0 0 0 0
  | VertexP 
      child.oldArr = case @lhs.oldArr of 
                       VertexA _ _ _ _ _ _ _ _ _ arr -> arr
                       _                             -> EmptyA NoIDA 0 0 0 0 0 0
  | StructuralP 
      child.oldArr = case @lhs.oldArr of
                       StructuralA _ arr -> arr
                       _                 -> EmptyA NoIDA 0 0 0 0 0 0
  | ParsingP 
      child.oldArr = case @lhs.oldArr of
                       ParsingA _ arr -> arr
                       _              -> EmptyA NoIDA 0 0 0 0 0 0
  | LocatorP 
      child.oldArr = case @lhs.oldArr of
                       LocatorA _ arr -> arr
                       _              -> EmptyA NoIDA 0 0 0 0 0 0
  | FormatterP
      presentationList.oldArrList = debug Err "FormatterP must be unfolded first" $
                                      repeat $ EmptyA NoIDA 0 0 0 0 0 0

SEM PresentationList [  oldArrList : {[Arrangement node]} | | ] --  diffTreeList : {[DiffTree]} | | ]
  | Cons 
      hd.oldArr     = head @lhs.oldArrList
      tl.oldArrList = tail @lhs.oldArrList
 
 
ATTR PresentationList [  | |  arrangementList : {[Arrangement node]} ]
SEM PresentationList
  | Nil
      lhs.arrangementList = []
  | Cons 
      lhs.arrangementList = @hd.arrangement : @tl.arrangementList
