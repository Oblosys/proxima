imports
{

import CommonTypes
import CommonUtils
import ArrLayerTypes
import ArrLayerUtils
import FontLib
import Maybe
import Debug.Trace
}



{
{-
TODO: 
- add check that graph only has vertex children

bug: boxed pres `withHRef` x  does not work for top and bottom line and background
- why does Empty.arrangement have 0 for x and y?



-}


{- for AlternativeP
selectFirstFit :: Int -> [ Int ] -> Int       
selectFirstFit availableWidth widths = 
  if null widths 
  then error "Alternative presentation has no alternatives"
  else select widths 0
 where
  select [_] n = n
  select (w:ws) n = if w <= availableWidth then n else select ws (n+1)

-- maybe nicer as synth attribute for presentationList

-}


{- for MatrixP
divide n [] = []
divide n xs = let (line, rest) = splitAt n xs in line : divide n rest

getRows n [] = []
getRows n xs = let (line, rest) = splitAt n xs in line : divide n rest

getCols n xs = foldr (zipWith (:)) (repeat []) (getRows n xs)
-}



-- for FormatterP
unfoldFormatter w ws presentations = 
 let breaks = firstFit w ws
     dividedPresentations = linesFromBreaks breaks presentations
     rows = -- map (\lst -> LayedOutRowP lst 100 32 (repeat (0,0))) presentationLists
         map (RowP NoIDP 0) dividedPresentations
     unfoldedList = ColP NoIDP 0 (F (map length dividedPresentations)) rows
 in  --debug Arr ("Unfolded formatter "++show ws++ " unfolded as"++ show (map length dividedPresentations)) $ 
     debug Arr ("Unfolding formatter") $
     unfoldedList



-- just add words until line overflow
firstFit lineWidth widths = buildFFBreaks lineWidth 0 0 widths

buildFFBreaks _ pos _ [] = [] -- add a breakpoint after last word? prob. not, otherwise return [pos]
buildFFBreaks maxLength pos currentLength (width:widths) =
  let space = if currentLength == 0 then 0 else 0 -- hard coded minimum space, and widths must be >= 0 
      newLength = currentLength + space + width
  in if currentLength == 0 && width > maxLength
     then if null widths 
          then []
          else (pos+1) : buildFFBreaks maxLength pos 0 (widths)
     else if newLength <= maxLength
          then buildFFBreaks maxLength (pos+1) newLength widths
          else pos : buildFFBreaks maxLength (pos) 0 (width:widths)

linesFromBreaks :: [Int] -> [a] -> [[a]]
linesFromBreaks brks wrds = tolines' brks 0 wrds 
   where
   tolines' [] _ wrds = [wrds]
   tolines' (brk:brks) lastbrk wrds = take (brk-lastbrk) wrds :
                                      tolines' brks brk (drop (brk-lastbrk) wrds)




assign [] _ _ = []
assign (str:strs) (a:as) (o:os) = (if str then a else o) : assign strs as os


data Root doc node clip = Root (Presentation doc node clip)

type PresentationList doc node clip = [Presentation doc node clip]
                      
-- We don't want AG to generate the Presentation data types, so data type generation is turned off.
-- However, we do need Root and PresentationList
}

DATA Root 
  | Root presentation : Presentation 


DATA Presentation
  | EmptyP      id : IDP
  | StringP     id : IDP text : String
  | ImageP      id : IDP src : String style : ImgStyle
  | PolyP       id : IDP pointList : {[ (Float, Float) ]} lineWidth : Int style : Style
  | RectangleP  id : IDP w,h : Int lineWidth : Int style : Style
  | EllipseP	id : IDP w, h : Int lineWidth : Int style : Style
  | RowP        id : IDP hRefNr : Int presentationList : PresentationList
  | ColP        id : IDP vRefNr : Int formatted : Formatted presentationList : PresentationList
  | OverlayP    id : IDP              presentationList : PresentationList
  | GraphP      id : IDP d : Dirty w,h : Int edges : {[(Int,Int)]} presentationList : PresentationList 
  | VertexP     id : IDP i,x,y: Int outline : Outline child : Presentation
  | FormatterP  id : IDP presentationList : PresentationList
  | WithP       attrRule : AttrRule  child : Presentation
  | StructuralP id : IDP  child : Presentation
  | ParsingP    id : IDP  child : Presentation
  | LocatorP location : {node} child : Presentation
  | ArrangedP

--  | TestPresentation id : IDP  area : Int color : Color
--  | MatrixPresentation id : IDP  m, n : Int presentationList : PresentationList
--  | LayedOutRowP id : IDP  presentationList : PresentationList w, h : Int offsets :  {[ (Int, Int) ]} -- optimization for laying out text
--  | AlternativePresentation id : IDP  presentationList : PresentationList

{-
structure of presentation tree: no children/one child/list of children

  | EmptyP StringP ImageP PolyP RectangleP EllipseP ArrangedP 
  | VertexP WithP StructuralP ParsingP LocatorP 
      @child.
  | RowP ColP OverlayP GraphP FormatterP
      @presentationList.

all Presentation attributes:

minWidth
minHeight
hStretch
vStretch
vRef
hRef
finalHeight
finalWidth
finalVRef
finalHRef
maxFormatterDepth
allFonts
arrangement
vertex
unprunedPres 
-}

--  For each Nonterminal:
 -- add id propagation
 -- add formatter depth computation
 -- add attributed tree definition


TYPE PresentationList = [Presentation]

SEM PresentationList [ || nrOfChildren : Int ]
  | Nil
      lhs.nrOfChildren = 0
  | Cons 
      lhs.nrOfChildren = 1 + @tl.nrOfChildren

ATTR Root [ font : Font textColor : Color lineColor : Color fillColor : Color backgroundColor : Color
            focus : FocusPres
            mouseDown : {Maybe (UpdateDoc doc clip)}
            popupMenuItems : {[ PopupMenuItem ]}
          || maxFormatterDepth : Int arrangement : {Arrangement node} ]
SEM Root
  | Root
      lhs.maxFormatterDepth = @presentation.maxFormatterDepth
      lhs.arrangement   = @presentation.arrangement


-- Presentation Attribute Propagation in Presentation Tree
-- Root: copy rule

-- Optimize: maybe we only want to update the attrs that are set by the with rule? Or won't that improve much?

SEM Presentation [ font : Font textColor, lineColor, fillColor, backgroundColor : Color
            mouseDown : {Maybe (UpdateDoc doc clip)}
            popupMenuItems : {[ PopupMenuItem ]}
            | | ]
  | WithP
      loc.newAttrs   = @attrRule ( Inh @lhs.font 
                                      @lhs.textColor @lhs.lineColor @lhs.fillColor @lhs.backgroundColor
                                      @lhs.mouseDown @lhs.popupMenuItems
				      @lhs.assignedWidth @lhs.assignedHeight @lhs.assignedVRef @lhs.assignedHRef
				, Syn @child.vRef @child.hRef @child.minWidth @child.minHeight
				      @child.hStretch @child.vStretch
				      @child.finalWidth @child.finalHeight @child.finalVRef @child.finalHRef) 
				           -- no names because ag parser can't handle braces (now it can)
      loc.newSyn = fst @newAttrs
      loc.newInh = snd @newAttrs
      child.font = font @newSyn
      child.textColor = textColor @newSyn
      child.lineColor = lineColor @newSyn
      child.fillColor = fillColor @newSyn
      child.backgroundColor = backgroundColor @newSyn     
      child.mouseDown = mouseDown @newSyn
      child.popupMenuItems = popupMenuItems @newSyn
      child.assignedWidth = assignedWidth @newSyn
      child.assignedHeight = assignedHeight @newSyn
      child.assignedVRef = assignedVRef @newSyn
      child.assignedHRef = assignedHRef @newSyn
      lhs.vRef = vRef @newInh
      lhs.hRef = hRef @newInh
      lhs.minWidth = minWidth @newInh
      lhs.minHeight = minHeight @newInh
      lhs.hStretch = hStretch @newInh
      lhs.vStretch = vStretch @newInh
      lhs.finalWidth = finalWidth @newInh
      lhs.finalHeight = finalHeight @newInh
      lhs.finalVRef = finalVRef @newInh
      lhs.finalHRef = finalHRef @newInh

-- rest is taken care of by copy rule

ATTR PresentationList [  font : Font textColor, lineColor, fillColor, backgroundColor : Color 
                 mouseDown : {Maybe (UpdateDoc doc clip)} popupMenuItems : {[ PopupMenuItem ]} | | ]



-- Font Metrics

-- first, collect all used fonts. They can only change at a with node, so only one check.
-- This could be optimised by only checking with nodes that update the font, instead of e.g.
-- color

ATTR Root [ | allFonts : {[Font]} | ]
-- copy rule

SEM Presentation [ | allFonts : {[Font]} | ]
  | WithP
      child.allFonts = let syn = @newSyn
                       in  font syn : @lhs.allFonts
  | FormatterP
      presentationList.allFonts = @lhs.allFonts
      lhs.allFonts = @presentationList.allFonts
      
-- these are nubbed later. Maybe they should only be added if not present?

ATTR PresentationList [ | allFonts : {[Font]} | ] 

ATTR Root [ fontMetrics : FontMetrics | | ]

ATTR Presentation [ fontMetrics : FontMetrics | | ]
  
ATTR PresentationList [ fontMetrics : FontMetrics | | ]  -- copy Rule



-- Focus
--ATTR Presentation [ focus : FocusPres | | ]
-- need some way to represent focus in arrangement.
-- putting in overlays changes paths, and may have many consequences
-- probably best to have a focus attribute in each arr node, but this involves
-- changing many patterns in arrangement functions
-- In the future we probably want an info node with (ID Focus Dirty etc.)
-- maybe for now just fix markFocusArr and diffArr a bit.



-- formatterDepth and maxFormatterDepth definitions   

ATTR Presentation [ | | maxFormatterDepth : Int ]
SEM Presentation
  | EmptyP StringP RectangleP EllipseP ImageP PolyP
      lhs.maxFormatterDepth = 0
  | RowP ColP OverlayP GraphP
      lhs.maxFormatterDepth = maximum @presentationList.maxFormatterDepthList
  | FormatterP
      lhs.maxFormatterDepth = 1 + maximum @presentationList.maxFormatterDepthList
{-
  | TestPresentation 
      lhs.maxFormatterDepth = 0

  | MatrixPresentation 
      lhs.maxFormatterDepth = maximum @presentationList.maxFormatterDepthList
  | LayedOutRowP
      lhs.maxFormatterDepth = maximum @presentationList.maxFormatterDepthList
  | AlternativePresentation 
      lhs.maxFormatterDepth = maximum @presentationList.maxFormatterDepthList
-}
-- | VertexP       copy
-- | WithP       copy
-- | StructuralP copy
-- | ParsingP    copy
-- | LocatorP    copy

ATTR PresentationList [ | | maxFormatterDepthList : {[Int]} ]
SEM PresentationList
  | Nil 
      lhs.maxFormatterDepthList = [0] -- so we get no maximum []
  | Cons 
      lhs.maxFormatterDepthList = @hd.maxFormatterDepth : @tl.maxFormatterDepthList


-- Unfolding formatters
SEM Presentation
  | FormatterP
      inst.unfoldedFormatter : Presentation
      inst.unfoldedFormatter = unfoldFormatter @lhs.assignedWidth @presentationList.minWidthList @presentationList.self

-- char width not ok for more complicated (overlapping) glyphs like ff ligature in tex. 
-- char height sometimes needed for individual characters

-- matrix does not work correctly yet: empty `withWidth` 50 `beside` matrix is problem
-- no stretch in matrix

-- row in row has problems with hRef
-- vRef and hRef updates do not work properly


-- ref and size as ag aspects:

SEM Presentation [ || minWidth, minHeight : Int hStretch, vStretch : Bool vRef, hRef : Int ]
  | *
      loc.minWidth : Int
      loc.minHeight : Int
      loc.hStretch : Bool
      loc.vStretch : Bool
      loc.vRef : Int
      loc.hRef : Int
      
  | EmptyP
      loc.minWidth = 0
      loc.minHeight = 0
      loc.hStretch = False
      loc.vStretch = False
      loc.vRef = 0
      loc.hRef = 0
  | StringP 
      loc.minWidth = textWidth @lhs.fontMetrics @lhs.font @text
      loc.minHeight = charHeight @lhs.fontMetrics @lhs.font
      loc.hStretch = False
      loc.vStretch = False
      loc.vRef = baseLine @lhs.fontMetrics @lhs.font
      loc.hRef = 0       
  | RectangleP EllipseP GraphP
      loc.minWidth = @w
      loc.minHeight = @h
      loc.hStretch = False
      loc.vStretch = False
      loc.vRef = 0
      loc.hRef = 0
  | ImageP PolyP
      loc.minWidth = 0
      loc.minHeight = 0
      loc.hStretch = True
      loc.vStretch = True
      loc.vRef = 0
      loc.hRef = 0
  | VertexP -- other attributes are not important because Graph ignores them anyway.
      loc.hRef = @child.hRef - @x
      loc.vRef = @child.vRef - @y
  | RowP 
      loc.minTopHeight = if null @presentationList.vRefList then 0
                            else maximum @presentationList.vRefList
      loc.minBottomHeight = if null @presentationList.vRefList then 0
                            else maximum [ minHeight - vRef | (minHeight, vRef) <- zip @presentationList.minHeightList @presentationList.vRefList ]
      loc.minWidth = sum @presentationList.minWidthList
      loc.minHeight = @minTopHeight + @minBottomHeight
      loc.hStretch = or @presentationList.hStretchList
      loc.vStretch = not (null @presentationList.vStretchList) && and @presentationList.vStretchList
      loc.vRef = @minTopHeight
      loc.hRef = if null @presentationList.hRefList then 0
                 else sum (take @hRefNr @presentationList.minWidthList) + @presentationList.hRefList !! @hRefNr
  | ColP
      loc.minLeftWidth = if null @presentationList.hRefList then 0
                         else maximum @presentationList.hRefList
      loc.minRightWidth = if null @presentationList.hRefList then 0
                          else maximum [ minWidth - hRef | (minWidth, hRef) <- zip @presentationList.minWidthList @presentationList.hRefList ]
      loc.minWidth = @minLeftWidth + @minRightWidth 
      loc.minHeight = sum @presentationList.minHeightList
      loc.hStretch = not (null @presentationList.hStretchList) && and @presentationList.hStretchList
      loc.vStretch = or @presentationList.vStretchList
      loc.vRef = if null @presentationList.vRefList then 0
                 else sum (take @vRefNr @presentationList.minHeightList) + @presentationList.vRefList !! @vRefNr
      loc.hRef = @minLeftWidth
  | OverlayP 
      loc.minLeftWidth = maximum @presentationList.hRefList
      loc.minRightWidth = maximum [ minWidth - hRef | (minWidth, hRef) <- zip @presentationList.minWidthList @presentationList.hRefList ]
      loc.minWidth = @minLeftWidth + @minRightWidth 
      loc.minTopHeight = maximum @presentationList.vRefList 
      loc.minBottomHeight = maximum [ minHeight - vRef | (minHeight, vRef) <- zip @presentationList.minHeightList @presentationList.vRefList ]
      loc.minHeight = @minTopHeight + @minBottomHeight
      loc.hStretch = not (null @presentationList.hStretchList) && and @presentationList.hStretchList
      loc.vStretch = not (null @presentationList.vStretchList) && and @presentationList.vStretchList
      loc.vRef = @minTopHeight
      loc.hRef = @minLeftWidth
  | FormatterP
      loc.minWidth = 0
      loc.minHeight = 0
      loc.hStretch = True
      loc.vStretch = True
      loc.vRef = 0
      loc.hRef = 0

    {-  loc.topHeight = maximum @presentationList.vRefList
      loc.bottomHeight = maximum [ minHeight - vRef | (minHeight, vRef) <- zip @presentationList.minHeightList @presentationList.vRefList ]
      loc.leftWidth = maximum @presentationList.hRefList
      loc.rightWidth = maximum [ minWidth - hRef | (minWidth, hRef) <- zip @presentationList.minWidthList @presentationList.hRefList ]
      loc.minWidth = @leftWidth + @rightWidth 
      loc.minHeight = @topHeight + @bottomHeight
      loc.vRef = @topHeight
      loc.hRef = @leftWidth-}
{-
  | TestPresentation 
      loc.minWidth = error "not implemented"
      loc.minHeight = error "not implemented"
      loc.hStretch = error "not implemented" 
      loc.vStretch = error "not implemented" 
      loc.vRef = error "not implemented"
      loc.hRef = error "not implemented"

  | MatrixPresentation
      loc.rowTopHeights = map maximum (getRows @n @presentationList.vRefList)
      loc.rowBottomHeights = map (\minHghtsVRefs ->
                                   maximum [ minHeight - vRef | (minHeight, vRef) <- minHghtsVRefs ]
				 ) (getRows @n (zip @presentationList.minHeightList @presentationList.vRefList))
      loc.colLeftWidths = map maximum (getCols @n @presentationList.hRefList)
      loc.colRightWidths = map (\minWdthsHRefs ->
                                   maximum [ minWidth - hRef | (minWidth, hRef) <- minWdthsHRefs ]
				 ) (getCols @n (zip @presentationList.minWidthList @presentationList.hRefList))
      loc.rowHeights = zipWith (+) @rowTopHeights @rowBottomHeights
      loc.colWidths = zipWith (+) @colLeftWidths @colRightWidths
      loc.minWidth = sum @colLeftWidths + sum @colRightWidths
      loc.minHeight = sum @rowTopHeights + sum @rowBottomHeights
      loc.hStretch = False
      loc.vStretch = False
      loc.vRef = if null @presentationList.vRefList then 0
                else head @rowTopHeights
      loc.hRef = 0
  | LayedOutRowP 
      loc.minWidth = error "not implemented"
      loc.minHeight = error "not implemented"
      loc.hStretch = error "not implemented" 
      loc.vStretch = error "not implemented" 
      loc.vRef = error "not implemented"
      loc.hRef = error "not implemented"
  | AlternativePresentation 
      loc.minWidth = 0
      loc.minHeight = 0
      loc.hStretch = True
      loc.vStretch = True
      loc.vRef = 0
      loc.hRef = 0
-}
  | WithP
{-
      loc.wdth = 
      loc.minHeight = 
      loc.vRef = 
      loc.hRef = 
-}
ATTR PresentationList [  | |  minWidthList, minHeightList : {[Int]} vRefList, hRefList : {[Int]}
                       hStretchList, vStretchList : {[Bool]} ]
SEM PresentationList
  | Nil
      lhs.minWidthList = []
      lhs.minHeightList = []
      lhs.hStretchList = []
      lhs.vStretchList = []
      lhs.vRefList = []
      lhs.hRefList = []
  | Cons 
      lhs.minWidthList = @hd.minWidth : @tl.minWidthList
      lhs.minHeightList = @hd.minHeight : @tl.minHeightList
      lhs.hStretchList = @hd.hStretch : @tl.hStretchList
      lhs.vStretchList = @hd.vStretch : @tl.vStretchList
      lhs.vRefList = @hd.vRef : @tl.vRefList
      lhs.hRefList = @hd.hRef : @tl.hRefList




SEM Root
  | Root
      presentation.assignedWidth  = let (_,(screenWidth,_)) = @lhs.viewedArea
                                    in  if @presentation.hStretch && screenWidth >= @presentation.minWidth 
                                        then screenWidth else @presentation.minWidth
      presentation.assignedHeight = let (_,(_,screenHeight)) = @lhs.viewedArea
                                    in  if @presentation.vStretch && screenHeight >= @presentation.minHeight
                                    then screenHeight else @presentation.minHeight
      presentation.assignedVRef = @presentation.vRef -- is ignored anyway 
      presentation.assignedHRef = @presentation.hRef 

SEM Presentation [ assignedWidth, assignedHeight, assignedVRef, assignedHRef : Int | | ]
  | RowP
      loc.assignedWidths = if @presentationList.hStretchList!! @hRefNr -- if Ref Object is stretch, all children get
                                 then assign @presentationList.hStretchList -- equal space           +1, because refobj is stretch too
                                               (repeat((@leftTotalSpace+ @rightTotalSpace)`div`(@leftHStretches+1+ @rightHStretches))
						
					       )
					       @presentationList.minWidthList
		                 else assign @presentationList.hStretchList
                                               (  replicate @hRefNr (@leftChildSpace) 
					       ++ [0] -- not used, since stretch for child nr @hRefNr is False 
					       ++ repeat @rightChildSpace
					       )
					       @presentationList.minWidthList
      presentationList.assignedWidthList    = @assignedWidths
      presentationList.assignedHRefList     = @presentationList.hRefList -- is not right, nested rows don't work now

      presentationList.assignedHeightList   = assign @presentationList.vStretchList
                                                (repeat @lhs.assignedHeight)
                                                @presentationList.minHeightList 
      presentationList.assignedVRefList     = assign @presentationList.vStretchList
                                                (repeat @vRef)--@lhs.assignedVRef)
                                                @presentationList.vRefList 

       -- width of stretching children should not be subtracted from available width
       -- for the moment this amount is added back to it as left and right corrections
      loc.stretchMinWidths = assign @presentationList.hStretchList @presentationList.minWidthList (repeat 0)
      -- this list contains the widths for the non stretchers, the other widths are 0

      loc.leftCorrection = sum (take @hRefNr @stretchMinWidths) 
                              + if @presentationList.hStretchList!! @hRefNr then @stretchMinWidths !! @hRefNr else 0
      loc.rightCorrection = sum (drop (@hRefNr+1) @stretchMinWidths)

      loc.leftTotalSpace = @lhs.assignedHRef - @hRef    + @leftCorrection
      loc.rightTotalSpace = @lhs.assignedWidth - @minWidth - @leftTotalSpace  + @rightCorrection
      loc.leftHStretches = length . filter (==True) . take @hRefNr $ @presentationList.hStretchList 
      loc.rightHStretches = length . filter (==True) . drop (@hRefNr+1) $ @presentationList.hStretchList 
      loc.leftChildSpace = round (fromIntegral @leftTotalSpace / fromIntegral @leftHStretches )
      loc.rightChildSpace = round (fromIntegral @rightTotalSpace / fromIntegral @rightHStretches )
 
       
      -- @lhs.assigned vs final????
  | ColP
      presentationList.assignedWidthList    = assign @presentationList.hStretchList
                                              (repeat @lhs.assignedWidth) @presentationList.minWidthList 
      -- in case of stretch, return composite's ref
      presentationList.assignedHRefList     = assign @presentationList.hStretchList
                                              (repeat @lhs.assignedHRef)
					      @presentationList.hRefList 
      loc.assignedHeights = if @presentationList.vStretchList!! @vRefNr -- if Ref Object is stretch, all children get
                            then assign @presentationList.vStretchList -- equal space           +1, because refobj is stretch too
                                               (repeat((@topTotalSpace+ @bottomTotalSpace)`div`(@topVStretches+1+ @bottomVStretches))
						
					       )
					       @presentationList.minHeightList
		            else assign @presentationList.vStretchList
                                               (  replicate @vRefNr (@topChildSpace) 
					       ++ [0] -- not used, since stretch for child nr @vRefNr is False 
					       ++ repeat @bottomChildSpace
					       )
					       @presentationList.minHeightList
      presentationList.assignedHeightList    = @assignedHeights
      presentationList.assignedVRefList     = {-debug Arr (  "assVRef:"++show @lhs.assignedVRef
						++ "VRef:"++ show @vRef
						++ "minHeight:"++show minHeight
						++ "assHeight:"++show @lhs.assignedHeight
						++ "topTotal:"++ show topTotalSpace
						++ "botTotal:"++ show bottomTotalSpace
						)-} @presentationList.vRefList -- is not right, nested cols don't work now

       -- width of stretching children should not be subtracted from available height
       -- for the moment this amount is added back to it as top and bottom corrections
      loc.stretchMinHeights = assign @presentationList.vStretchList @presentationList.minHeightList (repeat 0)
      -- this list contains the heights for the non stretchers, the other heights are 0

      loc.topCorrection = sum (take @vRefNr @stretchMinHeights) 
                              + if @presentationList.vStretchList!! @vRefNr then @stretchMinHeights !! @vRefNr else 0
      loc.bottomCorrection = sum (drop (@vRefNr+1) @stretchMinHeights)

      
      
      
      loc.topTotalSpace = @lhs.assignedVRef - @vRef  + @topCorrection     -- minTopHeight
      loc.bottomTotalSpace = @lhs.assignedHeight - @minHeight - @topTotalSpace   + @bottomCorrection
      loc.topVStretches = length . filter (==True) . take @vRefNr $ @presentationList.vStretchList 
      loc.bottomVStretches = length . filter (==True) . drop (@vRefNr+1) $ @presentationList.vStretchList 
      loc.topChildSpace = round (fromIntegral @topTotalSpace / fromIntegral @topVStretches )
      loc.bottomChildSpace = round (fromIntegral @bottomTotalSpace / fromIntegral @bottomVStretches )
  | OverlayP
      presentationList.assignedHeightList   = assign @presentationList.vStretchList
                                              (repeat @lhs.assignedHeight) @presentationList.minHeightList 
      presentationList.assignedVRefList     = assign @presentationList.vStretchList
                                              (repeat @lhs.assignedVRef) @presentationList.vRefList 
      presentationList.assignedWidthList    = assign @presentationList.hStretchList
                                              (repeat @lhs.assignedWidth) @presentationList.minWidthList 
      presentationList.assignedHRefList     = assign @presentationList.hStretchList
                                              (repeat @lhs.assignedHRef)  @presentationList.hRefList 
  | GraphP -- just use minSize and h/hRef for assigned Size and Ref. Stretching does not make sense in a GraphP
      presentationList.assignedHeightList = @presentationList.minHeightList 
      presentationList.assignedVRefList   = @presentationList.vRefList 
      presentationList.assignedWidthList  = @presentationList.minWidthList 
      presentationList.assignedHRefList   = @presentationList.hRefList 
  | VertexP
      child.assignedHeight                = @child.minHeight
      child.assignedWidth                 = @child.minWidth
      child.assignedHRef                  = @child.hRef
      child.assignedVRef                  = @child.vRef
  | FormatterP
      -- width height href and vref are assigned to unfoldedFormatter by copy rules
      presentationList.assignedWidthList    = debug Err "ArrangerAG.assignedWidthList: FormatterP must be unfolded first" $ replicate @presentationList.nrOfChildren 0
      presentationList.assignedHeightList   = debug Err "ArrangerAG.assignedHeightList: FormatterP must be unfolded first" $ replicate @presentationList.nrOfChildren 0
      presentationList.assignedVRefList     = debug Err "ArrangerAG.assignedVRefList: FormatterP must be unfolded first" $ replicate @presentationList.nrOfChildren 0
      presentationList.assignedHRefList     = debug Err "ArrangerAG.assignedHRefList: FormatterP must be unfolded first" $ replicate @presentationList.nrOfChildren 0
{-
  | MatrixPresentation
-- is a lot more complicated than this
      presentationList.assignedHeightList    =assign @presentationList.vStretchList
                                              (concat. map (replicate @n)$ @rowHeights)
					      @presentationList.minHeightList 
      presentationList.assignedVRefList     = assign @presentationList.vStretchList
                                              (concat. map (replicate @n)$ @rowTopHeights) --(repeat @lhs.assignedVRef)
					      @presentationList.vRefList 
      presentationList.assignedWidthList    = assign @presentationList.hStretchList
                                              (concat . repeat $ @colWidths) 
					      @presentationList.minWidthList 
      presentationList.assignedHRefList     = assign @presentationList.hStretchList
                                              (concat . repeat $ @colLeftWidths) --(repeat @lhs.assignedHRef)
					      @presentationList.hRefList 
   --   presentationList.assignedWidthList    = @presentationList.minWidthList
 --     presentationList.assignedHeightList   = @presentationList.minHeightList
 --     presentationList.assignedVRefList     = @presentationList.vRefList
   --   presentationList.assignedHRefList     = @presentationList.hRefList
  | LayedOutRowP
      presentationList.assignedWidthList    = error "LayedOut row not implemented yet."
      presentationList.assignedHeightList    = error "LayedOut row not implemented yet."
      presentationList.assignedVRefList    = error "LayedOut row not implemented yet."
      presentationList.assignedHRefList    = error "LayedOut row not implemented yet."
  | AlternativePresentation
      presentationList.assignedWidthList    = repeat @lhs.assignedWidth
      presentationList.assignedHeightList    = repeat @lhs.assignedHeight
      presentationList.assignedVRefList     = repeat @lhs.assignedVRef
      presentationList.assignedHRefList     = repeat @lhs.assignedHRef
-}
--  | WithP

SEM PresentationList [ assignedWidthList, assignedHeightList, assignedVRefList, assignedHRefList : {[Int]} | | ]
  | Cons 
      hd.assignedWidth = head @lhs.assignedWidthList
      tl.assignedWidthList = tail @lhs.assignedWidthList
      hd.assignedHeight = head @lhs.assignedHeightList
      tl.assignedHeightList = tail @lhs.assignedHeightList
      hd.assignedVRef = head @lhs.assignedVRefList
      tl.assignedVRefList = tail @lhs.assignedVRefList
      hd.assignedHRef = head @lhs.assignedHRefList
      tl.assignedHRefList = tail @lhs.assignedHRefList


-- why do presentations need this value themselves? Poly & rect need it for scaling.
-- instead of sending back, maybe row and col can keep a local copy? or will this interfere
-- with top/bottom/etc-aligning? 
SEM Presentation [ || finalHeight, finalWidth, finalVRef, finalHRef : Int ]
  | *
      loc.finalWidth  : Int
      loc.finalHeight : Int
      loc.finalVRef   : Int
      loc.finalHRef   : Int
  | EmptyP
      loc.finalWidth  = @lhs.assignedWidth
      loc.finalHeight = @lhs.assignedHeight
      loc.finalVRef   = @lhs.assignedVRef
      loc.finalHRef   = @lhs.assignedHRef
  | StringP 
      loc.finalWidth  = @minWidth
      loc.finalHeight = @minHeight
      loc.finalVRef   = @lhs.assignedVRef
      loc.finalHRef   = @lhs.assignedHRef
  | RectangleP  
      loc.finalWidth  = @minWidth
      loc.finalHeight = @minHeight
      loc.finalVRef   = @lhs.assignedVRef
      loc.finalHRef   = @lhs.assignedHRef
  | EllipseP  
      loc.finalWidth  = @minWidth
      loc.finalHeight = @minHeight
      loc.finalVRef   = @lhs.assignedVRef
      loc.finalHRef   = @lhs.assignedHRef
  | ImageP  
      loc.finalWidth  = @lhs.assignedWidth
      loc.finalHeight = @lhs.assignedHeight
      loc.finalVRef   = @lhs.assignedVRef
      loc.finalHRef   = @lhs.assignedHRef
  | PolyP 
      loc.finalWidth  = @lhs.assignedWidth
      loc.finalHeight = @lhs.assignedHeight
      loc.finalVRef   = @lhs.assignedVRef
      loc.finalHRef   = @lhs.assignedHRef
  | RowP
      loc.finalWidth  = sum @presentationList.finalWidthList
      loc.finalHeight = @lhs.assignedHeight
      loc.finalVRef   = @lhs.assignedVRef
      loc.finalHRef   = @lhs.assignedHRef
                        {- the sum below does not work when hRef is modified by a with. 
                           It is as of yet unclear whether the simpler computation causes any problems
                        if null @presentationList.hRefList then 0
                        else if @presentationList.hStretchList!! @hRefNr then @lhs.assignedHRef
		                else sum (take @hRefNr @assignedWidths) + (@presentationList.hRefList !! @hRefNr)
		        -}
  | ColP
      loc.finalWidth  = @lhs.assignedWidth
      loc.finalHeight = sum @presentationList.finalHeightList --@lhs.assignedHeight
      loc.finalVRef   = @lhs.assignedVRef
                        {-
                        if null @presentationList.vRefList then 0
                        else if @presentationList.vStretchList!! @vRefNr then @lhs.assignedVRef
		             else sum (take @vRefNr @assignedHeights) + (@presentationList.vRefList !! @vRefNr)
		        -}
      loc.finalHRef   = @lhs.assignedHRef
  | OverlayP 
      loc.finalWidth  = @lhs.assignedWidth
      loc.finalHeight = @lhs.assignedHeight
      loc.finalVRef   = @lhs.assignedVRef
      loc.finalHRef   = @lhs.assignedHRef
  | GraphP
      loc.finalWidth  = @minWidth
      loc.finalHeight = @minHeight
      loc.finalVRef   = @lhs.assignedVRef
      loc.finalHRef   = @lhs.assignedHRef
  | VertexP
      loc.finalWidth  = @lhs.assignedWidth
      loc.finalHeight = @lhs.assignedHeight
      loc.finalVRef   = @lhs.assignedVRef
      loc.finalHRef   = @lhs.assignedHRef
  | FormatterP
      loc.finalWidth  = @lhs.assignedWidth
      loc.finalHeight = @unfoldedFormatter.finalHeight
      loc.finalVRef   = @lhs.assignedVRef
      loc.finalHRef   = @lhs.assignedHRef
{-
  | TestPresentation 
      loc.finalWidth = error "not implemented"
      loc.finalHeight = error "not implemented"
      loc.finalVRef = error "not implemented"
      loc.finalHRef = error "not implemented"
  | MatrixPresentation
      loc.finalWidth = @lhs.assignedWidth
      loc.finalHeight = @lhs.assignedHeight
      loc.finalVRef = if null @presentationList.vRefList then 0 -- we need H/HRefNrs here, but there not in MatrixPresentation yet
                      else head @rowTopHeights
      loc.finalHRef = if null @presentationList.vRefList then 0
                      else head @colLeftWidths
  | LayedOutRowP 
      loc.finalWidth = error "not implemented"
      loc.finalHeight = error "not implemented"
      loc.finalVRef = error "not implemented"
      loc.finalHRef = error "not implemented"
  | AlternativePresentation 
      loc.finalWidth = @presentationList.finalWidthList !! @firstFit
      loc.finalHeight = @presentationList.finalHeightList !! @firstFit
      loc.finalVRef = @presentationList.finalVRefList !! @firstFit
      loc.finalHRef = @presentationList.finalHRefList !! @firstFit
      loc.firstFit = selectFirstFit @lhs.assignedWidth @presentationList.finalWidthList -- no HRefs (yet)
-}
  | WithP
{-
      loc.wdth = 
      loc.hght = 
      loc.vRef = 
      loc.hRef = 
-}


ATTR PresentationList [  | |  finalWidthList, finalHeightList, finalVRefList, finalHRefList : {[Int]} ]
SEM PresentationList
  | Nil
      lhs.finalWidthList  = []
      lhs.finalHeightList = []
      lhs.finalVRefList   = []
      lhs.finalHRefList   = []
  | Cons 
      lhs.finalWidthList  = @hd.finalWidth  : @tl.finalWidthList
      lhs.finalHeightList = @hd.finalHeight : @tl.finalHeightList
      lhs.finalVRefList   = @hd.finalVRef   : @tl.finalVRefList
      lhs.finalHRefList   = @hd.finalHRef   : @tl.finalHRefList


-- Viewed Area

-- propagated with copy rules
ATTR Root Presentation PresentationList [ viewedArea, oldViewedArea : Rectangle | | ]


-- Upper left corner of the arrangement. Used for determining whether arrangement is in view.
-- Note!! This absx & absy is not the same as the lux and luy in the renderer, which denote the upper
-- left corner of the parent arrangement. In the renderer, each presentation needs to add its own 
-- width and height to (lux,luy) to get its own upper left corner.
-- Also note that for vertices (absx,absy) is not position of the vertex, since for vertices
-- xList and yList are lists of 0's. 
ATTR Presentation PresentationList [ absx, absy : Int | | ]
SEM Root
  | Root 
      presentation.absx = 0
      presentation.absy = 0
      
SEM PresentationList
  | Cons 
      hd.absx = @lhs.absx + head @lhs.xList
      hd.absy = @lhs.absy + head @lhs.yList

      
-- lu attributes for all the other situations are handled by copy rules

-- Position calculation

SEM Root
  | Root 
      presentation.x = 0
      presentation.y = 0

ATTR Presentation [ x, y : Int | | ]
SEM Presentation
  | RowP
      presentationList.xList    = init.scanl (+) 0 $ @presentationList.finalWidthList
      presentationList.yList    = [ @finalVRef - cvRef | cvRef <- @presentationList.finalVRefList ]
  | ColP
      presentationList.xList    = [ @finalHRef - chRef | chRef <- @presentationList.finalHRefList ]
      presentationList.yList    = init.scanl (+) 0 $ @presentationList.finalHeightList
  | OverlayP
      presentationList.xList    = [ @finalHRef - chRef | chRef <- @presentationList.finalHRefList ]
      presentationList.yList    = [ @finalVRef - cvRef | cvRef <- @presentationList.finalVRefList ]
  | GraphP -- finalRefs are 0 for the GraphP
      presentationList.xList    = map (0-) @presentationList.finalHRefList
      presentationList.yList    = map (0-) @presentationList.finalVRefList
  | VertexP
      child.x                   = 0
      child.y                   = 0
  | FormatterP
      presentationList.xList    = debug Err "ArrangerAG.xList: x should not be evaluated for FormatterP children" $ replicate @presentationList.nrOfChildren 0
      presentationList.yList    = debug Err "ArrangerAG.yList: y should not be evaluated for FormatterP children" $ replicate @presentationList.nrOfChildren 0
--     @unfoldedFormatter.x/y handled by copy rule

{-
  | MatrixPresentation -- x and y are added to cumulative heights and widths
      loc.cumulativeColWidths = init. scanl (+) 0 $ @colWidths
      loc.cumulativeRowHeights = init. scanl (+) 0 $ @rowHeights
      loc.absoluteRowRefYs = zipWith (+) @cumulativeRowHeights @rowTopHeights
      loc.absoluteColRefXs = zipWith (+) @cumulativeColWidths @colLeftWidths 
      presentationList.xList    = zipWith (-) (concat . repeat $ @absoluteColRefXs) @presentationList.finalHRefList
      presentationList.yList    = zipWith (-) (concat . map (replicate @n) $ @absoluteRowRefYs) @presentationList.finalVRefList
  | LayedOutRowP
      presentationList.xList    = error "LayedOut row not implemented yet."
      presentationList.yList    = error "LayedOut row not implemented yet."
  | AlternativePresentation
      presentationList.xList    = repeat 0
      presentationList.yList    = repeat 0
-}

ATTR PresentationList [ xList, yList : {[Int]} | | ]
SEM PresentationList
  | Cons 
      hd.x = head @lhs.xList
      hd.y = head @lhs.yList
      tl.xList = tail @lhs.xList
      tl.yList = tail @lhs.yList







-- Creating the Arrangement

-- are the widths and heights really needed in the attributed tree?
-- yes, they define the area of the presentation, used for background coloring etc.


-- bit unclear what to do when href and vref are changed in with nodes  @finalVRef @finalHRef
-- for a child in a composite are not the same as the  @finalVRef @finalHRef at the with nodes
-- however in such a case we probably can't do it incrementally anyway

ATTR Presentation [  | | arrangement : {Arrangement node} ]
SEM Presentation
  | EmptyP
      lhs.arrangement = arrangeWhenViewed        @lhs.absx @lhs.absy @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lhs.viewedArea (idAFromP @id) $
                          EmptyA (idAFromP @id)  @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lhs.backgroundColor
  | StringP 
      lhs.arrangement = arrangeWhenViewed        @lhs.absx @lhs.absy @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lhs.viewedArea (idAFromP @id) $
                          StringA (idAFromP @id) @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @text @lhs.textColor @lhs.backgroundColor @lhs.font (cumulativeCharWidths @lhs.fontMetrics @lhs.font @text) -- expensive, but will be evaluated lazily
  | RectangleP
      lhs.arrangement = arrangeWhenViewed           @lhs.absx @lhs.absy @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lhs.viewedArea (idAFromP @id) $
                          RectangleA (idAFromP @id) @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lineWidth @style @lhs.lineColor @lhs.fillColor @lhs.backgroundColor
  | EllipseP
      lhs.arrangement = arrangeWhenViewed         @lhs.absx @lhs.absy @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lhs.viewedArea (idAFromP @id) $
                          EllipseA (idAFromP @id) @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lineWidth @style @lhs.lineColor @lhs.fillColor @lhs.backgroundColor
  | ImageP
      lhs.arrangement = arrangeWhenViewed       @lhs.absx @lhs.absy @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lhs.viewedArea (idAFromP @id) $
                          ImageA (idAFromP @id) @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @src @style @lhs.lineColor @lhs.backgroundColor
  | PolyP      
      lhs.arrangement = arrangeWhenViewed                  @lhs.absx @lhs.absy @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lhs.viewedArea (idAFromP @id) $
                          let mkPoint (rx, ry) = ( round (rx * fromIntegral ((@finalWidth-1) `max` 0))
			                         , round (ry * fromIntegral ((@finalHeight-1) `max` 0)) )
		                  in  PolyA (idAFromP @id) @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef (map mkPoint @pointList) @lineWidth @style @lhs.lineColor @lhs.fillColor @lhs.backgroundColor
		      
{-
  | TestPresentation
      lhs.arrangement =  RectangleA (idAFromP @id) @lhs.x @lhs.y @finalWidth @finalHeight 0 Solid @lhs.lineColor @lhs.fillColor
-}
  | RowP 
      lhs.arrangement = {- debug Arr ( "rowattrs:"++show 
                                                  ( (@presentationList.minWidthList
						  , @presentationList.hRefList
						  , @presentationList.finalWidthList 
                                                  , @presentationList.finalHRefList )
                                                  , @lhs.assignedWidth
						  , leftCorrection
						  , rightCorrection
						  , assignedWidths 
						  ))$ -}
                        --debug Err ("Row in view with #children: "++ show @presentationList.nrOfChildren ++" "++ show @finalWidth ++" "++ show @presentationList.finalWidthList) $
                          arrangeWhenViewed     @lhs.absx @lhs.absy @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lhs.viewedArea (idAFromP @id) $
                          RowA (idAFromP @id) @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lhs.backgroundColor @presentationList.arrangementList
  | ColP 
      lhs.arrangement = {- debug Arr ( "colattrs:"++show 
                                                  ( (@presentationList.minWidthList
						  , @presentationList.hRefList
						  , @presentationList.finalWidthList 
                                                  , @presentationList.finalHRefList )
                                                  , @lhs.assignedWidth
						  , assign @presentationList.hStretchList (repeat @lhs.assignedWidth) @presentationList.minWidthList 
					          ))$ -}
	                arrangeWhenViewed     @lhs.absx @lhs.absy @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lhs.viewedArea (idAFromP @id) $
                          ColA (idAFromP @id) @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lhs.backgroundColor @formatted @presentationList.arrangementList 
  | OverlayP 
      lhs.arrangement = arrangeWhenViewed         @lhs.absx @lhs.absy @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lhs.viewedArea (idAFromP @id) $
                          OverlayA (idAFromP @id) @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lhs.backgroundColor @presentationList.arrangementList
  | GraphP 
      lhs.arrangement = arrangeWhenViewed       @lhs.absx @lhs.absy @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lhs.viewedArea (idAFromP @id) $
                          GraphA (idAFromP @id) @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lhs.backgroundColor 
                                 (length @presentationList.vertices)
                                 ( @presentationList.arrangementList  ++
                                   mkEdges @edges @presentationList.vertices @lhs.lineColor )
                        -- All edges are arranged, even if the graph is partially in view.
                        -- This could be optimized further, but is probably not worth the effort.
    | VertexP
      lhs.arrangement = arrangeWhenViewed @lhs.absx @lhs.absy
                                         @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lhs.viewedArea (idAFromP @id) $
                          VertexA (idAFromP @id) @lhs.x @lhs.y 
                                  @finalWidth @finalHeight @finalHRef @finalVRef @lhs.backgroundColor 
                                  (\a -> let (x,y) = @outline a in (x+ @child.hRef,y+ @child.vRef)) @child.arrangement
  | FormatterP
      -- unfoldedFormatter.arrangement handled by copy rule
{-
  | LayedOutRowP 
      lhs.arrangement = RowA (idAFromP @id) @lhs.x @lhs.y @finalWidth @finalHeight @finalVRef @finalHRef @lhs.backgroundColor @presentationList.arrangementList
  | MatrixPresentation 
      lhs.arrangement = StringA NoID 0 40 0 0 0 0 ("unimplemented AttrPresentation MatrixPresentation") (0,0,0) defaultFont []
       -- MatrixPresentation (idAFromP @id) @presentationList.arrangementList @lhs.x @lhs.y finalWidth finalHeight @lhs.backgroundColor
  | AlternativePresentation -- remove the alternative presentation
      lhs.arrangement = @presentationList.arrangementList !! @firstFit 
   -- with node is removed by copy rule
-}
  | StructuralP 
      lhs.arrangement = StructuralA (idAFromP @id) @child.arrangement
  | ParsingP 
      lhs.arrangement = ParsingA (idAFromP @id) @child.arrangement
  | LocatorP 
      lhs.arrangement = LocatorA @location @child.arrangement
  | ArrangedP
      lhs.arrangement = case @lhs.oldArr of
                          Just oldArr -> 
                            
                            if 
                               overlap ((@lhs.absx,@lhs.absy),(@finalWidth,@finalHeight)) @lhs.viewedArea
                               && not (isComplete oldArr) 
                               && (    not (@lhs.x == xA oldArr && @lhs.y == yA oldArr )
                                    || @lhs.viewedArea /= @lhs.oldViewedArea )
                               
                            then --debug Arr ("Failed reuse: "++ show (not (isComplete oldArr))
                                 --           ++ show @lhs.viewedArea ++ show @lhs.oldViewedArea 
                                 --           ++ show (@lhs.x == xA oldArr && @lhs.y == yA oldArr )   ++show oldArr ) $
                                 arrangeWhenViewed @lhs.absx @lhs.absy
                                              @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lhs.viewedArea NoIDA $
                                   (if markArrangementBackground then setBGColor red else id) $      -- @finalVRef @finalHRef are taken from the arrangedP node
                                   @unprunedPresHO.arrangement
                            else  
                                 arrangeWhenViewed @lhs.absx @lhs.absy
                                              @lhs.x @lhs.y (widthA oldArr) (heightA oldArr) (hRefA oldArr) (vRefA oldArr) {-@finalWidth @finalHeight @finalHRef @finalVRef-} @lhs.viewedArea NoIDA $
                                   (if markArrangementBackground then setBGColor yellow else id) $      -- @finalVRef @finalHRef are taken from the arrangedP node
                                   setXYWHA @lhs.x @lhs.y @finalWidth @finalHeight oldArr 
                          Nothing ->
                            arrangeWhenViewed @lhs.absx @lhs.absy
                                              @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lhs.viewedArea NoIDA $
                              (if markArrangementBackground then setBGColor blue else id) $      -- @finalVRef @finalHRef are taken from the arrangedP node
                              @unprunedPresHO.arrangement

                                -- do we need to set width and height? These should not have changed
                                -- the last one seems wrong for sure 
  | ArrangedP
      inst.unprunedPresHO : Presentation
      inst.unprunedPresHO = case @lhs.oldArr of
                              Just oldArr -> 
                                if overlap ((@lhs.absx,@lhs.absy),(@finalWidth,@finalHeight)) @lhs.viewedArea
                                   && not (isComplete oldArr)
                                   && (   not (@lhs.x == xA oldArr && @lhs.y == yA oldArr )
                                       || @lhs.viewedArea /= @lhs.oldViewedArea )
                                then @lhs.unprunedPres
                                else debug Err ("ERROR:unprunedPresHO accessed while not assigned") $
                                     EmptyP NoIDP
                              Nothing -> @lhs.unprunedPres -- no oldArr, so we always use the presentation
  
                          -- not exactly clear how to assign these attributes using the old values
                          -- what if the AG computes a different value for the refs, reassign?
      loc.minWidth    = case @lhs.oldArr of
                          Just oldArr -> widthA oldArr
                          Nothing     -> @unprunedPresHO.minWidth
      loc.minHeight   = case @lhs.oldArr of
                          Just oldArr -> heightA oldArr
                          Nothing     -> @unprunedPresHO.minHeight
      loc.hStretch    = case @lhs.oldArr of
                          Just oldArr -> False
                          Nothing     -> @unprunedPresHO.hStretch
      loc.vStretch    = case @lhs.oldArr of
                          Just oldArr -> False
                          Nothing     -> @unprunedPresHO.vStretch
      loc.vRef        = case @lhs.oldArr of
                          Just oldArr -> vRefA oldArr
                          Nothing     -> @unprunedPresHO.vRef
      loc.hRef        = case @lhs.oldArr of
                          Just oldArr -> hRefA oldArr
                          Nothing     -> @unprunedPresHO.hRef
 
      loc.finalWidth  = case @lhs.oldArr of
                          Just oldArr -> widthA oldArr
                          Nothing     -> @unprunedPresHO.finalWidth
      loc.finalHeight = case @lhs.oldArr of
                          Just oldArr -> heightA oldArr
                          Nothing     -> @unprunedPresHO.finalHeight
      loc.finalVRef   = case @lhs.oldArr of
                          Just oldArr -> vRefA oldArr
                          Nothing     -> @unprunedPresHO.finalVRef
      loc.finalHRef   = case @lhs.oldArr of
                          Just oldArr -> hRefA oldArr
                          Nothing     -> @unprunedPresHO.finalHRef

      loc.maxFormatterDepth = case @lhs.oldArr of
                                Just oldArr -> 0 
                                Nothing     -> @unprunedPresHO.maxFormatterDepth

      unprunedPresHO.allFonts = @lhs.allFonts -- to prevent copy rule from getting childs inherited allFonts
                                              -- from loc.allFonts, creating a cycle

      -- fonts returned by pruned presentation are not complete. As long as fonts are not deleted,
      -- this is not a problem.
      loc.allFonts = case @lhs.oldArr of  
                       Just oldArr -> @lhs.allFonts
                       Nothing     -> @unprunedPresHO.allFonts
      loc.vertex = case @lhs.oldArr of
                       Just oldArr -> debug Err "Warning: ArrangedP instead of VertexP" (0,0,0,\_->(0,0))
                       Nothing     -> @unprunedPresHO.vertex
  
                                   
ATTR Presentation [ || vertex : {(Int,Int,Int,Outline)} ]
SEM Presentation
  | VertexP
      lhs.vertex = (@i,@x,@y,@outline)
  | EmptyP
      lhs.vertex = debug Err "Warning: graph presentation with non-vertex child:" (0,0,0,\_->(0,0))
  | StringP
      lhs.vertex = debug Err "Warning: graph presentation with non-vertex child:" (0,0,0,\_->(0,0))
  | RectangleP
      lhs.vertex = debug Err "Warning: graph presentation with non-vertex child:" (0,0,0,\_->(0,0))
  | EllipseP
      lhs.vertex = debug Err "Warning: graph presentation with non-vertex child:" (0,0,0,\_->(0,0))
  | ImageP
      lhs.vertex = debug Err "Warning: graph presentation with non-vertex child:" (0,0,0,\_->(0,0))
  | PolyP
      lhs.vertex = debug Err "Warning: graph presentation with non-vertex child:" (0,0,0,\_->(0,0))
  | RowP
      lhs.vertex = debug Err "Warning: graph presentation with non-vertex child:" (0,0,0,\_->(0,0))
  | ColP
      lhs.vertex = debug Err "Warning: graph presentation with non-vertex child:" (0,0,0,\_->(0,0))
  | OverlayP
      lhs.vertex = debug Err "Warning: graph presentation with non-vertex child:" (0,0,0,\_->(0,0))
  | GraphP
      lhs.vertex = debug Err "Warning: graph presentation with non-vertex child:" (0,0,0,\_->(0,0))
  | ArrangedP
      lhs.vertex = debug Err "Warning: graph presentation with non-vertex child:" (0,0,0,\_->(0,0))
  | FormatterP
      lhs.vertex = debug Err "Warning: graph presentation with non-vertex child:" (0,0,0,\_->(0,0))


SEM PresentationList [ || vertices : {[(Int,Int,Outline)]} ]
  | Nil
      lhs.vertices = []
  | Cons 
      lhs.vertices = @hd.vertex : @tl.vertices
      
ATTR Root [ unprunedPres : {Presentation doc node clip} | | ]

SEM Presentation [ unprunedPres : {Presentation doc node clip} | | ]
  | EmptyP StringP ImageP PolyP RectangleP EllipseP ArrangedP 
  | RowP OverlayP GraphP FormatterP
      presentationList.unprunedPresList = {- debug Arr ("Lengths "++show (length (getChildrenP @lhs.unprunedPres))
                                                        ++","  ++show (length @presentationList.minWidthList)
                                                               ++show (map shallowShowPres (getChildrenP @lhs.unprunedPres))
                                                        ++","  ++show (map shallowShowPres (getChildrenP @self))
                                                               ) $ -}
                                          getChildrenP @lhs.unprunedPres
                                          ++ repeat (debug Err ("ERROR:unprunedPres list of differing length accessed in" ++ shallowShowPres @self) (EmptyP NoIDP))

  | VertexP WithP StructuralP ParsingP LocatorP 
      child.unprunedPres = {- case (@self, @lhs.unprunedPres) of
                                    (WithP _ _, WithP _ _) -> id
                                    (LocatorP _ _, LocatorP _ _) -> id
                                    (StructuralP _ _, StructuralP _ _) -> id
                                    (ParsingP _ _, ParsingP _ _) -> id
                                    (p,upp)            -> debug Arr $ "not the same:" ++ shallowShowPres p ++ shallowShowPres upp
                             $ -}
                             getChildP @lhs.unprunedPres
  | ColP 
      presentationList.unprunedPresList =
        case @formatted of
          NF -> getChildrenP @lhs.unprunedPres
                ++ repeat (debug Err ("ERROR:unprunedPres list of differing length accessed in ColP NF") (EmptyP NoIDP))
          F nrOfEltss ->
            let press = getChildrenP @lhs.unprunedPres -- @lhs.unprunedPres is a FormatterP
                breaks = tail (scanl (+) 0 nrOfEltss)
                mkDummyRow = RowP NoIDP 0
            in  (map mkDummyRow $ linesFromBreaks breaks press)
                ++ repeat (debug Err ("ERROR:unprunedPres list of differing length accessed in ColP F") (EmptyP NoIDP))
-- for a column that came from a formatter, we distribute the unpruned presentation over the
-- column of rows.

-- The unprunedPres for @inst.unfoldedFormatter HO attribute is copied directly from its FormatterP parent
       
SEM PresentationList [ unprunedPresList : {[Presentation doc node clip]} | | ]
  | Cons 
      hd.unprunedPres     = head @lhs.unprunedPresList
      tl.unprunedPresList = tail @lhs.unprunedPresList

ATTR Root         [ oldArr : {Maybe (Arrangement node)}  | | ]


{-
Old arrangement is passed along according to the structure of the presentation tree.

If a row/col/etc. has different nrs of children in the presentation and the old arrangement,
the node in the diffTree is (DiffLeaf False), and therefore, the list of children will not be used.

A ColP may be a column in the presentation, or a generated column originating from a formatter.
In the latter case, the arrangement will be a column of rows, from which we retrieve the old
arrangements and redistribute them according to the new column of rows structure.


Similarly, a FormatterP will have a column of rows as its old arrangement, from which the old arrangements
are retrieved.

In both these cases, we must take into account that the column of rows may contain unarranged rows. Because
unarranged rows do not contain info on how many children the row has, we cannot continue the extraction after
encountering an unarranged row.

TODO rewrite with getChildrenA etc.
TODO linesFromBreaks produces an extra empty line, when given list of nrs of elts. Is this a problem?
-}
SEM Presentation  [ oldArr : {Maybe (Arrangement node)}   | | ]
  | RowP 
      presentationList.oldArrList = case @lhs.oldArr of 
                                      Just (RowA idp _ _ _ _ _ _ _ arrs) -> debug Err ("ArrRow "++show idp++" has "++show (length arrs) ++" arr kids and "++ show @presentationList.nrOfChildren++ "kids") $ 
                                                                          map Just arrs ++ repeat (debug Err ("ERROR: old arr list of differing length accessed in RowP") Nothing)
                                      arr                              -> repeat Nothing
  | ColP 
      presentationList.oldArrList = case @lhs.oldArr of
                                      Just (ColA _ _ _ _ _ _ _ _ _ rows) -> 
                                        case @formatted of
                                          NF -> map Just rows -- rows not the right name in this case
                                                ++ repeat (debug Err ("ERROR: old arr list of differing length accessed in ColP NF") Nothing)
                                          F nrOfEltss ->
                                           let arrs = retrieveOldArrangements rows -- may be infinite
                                               breaks = tail (scanl (+) 0 nrOfEltss)
                                               maybeRows = linesFromBreaks breaks arrs
                                            in  debug Arr ("breaks are "++ show breaks ++ "line lens:" ++ show (map length (init (linesFromBreaks breaks arrs)))) $ 
                                                (map Just $ makeDummyRows maybeRows)
                                                 ++ repeat (debug Err ("ERROR: old arr list of differing length accessed in ColP F") Nothing)
                                      _ -> repeat Nothing
--TODO!! Check that dummyrow is never used, and make annotation in source                                        
-- If the ColP came from a formatter, we take the old arrangements of the child rows, and distribute
-- them according to the new child distribution in new Rows.
  | FormatterP -- TODO add check for Nothing
      presentationList.oldArrList = case @lhs.oldArr of
                                      Just (ColA _ _ _ _ _ _ _ _ _ rows) -> 
                                        retrieveOldArrangements rows -- possibly infinite list is handled all right by oldArrList attribution rules
                                      Nothing -> repeat Nothing
  | OverlayP 
      presentationList.oldArrList = case @lhs.oldArr of 
                                      Just (OverlayA _ _ _ _ _ _ _ _ arrs) -> map Just arrs ++ repeat (debug Err ("ERROR:old arr list of differing length accessed in OverlayP") Nothing)
                                      arr                                  -> repeat Nothing
  | GraphP 
      presentationList.oldArrList = case @lhs.oldArr of
                                      Just (GraphA _ _ _ _ _ _ _ _ _ arrs) -> map Just arrs ++ repeat (debug Err ("ERROR:old arr list of differing length accessed in GraphP") Nothing)
                                      arr                                  -> repeat Nothing
  | VertexP 
      child.oldArr = case @lhs.oldArr of 
                       Just (VertexA _ _ _ _ _ _ _ _ _ arr) -> Just arr
                       arr                                  -> Nothing
  | StructuralP 
      child.oldArr = case @lhs.oldArr of
                       Just (StructuralA _ arr) -> Just arr
                       arr                      -> Nothing
  | ParsingP 
      child.oldArr = case @lhs.oldArr of
                       Just (ParsingA _ arr) -> Just arr
                       arr                   -> Nothing
  | LocatorP 
      child.oldArr = case @lhs.oldArr of
                       Just (LocatorA _ arr) -> Just arr
                       arr                   -> Nothing
{
-- After encountering an unarranged row, just return Nothings
retrieveOldArrangements [] = []
retrieveOldArrangements (RowA _ _ _ _ _ _ _ _ elts : rows) = 
  map Just elts
  ++ retrieveOldArrangements rows
retrieveOldArrangements (PolyA _ _ _ _ _ _ _ _ _ _ _ _ _ : _) = repeat Nothing
retrieveOldArrangements (arr:_) = debug Err ("ArrangerAG: retrieveOldArrangements encountered something other than row or poly:"++shallowShowArr arr) $ repeat Nothing

-- create dummy rows for a list of lists of maybe arrangements. In case of Nothing, we put an unnarranged in the
-- row, so the attribution rule for oldArr will assign a Nothing to the attribute.
makeDummyRows [] = []
makeDummyRows (maybeRow:maybeRows) =
  RowA (IDA (-88)) 0 0 0 0 0 0 black 
    [ case mArr of 
        Nothing -> unarrangedA 0 0 0 0 0 0
        Just arr -> arr
    | mArr <- maybeRow
    ]
  : makeDummyRows maybeRows
{-
makeDummyRows [] = []
makeDummyRows (maybeRow:maybeRows) =
  (if all isJust maybeRow 
   then RowA (IDA (-88)) 0 0 0 0 0 0 black $ catMaybes maybeRow
   else debug Arr "Unarrangeable" unarrangedA 0 0 0 0 0 0)
  : makeDummyRows maybeRows
-}
}

SEM PresentationList [  oldArrList : {[Maybe (Arrangement node)]} | | ]
  | Cons 
      hd.oldArr     = head @lhs.oldArrList
      tl.oldArrList = tail @lhs.oldArrList
 

ATTR PresentationList [  | |  arrangementList : {[Arrangement node]} ]
SEM PresentationList
  | Nil
      lhs.arrangementList = []
  | Cons 
      lhs.arrangementList = @hd.arrangement : @tl.arrangementList
