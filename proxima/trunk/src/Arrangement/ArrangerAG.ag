imports
{

import Common.CommonTypes
import Common.CommonUtils
import Arrangement.ArrLayerTypes
import Arrangement.ArrLayerUtils
import Arrangement.FontLib
import Proxima.Wrap
import Maybe
import Debug.Trace
}



{
{-
TODO: 
- add check that graph only has vertex children

bug: boxed pres `withHRef` x  does not work for top and bottom line and background
- why does Empty.arrangement have 0 for x and y?


unclear: should row [] / col [] be v/h-stretch? probably not.
-}


{- for AlternativeP
selectFirstFit :: Int -> [ Int ] -> Int       
selectFirstFit availableWidth widths = 
  if null widths 
  then error "Alternative presentation has no alternatives"
  else select widths 0
 where
  select [_] n = n
  select (w:ws) n = if w <= availableWidth then n else select ws (n+1)

-- maybe nicer as synth attribute for layoutList

-}


{- for MatrixP
divide n [] = []
divide n xs = let (line, rest) = splitAt n xs in line : divide n rest

getRows n [] = []
getRows n xs = let (line, rest) = splitAt n xs in line : divide n rest

getCols n xs = foldr (zipWith (:)) (repeat []) (getRows n xs)
-}



-- for FormatterP
unfoldFormatter w ws presentations = 
 let breaks = firstFit w ws
     dividedPresentations = linesFromBreaks breaks presentations
     rows = -- map (\lst -> LayedOutRowP lst 100 32 (repeat (0,0))) presentationLists
         map (RowP NoIDP 0) dividedPresentations
     unfoldedList = ColP NoIDP 0 (F (map length dividedPresentations)) rows
 in  --debug Arr ("Unfolded formatter "++show ws++ " unfolded as"++ show (map length dividedPresentations)) $ 
     --debug Arr ("Unfolding formatter") $
     unfoldedList



-- just add words until line overflow
firstFit lineWidth widths = buildFFBreaks lineWidth 0 0 widths

buildFFBreaks _ pos _ [] = [] -- add a breakpoint after last word? prob. not, otherwise return [pos]
buildFFBreaks maxLength pos currentLength (width:widths) =
  let space = if currentLength == 0 then 0 else 0 -- hard coded minimum space, and widths must be >= 0 
      newLength = currentLength + space + width
  in if currentLength == 0 && width > maxLength
     then if null widths 
          then []
          else (pos+1) : buildFFBreaks maxLength pos 0 (widths)
     else if newLength <= maxLength
          then buildFFBreaks maxLength (pos+1) newLength widths
          else pos : buildFFBreaks maxLength (pos) 0 (width:widths)

linesFromBreaks :: [Int] -> [a] -> [[a]]
linesFromBreaks brks wrds = tolines' brks 0 wrds 
   where
   tolines' [] _ wrds = [wrds]
   tolines' (brk:brks) lastbrk wrds = take (brk-lastbrk) wrds :
                                      tolines' brks brk (drop (brk-lastbrk) wrds)




assign [] _ _ = []
assign (str:strs) (a:as) (o:os) = (if str then a else o) : assign strs as os


data Root doc enr node clip token = Root (Layout doc enr node clip token)
                      
-- We don't want AG to generate the Layout data types, so data type generation is turned off.
-- However, we do need Root
}

DATA Root doc enr node clip token
  | Root layout : (Layout {doc} {enr} {node} {clip} {token}) 


DATA Layout doc enr node clip token
  | EmptyP      id : IDP
  | StringP     id : IDP text : String
  | ImageP      id : IDP src : String style : ImgStyle
  | PolyP       id : IDP pointList : {[ (Float, Float) ]} lineWidth : Int style : FillStyle
  | RectangleP  id : IDP w,h : Int lineWidth : Int style : FillStyle
  | EllipseP	id : IDP w, h : Int lineWidth : Int style : FillStyle
  | RowP        id : IDP hRefNr : Int layoutList : (LayoutList {doc} {enr} {node} {clip} {token})
  | ColP        id : IDP vRefNr : Int formatted : Formatted layoutList : (LayoutList {doc} {enr} {node} {clip} {token})
  | OverlayP    id : IDP direction : Order layoutList : (LayoutList {doc} {enr} {node} {clip} {token})
  | GraphP      id : IDP d : Dirty w,h : Int edges : {[(Int,Int)]} layoutList : (LayoutList {doc} {enr} {node} {clip} {token}) 
  | VertexP     id : IDP i,x,y: Int outline : Outline child : (Layout {doc} {enr} {node} {clip} {token})
  | FormatterP  id : IDP layoutList : (LayoutList {doc} {enr} {node} {clip} {token})
  | WithP       attrRule : (AttrRule {doc} {enr} {node} {clip} {token})  child : (Layout {doc} {enr} {node} {clip} {token})
  | StructuralP id : IDP child : (Layout {doc} {enr} {node} {clip} {token})
  | ParsingP    id : IDP parser : {Maybe (ClipParser doc enr node clip token)} lexer : Lexer child : (Layout {doc} {enr} {node} {clip} {token})
  | LocatorP location : {node} child : (Layout {doc} {enr} {node} {clip} {token})
  | TagP tags : {Tags} child : (Layout {doc} {enr} {node} {clip} {token})
  | ArrangedP

--  | TestPresentation id : IDP  area : Int color : Color
--  | MatrixPresentation id : IDP  m, n : Int layoutList : (LayoutList {doc} {enr} {node} {clip} {token})
--  | LayedOutRowP id : IDP  layoutList : (LayoutList {doc} {enr} {node} {clip} {token}) w, h : Int offsets :  {[ (Int, Int) ]} -- optimization for laying out text
--  | AlternativePresentation id : IDP  layoutList : (LayoutList {doc} {enr} {node} {clip} {token})

{-
structure of layout tree: no children/one child/list of children

  | EmptyP StringP ImageP PolyP RectangleP EllipseP ArrangedP 
  | VertexP WithP StructuralP ParsingP LocatorP TagP
      child.
  | RowP ColP OverlayP GraphP FormatterP
      layoutList.

all Layout attributes:

minWidth
minHeight
hStretch
vStretch
vRef
hRef
finalHeight
finalWidth
finalVRef
finalHRef
maxFormatterDepth
allFonts
arrangement
vertex
unprunedLay 
rootPath
focusMinPath
focusMaxPath
-}

--  For each Nonterminal:
 -- add id propagation
 -- add formatter depth computation
 -- add attributed tree definition


TYPE LayoutList doc enr node clip token = [(Layout {doc} {enr} {node} {clip} {token})]

SEM LayoutList [ || nrOfChildren : Int ]
  | Nil
      lhs.nrOfChildren = 0
  | Cons 
      lhs.nrOfChildren = 1 + @tl.nrOfChildren

ATTR Root [ font : Font textColor : Color lineColor : Color fillColor : Color backgroundColor : Color
            mouseDown : {Maybe (Wrapped @doc @enr @node @clip @token)}
--            inheritablePopupMenuItems : {[ PopupMenuItem @doc @clip ]}
--            localPopupMenuItems : {[ PopupMenuItem @doc @clip ]}
          || maxFormatterDepth : Int arrangement : {Arrangement @node} ]
SEM Root
  | Root
      lhs.maxFormatterDepth = @layout.maxFormatterDepth
      lhs.arrangement   = @layout.arrangement


-- Presentation Attribute Propagation in Layout Tree
-- Root: copy rule

-- Optimize: maybe we only want to update the attrs that are set by the with rule? Or won't that improve much?

SEM Layout [ font : Font textColor, lineColor, fillColor, backgroundColor : Color
            mouseDown : {Maybe (Wrapped @doc @enr @node @clip @token)}
--            popupMenuItems : {[ PopupMenuItem @doc @clip ]}
            | | ]
  | WithP -- note popupItems are not propagated in the AG
          -- they are extracted with PresUtils.popupMenuItemsPres
      loc.newAttrs   = @attrRule ( Inh @lhs.font 
                                      @lhs.textColor @lhs.lineColor @lhs.fillColor @lhs.backgroundColor
                                      @lhs.mouseDown [] [] -- @lhs.popupMenuItems
				      @lhs.assignedWidth @lhs.assignedHeight @lhs.assignedVRef @lhs.assignedHRef
				, Syn @child.vRef @child.hRef @child.minWidth @child.minHeight
				      @child.hStretch @child.vStretch
				      @child.finalWidth @child.finalHeight @child.finalVRef @child.finalHRef) 
				           -- no names because ag parser can't handle braces (now it can)
      loc.newSyn = fst @newAttrs
      loc.newInh = snd @newAttrs
      child.font = font @newSyn
      child.textColor = textColor @newSyn
      child.lineColor = lineColor @newSyn
      child.fillColor = fillColor @newSyn
      child.backgroundColor = backgroundColor @newSyn     
      child.mouseDown = mouseDown @newSyn
--      child.popupMenuItems = popupMenuItems @newSyn
      child.assignedWidth = assignedWidth @newSyn
      child.assignedHeight = assignedHeight @newSyn
      child.assignedVRef = assignedVRef @newSyn
      child.assignedHRef = assignedHRef @newSyn
      lhs.vRef = vRef @newInh
      lhs.hRef = hRef @newInh
      lhs.minWidth = minWidth @newInh
      lhs.minHeight = minHeight @newInh
      lhs.hStretch = hStretch @newInh
      lhs.vStretch = vStretch @newInh
      lhs.finalWidth = finalWidth @newInh
      lhs.finalHeight = finalHeight @newInh
      lhs.finalVRef = finalVRef @newInh
      lhs.finalHRef = finalHRef @newInh

-- rest is taken care of by copy rule

ATTR LayoutList [  font : Font textColor, lineColor, fillColor, backgroundColor : Color 
                 mouseDown : {Maybe (Wrapped @doc @enr @node @clip @token)}
--                 popupMenuItems : {[ PopupMenuItem @doc @clip ]} 
                | | ]


-- Unique ids

ATTR Root Layout LayoutList [ | idCounter : Int | ]

SEM Layout
  | EmptyP StringP ImageP PolyP RectangleP EllipseP ArrangedP 
      lhs.idCounter = @lhs.idCounter + 1
  | VertexP WithP StructuralP ParsingP LocatorP TagP 
      child.idCounter = @lhs.idCounter + 1
  | RowP ColP OverlayP GraphP FormatterP
      layoutList.idCounter = @lhs.idCounter + 1


-- Font Metrics

-- first, collect all used fonts. They can only change at a with node, so only one check.
-- This could be optimised by only checking with nodes that update the font, instead of e.g.
-- color

ATTR Root [ | allFonts : {[Font]} | ]
-- copy rule

SEM Layout [ | allFonts : {[Font]} | ]
  | WithP
      child.allFonts = let syn = @newSyn
                       in  font syn : @lhs.allFonts
  | FormatterP
      layoutList.allFonts = @lhs.allFonts
      lhs.allFonts = @layoutList.allFonts
      
-- these are nubbed later. Maybe they should only be added if not present?

ATTR LayoutList [ | allFonts : {[Font]} | ] 

ATTR Root [ fontMetrics : FontMetrics | | ]

ATTR Layout [ fontMetrics : FontMetrics | | ]
  
ATTR LayoutList [ fontMetrics : FontMetrics | | ]  -- copy Rule



-- Focus
--ATTR Layout [ focus : FocusPres | | ]
-- need some way to represent focus in arrangement.
-- putting in overlays changes paths, and may have many consequences
-- probably best to have a focus attribute in each arr node, but this involves
-- changing many patterns in arrangement functions
-- In the future we probably want an info node with (IDP Focus Dirty etc.)
-- maybe for now just fix markFocusArr and diffArr a bit.



-- formatterDepth and maxFormatterDepth definitions   

ATTR Layout [ | | maxFormatterDepth : Int ]
SEM Layout
  | EmptyP StringP RectangleP EllipseP ImageP PolyP
      lhs.maxFormatterDepth = 0
  | RowP ColP OverlayP GraphP
      lhs.maxFormatterDepth = maximum @layoutList.maxFormatterDepthList
  | FormatterP
      lhs.maxFormatterDepth = 1 + maximum @layoutList.maxFormatterDepthList
{-
  | TestPresentation 
      lhs.maxFormatterDepth = 0

  | MatrixPresentation 
      lhs.maxFormatterDepth = maximum @layoutList.maxFormatterDepthList
  | LayedOutRowP
      lhs.maxFormatterDepth = maximum @layoutList.maxFormatterDepthList
  | AlternativePresentation 
      lhs.maxFormatterDepth = maximum @layoutList.maxFormatterDepthList
-}
-- | VertexP       copy
-- | WithP       copy
-- | StructuralP copy
-- | ParsingP    copy
-- | LocatorP    copy
-- | TagP    copy

ATTR LayoutList [ | | maxFormatterDepthList : {[Int]} ]
SEM LayoutList
  | Nil 
      lhs.maxFormatterDepthList = [0] -- so we get no maximum []
  | Cons 
      lhs.maxFormatterDepthList = @hd.maxFormatterDepth : @tl.maxFormatterDepthList


-- Unfolding formatters
SEM Layout
  | FormatterP
      inst.unfoldedFormatter : (Layout {doc} {enr} {node} {clip} {token})
      inst.unfoldedFormatter = unfoldFormatter @lhs.assignedWidth @layoutList.minWidthList @layoutList.self

-- char width not ok for more complicated (overlapping) glyphs like ff ligature in tex. 
-- char height sometimes needed for individual characters

-- matrix does not work correctly yet: empty `withWidth` 50 `beside` matrix is problem
-- no stretch in matrix

-- row in row has problems with hRef
-- vRef and hRef updates do not work properly


-- ref and size as ag aspects:

SEM Layout [ || minWidth, minHeight : Int hStretch, vStretch : Bool vRef, hRef : Int ]
  | *
      loc.minWidth : Int
      loc.minHeight : Int
      loc.hStretch : Bool
      loc.vStretch : Bool
      loc.vRef : Int
      loc.hRef : Int
      
  | EmptyP
      loc.minWidth = 0
      loc.minHeight = 0
      loc.hStretch = False
      loc.vStretch = False
      loc.vRef = 0
      loc.hRef = 0
  | StringP 
      loc.minWidth = textWidth @lhs.fontMetrics @lhs.font @text
      loc.minHeight = charHeight @lhs.fontMetrics @lhs.font
      loc.hStretch = False
      loc.vStretch = False
      loc.vRef = baseLine @lhs.fontMetrics @lhs.font
      loc.hRef = 0       
  | RectangleP EllipseP GraphP
      loc.minWidth = @w
      loc.minHeight = @h
      loc.hStretch = False
      loc.vStretch = False
      loc.vRef = 0
      loc.hRef = 0
  | ImageP PolyP
      loc.minWidth = 0
      loc.minHeight = 0
      loc.hStretch = True
      loc.vStretch = True
      loc.vRef = 0
      loc.hRef = 0
  | VertexP -- other attributes are not important because Graph ignores them anyway.
      loc.hRef = @child.hRef - @x
      loc.vRef = @child.vRef - @y
  | RowP 
      loc.minTopHeight = if null @layoutList.vRefList then 0
                            else maximum @layoutList.vRefList
      loc.minBottomHeight = if null @layoutList.vRefList then 0
                            else maximum [ minHeight - vRef | (minHeight, vRef) <- zip @layoutList.minHeightList @layoutList.vRefList ]
      loc.minWidth = sum @layoutList.minWidthList
      loc.minHeight = @minTopHeight + @minBottomHeight
      loc.hStretch = or @layoutList.hStretchList
      loc.vStretch = not (null @layoutList.vStretchList) && and @layoutList.vStretchList
      loc.vRef = @minTopHeight
      loc.hRef = if null @layoutList.hRefList then 0
                 else sum (take @hRefNr @layoutList.minWidthList) + @layoutList.hRefList !! @hRefNr
  | ColP
      loc.minLeftWidth = if null @layoutList.hRefList then 0
                         else maximum @layoutList.hRefList
      loc.minRightWidth = if null @layoutList.hRefList then 0
                          else maximum [ minWidth - hRef | (minWidth, hRef) <- zip @layoutList.minWidthList @layoutList.hRefList ]
      loc.minWidth = @minLeftWidth + @minRightWidth 
      loc.minHeight = sum @layoutList.minHeightList
      loc.hStretch = not (null @layoutList.hStretchList) && and @layoutList.hStretchList
      loc.vStretch = or @layoutList.vStretchList
      loc.vRef = if null @layoutList.vRefList then 0
                 else sum (take @vRefNr @layoutList.minHeightList) + @layoutList.vRefList !! @vRefNr
      loc.hRef = @minLeftWidth
  | OverlayP 
      loc.minLeftWidth = maximum @layoutList.hRefList
      loc.minRightWidth = maximum [ minWidth - hRef | (minWidth, hRef) <- zip @layoutList.minWidthList @layoutList.hRefList ]
      loc.minWidth = @minLeftWidth + @minRightWidth 
      loc.minTopHeight = maximum @layoutList.vRefList 
      loc.minBottomHeight = maximum [ minHeight - vRef | (minHeight, vRef) <- zip @layoutList.minHeightList @layoutList.vRefList ]
      loc.minHeight = @minTopHeight + @minBottomHeight
      loc.hStretch = not (null @layoutList.hStretchList) && and @layoutList.hStretchList
      loc.vStretch = not (null @layoutList.vStretchList) && and @layoutList.vStretchList
      loc.hRef = @minLeftWidth
      loc.vRef = @minTopHeight
  | FormatterP
      loc.minWidth = maximum (0 : @layoutList.minWidthList)
      loc.minHeight = @unfoldedFormatter.finalHeight
      loc.hStretch = True
      loc.vStretch = False 
      loc.hRef = 0 -- hRef is not taken from children, since formatter is hstretch, and the meaning would not be clear.
      loc.vRef = @unfoldedFormatter.vRef

    {-  loc.topHeight = maximum @layoutList.vRefList
      loc.bottomHeight = maximum [ minHeight - vRef | (minHeight, vRef) <- zip @layoutList.minHeightList @layoutList.vRefList ]
      loc.leftWidth = maximum @layoutList.hRefList
      loc.rightWidth = maximum [ minWidth - hRef | (minWidth, hRef) <- zip @layoutList.minWidthList @layoutList.hRefList ]
      loc.minWidth = @leftWidth + @rightWidth 
      loc.minHeight = @topHeight + @bottomHeight
      loc.vRef = @topHeight
      loc.hRef = @leftWidth-}
{-
  | TestPresentation 
      loc.minWidth = error "not implemented"
      loc.minHeight = error "not implemented"
      loc.hStretch = error "not implemented" 
      loc.vStretch = error "not implemented" 
      loc.vRef = error "not implemented"
      loc.hRef = error "not implemented"

  | MatrixPresentation
      loc.rowTopHeights = map maximum (getRows @n @layoutList.vRefList)
      loc.rowBottomHeights = map (\minHghtsVRefs ->
                                   maximum [ minHeight - vRef | (minHeight, vRef) <- minHghtsVRefs ]
				 ) (getRows @n (zip @layoutList.minHeightList @layoutList.vRefList))
      loc.colLeftWidths = map maximum (getCols @n @layoutList.hRefList)
      loc.colRightWidths = map (\minWdthsHRefs ->
                                   maximum [ minWidth - hRef | (minWidth, hRef) <- minWdthsHRefs ]
				 ) (getCols @n (zip @layoutList.minWidthList @layoutList.hRefList))
      loc.rowHeights = zipWith (+) @rowTopHeights @rowBottomHeights
      loc.colWidths = zipWith (+) @colLeftWidths @colRightWidths
      loc.minWidth = sum @colLeftWidths + sum @colRightWidths
      loc.minHeight = sum @rowTopHeights + sum @rowBottomHeights
      loc.hStretch = False
      loc.vStretch = False
      loc.vRef = if null @layoutList.vRefList then 0
                else head' "ArrangerAG.MatrixPresentation.loc.vRef" @rowTopHeights
      loc.hRef = 0
  | LayedOutRowP 
      loc.minWidth = error "not implemented"
      loc.minHeight = error "not implemented"
      loc.hStretch = error "not implemented" 
      loc.vStretch = error "not implemented" 
      loc.vRef = error "not implemented"
      loc.hRef = error "not implemented"
  | AlternativePresentation 
      loc.minWidth = 0
      loc.minHeight = 0
      loc.hStretch = True
      loc.vStretch = True
      loc.vRef = 0
      loc.hRef = 0
-}
  | WithP
{-
      loc.wdth = 
      loc.minHeight = 
      loc.vRef = 
      loc.hRef = 
-}
ATTR LayoutList [  | |  minWidthList, minHeightList : {[Int]} vRefList, hRefList : {[Int]}
                       hStretchList, vStretchList : {[Bool]} ]
SEM LayoutList
  | Nil
      lhs.minWidthList = []
      lhs.minHeightList = []
      lhs.hStretchList = []
      lhs.vStretchList = []
      lhs.vRefList = []
      lhs.hRefList = []
  | Cons 
      lhs.minWidthList = @hd.minWidth : @tl.minWidthList
      lhs.minHeightList = @hd.minHeight : @tl.minHeightList
      lhs.hStretchList = @hd.hStretch : @tl.hStretchList
      lhs.vStretchList = @hd.vStretch : @tl.vStretchList
      lhs.vRefList = @hd.vRef : @tl.vRefList
      lhs.hRefList = @hd.hRef : @tl.hRefList




SEM Root
  | Root
      layout.assignedWidth  = let (_,(extendedScreenWidth,_)) = @lhs.viewedArea
                                  screenWidth = extendedScreenWidth * 2 `div` 3 -- correction for extended viewed area
                              in  if @layout.hStretch && screenWidth >= @layout.minWidth 
                                  then screenWidth else @layout.minWidth
      layout.assignedHeight = let (_,(_,extendedScreenHeight)) = @lhs.viewedArea
                                  screenHeight = extendedScreenHeight * 2 `div` 3 -- correction for extended viewed area
                              in  if @layout.vStretch && screenHeight >= @layout.minHeight
                                  then screenHeight else @layout.minHeight
      layout.assignedVRef = @layout.vRef -- is ignored anyway 
      layout.assignedHRef = @layout.hRef 

SEM Layout [ assignedWidth, assignedHeight, assignedVRef, assignedHRef : Int | | ]
  | RowP
      loc.assignedWidths = if @layoutList.hStretchList!! @hRefNr -- if Ref Object is stretch, all children get
                                 then assign @layoutList.hStretchList -- equal space           +1, because refobj is stretch too
                                               (repeat((@leftTotalSpace+ @rightTotalSpace)`div`(@leftHStretches+1+ @rightHStretches))
						
					       )
					       @layoutList.minWidthList
		                 else assign @layoutList.hStretchList
                                               (  replicate @hRefNr (@leftChildSpace) 
					       ++ [0] -- not used, since stretch for child nr @hRefNr is False 
					       ++ repeat @rightChildSpace
					       )
					       @layoutList.minWidthList
      layoutList.assignedWidthList    = @assignedWidths
      layoutList.assignedHRefList     = @layoutList.hRefList -- is not right, nested rows don't work now

      layoutList.assignedHeightList   = assign @layoutList.vStretchList
                                                (repeat @lhs.assignedHeight)
                                                @layoutList.minHeightList 
      layoutList.assignedVRefList     = assign @layoutList.vStretchList
                                                (repeat @lhs.assignedVRef)
                                                @layoutList.vRefList 

       -- width of stretching children should not be subtracted from available width
       -- for the moment this amount is added back to it as left and right corrections
      loc.stretchMinWidths = assign @layoutList.hStretchList @layoutList.minWidthList (repeat 0)
      -- this list contains the widths for the non stretchers, the other widths are 0

      loc.leftCorrection = sum (take @hRefNr @stretchMinWidths) 
                              + if @layoutList.hStretchList!! @hRefNr then @stretchMinWidths !! @hRefNr else 0
      loc.rightCorrection = sum (drop (@hRefNr+1) @stretchMinWidths)

      loc.leftTotalSpace = @lhs.assignedHRef - @hRef    + @leftCorrection
      loc.rightTotalSpace = @lhs.assignedWidth - @minWidth - @leftTotalSpace  + @rightCorrection
      loc.leftHStretches = length . filter (==True) . take @hRefNr $ @layoutList.hStretchList 
      loc.rightHStretches = length . filter (==True) . drop (@hRefNr+1) $ @layoutList.hStretchList 
      loc.leftChildSpace = round (fromIntegral @leftTotalSpace / fromIntegral @leftHStretches )
      loc.rightChildSpace = round (fromIntegral @rightTotalSpace / fromIntegral @rightHStretches )
 
       
      -- @lhs.assigned vs final????
  | ColP
      layoutList.assignedWidthList    = assign @layoutList.hStretchList
                                              (repeat @lhs.assignedWidth) @layoutList.minWidthList 
      -- in case of stretch, return composite's ref
      layoutList.assignedHRefList     = assign @layoutList.hStretchList
                                              (repeat @lhs.assignedHRef)
					      @layoutList.hRefList 
      loc.assignedHeights = if @layoutList.vStretchList!! @vRefNr -- if Ref Object is stretch, all children get
                            then assign @layoutList.vStretchList -- equal space           +1, because refobj is stretch too
                                               (repeat((@topTotalSpace+ @bottomTotalSpace)`div`(@topVStretches+1+ @bottomVStretches))
						
					       )
					       @layoutList.minHeightList
		            else assign @layoutList.vStretchList
                                               (  replicate @vRefNr (@topChildSpace) 
					       ++ [0] -- not used, since stretch for child nr @vRefNr is False 
					       ++ repeat @bottomChildSpace
					       )
					       @layoutList.minHeightList
      layoutList.assignedHeightList    = @assignedHeights
      layoutList.assignedVRefList     = {- debug Arr (  "assVRef:"++show @lhs.assignedVRef
						++ "VRef:"++ show @vRef
						++ "minHeight:"++show minHeight
						++ "assHeight:"++show @lhs.assignedHeight
						) -} 
					      @layoutList.vRefList -- is not right, nested cols don't work now

       -- width of stretching children should not be subtracted from available height
       -- for the moment this amount is added back to it as top and bottom corrections
      loc.stretchMinHeights = assign @layoutList.vStretchList @layoutList.minHeightList (repeat 0)
      -- this list contains the heights for the non stretchers, the other heights are 0

      loc.topCorrection = sum (take @vRefNr @stretchMinHeights) 
                              + if @layoutList.vStretchList!! @vRefNr then @stretchMinHeights !! @vRefNr else 0
      loc.bottomCorrection = sum (drop (@vRefNr+1) @stretchMinHeights)

      
      
      
      loc.topTotalSpace = @lhs.assignedVRef - @vRef  + @topCorrection     -- minTopHeight
      loc.bottomTotalSpace = @lhs.assignedHeight - @minHeight - @topTotalSpace   + @bottomCorrection
      loc.topVStretches = length . filter (==True) . take @vRefNr $ @layoutList.vStretchList 
      loc.bottomVStretches = length . filter (==True) . drop (@vRefNr+1) $ @layoutList.vStretchList 
      loc.topChildSpace = round (fromIntegral @topTotalSpace / fromIntegral @topVStretches )
      loc.bottomChildSpace = round (fromIntegral @bottomTotalSpace / fromIntegral @bottomVStretches )
  | OverlayP
      layoutList.assignedHeightList   = assign @layoutList.vStretchList
                                              (repeat @lhs.assignedHeight) @layoutList.minHeightList 
      layoutList.assignedVRefList     = assign @layoutList.vStretchList
                                              (repeat @lhs.assignedVRef) @layoutList.vRefList 
      layoutList.assignedWidthList    = assign @layoutList.hStretchList
                                              (repeat @lhs.assignedWidth) @layoutList.minWidthList 
      layoutList.assignedHRefList     = assign @layoutList.hStretchList
                                              (repeat @lhs.assignedHRef)  @layoutList.hRefList 
  | GraphP -- just use minSize and h/hRef for assigned Size and Ref. Stretching does not make sense in a GraphP
      layoutList.assignedHeightList = @layoutList.minHeightList 
      layoutList.assignedVRefList   = @layoutList.vRefList 
      layoutList.assignedWidthList  = @layoutList.minWidthList 
      layoutList.assignedHRefList   = @layoutList.hRefList 
  | VertexP
      child.assignedHeight                = @child.minHeight
      child.assignedWidth                 = @child.minWidth
      child.assignedHRef                  = @child.hRef
      child.assignedVRef                  = @child.vRef
  | FormatterP
      -- width height href and vref are assigned to unfoldedFormatter by copy rules
      layoutList.assignedWidthList    = debug Err "ArrangerAG.assignedWidthList: FormatterP must be unfolded first" $ replicate @layoutList.nrOfChildren 0
      layoutList.assignedHeightList   = debug Err "ArrangerAG.assignedHeightList: FormatterP must be unfolded first" $ replicate @layoutList.nrOfChildren 0
      layoutList.assignedVRefList     = debug Err "ArrangerAG.assignedVRefList: FormatterP must be unfolded first" $ replicate @layoutList.nrOfChildren 0
      layoutList.assignedHRefList     = debug Err "ArrangerAG.assignedHRefList: FormatterP must be unfolded first" $ replicate @layoutList.nrOfChildren 0
{-
  | MatrixPresentation
-- is a lot more complicated than this
      layoutList.assignedHeightList    =assign @layoutList.vStretchList
                                              (concat. map (replicate @n)$ @rowHeights)
					      @layoutList.minHeightList 
      layoutList.assignedVRefList     = assign @layoutList.vStretchList
                                              (concat. map (replicate @n)$ @rowTopHeights) --(repeat @lhs.assignedVRef)
					      @layoutList.vRefList 
      layoutList.assignedWidthList    = assign @layoutList.hStretchList
                                              (concat . repeat $ @colWidths) 
					      @layoutList.minWidthList 
      layoutList.assignedHRefList     = assign @layoutList.hStretchList
                                              (concat . repeat $ @colLeftWidths) --(repeat @lhs.assignedHRef)
					      @layoutList.hRefList 
   --   layoutList.assignedWidthList    = @layoutList.minWidthList
 --     layoutList.assignedHeightList   = @layoutList.minHeightList
 --     layoutList.assignedVRefList     = @layoutList.vRefList
   --   layoutList.assignedHRefList     = @layoutList.hRefList
  | LayedOutRowP
      layoutList.assignedWidthList    = error "LayedOut row not implemented yet."
      layoutList.assignedHeightList    = error "LayedOut row not implemented yet."
      layoutList.assignedVRefList    = error "LayedOut row not implemented yet."
      layoutList.assignedHRefList    = error "LayedOut row not implemented yet."
  | AlternativePresentation
      layoutList.assignedWidthList    = repeat @lhs.assignedWidth
      layoutList.assignedHeightList    = repeat @lhs.assignedHeight
      layoutList.assignedVRefList     = repeat @lhs.assignedVRef
      layoutList.assignedHRefList     = repeat @lhs.assignedHRef
-}
--  | WithP

SEM LayoutList [ assignedWidthList, assignedHeightList, assignedVRefList, assignedHRefList : {[Int]} | | ]
  | Cons 
      hd.assignedWidth = head' "ArrangerAG.LayoutList.hd.assignedWidth" @lhs.assignedWidthList
      tl.assignedWidthList = tail @lhs.assignedWidthList
      hd.assignedHeight = head' "ArrangerAG.LayoutList.hd.assignedHeight" @lhs.assignedHeightList
      tl.assignedHeightList = tail @lhs.assignedHeightList
      hd.assignedVRef = head' "ArrangerAG.LayoutList.assignedVRef" @lhs.assignedVRefList
      tl.assignedVRefList = tail @lhs.assignedVRefList
      hd.assignedHRef = head' "ArrangerAG.LayoutList.assignedHRef" @lhs.assignedHRefList
      tl.assignedHRefList = tail @lhs.assignedHRefList


-- why do presentations need this value themselves? Poly & rect need it for scaling.
-- instead of sending back, maybe row and col can keep a local copy? or will this interfere
-- with top/bottom/etc-aligning? 
SEM Layout [ || finalHeight, finalWidth, finalVRef, finalHRef : Int ]
  | *
      loc.finalWidth  : Int
      loc.finalHeight : Int
      loc.finalVRef   : Int
      loc.finalHRef   : Int
  | EmptyP
      loc.finalWidth  = @lhs.assignedWidth
      loc.finalHeight = @lhs.assignedHeight
      loc.finalVRef   = @lhs.assignedVRef
      loc.finalHRef   = @lhs.assignedHRef
  | StringP 
      loc.finalWidth  = @minWidth
      loc.finalHeight = @minHeight
      loc.finalVRef   = @lhs.assignedVRef
      loc.finalHRef   = @lhs.assignedHRef
  | RectangleP  
      loc.finalWidth  = @minWidth
      loc.finalHeight = @minHeight
      loc.finalVRef   = @lhs.assignedVRef
      loc.finalHRef   = @lhs.assignedHRef
  | EllipseP  
      loc.finalWidth  = @minWidth
      loc.finalHeight = @minHeight
      loc.finalVRef   = @lhs.assignedVRef
      loc.finalHRef   = @lhs.assignedHRef
  | ImageP  
      loc.finalWidth  = @lhs.assignedWidth
      loc.finalHeight = @lhs.assignedHeight
      loc.finalVRef   = @lhs.assignedVRef
      loc.finalHRef   = @lhs.assignedHRef
  | PolyP 
      loc.finalWidth  = @lhs.assignedWidth
      loc.finalHeight = @lhs.assignedHeight
      loc.finalVRef   = @lhs.assignedVRef
      loc.finalHRef   = @lhs.assignedHRef
  | RowP
      loc.finalWidth  = sum @layoutList.finalWidthList
      loc.finalHeight = @lhs.assignedHeight
      loc.finalVRef   = @lhs.assignedVRef
      loc.finalHRef   = @lhs.assignedHRef
                        {- the sum below does not work when hRef is modified by a with. 
                           It is as of yet unclear whether the simpler computation causes any problems
                        if null @layoutList.hRefList then 0
                        else if @layoutList.hStretchList!! @hRefNr then @lhs.assignedHRef
		                else sum (take @hRefNr @assignedWidths) + (@layoutList.hRefList !! @hRefNr)
		        -}
  | ColP
      loc.finalWidth  = @lhs.assignedWidth
      loc.finalHeight = sum @layoutList.finalHeightList --@lhs.assignedHeight
      loc.finalVRef   = @lhs.assignedVRef
                        {-
                        if null @layoutList.vRefList then 0
                        else if @layoutList.vStretchList!! @vRefNr then @lhs.assignedVRef
		             else sum (take @vRefNr @assignedHeights) + (@layoutList.vRefList !! @vRefNr)
		        -}
      loc.finalHRef   = @lhs.assignedHRef
  | OverlayP 
      loc.finalWidth  = @lhs.assignedWidth
      loc.finalHeight = @lhs.assignedHeight
      loc.finalVRef   = @lhs.assignedVRef
      loc.finalHRef   = @lhs.assignedHRef
  | GraphP
      loc.finalWidth  = @minWidth
      loc.finalHeight = @minHeight
      loc.finalVRef   = @lhs.assignedVRef
      loc.finalHRef   = @lhs.assignedHRef
  | VertexP
      loc.finalWidth  = @lhs.assignedWidth
      loc.finalHeight = @lhs.assignedHeight
      loc.finalVRef   = @lhs.assignedVRef
      loc.finalHRef   = @lhs.assignedHRef
  | FormatterP
      loc.finalWidth  = @lhs.assignedWidth
      loc.finalHeight = @unfoldedFormatter.finalHeight
      loc.finalVRef   = @lhs.assignedVRef
      loc.finalHRef   = @lhs.assignedHRef
{-
  | TestPresentation 
      loc.finalWidth = error "not implemented"
      loc.finalHeight = error "not implemented"
      loc.finalVRef = error "not implemented"
      loc.finalHRef = error "not implemented"
  | MatrixPresentation
      loc.finalWidth = @lhs.assignedWidth
      loc.finalHeight = @lhs.assignedHeight
      loc.finalVRef = if null @layoutList.vRefList then 0 -- we need H/HRefNrs here, but there not in MatrixPresentation yet
                      else head' "ArrangerAG.MatrixPresentation.finalVRef" @rowTopHeights
      loc.finalHRef = if null @layoutList.vRefList then 0
                      else head' "ArrangerAG.MatrixPresentation.finalHRef" @colLeftWidths
  | LayedOutRowP 
      loc.finalWidth = error "not implemented"
      loc.finalHeight = error "not implemented"
      loc.finalVRef = error "not implemented"
      loc.finalHRef = error "not implemented"
  | AlternativePresentation 
      loc.finalWidth = @layoutList.finalWidthList !! @firstFit
      loc.finalHeight = @layoutList.finalHeightList !! @firstFit
      loc.finalVRef = @layoutList.finalVRefList !! @firstFit
      loc.finalHRef = @layoutList.finalHRefList !! @firstFit
      loc.firstFit = selectFirstFit @lhs.assignedWidth @layoutList.finalWidthList -- no HRefs (yet)
-}
  | WithP
{-
      loc.wdth = 
      loc.hght = 
      loc.vRef = 
      loc.hRef = 
-}


ATTR LayoutList [  | |  finalWidthList, finalHeightList, finalVRefList, finalHRefList : {[Int]} ]
SEM LayoutList
  | Nil
      lhs.finalWidthList  = []
      lhs.finalHeightList = []
      lhs.finalVRefList   = []
      lhs.finalHRefList   = []
  | Cons 
      lhs.finalWidthList  = @hd.finalWidth  : @tl.finalWidthList
      lhs.finalHeightList = @hd.finalHeight : @tl.finalHeightList
      lhs.finalVRefList   = @hd.finalVRef   : @tl.finalVRefList
      lhs.finalHRefList   = @hd.finalHRef   : @tl.finalHRefList


-- Viewed Area

-- propagated with copy rules
ATTR Root Layout LayoutList [ viewedArea, oldViewedArea : Rectangle | | ]


-- Upper left corner of the arrangement. Used for determining whether arrangement is in view.
-- Note!! This absx & absy is not the same as the lux and luy in the renderer, which denote the upper
-- left corner of the parent arrangement. In the renderer, each layout needs to add its own 
-- width and height to (lux,luy) to get its own upper left corner.
-- Also note that for vertices (absx,absy) is not position of the vertex, since for vertices
-- xList and yList are lists of 0's. 
ATTR Layout LayoutList [ absx, absy : Int | | ]
SEM Root
  | Root 
      layout.absx = 0
      layout.absy = 0
      
SEM LayoutList
  | Cons 
      hd.absx = @lhs.absx + head' "ArrangerAG.LayoutList.hd.absx" @lhs.xList
      hd.absy = @lhs.absy + head' "ArrangerAG.LayoutList.hd.absy" @lhs.yList

      
-- lu attributes for all the other situations are handled by copy rules

-- Position calculation

SEM Root
  | Root 
      layout.x = 0
      layout.y = 0

ATTR Layout [ x, y : Int | | ]
SEM Layout
  | RowP
      layoutList.xList    = init.scanl (+) 0 $ @layoutList.finalWidthList
      layoutList.yList    = [ @finalVRef - cvRef | cvRef <- @layoutList.finalVRefList ]
  | ColP
      layoutList.xList    = [ @finalHRef - chRef | chRef <- @layoutList.finalHRefList ]
      layoutList.yList    = init.scanl (+) 0 $ @layoutList.finalHeightList
  | OverlayP
      layoutList.xList    = [ @finalHRef - chRef | chRef <- @layoutList.finalHRefList ]
      layoutList.yList    = [ @finalVRef - cvRef | cvRef <- @layoutList.finalVRefList ]
  | GraphP -- finalRefs are 0 for the GraphP
      layoutList.xList    = map (0-) @layoutList.finalHRefList
      layoutList.yList    = map (0-) @layoutList.finalVRefList
  | VertexP
      child.x                   = 0
      child.y                   = 0
  | FormatterP
      layoutList.xList    = debug Err "ArrangerAG.xList: x should not be evaluated for FormatterP children" $ replicate @layoutList.nrOfChildren 0
      layoutList.yList    = debug Err "ArrangerAG.yList: y should not be evaluated for FormatterP children" $ replicate @layoutList.nrOfChildren 0
--     @unfoldedFormatter.x/y handled by copy rule

{-
  | MatrixPresentation -- x and y are added to cumulative heights and widths
      loc.cumulativeColWidths = init. scanl (+) 0 $ @colWidths
      loc.cumulativeRowHeights = init. scanl (+) 0 $ @rowHeights
      loc.absoluteRowRefYs = zipWith (+) @cumulativeRowHeights @rowTopHeights
      loc.absoluteColRefXs = zipWith (+) @cumulativeColWidths @colLeftWidths 
      layoutList.xList    = zipWith (-) (concat . repeat $ @absoluteColRefXs) @layoutList.finalHRefList
      layoutList.yList    = zipWith (-) (concat . map (replicate @n) $ @absoluteRowRefYs) @layoutList.finalVRefList
  | LayedOutRowP
      layoutList.xList    = error "LayedOut row not implemented yet."
      layoutList.yList    = error "LayedOut row not implemented yet."
  | AlternativePresentation
      layoutList.xList    = repeat 0
      layoutList.yList    = repeat 0
-}

ATTR LayoutList [ xList, yList : {[Int]} | | ]
SEM LayoutList
  | Cons 
      hd.x = head' "ArrangerAG.LayoutList.hd.x" @lhs.xList
      hd.y = head' "ArrangerAG.LayoutList.hd.y" @lhs.yList
      tl.xList = tail @lhs.xList
      tl.yList = tail @lhs.yList







-- Creating the Arrangement

-- are the widths and heights really needed in the attributed tree?
-- yes, they define the area of the layout, used for background coloring etc.


-- bit unclear what to do when href and vref are changed in with nodes  @finalVRef @finalHRef
-- for a child in a composite are not the same as the  @finalVRef @finalHRef at the with nodes
-- however in such a case we probably can't do it incrementally anyway

ATTR Layout [  | | arrangement : {Arrangement @node} ]
SEM Layout
  | EmptyP
      lhs.arrangement = arrangeWhenFocusedOrViewed @lhs.rootPath @lhs.focusMinPath @lhs.focusMaxPath @lhs.absx @lhs.absy @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lhs.viewedArea (IDA @lhs.idCounter) {- (idAFromP @id) -} $
                          EmptyA (IDA @lhs.idCounter) {- (idAFromP @id) -}  @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lhs.backgroundColor
  | StringP 
      lhs.arrangement = arrangeWhenFocusedOrViewed @lhs.rootPath @lhs.focusMinPath @lhs.focusMaxPath @lhs.absx @lhs.absy @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lhs.viewedArea (IDA @lhs.idCounter) {- (idAFromP @id) -} $
                          StringA (IDA @lhs.idCounter) {- (idAFromP @id) -} @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @text @lhs.textColor @lhs.backgroundColor @lhs.font (cumulativeCharWidths @lhs.fontMetrics @lhs.font @text) -- expensive, but will be evaluated lazily
  | RectangleP
      lhs.arrangement = arrangeWhenFocusedOrViewed @lhs.rootPath @lhs.focusMinPath @lhs.focusMaxPath    @lhs.absx @lhs.absy @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lhs.viewedArea (IDA @lhs.idCounter) {- (idAFromP @id) -} $
                          RectangleA (IDA @lhs.idCounter) {- (idAFromP @id) -} @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lineWidth @style @lhs.lineColor @lhs.fillColor @lhs.backgroundColor
  | EllipseP
      lhs.arrangement = arrangeWhenFocusedOrViewed @lhs.rootPath @lhs.focusMinPath @lhs.focusMaxPath  @lhs.absx @lhs.absy @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lhs.viewedArea (IDA @lhs.idCounter) {- (idAFromP @id) -} $
                          EllipseA (IDA @lhs.idCounter) {- (idAFromP @id) -} @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lineWidth @style @lhs.lineColor @lhs.fillColor @lhs.backgroundColor
  | ImageP
      lhs.arrangement = arrangeWhenFocusedOrViewed @lhs.rootPath @lhs.focusMinPath @lhs.focusMaxPath @lhs.absx @lhs.absy @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lhs.viewedArea (IDA @lhs.idCounter) {- (idAFromP @id) -} $
                          ImageA (IDA @lhs.idCounter) {- (idAFromP @id) -} @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @src @style @lhs.lineColor @lhs.backgroundColor
  | PolyP      
      lhs.arrangement = arrangeWhenFocusedOrViewed @lhs.rootPath @lhs.focusMinPath @lhs.focusMaxPath           @lhs.absx @lhs.absy @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lhs.viewedArea (IDA @lhs.idCounter) {- (idAFromP @id) -} $
                          let mkPoint (rx, ry) = ( round (rx * fromIntegral ((@finalWidth-1) `max` 0))
			                         , round (ry * fromIntegral ((@finalHeight-1) `max` 0)) )
		                  in  PolyA (IDA @lhs.idCounter) {- (idAFromP @id) -} @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef (map mkPoint @pointList) @lineWidth @style @lhs.lineColor @lhs.fillColor @lhs.backgroundColor
		      
{-
  | TestPresentation
      lhs.arrangement =  RectangleA (IDA @lhs.idCounter) {- (idAFromP @id) -} @lhs.x @lhs.y @finalWidth @finalHeight 0 Solid @lhs.lineColor @lhs.fillColor


-}
  | RowP 
      lhs.arrangement = {-
                        debug Arr ( "rowattrs:"++show 
                                                  (@layoutList.minWidthList
						  , @layoutList.hRefList
						  , @layoutList.finalWidthList 
                          , @layoutList.finalHeightList 
                          , @layoutList.finalHRefList 
                          , @layoutList.finalVRefList
                                                
                          , @lhs.assignedWidth
						  , @leftCorrection
						  , @rightCorrection
						  , @assignedWidths
						  ))$ 
                        -}
						--debug Err ("Row in view with #children: "++ show @layoutList.nrOfChildren ++" "++ show @finalWidth ++" "++ show @layoutList.finalWidthList) $
                          arrangeWhenFocusedOrViewed @lhs.rootPath @lhs.focusMinPath @lhs.focusMaxPath     @lhs.absx @lhs.absy @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lhs.viewedArea (IDA @lhs.idCounter) {- (idAFromP @id) -} $
                          RowA (IDA @lhs.idCounter) {- (idAFromP @id) -} @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lhs.backgroundColor @layoutList.arrangementList
  | ColP 
      lhs.arrangement = {-
						debug Arr ( "colattrs:"++show 
                          (@layoutList.minHeightList
						  , @layoutList.vRefList
                          , @layoutList.finalHeightList 
						  , @layoutList.finalWidthList 
                          , @layoutList.finalVRefList 
                          , @layoutList.finalHRefList 
						  , @layoutList.finalWidthList 
                          , @layoutList.finalHRefList 
                          , @lhs.assignedWidth
                              ))$
	                    -}
					    arrangeWhenFocusedOrViewed @lhs.rootPath @lhs.focusMinPath @lhs.focusMaxPath     @lhs.absx @lhs.absy @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lhs.viewedArea (IDA @lhs.idCounter) {- (idAFromP @id) -} $
                          ColA (IDA @lhs.idCounter) {- (idAFromP @id) -} @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lhs.backgroundColor @formatted @layoutList.arrangementList 
  | OverlayP 
      lhs.arrangement = arrangeWhenFocusedOrViewed @lhs.rootPath @lhs.focusMinPath @lhs.focusMaxPath @lhs.absx @lhs.absy @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lhs.viewedArea (IDA @lhs.idCounter) {- (idAFromP @id) -} $
                          OverlayA (IDA @lhs.idCounter) {- (idAFromP @id) -} @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lhs.backgroundColor @direction @layoutList.arrangementList
  | GraphP 
      lhs.arrangement = arrangeWhenFocusedOrViewed @lhs.rootPath @lhs.focusMinPath @lhs.focusMaxPath @lhs.absx @lhs.absy @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lhs.viewedArea (IDA @lhs.idCounter) {- (idAFromP @id) -} $
                          GraphA (IDA @lhs.idCounter) {- (idAFromP @id) -} @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lhs.backgroundColor 
                                 (length @layoutList.vertices)
                                 ( @layoutList.arrangementList  ++
                                   mkEdges @edges @layoutList.vertices @lhs.lineColor )
                        -- All edges are arranged, even if the graph is partially in view.
                        -- This could be optimized further, but is probably not worth the effort.
    | VertexP
      lhs.arrangement = arrangeWhenFocusedOrViewed @lhs.rootPath @lhs.focusMinPath @lhs.focusMaxPath @lhs.absx @lhs.absy
                                         @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lhs.viewedArea (IDA @lhs.idCounter) {- (idAFromP @id) -} $
                          VertexA (IDA @lhs.idCounter) {- (idAFromP @id) -} @lhs.x @lhs.y 
                                  @finalWidth @finalHeight @finalHRef @finalVRef @lhs.backgroundColor 
                                  (\a -> let (x,y) = @outline a in (x+ @child.hRef,y+ @child.vRef)) @child.arrangement
  | FormatterP
      -- unfoldedFormatter.arrangement handled by copy rule
{-
  | LayedOutRowP 
      lhs.arrangement = RowA (IDA @lhs.idCounter) {- (idAFromP @id) -} @lhs.x @lhs.y @finalWidth @finalHeight @finalVRef @finalHRef @lhs.backgroundColor @layoutList.arrangementList
  | MatrixPresentation 
      lhs.arrangement = StringA NoID 0 40 0 0 0 0 ("unimplemented AttrPresentation MatrixPresentation") (0,0,0) defaultFont []
       -- MatrixPresentation (IDA @lhs.idCounter) {- (idAFromP @id) -} @layoutList.arrangementList @lhs.x @lhs.y finalWidth finalHeight @lhs.backgroundColor
  | AlternativePresentation -- remove the alternative layout
      lhs.arrangement = @layoutList.arrangementList !! @firstFit 
-}

  | WithP
      lhs.arrangement = @child.arrangement
  | StructuralP 
      lhs.arrangement = StructuralA (IDA @lhs.idCounter) {- (idAFromP @id) -} @child.arrangement
  | ParsingP 
      lhs.arrangement = ParsingA (IDA @lhs.idCounter) {- (idAFromP @id) -} @child.arrangement
  | LocatorP 
      lhs.arrangement = LocatorA @location @child.arrangement
  | TagP 
      lhs.arrangement = TagA @tags @child.arrangement
  | ArrangedP
      lhs.arrangement = case @lhs.oldArr of
                          Just oldArr -> 
                            
                            if 
                               overlap ((@lhs.absx,@lhs.absy),(@finalWidth,@finalHeight)) @lhs.viewedArea
                               && not (isComplete oldArr) 
                               && (    not (@lhs.x == xA oldArr && @lhs.y == yA oldArr )
                                    || @lhs.viewedArea /= @lhs.oldViewedArea )
                               
                            then --debug Arr ("Failed reuse: "++ show (not (isComplete oldArr))
                                 --           ++ show @lhs.viewedArea ++ show @lhs.oldViewedArea 
                                 --           ++ show (@lhs.x == xA oldArr && @lhs.y == yA oldArr )   ++show oldArr ) $
                                 arrangeWhenFocusedOrViewed @lhs.rootPath @lhs.focusMinPath @lhs.focusMaxPath @lhs.absx @lhs.absy
                                              @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lhs.viewedArea NoIDA $
                                   (if markArrangementBackground then setBGColor red else id) $      -- @finalVRef @finalHRef are taken from the arrangedP node
                                   @unprunedLayHO.arrangement
                            else  
                                 arrangeWhenFocusedOrViewed @lhs.rootPath @lhs.focusMinPath @lhs.focusMaxPath @lhs.absx @lhs.absy
                                              @lhs.x @lhs.y (widthA oldArr) (heightA oldArr) (hRefA oldArr) (vRefA oldArr) {-@finalWidth @finalHeight @finalHRef @finalVRef-} @lhs.viewedArea NoIDA $
                                   (if markArrangementBackground then setBGColor yellow else id) $      -- @finalVRef @finalHRef are taken from the arrangedP node
                                   setXYWHA @lhs.x @lhs.y @finalWidth @finalHeight oldArr 
                          Nothing ->
                            arrangeWhenFocusedOrViewed @lhs.rootPath @lhs.focusMinPath @lhs.focusMaxPath @lhs.absx @lhs.absy
                                              @lhs.x @lhs.y @finalWidth @finalHeight @finalHRef @finalVRef @lhs.viewedArea NoIDA $
                              (if markArrangementBackground then setBGColor blue else id) $      -- @finalVRef @finalHRef are taken from the arrangedP node
                              @unprunedLayHO.arrangement

                                -- do we need to set width and height? These should not have changed
                                -- the last one seems wrong for sure 
  | ArrangedP
      inst.unprunedLayHO : (Layout {doc} {enr} {node} {clip} {token})
      inst.unprunedLayHO = case @lhs.oldArr of
                              Just oldArr -> 
                                if overlap ((@lhs.absx,@lhs.absy),(@finalWidth,@finalHeight)) @lhs.viewedArea
                                   && not (isComplete oldArr)
                                   && (   not (@lhs.x == xA oldArr && @lhs.y == yA oldArr )
                                       || @lhs.viewedArea /= @lhs.oldViewedArea )
                                then @lhs.unprunedLay
                                else debug Err ("ERROR:unprunedLayHO accessed while not assigned") $
                                     EmptyP NoIDP
                              Nothing -> @lhs.unprunedLay -- no oldArr, so we always use the layout
  
                          -- not exactly clear how to assign these attributes using the old values
                          -- what if the AG computes a different value for the refs, reassign?
      loc.minWidth    = case @lhs.oldArr of
                          Just oldArr -> widthA oldArr
                          Nothing     -> @unprunedLayHO.minWidth
      loc.minHeight   = case @lhs.oldArr of
                          Just oldArr -> heightA oldArr
                          Nothing     -> @unprunedLayHO.minHeight
      loc.hStretch    = case @lhs.oldArr of
                          Just oldArr -> False
                          Nothing     -> @unprunedLayHO.hStretch
      loc.vStretch    = case @lhs.oldArr of
                          Just oldArr -> False
                          Nothing     -> @unprunedLayHO.vStretch
      loc.vRef        = case @lhs.oldArr of
                          Just oldArr -> vRefA oldArr
                          Nothing     -> @unprunedLayHO.vRef
      loc.hRef        = case @lhs.oldArr of
                          Just oldArr -> hRefA oldArr
                          Nothing     -> @unprunedLayHO.hRef
 
      loc.finalWidth  = case @lhs.oldArr of
                          Just oldArr -> widthA oldArr
                          Nothing     -> @unprunedLayHO.finalWidth
      loc.finalHeight = case @lhs.oldArr of
                          Just oldArr -> heightA oldArr
                          Nothing     -> @unprunedLayHO.finalHeight
      loc.finalVRef   = case @lhs.oldArr of
                          Just oldArr -> vRefA oldArr
                          Nothing     -> @unprunedLayHO.finalVRef
      loc.finalHRef   = case @lhs.oldArr of
                          Just oldArr -> hRefA oldArr
                          Nothing     -> @unprunedLayHO.finalHRef

      loc.maxFormatterDepth = case @lhs.oldArr of
                                Just oldArr -> 0 
                                Nothing     -> @unprunedLayHO.maxFormatterDepth

      unprunedLayHO.allFonts = @lhs.allFonts -- to prevent copy rule from getting childs inherited allFonts
                                              -- from loc.allFonts, creating a cycle

      -- fonts returned by pruned layout are not complete. As long as fonts are not deleted,
      -- this is not a problem.
      loc.allFonts = case @lhs.oldArr of  
                       Just oldArr -> @lhs.allFonts
                       Nothing     -> @unprunedLayHO.allFonts
      loc.vertex = case @lhs.oldArr of
                       Just oldArr -> debug Err "Warning: ArrangedP instead of VertexP" (0,0,0,\_->(0,0))
                       Nothing     -> @unprunedLayHO.vertex
  
                                   
ATTR Layout [ || vertex : {(Int,Int,Int,Outline)} ]
SEM Layout
  | VertexP
      lhs.vertex = (@i,@x,@y,@outline)
  | EmptyP
      lhs.vertex = debug Err "Warning: graph presentation with non-vertex child:" (0,0,0,\_->(0,0))
  | StringP
      lhs.vertex = debug Err "Warning: graph presentation with non-vertex child:" (0,0,0,\_->(0,0))
  | RectangleP
      lhs.vertex = debug Err "Warning: graph presentation with non-vertex child:" (0,0,0,\_->(0,0))
  | EllipseP
      lhs.vertex = debug Err "Warning: graph presentation with non-vertex child:" (0,0,0,\_->(0,0))
  | ImageP
      lhs.vertex = debug Err "Warning: graph presentation with non-vertex child:" (0,0,0,\_->(0,0))
  | PolyP
      lhs.vertex = debug Err "Warning: graph presentation with non-vertex child:" (0,0,0,\_->(0,0))
  | RowP
      lhs.vertex = debug Err "Warning: graph presentation with non-vertex child:" (0,0,0,\_->(0,0))
  | ColP
      lhs.vertex = debug Err "Warning: graph presentation with non-vertex child:" (0,0,0,\_->(0,0))
  | OverlayP
      lhs.vertex = debug Err "Warning: graph presentation with non-vertex child:" (0,0,0,\_->(0,0))
  | GraphP
      lhs.vertex = debug Err "Warning: graph presentation with non-vertex child:" (0,0,0,\_->(0,0))
  | ArrangedP
      lhs.vertex = debug Err "Warning: graph presentation with non-vertex child:" (0,0,0,\_->(0,0))
  | FormatterP
      lhs.vertex = debug Err "Warning: graph presentation with non-vertex child:" (0,0,0,\_->(0,0))


SEM LayoutList [ || vertices : {[(Int,Int,Int,Outline)]} ]
  | Nil
      lhs.vertices = []
  | Cons 
      lhs.vertices = @hd.vertex : @tl.vertices
      
ATTR Show {node}, Show {token} =>
     Root [ unprunedLay : {Layout @doc @enr @node @clip @token} | | ]

SEM Show {node}, Show {token} =>
    Layout [ unprunedLay : {Layout @doc @enr @node @clip @token} | | ]
  | EmptyP StringP ImageP PolyP RectangleP EllipseP ArrangedP 
  | RowP OverlayP GraphP FormatterP
      layoutList.unprunedLayList = {- debug Arr ("Lengths "++show (length (getChildrenP @lhs.unprunedLay))
                                                        ++","  ++show (length @layoutList.minWidthList)
                                                               ++show (map shallowShowPres (getChildrenP @lhs.unprunedLay))
                                                        ++","  ++show (map shallowShowPres (getChildrenP @self))
                                                               ) $ -}
                                          getChildrenP @lhs.unprunedLay
                                          ++ repeat (debug Err ("ERROR:unprunedLay list of differing length accessed in" ++ shallowShowPres @self) (EmptyP NoIDP))

  | VertexP WithP StructuralP ParsingP LocatorP TagP 
      child.unprunedLay = {- case (@self, @lhs.unprunedLay) of
                                    (WithP _ _, WithP _ _) -> id
                                    (LocatorP _ _, LocatorP _ _) -> id
                                    (TagP _ _, TagP _ _) -> id
                                    (StructuralP _ _, StructuralP _ _) -> id
                                    (ParsingP _ _, ParsingP _ _) -> id
                                    (p,upp)            -> debug Arr $ "not the same:" ++ shallowShowPres p ++ shallowShowPres upp
                             $ -}
                             getChildP @lhs.unprunedLay
  | ColP 
      layoutList.unprunedLayList =
        case @formatted of
          NF -> getChildrenP @lhs.unprunedLay
                ++ repeat (debug Err ("ERROR:unprunedLay list of differing length accessed in ColP NF") (EmptyP NoIDP))
          F nrOfEltss ->
            let press = getChildrenP @lhs.unprunedLay -- @lhs.unprunedLay is a FormatterP
                breaks = tail (scanl (+) 0 nrOfEltss)
                mkDummyRow = RowP NoIDP 0
            in  (map mkDummyRow $ linesFromBreaks breaks press)
                ++ repeat (debug Err ("ERROR:unprunedLay list of differing length accessed in ColP F") (EmptyP NoIDP))
-- for a column that came from a formatter, we distribute the unpruned layout over the
-- column of rows.

-- The unprunedLay for @inst.unfoldedFormatter HO attribute is copied directly from its FormatterP parent
       
SEM Show {node}, Show {token} =>
    LayoutList [ unprunedLayList : {[Layout @doc @enr @node @clip @token]} | | ]
  | Cons 
      hd.unprunedLay     = head' "ArrangerAG.LayoutList.hd.unPrunedPres" @lhs.unprunedLayList
      tl.unprunedLayList = tail @lhs.unprunedLayList

ATTR Root         [ oldArr : {Maybe (Arrangement @node)}  | | ]


{-
Old arrangement is passed along according to the structure of the layout tree.

If a row/col/etc. has different nrs of children in the layout and the old arrangement,
the node in the diffTree is (DiffLeaf False), and therefore, the list of children will not be used.

A ColP may be a column in the layout, or a generated column originating from a formatter.
In the latter case, the arrangement will be a column of rows, from which we retrieve the old
arrangements and redistribute them according to the new column of rows structure.


Similarly, a FormatterP will have a column of rows as its old arrangement, from which the old arrangements
are retrieved.

In both these cases, we must take into account that the column of rows may contain unarranged rows. Because
unarranged rows do not contain info on how many children the row has, we cannot continue the extraction after
encountering an unarranged row.

TODO rewrite with getChildrenA etc.
TODO linesFromBreaks produces an extra empty line, when given list of nrs of elts. Is this a problem?
-}
SEM Layout  [ oldArr : {Maybe (Arrangement node)}   | | ]
  | RowP 
      layoutList.oldArrList = case @lhs.oldArr of 
                                      Just (RowA idp _ _ _ _ _ _ _ arrs) -> -- debug Err ("ArrRow "++show idp++" has "++show (length arrs) ++" arr kids and "++ show @layoutList.nrOfChildren++ "kids") $ 
                                                                          map Just arrs ++ repeat (debug Err ("ERROR: old arr list of differing length accessed in RowP") Nothing)
                                      arr                              -> repeat Nothing
  | ColP 
      layoutList.oldArrList = case @lhs.oldArr of
                                      Just (ColA _ _ _ _ _ _ _ _ _ rows) -> 
                                        case @formatted of
                                          NF -> map Just rows -- rows not the right name in this case
                                                ++ repeat (debug Err ("ERROR: old arr list of differing length accessed in ColP NF") Nothing)
                                          F nrOfEltss ->
                                           let arrs = retrieveOldArrangements rows -- may be infinite
                                               breaks = tail (scanl (+) 0 nrOfEltss)
                                               maybeRows = linesFromBreaks breaks arrs
                                            in -- debug Arr ("breaks are "++ show breaks ++ "line lens:" ++ show (map length (init (linesFromBreaks breaks arrs)))) $ 
                                                (map Just $ makeDummyRows maybeRows)
                                                 ++ repeat (debug Err ("ERROR: old arr list of differing length accessed in ColP F") Nothing)
                                      _ -> repeat Nothing
--TODO!! Check that dummyrow is never used, and make annotation in source                                        
-- If the ColP came from a formatter, we take the old arrangements of the child rows, and distribute
-- them according to the new child distribution in new Rows.
  | FormatterP -- TODO add check for Nothing
      layoutList.oldArrList = case @lhs.oldArr of
                                      Just (ColA _ _ _ _ _ _ _ _ _ rows) -> 
                                        retrieveOldArrangements rows -- possibly infinite list is handled all right by oldArrList attribution rules
                                      Nothing -> repeat Nothing
  | OverlayP 
      layoutList.oldArrList = case @lhs.oldArr of 
                                      Just (OverlayA _ _ _ _ _ _ _ _ _ arrs) -> map Just arrs ++ repeat (debug Err ("ERROR:old arr list of differing length accessed in OverlayP") Nothing)
                                      arr                                    -> repeat Nothing
  | GraphP 
      layoutList.oldArrList = case @lhs.oldArr of
                                      Just (GraphA _ _ _ _ _ _ _ _ _ arrs) -> map Just arrs ++ repeat (debug Err ("ERROR:old arr list of differing length accessed in GraphP") Nothing)
                                      arr                                  -> repeat Nothing
  | VertexP 
      child.oldArr = case @lhs.oldArr of 
                       Just (VertexA _ _ _ _ _ _ _ _ _ arr) -> Just arr
                       arr                                  -> Nothing
  | StructuralP 
      child.oldArr = case @lhs.oldArr of
                       Just (StructuralA _ arr) -> Just arr
                       arr                      -> Nothing
  | ParsingP 
      child.oldArr = case @lhs.oldArr of
                       Just (ParsingA _ arr) -> Just arr
                       arr                   -> Nothing
  | LocatorP 
      child.oldArr = case @lhs.oldArr of
                       Just (LocatorA _ arr) -> Just arr
                       arr                   -> Nothing
  | TagP 
      child.oldArr = case @lhs.oldArr of
                       Just (TagA _ arr) -> Just arr
                       arr               -> Nothing
{
-- After encountering an unarranged row, just return Nothings
retrieveOldArrangements [] = []
retrieveOldArrangements (RowA _ _ _ _ _ _ _ _ elts : rows) = 
  map Just elts
  ++ retrieveOldArrangements rows
retrieveOldArrangements (PolyA _ _ _ _ _ _ _ _ _ _ _ _ _ : _) = repeat Nothing
retrieveOldArrangements (arr:_) = debug Err ("ArrangerAG: retrieveOldArrangements encountered something other than row or poly:"++shallowShowArr arr) $ repeat Nothing

-- create dummy rows for a list of lists of maybe arrangements. In case of Nothing, we put an unnarranged in the
-- row, so the attribution rule for oldArr will assign a Nothing to the attribute.
makeDummyRows [] = []
makeDummyRows (maybeRow:maybeRows) =
  RowA (IDA (-88)) 0 0 0 0 0 0 black 
    [ case mArr of 
        Nothing -> unarrangedA 0 0 0 0 0 0
        Just arr -> arr
    | mArr <- maybeRow
    ]
  : makeDummyRows maybeRows
{-
makeDummyRows [] = []
makeDummyRows (maybeRow:maybeRows) =
  (if all isJust maybeRow 
   then RowA (IDA (-88)) 0 0 0 0 0 0 black $ catMaybes maybeRow
   else debug Arr "Unarrangeable" unarrangedA 0 0 0 0 0 0)
  : makeDummyRows maybeRows
-}
}

SEM LayoutList [  oldArrList : {[Maybe (Arrangement node)]} | | ]
  | Cons 
      hd.oldArr     = head'  "ArrangerAG.LayoutList.hd.oldArr" @lhs.oldArrList
      tl.oldArrList = tail @lhs.oldArrList
 

ATTR LayoutList [  | |  arrangementList : {[Arrangement node]} ]
SEM LayoutList
  | Nil
      lhs.arrangementList = []
  | Cons 
      lhs.arrangementList = @hd.arrangement : @tl.arrangementList




-- rootPath and focus

SEM Root [ focusMinPath : Path focusMaxPath : Path | | ]
  | Root
      layout.focusMinPath = @lhs.focusMinPath
      layout.focusMaxPath = @lhs.focusMaxPath
      layout.rootPath = []
      layout.isFormattedRow = Nothing

SEM Layout [ rootPath : Path focusMinPath : Path focusMaxPath : Path | | ]
  | VertexP WithP StructuralP ParsingP LocatorP TagP
      child.rootPath = @lhs.rootPath ++ [0]
  | RowP ColP OverlayP GraphP FormatterP
      layoutList.rootPath = @lhs.rootPath
      layoutList.ix       = 0
            
ATTR LayoutList [ isFormattedCol : {Maybe [Int]} isFormattedRow : {Maybe Int} | | ]


SEM Layout
  | ColP
      layoutList.isFormattedCol = case @formatted of 
                                    F rowLengths -> Just $ init $ scanl (+)  0 $ rowLengths
                                    NF -> Nothing
  | RowP OverlayP GraphP FormatterP
      layoutList.isFormattedCol = Nothing

SEM Layout [ isFormattedRow : {Maybe Int} | | ]
  | RowP
      layoutList.isFormattedRow = @lhs.isFormattedRow 
  | ColP OverlayP GraphP FormatterP
      layoutList.isFormattedRow = Nothing

-- computation of rootPath has to take into account the Col [Row ..] structures created by Formatters,
-- since the path refers to the index in the original Formatter.
SEM LayoutList [ rootPath : Path focusMinPath : Path focusMaxPath : Path ix : Int | | ]
  | Cons
      hd.rootPath = if isJust @lhs.isFormattedCol 
                    then @lhs.rootPath
		    else case @lhs.isFormattedRow of
                           Just offset -> @lhs.rootPath ++ [offset + @lhs.ix]
                           Nothing -> @lhs.rootPath ++ [@lhs.ix]
      tl.ix       = @lhs.ix + 1
      hd.isFormattedRow = case @lhs.isFormattedCol of
                             Just rowLengths -> Just $ index "ArrangerAG.LayoutList.Cons.hd.formatterOffset" rowLengths @lhs.ix
                             Nothing -> Nothing