-- do not edit; automatically generated by UU.AG
module PresentationAG where

import CommonTypes
import PresLayerTypes
import PresLayerUtils

import XprezLib
import XLatex hiding (bold)

import DocumentEdit

import List
import Data.FiniteMap

import IOExts

import qualified Chess

pthFrmMsg :: HeliumMessage -> ([PathDoc], [PathDoc], [PathDoc])
pthFrmMsg (HError _ ps1 ps2 ps3) = (ps1, ps2, ps3)
pthFrmMsg _ = ([],[],[])

toMessage str = HError (lines str) [] [] []

-- if ps1 ++ ps2 ++ ps3 not null then head is link
presMessage :: HeliumMessage -> Presentation
presMessage (HError lns ps1 ps2 ps3) = case ps1++ps2++ps3 of []      -> col' (map (text' NoIDP) lns) `withColor` errColor
                                                             rng:_   -> col' (map (text' NoIDP) lns) `withColor` errColor
                                                                        `link` rng
presMessage (HMessage lns)           = col' (map (text' NoIDP) lns) `withColor` msgColor 

msgColor = blue
errColor = red


presentFocus NoPathD     path pres = pres
presentFocus (PathD pth) path pres = if pth==path then pres `withbgColor` lightBlue else pres

squiggleRanges (rngs1, rngs2, rngs3) pth pres =
  if (PathD pth) `elem` rngs1 then squiggly error1Color pres
  else if (PathD pth) `elem` rngs2 then pres -- squiggly error2Color pres
  else if (PathD pth) `elem` rngs3 then squiggly error3Color pres
  else pres
-- WX bitmap coloring is not ok yet, so squigglies are always red.
-- Until this is fixed, green squigglies are not shown

error1Color = red
error2Color = green
error3Color = red

link :: Xprez -> PathDoc -> Xprez
link xp NoPathD = xp
link xp path    = xp `withMouseDown` navigateTo path

navigateTo :: PathDoc -> UpdateDoc
navigateTo NoPathD = id
navigateTo (PathD pth) = (\(DocumentLevel d _ cl) -> DocumentLevel d (PathD pth) cl)


expand :: [Int] -> Decl -> UpdateDoc
expand pth (Decl idD idP0 idP1 idP2 idP3 expanded autoLayout ident exp) =
  \(DocumentLevel d path cl) ->
    let (DocumentLevel d' _ _) = editPasteD (DocumentLevel d (PathD pth) 
                                              (Clip_Decl (Decl idD idP0 idP1 idP2 idP3 True autoLayout ident exp))
                                            )
    in  (DocumentLevel d' path cl)

toggleExpanded :: [Int] -> Decl -> UpdateDoc
toggleExpanded pth (Decl idD idP0 idP1 idP2 idP3 expanded autoLayout ident exp) =
  \(DocumentLevel d path cl) ->
    let (DocumentLevel d' _ _) = editPasteD (DocumentLevel d (PathD pth) 
                                              (Clip_Decl (Decl idD idP0 idP1 idP2 idP3 (not expanded) autoLayout ident exp))
                                            )
    in  (DocumentLevel d' path cl)


toggleAutoLayout :: [Int] -> Decl -> UpdateDoc
toggleAutoLayout pth (Decl idD idP0 idP1 idP2 idP3 expanded autoLayout ident exp) =
  \(DocumentLevel d path cl) ->
    let (DocumentLevel d' _ _) = editPasteD (DocumentLevel d (PathD pth) 
                                              (Clip_Decl (Decl idD idP0 idP1 idP2 idP3 expanded (not autoLayout) ident exp))
                                            )
    in  (DocumentLevel d' path cl)




strFromIdent (Ident _ _ _ str) = str
strFromIdent _               = ""

idP0FromIdent (Ident _ idp0 _ str) = idp0
idP0FromIdent _                    = NoIDP

box xp = overlay [xp, poly [(0,0),(1,0),(1,1),(0,1),(0,0)],empty]
presHole focus typeStr nd pth = loc nd $ 
  structural $ row [text $ "{"++typeStr++"}"] `withColor` black `withbgColor` yellow `withFontFam` ("Courier New")
  
--  structural $ overlay [poly [(0,0),(1,0),(1,1),(0,1),(0,0)], text $ "{"++typeStr++"}"] `withColor` black `withbgColor` yellow `withFont'` ("Courier New", 10)
  
presParseErr node pres =
  loc node $ parsing $ pres {- $ overlay [ pres, poly [(0,0),(1,0),(1,1),(0,1),(0,0)] `withColor` red, empty ] -} `withbgColor` whiteSmoke
                                                                                     -- empty trick


row'  = RowP (NoIDP) 0 
col'  = ColP (NoIDP) 0
text' idc = StringP idc

der:: IDP -> String -> Xprez
der idc str = StringP idc str `withColor` derCol
 

op :: IDP -> String -> Xprez
op idc str = StringP idc str `withColor` opCol

key :: IDP -> String -> Xprez
key idc str = StringP idc str `withColor` keyCol

sep :: IDP -> String -> Xprez
sep idc str = StringP idc str `withColor` sepCol

cons :: IDP -> String -> Xprez
cons idc str = StringP idc str `withColor` consCol

typeD :: IDP -> String -> Xprez
typeD idc str = bold $ StringP idc str `withColor` typeDCol



derCol = green
opCol = black
keyCol = blue
sepCol = brown
consCol = black
typeDCol = purple --darkViolet
--idC = unsafePerformIO $ newIORef (0 :: Int)

--newIDP _ = IDP $ unsafePerformIO $ do {modifyIORef idC (+1); readIORef idC}




-- oparen pprec cprec = if pprec > cprec then [text "("] else []
-- cparen pprec cprec = if pprec > cprec then [text ")"] else []

addloc exp pth pres = loc (ExpNode exp pth)


idCounter = unsafePerformIO $ newIORef (0 :: Int)

-- needs a fresh arg to prevent sharing.
newIDP _ = IDP $ unsafePerformIO $ do {modifyIORef idCounter (+1); readIORef idCounter}


mkIDP NoIDP idC offset = IDP (idC + offset)
mkIDP id@(IDP _) _ _   = id


data TypeTree = TypeNode TypeInfo [TypeTree]  

data TypeInfo = TypeInfo String (Maybe String)

lookupType typeEnv path = case lookup (PathD path) typeEnv of 
                            Nothing -> "<no type>"  -- use Maybe here?
                            Just tp -> tp

type Bindings = [Binding]
type Binding = (String, Value)



data Value = BoolVal Bool
         | IntVal Int
         | LamVal (Value -> Value)
         | ListVal [Value]
         | ProdVal [Value]
         | ErrVal 

instance Show Value where
  show (BoolVal b) = show b
  show (IntVal i)  = show i
  show (LamVal _)  = "<function>"
  show (ListVal vs) = "[" ++ concat (intersperse ", " (map show vs)) ++ "]"
  show (ProdVal vs) = "(" ++ concat (intersperse ", " (map show vs)) ++ ")"
  show (ErrVal)   = "ERROR"
{-

evaluate :: Exp -> [(String, Val)] -> Val
evaluate (Lam ident exp) env =
evaluate (AppExp f a) env =   
-}
evaluateIntOp op (IntVal v1) (IntVal v2) = IntVal $ v1 `op` v2
evaluateIntOp _  _           _           = ErrVal



presentList []     = row' [sep NoIDP "  []"]
presentList (p:ps) = col' $  [ row' [sep NoIDP "  [ ", p ] ]
                          ++ [ row' [sep NoIDP "  , ", p]| p <- ps ]
                          ++ [ sep NoIDP "  ] "]

toggleViewType :: [Int] -> PPPresentation -> UpdateDoc
toggleViewType pth (PPPresentation idD viewtp slides) =
  \(DocumentLevel d path cl) ->
    let (DocumentLevel d' _ _) = editPasteD (DocumentLevel d (PathD pth) 
                                              (Clip_PPPresentation (PPPresentation idD (not viewtp) slides))
                                            )
    in  (DocumentLevel d' path cl)


itemStart i (Bullet _) = text' NoIDP "- "
itemStart i (Number _) = text' NoIDP (show (i+1) ++ ") ")
itemStart i (Alpha  _) = text' NoIDP (chr (ord 'a' + i):") ")

--addReductionPopupItems :: [ PopupItem ] -> Presentation -> Presentation
addReductionPopupItems its pres = addPopupItems pres its

pasteExp :: [Int] -> Exp -> UpdateDoc
pasteExp pth exp =
  \(DocumentLevel d path cl) ->
    let (DocumentLevel d' _ _) = editPasteD (DocumentLevel d (PathD pth) 
                                              (Clip_Exp exp)
                                            )
    in  (DocumentLevel d' path cl)


setIDPExp newIdp (PlusExp idd idp0 x1 x2)           = PlusExp idd newIdp x1 x2          
setIDPExp newIdp (TimesExp idd idp x1 x2)           = TimesExp idd newIdp x1 x2          
setIDPExp newIdp (DivExp idd idp0 x1 x2)            = DivExp idd idp0 x1 x2           
setIDPExp newIdp (PowerExp idd idp0 x1 x2)          = PowerExp idd newIdp x1 x2         
setIDPExp newIdp (BoolExp idd idp0 x1)              = BoolExp idd newIdp x1             
setIDPExp newIdp (IntExp idd idp0 x1)               = IntExp idd newIdp x1              
setIDPExp newIdp (CaseExp idd idp0 idp1 x1 x2)       = CaseExp idd newIdp idp1 x1 x2      
setIDPExp newIdp (LetExp idd idp0 idp1 dcls x2)     = LetExp idd newIdp idp1 dcls x2    
setIDPExp newIdp (LamExp idd idp0 idp1 x1 x2)       = LamExp idd newIdp idp1 x1 x2      
setIDPExp newIdp (AppExp idd x1 x2)                 = AppExp idd (setIDPExp newIdp x1) x2  -- has no pid of its own
setIDPExp newIdp (IdentExp idd x1)                  = IdentExp idd (setIDPIdent newIdp x1) -- has no pid of its own
setIDPExp newIdp (IfExp idd idp0 idp idp1 x1 x2 x3) = IfExp idd newIdp idp idp1 x1 x2 x3
setIDPExp newIdp (ParenExp idd idp0 idp1 x1)        = ParenExp idd newIdp idp1 x1    
setIDPExp newIdp (ListExp idd idp0 idp1 idps x1)    = ListExp idd newIdp idp1 idps x1
setIDPExp newIdp (ProductExp idd idp0 idp1 idps x1) = ProductExp idd newIdp idp1 idps x1
setIDPExp _   exp                                   = exp

setIDPIdent newIdp (Ident idd idp0 idp1 str) = Ident idd newIdp idp1 str

removeParens (ParenExp _ _ _ x1) = removeParens x1
removeParens exp                 = exp

ensureParens exp = ParenExp NoIDD NoIDP NoIDP (removeParens exp)
-- Alt ---------------------------------------------------------
{-
   inherited attributes:
      env                  : Bindings
      errs                 : [HeliumMessage]
      focusD               : FocusDoc
      ix                   : Int
      level                : Int
      path                 : [Int]
      ranges               : ([PathDoc],[PathDoc],[PathDoc])
      topLevelEnv          : [(String, String)]
      totalMaxLHSLength    : Int
      typeEnv              : [(PathDoc,String)]
      varsInScope          : FiniteMap String (PathDoc, String)

   chained attributes:
      col                  : Int
      idC                  : Int
      layoutMap            : LayoutMap
      newlines             : Int
      pIdC                 : IDPCounter
      spaces               : Int
      varsInScopeAtFocus   : FiniteMap String (PathDoc, String)

   synthesised attributes:
      alt                  : Binding
      lhsLength            : Int
      pres                 : Presentation
      self                 : Alt

-}
{-
   local variables for Alt.Alt:
      lhsLength
      self

-}
{-
   local variables for Alt.HoleAlt:
      self

-}
{-
   local variables for Alt.ParseErrAlt:
      self

-}
-- semantic domain
type T_Alt = (Int) ->
             (Bindings) ->
             ([HeliumMessage]) ->
             (FocusDoc) ->
             (Int) ->
             (Int) ->
             (LayoutMap) ->
             (Int) ->
             (Int) ->
             (IDPCounter) ->
             ([Int]) ->
             (([PathDoc],[PathDoc],[PathDoc])) ->
             (Int) ->
             ([(String, String)]) ->
             (Int) ->
             ([(PathDoc,String)]) ->
             (FiniteMap String (PathDoc, String)) ->
             (FiniteMap String (PathDoc, String)) ->
             ( (Binding),(Int),(Int),(LayoutMap),(Int),(Int),(IDPCounter),(Presentation),(Alt),(Int),(FiniteMap String (PathDoc, String)))
-- cata
sem_Alt :: (Alt) ->
           (T_Alt)
sem_Alt ((Alt (_idD) (_idP0) (_idP1) (_ident) (_exp))) =
    (sem_Alt_Alt (_idD) (_idP0) (_idP1) ((sem_Ident (_ident))) ((sem_Exp (_exp))))
sem_Alt ((HoleAlt )) =
    (sem_Alt_HoleAlt )
sem_Alt ((ParseErrAlt (_node) (_presentation))) =
    (sem_Alt_ParseErrAlt (_node) (_presentation))
sem_Alt_Alt :: (IDD) ->
               (IDP) ->
               (IDP) ->
               (T_Ident) ->
               (T_Exp) ->
               (T_Alt)
sem_Alt_Alt (_idD) (_idP0) (_idP1) (_ident) (_exp) (_lhs_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_idC) (_lhs_ix) (_lhs_layoutMap) (_lhs_level) (_lhs_newlines) (_lhs_pIdC) (_lhs_path) (_lhs_ranges) (_lhs_spaces) (_lhs_topLevelEnv) (_lhs_totalMaxLHSLength) (_lhs_typeEnv) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            Alt _idD _idP0 _idP1 _ident_self _exp_self
        (_lhsLength) =
            length $ strFromIdent _ident_self
        ( _ident_col,_ident_firstToken,_ident_idC,_ident_idsPres,_ident_layoutMap,_ident_newlines,_ident_pIdC,_ident_pres,_ident_self,_ident_spaces,_ident_str,_ident_varsInScopeAtFocus) =
            (_ident (_lhs_col) (_lhs_focusD) (_lhs_idC + 2) (addListToFM _lhs_layoutMap [(_idP0, (0,_lhs_totalMaxLHSLength - _lhsLength+1)), (_idP1, (0,0))]) (_lhs_level) (_lhs_newlines) (_lhs_pIdC) (_lhs_path++[0]) (_lhs_ranges) (_lhs_spaces) (_lhs_varsInScope) (if (PathD _lhs_path) == _lhs_focusD then _lhs_varsInScope else _lhs_varsInScopeAtFocus))
        ( _exp_col,_exp_idC,_exp_lamBody,_exp_layoutMap,_exp_newlines,_exp_pIdC,_exp_pres,_exp_self,_exp_spaces,_exp_substitute,_exp_type,_exp_val,_exp_varsInScopeAtFocus) =
            (_exp (_ident_col+ _lhs_totalMaxLHSLength - _lhsLength + 3) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_idC) (_ident_layoutMap) (_lhs_level) (0) (_ident_pIdC) (_lhs_path++[1]) (_lhs_ranges) (1) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_ident_varsInScopeAtFocus))
    in  ( (_ident_str, _exp_val)
         ,_lhs_col
         ,_exp_idC
         ,_exp_layoutMap
         ,_lhsLength
         ,1
         ,_exp_pIdC
         ,loc (AltNode _self _lhs_path) $ parsing $ presentFocus _lhs_focusD _lhs_path $
            squiggleRanges _lhs_ranges _lhs_path $
            row'  $ [ _ident_pres
                    , text' (mkIDP _idP0 _lhs_idC 0) "",
                             key NoIDP "®"    `withFontFam` "symbol"
                    , _exp_pres
                    , sep (mkIDP _idP1 _lhs_idC 1) ";"
                    ]
         ,_self
         ,_lhs_col
         ,_exp_varsInScopeAtFocus
         )
sem_Alt_HoleAlt :: (T_Alt)
sem_Alt_HoleAlt (_lhs_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_idC) (_lhs_ix) (_lhs_layoutMap) (_lhs_level) (_lhs_newlines) (_lhs_pIdC) (_lhs_path) (_lhs_ranges) (_lhs_spaces) (_lhs_topLevelEnv) (_lhs_totalMaxLHSLength) (_lhs_typeEnv) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            HoleAlt
    in  ( ("XXXXXX", ErrVal),_lhs_col,_lhs_idC,_lhs_layoutMap,0,_lhs_newlines,_lhs_pIdC,presHole _lhs_focusD "Alt" (AltNode _self _lhs_path) _lhs_path,_self,_lhs_spaces,_lhs_varsInScopeAtFocus)
sem_Alt_ParseErrAlt :: (Node) ->
                       (Presentation) ->
                       (T_Alt)
sem_Alt_ParseErrAlt (_node) (_presentation) (_lhs_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_idC) (_lhs_ix) (_lhs_layoutMap) (_lhs_level) (_lhs_newlines) (_lhs_pIdC) (_lhs_path) (_lhs_ranges) (_lhs_spaces) (_lhs_topLevelEnv) (_lhs_totalMaxLHSLength) (_lhs_typeEnv) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            ParseErrAlt _node _presentation
    in  ( ("XXXXXX", ErrVal),_lhs_col,_lhs_idC,_lhs_layoutMap,0,_lhs_newlines,_lhs_pIdC,presParseErr _node _presentation,_self,_lhs_spaces,_lhs_varsInScopeAtFocus)
-- Alts --------------------------------------------------------
{-
   inherited attributes:
      env                  : Bindings
      errs                 : [HeliumMessage]
      focusD               : FocusDoc
      ix                   : Int
      level                : Int
      ranges               : ([PathDoc],[PathDoc],[PathDoc])
      topLevelEnv          : [(String, String)]
      totalMaxLHSLength    : Int
      typeEnv              : [(PathDoc,String)]
      varsInScope          : FiniteMap String (PathDoc, String)

   chained attributes:
      col                  : Int
      idC                  : Int
      layoutMap            : LayoutMap
      newlines             : Int
      pIdC                 : IDPCounter
      path                 : [Int]
      spaces               : Int
      varsInScopeAtFocus   : FiniteMap String (PathDoc, String)

   synthesised attributes:
      alts                 : Bindings
      maxLHSLength         : Int
      press                : [Presentation]
      self                 : Alts

-}
{-
   local variables for Alts.ConsAlts:
      self

-}
{-
   local variables for Alts.HoleAlts:
      self

-}
{-
   local variables for Alts.NilAlts:
      self

-}
{-
   local variables for Alts.ParseErrAlts:
      self

-}
-- semantic domain
type T_Alts = (Int) ->
              (Bindings) ->
              ([HeliumMessage]) ->
              (FocusDoc) ->
              (Int) ->
              (Int) ->
              (LayoutMap) ->
              (Int) ->
              (Int) ->
              (IDPCounter) ->
              ([Int]) ->
              (([PathDoc],[PathDoc],[PathDoc])) ->
              (Int) ->
              ([(String, String)]) ->
              (Int) ->
              ([(PathDoc,String)]) ->
              (FiniteMap String (PathDoc, String)) ->
              (FiniteMap String (PathDoc, String)) ->
              ( (Bindings),(Int),(Int),(LayoutMap),(Int),(Int),(IDPCounter),([Int]),([Presentation]),(Alts),(Int),(FiniteMap String (PathDoc, String)))
-- cata
sem_Alts :: (Alts) ->
            (T_Alts)
sem_Alts ((ConsAlts (_iDD) (_alt) (_alts))) =
    (sem_Alts_ConsAlts (_iDD) ((sem_Alt (_alt))) ((sem_Alts (_alts))))
sem_Alts ((HoleAlts )) =
    (sem_Alts_HoleAlts )
sem_Alts ((NilAlts (_iDD))) =
    (sem_Alts_NilAlts (_iDD))
sem_Alts ((ParseErrAlts (_node) (_presentation))) =
    (sem_Alts_ParseErrAlts (_node) (_presentation))
sem_Alts_ConsAlts :: (IDD) ->
                     (T_Alt) ->
                     (T_Alts) ->
                     (T_Alts)
sem_Alts_ConsAlts (_iDD) (_alt) (_alts) (_lhs_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_idC) (_lhs_ix) (_lhs_layoutMap) (_lhs_level) (_lhs_newlines) (_lhs_pIdC) (_lhs_path) (_lhs_ranges) (_lhs_spaces) (_lhs_topLevelEnv) (_lhs_totalMaxLHSLength) (_lhs_typeEnv) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            ConsAlts _iDD _alt_self _alts_self
        ( _alt_alt,_alt_col,_alt_idC,_alt_layoutMap,_alt_lhsLength,_alt_newlines,_alt_pIdC,_alt_pres,_alt_self,_alt_spaces,_alt_varsInScopeAtFocus) =
            (_alt (_lhs_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_idC + 0) (_lhs_ix) (_lhs_layoutMap) (_lhs_level) (_lhs_newlines) (_lhs_pIdC) (_lhs_path++[_lhs_ix]) (_lhs_ranges) (_lhs_spaces) (_lhs_topLevelEnv) (_lhs_totalMaxLHSLength) (_lhs_typeEnv) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus))
        ( _alts_alts,_alts_col,_alts_idC,_alts_layoutMap,_alts_maxLHSLength,_alts_newlines,_alts_pIdC,_alts_path,_alts_press,_alts_self,_alts_spaces,_alts_varsInScopeAtFocus) =
            (_alts (_alt_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_alt_idC) (_lhs_ix + 1) (_alt_layoutMap) (_lhs_level) (_alt_newlines) (_alt_pIdC) (_lhs_path) (_lhs_ranges) (_alt_spaces) (_lhs_topLevelEnv) (_lhs_totalMaxLHSLength) (_lhs_typeEnv) (_lhs_varsInScope) (_alt_varsInScopeAtFocus))
    in  ( _alt_alt : _alts_alts,_alts_col,_alts_idC,_alts_layoutMap,_alt_lhsLength `max` _alts_maxLHSLength,_alts_newlines,_alts_pIdC,_lhs_path,_alt_pres : _alts_press,_self,_alts_spaces,_alts_varsInScopeAtFocus)
sem_Alts_HoleAlts :: (T_Alts)
sem_Alts_HoleAlts (_lhs_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_idC) (_lhs_ix) (_lhs_layoutMap) (_lhs_level) (_lhs_newlines) (_lhs_pIdC) (_lhs_path) (_lhs_ranges) (_lhs_spaces) (_lhs_topLevelEnv) (_lhs_totalMaxLHSLength) (_lhs_typeEnv) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            HoleAlts
    in  ( [],_lhs_col,_lhs_idC,_lhs_layoutMap,0,_lhs_newlines,_lhs_pIdC,_lhs_path,[presHole _lhs_focusD "Alts" (AltsNode _self _lhs_path) _lhs_path],_self,_lhs_spaces,_lhs_varsInScopeAtFocus)
sem_Alts_NilAlts :: (IDD) ->
                    (T_Alts)
sem_Alts_NilAlts (_iDD) (_lhs_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_idC) (_lhs_ix) (_lhs_layoutMap) (_lhs_level) (_lhs_newlines) (_lhs_pIdC) (_lhs_path) (_lhs_ranges) (_lhs_spaces) (_lhs_topLevelEnv) (_lhs_totalMaxLHSLength) (_lhs_typeEnv) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            NilAlts _iDD
    in  ( [],_lhs_col,_lhs_idC,_lhs_layoutMap,0,_lhs_newlines,_lhs_pIdC,_lhs_path,[],_self,_lhs_spaces,_lhs_varsInScopeAtFocus)
sem_Alts_ParseErrAlts :: (Node) ->
                         (Presentation) ->
                         (T_Alts)
sem_Alts_ParseErrAlts (_node) (_presentation) (_lhs_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_idC) (_lhs_ix) (_lhs_layoutMap) (_lhs_level) (_lhs_newlines) (_lhs_pIdC) (_lhs_path) (_lhs_ranges) (_lhs_spaces) (_lhs_topLevelEnv) (_lhs_totalMaxLHSLength) (_lhs_typeEnv) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            ParseErrAlts _node _presentation
    in  ( [],_lhs_col,_lhs_idC,_lhs_layoutMap,0,_lhs_newlines,_lhs_pIdC,_lhs_path,[presParseErr _node _presentation],_self,_lhs_spaces,_lhs_varsInScopeAtFocus)
-- Board -------------------------------------------------------
{-
   inherited attributes:
      focusD               : FocusDoc
      path                 : [Int]

   chained attributes:
      idC                  : Int

   synthesised attributes:
      pres                 : Presentation
      self                 : Board

-}
{-
   local variables for Board.Board:
      possibleMoves
      self

-}
-- semantic domain
type T_Board = (FocusDoc) ->
               (Int) ->
               ([Int]) ->
               ( (Int),(Presentation),(Board))
-- cata
sem_Board :: (Board) ->
             (T_Board)
sem_Board ((Board (_idD) (_r1) (_r2) (_r3) (_r4) (_r5) (_r6) (_r7) (_r8))) =
    (sem_Board_Board (_idD) ((sem_BoardRow (_r1))) ((sem_BoardRow (_r2))) ((sem_BoardRow (_r3))) ((sem_BoardRow (_r4))) ((sem_BoardRow (_r5))) ((sem_BoardRow (_r6))) ((sem_BoardRow (_r7))) ((sem_BoardRow (_r8))))
sem_Board_Board :: (IDD) ->
                   (T_BoardRow) ->
                   (T_BoardRow) ->
                   (T_BoardRow) ->
                   (T_BoardRow) ->
                   (T_BoardRow) ->
                   (T_BoardRow) ->
                   (T_BoardRow) ->
                   (T_BoardRow) ->
                   (T_Board)
sem_Board_Board (_idD) (_r1) (_r2) (_r3) (_r4) (_r5) (_r6) (_r7) (_r8) (_lhs_focusD) (_lhs_idC) (_lhs_path) =
    let (_self) =
            Board _idD _r1_self _r2_self _r3_self _r4_self _r5_self _r6_self _r7_self _r8_self
        (_possibleMoves) =
            case _r8_focusedPiece of
              Just (square, (r,c)) -> Chess.computeMoves _self (r,c)
              Nothing              -> []
        ( _r1_focusedPiece,_r1_idC,_r1_pres,_r1_rowNr,_r1_self,_r1_sqCol) =
            (_r1 (_lhs_focusD) (Nothing) (_lhs_idC) (_lhs_path++[0]) (_possibleMoves) (0) (False))
        ( _r2_focusedPiece,_r2_idC,_r2_pres,_r2_rowNr,_r2_self,_r2_sqCol) =
            (_r2 (_lhs_focusD) (_r1_focusedPiece) (_r1_idC) (_lhs_path++[1]) (_possibleMoves) (_r1_rowNr) (_r1_sqCol))
        ( _r3_focusedPiece,_r3_idC,_r3_pres,_r3_rowNr,_r3_self,_r3_sqCol) =
            (_r3 (_lhs_focusD) (_r2_focusedPiece) (_r2_idC) (_lhs_path++[2]) (_possibleMoves) (_r2_rowNr) (_r2_sqCol))
        ( _r4_focusedPiece,_r4_idC,_r4_pres,_r4_rowNr,_r4_self,_r4_sqCol) =
            (_r4 (_lhs_focusD) (_r3_focusedPiece) (_r3_idC) (_lhs_path++[3]) (_possibleMoves) (_r3_rowNr) (_r3_sqCol))
        ( _r5_focusedPiece,_r5_idC,_r5_pres,_r5_rowNr,_r5_self,_r5_sqCol) =
            (_r5 (_lhs_focusD) (_r4_focusedPiece) (_r4_idC) (_lhs_path++[4]) (_possibleMoves) (_r4_rowNr) (_r4_sqCol))
        ( _r6_focusedPiece,_r6_idC,_r6_pres,_r6_rowNr,_r6_self,_r6_sqCol) =
            (_r6 (_lhs_focusD) (_r5_focusedPiece) (_r5_idC) (_lhs_path++[5]) (_possibleMoves) (_r5_rowNr) (_r5_sqCol))
        ( _r7_focusedPiece,_r7_idC,_r7_pres,_r7_rowNr,_r7_self,_r7_sqCol) =
            (_r7 (_lhs_focusD) (_r6_focusedPiece) (_r6_idC) (_lhs_path++[6]) (_possibleMoves) (_r6_rowNr) (_r6_sqCol))
        ( _r8_focusedPiece,_r8_idC,_r8_pres,_r8_rowNr,_r8_self,_r8_sqCol) =
            (_r8 (_lhs_focusD) (_r7_focusedPiece) (_r7_idC) (_lhs_path++[7]) (_possibleMoves) (_r7_rowNr) (_r7_sqCol))
    in  ( _r8_idC
         ,loc (BoardNode _self _lhs_path) $ presentFocus _lhs_focusD _lhs_path $
            structural $ colR 4 (reverse [_r1_pres,_r2_pres,_r3_pres,_r4_pres,_r5_pres,_r6_pres,_r7_pres,_r8_pres])
         ,_self
         )
-- BoardRow ----------------------------------------------------
{-
   inherited attributes:
      focusD               : FocusDoc
      path                 : [Int]
      possibleMoves        : [(Int, Int)]

   chained attributes:
      focusedPiece         :  Maybe (BoardSquare,(Int,Int)) 
      idC                  : Int
      rowNr                : Int
      sqCol                : Bool

   synthesised attributes:
      pres                 : Presentation
      self                 : BoardRow

-}
{-
   local variables for BoardRow.BoardRow:
      self

-}
-- semantic domain
type T_BoardRow = (FocusDoc) ->
                  ( Maybe (BoardSquare,(Int,Int)) ) ->
                  (Int) ->
                  ([Int]) ->
                  ([(Int, Int)]) ->
                  (Int) ->
                  (Bool) ->
                  ( ( Maybe (BoardSquare,(Int,Int)) ),(Int),(Presentation),(Int),(BoardRow),(Bool))
-- cata
sem_BoardRow :: (BoardRow) ->
                (T_BoardRow)
sem_BoardRow ((BoardRow (_idD) (_ca) (_cb) (_cc) (_cd) (_ce) (_cf) (_cg) (_ch))) =
    (sem_BoardRow_BoardRow (_idD) ((sem_BoardSquare (_ca))) ((sem_BoardSquare (_cb))) ((sem_BoardSquare (_cc))) ((sem_BoardSquare (_cd))) ((sem_BoardSquare (_ce))) ((sem_BoardSquare (_cf))) ((sem_BoardSquare (_cg))) ((sem_BoardSquare (_ch))))
sem_BoardRow_BoardRow :: (IDD) ->
                         (T_BoardSquare) ->
                         (T_BoardSquare) ->
                         (T_BoardSquare) ->
                         (T_BoardSquare) ->
                         (T_BoardSquare) ->
                         (T_BoardSquare) ->
                         (T_BoardSquare) ->
                         (T_BoardSquare) ->
                         (T_BoardRow)
sem_BoardRow_BoardRow (_idD) (_ca) (_cb) (_cc) (_cd) (_ce) (_cf) (_cg) (_ch) (_lhs_focusD) (_lhs_focusedPiece) (_lhs_idC) (_lhs_path) (_lhs_possibleMoves) (_lhs_rowNr) (_lhs_sqCol) =
    let (_self) =
            BoardRow _idD _ca_self _cb_self _cc_self _cd_self _ce_self _cf_self _cg_self _ch_self
        ( _ca_colNr,_ca_focusedPiece,_ca_idC,_ca_pres,_ca_self,_ca_sqCol) =
            (_ca (0) (_lhs_focusD) (_lhs_focusedPiece) (_lhs_idC) (_lhs_path++[0]) (_lhs_possibleMoves) (_lhs_rowNr) (_lhs_sqCol))
        ( _cb_colNr,_cb_focusedPiece,_cb_idC,_cb_pres,_cb_self,_cb_sqCol) =
            (_cb (_ca_colNr) (_lhs_focusD) (_ca_focusedPiece) (_ca_idC) (_lhs_path++[1]) (_lhs_possibleMoves) (_lhs_rowNr) (_ca_sqCol))
        ( _cc_colNr,_cc_focusedPiece,_cc_idC,_cc_pres,_cc_self,_cc_sqCol) =
            (_cc (_cb_colNr) (_lhs_focusD) (_cb_focusedPiece) (_cb_idC) (_lhs_path++[2]) (_lhs_possibleMoves) (_lhs_rowNr) (_cb_sqCol))
        ( _cd_colNr,_cd_focusedPiece,_cd_idC,_cd_pres,_cd_self,_cd_sqCol) =
            (_cd (_cc_colNr) (_lhs_focusD) (_cc_focusedPiece) (_cc_idC) (_lhs_path++[3]) (_lhs_possibleMoves) (_lhs_rowNr) (_cc_sqCol))
        ( _ce_colNr,_ce_focusedPiece,_ce_idC,_ce_pres,_ce_self,_ce_sqCol) =
            (_ce (_cd_colNr) (_lhs_focusD) (_cd_focusedPiece) (_cd_idC) (_lhs_path++[4]) (_lhs_possibleMoves) (_lhs_rowNr) (_cd_sqCol))
        ( _cf_colNr,_cf_focusedPiece,_cf_idC,_cf_pres,_cf_self,_cf_sqCol) =
            (_cf (_ce_colNr) (_lhs_focusD) (_ce_focusedPiece) (_ce_idC) (_lhs_path++[5]) (_lhs_possibleMoves) (_lhs_rowNr) (_ce_sqCol))
        ( _cg_colNr,_cg_focusedPiece,_cg_idC,_cg_pres,_cg_self,_cg_sqCol) =
            (_cg (_cf_colNr) (_lhs_focusD) (_cf_focusedPiece) (_cf_idC) (_lhs_path++[6]) (_lhs_possibleMoves) (_lhs_rowNr) (_cf_sqCol))
        ( _ch_colNr,_ch_focusedPiece,_ch_idC,_ch_pres,_ch_self,_ch_sqCol) =
            (_ch (_cg_colNr) (_lhs_focusD) (_cg_focusedPiece) (_cg_idC) (_lhs_path++[7]) (_lhs_possibleMoves) (_lhs_rowNr) (_cg_sqCol))
    in  ( _ch_focusedPiece
         ,_ch_idC
         ,loc (BoardRowNode _self _lhs_path) $ presentFocus _lhs_focusD _lhs_path $
          structural $  row' [_ca_pres,_cb_pres,_cc_pres,_cd_pres,_ce_pres,_cf_pres,_cg_pres,_ch_pres]
         ,1 + _lhs_rowNr
         ,_self
         ,not _lhs_sqCol
         )
-- BoardSquare -------------------------------------------------
{-
   inherited attributes:
      focusD               : FocusDoc
      path                 : [Int]
      possibleMoves        : [(Int, Int)]
      rowNr                : Int

   chained attributes:
      colNr                : Int
      focusedPiece         :  Maybe (BoardSquare,(Int,Int)) 
      idC                  : Int
      sqCol                : Bool

   synthesised attributes:
      pres                 : Presentation
      self                 : BoardSquare

-}
{-
   local variables for BoardSquare.Bishop:
      self

-}
{-
   local variables for BoardSquare.Empty:
      self

-}
{-
   local variables for BoardSquare.King:
      self

-}
{-
   local variables for BoardSquare.Knight:
      self

-}
{-
   local variables for BoardSquare.Pawn:
      self

-}
{-
   local variables for BoardSquare.Queen:
      self

-}
{-
   local variables for BoardSquare.Rook:
      self

-}
-- semantic domain
type T_BoardSquare = (Int) ->
                     (FocusDoc) ->
                     ( Maybe (BoardSquare,(Int,Int)) ) ->
                     (Int) ->
                     ([Int]) ->
                     ([(Int, Int)]) ->
                     (Int) ->
                     (Bool) ->
                     ( (Int),( Maybe (BoardSquare,(Int,Int)) ),(Int),(Presentation),(BoardSquare),(Bool))
-- cata
sem_BoardSquare :: (BoardSquare) ->
                   (T_BoardSquare)
sem_BoardSquare ((Bishop (_idD) (_color))) =
    (sem_BoardSquare_Bishop (_idD) (_color))
sem_BoardSquare ((Empty )) =
    (sem_BoardSquare_Empty )
sem_BoardSquare ((King (_idD) (_color))) =
    (sem_BoardSquare_King (_idD) (_color))
sem_BoardSquare ((Knight (_idD) (_color))) =
    (sem_BoardSquare_Knight (_idD) (_color))
sem_BoardSquare ((Pawn (_idD) (_color))) =
    (sem_BoardSquare_Pawn (_idD) (_color))
sem_BoardSquare ((Queen (_idD) (_color))) =
    (sem_BoardSquare_Queen (_idD) (_color))
sem_BoardSquare ((Rook (_idD) (_color))) =
    (sem_BoardSquare_Rook (_idD) (_color))
sem_BoardSquare_Bishop :: (IDD) ->
                          (Bool) ->
                          (T_BoardSquare)
sem_BoardSquare_Bishop (_idD) (_color) (_lhs_colNr) (_lhs_focusD) (_lhs_focusedPiece) (_lhs_idC) (_lhs_path) (_lhs_possibleMoves) (_lhs_rowNr) (_lhs_sqCol) =
    let (_self) =
            Bishop _idD _color
    in  ( 1 + _lhs_colNr
         ,if (PathD _lhs_path) == _lhs_focusD then Just (_self, (_lhs_colNr,_lhs_rowNr)) else _lhs_focusedPiece
         ,_lhs_idC
         ,loc (BoardSquareNode _self _lhs_path) $
            structural $ Chess.piece _self _color _lhs_sqCol _lhs_rowNr _lhs_colNr _lhs_possibleMoves _lhs_focusD _lhs_path
         ,_self
         ,not _lhs_sqCol
         )
sem_BoardSquare_Empty :: (T_BoardSquare)
sem_BoardSquare_Empty (_lhs_colNr) (_lhs_focusD) (_lhs_focusedPiece) (_lhs_idC) (_lhs_path) (_lhs_possibleMoves) (_lhs_rowNr) (_lhs_sqCol) =
    let (_self) =
            Empty
    in  ( 1 + _lhs_colNr
         ,_lhs_focusedPiece
         ,_lhs_idC
         ,loc (BoardSquareNode _self _lhs_path) $
            structural $ Chess.piece _self False _lhs_sqCol _lhs_rowNr _lhs_colNr _lhs_possibleMoves _lhs_focusD _lhs_path
         ,_self
         ,not _lhs_sqCol
         )
sem_BoardSquare_King :: (IDD) ->
                        (Bool) ->
                        (T_BoardSquare)
sem_BoardSquare_King (_idD) (_color) (_lhs_colNr) (_lhs_focusD) (_lhs_focusedPiece) (_lhs_idC) (_lhs_path) (_lhs_possibleMoves) (_lhs_rowNr) (_lhs_sqCol) =
    let (_self) =
            King _idD _color
    in  ( 1 + _lhs_colNr
         ,if (PathD _lhs_path) == _lhs_focusD then Just (_self, (_lhs_colNr,_lhs_rowNr)) else _lhs_focusedPiece
         ,_lhs_idC
         ,loc (BoardSquareNode _self _lhs_path) $
            structural $ Chess.piece _self _color _lhs_sqCol _lhs_rowNr _lhs_colNr _lhs_possibleMoves _lhs_focusD _lhs_path
         ,_self
         ,not _lhs_sqCol
         )
sem_BoardSquare_Knight :: (IDD) ->
                          (Bool) ->
                          (T_BoardSquare)
sem_BoardSquare_Knight (_idD) (_color) (_lhs_colNr) (_lhs_focusD) (_lhs_focusedPiece) (_lhs_idC) (_lhs_path) (_lhs_possibleMoves) (_lhs_rowNr) (_lhs_sqCol) =
    let (_self) =
            Knight _idD _color
    in  ( 1 + _lhs_colNr
         ,if (PathD _lhs_path) == _lhs_focusD then Just (_self, (_lhs_colNr,_lhs_rowNr)) else _lhs_focusedPiece
         ,_lhs_idC
         ,loc (BoardSquareNode _self _lhs_path) $
            structural $ Chess.piece _self _color _lhs_sqCol _lhs_rowNr _lhs_colNr _lhs_possibleMoves _lhs_focusD _lhs_path
         ,_self
         ,not _lhs_sqCol
         )
sem_BoardSquare_Pawn :: (IDD) ->
                        (Bool) ->
                        (T_BoardSquare)
sem_BoardSquare_Pawn (_idD) (_color) (_lhs_colNr) (_lhs_focusD) (_lhs_focusedPiece) (_lhs_idC) (_lhs_path) (_lhs_possibleMoves) (_lhs_rowNr) (_lhs_sqCol) =
    let (_self) =
            Pawn _idD _color
    in  ( 1 + _lhs_colNr
         ,if (PathD _lhs_path) == _lhs_focusD then Just (_self, (_lhs_colNr,_lhs_rowNr)) else _lhs_focusedPiece
         ,_lhs_idC
         ,loc (BoardSquareNode _self _lhs_path) $
            structural $ Chess.piece _self _color _lhs_sqCol _lhs_rowNr _lhs_colNr _lhs_possibleMoves _lhs_focusD _lhs_path
         ,_self
         ,not _lhs_sqCol
         )
sem_BoardSquare_Queen :: (IDD) ->
                         (Bool) ->
                         (T_BoardSquare)
sem_BoardSquare_Queen (_idD) (_color) (_lhs_colNr) (_lhs_focusD) (_lhs_focusedPiece) (_lhs_idC) (_lhs_path) (_lhs_possibleMoves) (_lhs_rowNr) (_lhs_sqCol) =
    let (_self) =
            Queen _idD _color
    in  ( 1 + _lhs_colNr
         ,if (PathD _lhs_path) == _lhs_focusD then Just (_self, (_lhs_colNr,_lhs_rowNr)) else _lhs_focusedPiece
         ,_lhs_idC
         ,loc (BoardSquareNode _self _lhs_path) $
            structural $ Chess.piece _self _color _lhs_sqCol _lhs_rowNr _lhs_colNr _lhs_possibleMoves _lhs_focusD _lhs_path
         ,_self
         ,not _lhs_sqCol
         )
sem_BoardSquare_Rook :: (IDD) ->
                        (Bool) ->
                        (T_BoardSquare)
sem_BoardSquare_Rook (_idD) (_color) (_lhs_colNr) (_lhs_focusD) (_lhs_focusedPiece) (_lhs_idC) (_lhs_path) (_lhs_possibleMoves) (_lhs_rowNr) (_lhs_sqCol) =
    let (_self) =
            Rook _idD _color
    in  ( 1 + _lhs_colNr
         ,if (PathD _lhs_path) == _lhs_focusD then Just (_self, (_lhs_colNr,_lhs_rowNr)) else _lhs_focusedPiece
         ,_lhs_idC
         ,loc (BoardSquareNode _self _lhs_path) $
            structural $ Chess.piece _self _color _lhs_sqCol _lhs_rowNr _lhs_colNr _lhs_possibleMoves _lhs_focusD _lhs_path
         ,_self
         ,not _lhs_sqCol
         )
-- Decl --------------------------------------------------------
{-
   inherited attributes:
      env                  : Bindings
      errs                 : [HeliumMessage]
      focusD               : FocusDoc
      ix                   : Int
      level                : Int
      path                 : [Int]
      ranges               : ([PathDoc],[PathDoc],[PathDoc])
      topLevelEnv          : [(String, String)]
      typeEnv              : [(PathDoc,String)]
      varsInScope          : FiniteMap String (PathDoc, String)

   chained attributes:
      col                  : Int
      idC                  : Int
      layoutMap            : LayoutMap
      newlines             : Int
      pIdC                 : IDPCounter
      spaces               : Int
      varsInScopeAtFocus   : FiniteMap String (PathDoc, String)

   synthesised attributes:
      dcl                  : Binding
      declaredVars         : [(String,(PathDoc,String))]
      idsPres              : Presentation
      pres                 : Presentation
      self                 : Decl
      typeStr              : Maybe String

-}
{-
   local variables for Decl.BoardDecl:
      typeStr
      self

-}
{-
   local variables for Decl.Decl:
      typeStr
      self

-}
{-
   local variables for Decl.HoleDecl:
      typeStr
      self

-}
{-
   local variables for Decl.PPPresentationDecl:
      typeStr
      self

-}
{-
   local variables for Decl.ParseErrDecl:
      typeStr
      self

-}
-- semantic domain
type T_Decl = (Int) ->
              (Bindings) ->
              ([HeliumMessage]) ->
              (FocusDoc) ->
              (Int) ->
              (Int) ->
              (LayoutMap) ->
              (Int) ->
              (Int) ->
              (IDPCounter) ->
              ([Int]) ->
              (([PathDoc],[PathDoc],[PathDoc])) ->
              (Int) ->
              ([(String, String)]) ->
              ([(PathDoc,String)]) ->
              (FiniteMap String (PathDoc, String)) ->
              (FiniteMap String (PathDoc, String)) ->
              ( (Int),(Binding),([(String,(PathDoc,String))]),(Int),(Presentation),(LayoutMap),(Int),(IDPCounter),(Presentation),(Decl),(Int),(Maybe String),(FiniteMap String (PathDoc, String)))
-- cata
sem_Decl :: (Decl) ->
            (T_Decl)
sem_Decl ((BoardDecl (_idD) (_idP0) (_idP1) (_board))) =
    (sem_Decl_BoardDecl (_idD) (_idP0) (_idP1) ((sem_Board (_board))))
sem_Decl ((Decl (_idD) (_idP0) (_idP1) (_idP2) (_idP3) (_expanded) (_autoLayout) (_ident) (_exp))) =
    (sem_Decl_Decl (_idD) (_idP0) (_idP1) (_idP2) (_idP3) (_expanded) (_autoLayout) ((sem_Ident (_ident))) ((sem_Exp (_exp))))
sem_Decl ((HoleDecl )) =
    (sem_Decl_HoleDecl )
sem_Decl ((PPPresentationDecl (_idD) (_idP0) (_idP1) (_pPPresentation))) =
    (sem_Decl_PPPresentationDecl (_idD) (_idP0) (_idP1) ((sem_PPPresentation (_pPPresentation))))
sem_Decl ((ParseErrDecl (_node) (_presentation))) =
    (sem_Decl_ParseErrDecl (_node) (_presentation))
sem_Decl_BoardDecl :: (IDD) ->
                      (IDP) ->
                      (IDP) ->
                      (T_Board) ->
                      (T_Decl)
sem_Decl_BoardDecl (_idD) (_idP0) (_idP1) (_board) (_lhs_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_idC) (_lhs_ix) (_lhs_layoutMap) (_lhs_level) (_lhs_newlines) (_lhs_pIdC) (_lhs_path) (_lhs_ranges) (_lhs_spaces) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            BoardDecl _idD _idP0 _idP1 _board_self
        (_typeStr) =
            Nothing
        ( _board_idC,_board_pres,_board_self) =
            (_board (_lhs_focusD) (_lhs_idC) (_lhs_path++[0]))
    in  ( _lhs_col
         ,("XXXXXX", ErrVal)
         ,[]
         ,_lhs_idC + 1
         ,loc (DeclNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
            row' [ text "board;" ]
         ,_lhs_layoutMap
         ,_lhs_newlines
         ,_lhs_pIdC
         ,loc (DeclNode _self _lhs_path) $ parsing $ presentFocus _lhs_focusD _lhs_path $
            row' [text' (mkIDP _idP0 _lhs_idC 0) "Chess: ", _board_pres]
         ,_self
         ,_lhs_spaces
         ,_typeStr
         ,_lhs_varsInScopeAtFocus
         )
sem_Decl_Decl :: (IDD) ->
                 (IDP) ->
                 (IDP) ->
                 (IDP) ->
                 (IDP) ->
                 (Bool) ->
                 (Bool) ->
                 (T_Ident) ->
                 (T_Exp) ->
                 (T_Decl)
sem_Decl_Decl (_idD) (_idP0) (_idP1) (_idP2) (_idP3) (_expanded) (_autoLayout) (_ident) (_exp) (_lhs_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_idC) (_lhs_ix) (_lhs_layoutMap) (_lhs_level) (_lhs_newlines) (_lhs_pIdC) (_lhs_path) (_lhs_ranges) (_lhs_spaces) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            Decl _idD _idP0 _idP1 _idP2 _idP3 _expanded _autoLayout _ident_self _exp_self
        (_typeStr) =
            case lookup (strFromIdent _ident_self) _lhs_topLevelEnv of
              Nothing -> Nothing
              Just tp -> Just $ strFromIdent _ident_self ++ " :: "++ tp
        ( _ident_col,_ident_firstToken,_ident_idC,_ident_idsPres,_ident_layoutMap,_ident_newlines,_ident_pIdC,_ident_pres,_ident_self,_ident_spaces,_ident_str,_ident_varsInScopeAtFocus) =
            (_ident (_lhs_col) (_lhs_focusD) (_lhs_idC + 3) (addListToFM _lhs_layoutMap [(_idP0, (0,1)), (_idP1, (0,0))]) (_lhs_level) (_lhs_newlines) (_lhs_pIdC) (_lhs_path++[0]) (_lhs_ranges) (_lhs_spaces) (_lhs_varsInScope) (if (PathD _lhs_path) == _lhs_focusD then _lhs_varsInScope else _lhs_varsInScopeAtFocus))
        ( _exp_col,_exp_idC,_exp_lamBody,_exp_layoutMap,_exp_newlines,_exp_pIdC,_exp_pres,_exp_self,_exp_spaces,_exp_substitute,_exp_type,_exp_val,_exp_varsInScopeAtFocus) =
            (_exp (_ident_col+2+1) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_ident_idC) (_ident_layoutMap) (_lhs_level) (0) (_ident_pIdC) (_lhs_path++[1]) (_lhs_ranges) (1) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_ident_varsInScopeAtFocus))
    in  ( _lhs_col
         ,(_ident_str, _exp_val)
         ,[(strFromIdent _ident_self, (PathD (_lhs_path++[0]), _exp_type))]
         ,_exp_idC
         ,loc (DeclNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
            row' [ text "'", _ident_idsPres, text' NoIDP "';" ]
         ,let lm = if _autoLayout || _lhs_level /= 0 then _exp_layoutMap else _lhs_layoutMap
          in if _idP2 /= NoIDP || _lhs_level /= 0 then lm
             else case lookupFM lm (_ident_firstToken) of
                    Just (nwln,sp) -> addListToFM lm [ (mkIDP _idP2 _lhs_idC 2,(nwln,sp))
                                                                 , (_ident_firstToken, (1,sp)) ]
                    _        -> addToFM lm (mkIDP _idP2 _lhs_idC 2) (1,0)
         ,1
         ,_exp_pIdC
         ,loc (DeclNode _self _lhs_path) $ parsing $ presentFocus _lhs_focusD _lhs_path $
            squiggleRanges _lhs_ranges _lhs_path $
              (row' $
                 (if _lhs_level == 0
                  then let sigIDP    = mkIDP _idP2 _lhs_idC 2
                           autoLStr = if _autoLayout then "             {auto layout}" else ""
                       in  case _typeStr of
                             Nothing ->
                                case _exp_val of
                                        ErrVal -> [ StructuralP sigIDP $ row'
                                                     [text' NoIDP ("-- No value"++autoLStr)]
                                                       `withbgColor` lightGrey
                                                  ]
                                        v      -> [ StructuralP sigIDP $ row'
                                                     [text' NoIDP ("-- Value: " ++ show _exp_val++autoLStr )]
                                                       `withbgColor` lightGrey
                                                  ]
                             Just tpstr ->
                               [  StructuralP sigIDP . row' $
                                    [ typeD NoIDP (tpstr)
                                    , text " "
                                    , case _exp_val of
                                        ErrVal -> row' [text' NoIDP ("-- No value"++autoLStr)]
                                                           `withbgColor` lightGrey
                                        v      -> row' [ text' NoIDP ("-- Value: " ++ show _exp_val++autoLStr)]
                                                           `withbgColor` lightGrey
                                    ]
                               ]
                  else [empty])
                    ++
                       [ _ident_pres, key (mkIDP _idP0 _lhs_idC 0) "="]
                    ++ (if _expanded then
                          [ _exp_pres,  sep (mkIDP _idP1 _lhs_idC 1) ";"
                          ] else [text " ", box (text "...") `withColor` black `withbgColor` yellow
                                                             `withMouseDown` expand _lhs_path _self])
                   ) `addPopupItems`  [ if _expanded then ( "Collapse: "++strFromIdent _ident_self, toggleExpanded _lhs_path _self)
                                                     else ( "Expand: "++strFromIdent _ident_self, toggleExpanded _lhs_path _self)]
                     `addPopupItems`  if _lhs_level == 0 then [ if _autoLayout then ( "Disable Auto Layout", toggleAutoLayout _lhs_path _self)
                                                                               else ( "Enable Auto Layout", toggleAutoLayout _lhs_path _self) ]
                                                         else []
         ,_self
         ,_lhs_col
         ,_typeStr
         ,_exp_varsInScopeAtFocus
         )
sem_Decl_HoleDecl :: (T_Decl)
sem_Decl_HoleDecl (_lhs_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_idC) (_lhs_ix) (_lhs_layoutMap) (_lhs_level) (_lhs_newlines) (_lhs_pIdC) (_lhs_path) (_lhs_ranges) (_lhs_spaces) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            HoleDecl
        (_typeStr) =
            Nothing
    in  ( _lhs_col,("XXXXXX", ErrVal),[],_lhs_idC,presHole _lhs_focusD "Decl" (DeclNode _self _lhs_path) _lhs_path,_lhs_layoutMap,_lhs_newlines,_lhs_pIdC,presHole _lhs_focusD "Decl" (DeclNode _self _lhs_path) _lhs_path,_self,_lhs_spaces,_typeStr,_lhs_varsInScopeAtFocus)
sem_Decl_PPPresentationDecl :: (IDD) ->
                               (IDP) ->
                               (IDP) ->
                               (T_PPPresentation) ->
                               (T_Decl)
sem_Decl_PPPresentationDecl (_idD) (_idP0) (_idP1) (_pPPresentation) (_lhs_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_idC) (_lhs_ix) (_lhs_layoutMap) (_lhs_level) (_lhs_newlines) (_lhs_pIdC) (_lhs_path) (_lhs_ranges) (_lhs_spaces) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            PPPresentationDecl _idD _idP0 _idP1 _pPPresentation_self
        (_typeStr) =
            Nothing
        ( _pPPresentation_idC,_pPPresentation_pres,_pPPresentation_self,_pPPresentation_varsInScopeAtFocus) =
            (_pPPresentation (_lhs_focusD) (_lhs_idC) (_lhs_path++[0]) (_lhs_ranges) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus))
    in  ( _lhs_col
         ,("XXXXXX", ErrVal)
         ,[]
         ,_pPPresentation_idC
         ,loc (DeclNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
            row' [ text "slides;" ]
         ,_lhs_layoutMap
         ,_lhs_newlines
         ,_lhs_pIdC
         ,loc (DeclNode _self _lhs_path) $ parsing $ presentFocus _lhs_focusD _lhs_path $
            row' [ text' (mkIDP _idP0 _lhs_idC 0) "PPT: ", _pPPresentation_pres ]
         ,_self
         ,_lhs_spaces
         ,_typeStr
         ,_pPPresentation_varsInScopeAtFocus
         )
sem_Decl_ParseErrDecl :: (Node) ->
                         (Presentation) ->
                         (T_Decl)
sem_Decl_ParseErrDecl (_node) (_presentation) (_lhs_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_idC) (_lhs_ix) (_lhs_layoutMap) (_lhs_level) (_lhs_newlines) (_lhs_pIdC) (_lhs_path) (_lhs_ranges) (_lhs_spaces) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            ParseErrDecl _node _presentation
        (_typeStr) =
            Nothing
    in  ( _lhs_col,("XXXXXX", ErrVal),[],_lhs_idC,presParseErr _node _presentation,_lhs_layoutMap,_lhs_newlines,_lhs_pIdC,presParseErr _node _presentation,_self,_lhs_spaces,_typeStr,_lhs_varsInScopeAtFocus)
-- Decls -------------------------------------------------------
{-
   inherited attributes:
      env                  : Bindings
      errs                 : [HeliumMessage]
      focusD               : FocusDoc
      ix                   : Int
      level                : Int
      ranges               : ([PathDoc],[PathDoc],[PathDoc])
      topLevelEnv          : [(String, String)]
      typeEnv              : [(PathDoc,String)]
      varsInScope          : FiniteMap String (PathDoc, String)

   chained attributes:
      col                  : Int
      idC                  : Int
      layoutMap            : LayoutMap
      newlines             : Int
      pIdC                 : IDPCounter
      path                 : [Int]
      spaces               : Int
      varsInScopeAtFocus   : FiniteMap String (PathDoc, String)

   synthesised attributes:
      dcls                 : Bindings
      declaredVars         : [(String,(PathDoc,String))]
      idsPres              : Presentation
      parseErrs            : [String]
      press                : [Presentation]
      self                 : Decls

-}
{-
   local variables for Decls.ConsDecls:
      self

-}
{-
   local variables for Decls.HoleDecls:
      self

-}
{-
   local variables for Decls.NilDecls:
      self

-}
{-
   local variables for Decls.ParseErrDecls:
      self

-}
-- semantic domain
type T_Decls = (Int) ->
               (Bindings) ->
               ([HeliumMessage]) ->
               (FocusDoc) ->
               (Int) ->
               (Int) ->
               (LayoutMap) ->
               (Int) ->
               (Int) ->
               (IDPCounter) ->
               ([Int]) ->
               (([PathDoc],[PathDoc],[PathDoc])) ->
               (Int) ->
               ([(String, String)]) ->
               ([(PathDoc,String)]) ->
               (FiniteMap String (PathDoc, String)) ->
               (FiniteMap String (PathDoc, String)) ->
               ( (Int),(Bindings),([(String,(PathDoc,String))]),(Int),(Presentation),(LayoutMap),(Int),(IDPCounter),([String]),([Int]),([Presentation]),(Decls),(Int),(FiniteMap String (PathDoc, String)))
-- cata
sem_Decls :: (Decls) ->
             (T_Decls)
sem_Decls ((ConsDecls (_iDD) (_decl) (_decls))) =
    (sem_Decls_ConsDecls (_iDD) ((sem_Decl (_decl))) ((sem_Decls (_decls))))
sem_Decls ((HoleDecls )) =
    (sem_Decls_HoleDecls )
sem_Decls ((NilDecls (_iDD))) =
    (sem_Decls_NilDecls (_iDD))
sem_Decls ((ParseErrDecls (_node) (_presentation) (_parseErrs))) =
    (sem_Decls_ParseErrDecls (_node) (_presentation) (_parseErrs))
sem_Decls_ConsDecls :: (IDD) ->
                       (T_Decl) ->
                       (T_Decls) ->
                       (T_Decls)
sem_Decls_ConsDecls (_iDD) (_decl) (_decls) (_lhs_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_idC) (_lhs_ix) (_lhs_layoutMap) (_lhs_level) (_lhs_newlines) (_lhs_pIdC) (_lhs_path) (_lhs_ranges) (_lhs_spaces) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            ConsDecls _iDD _decl_self _decls_self
        ( _decl_col,_decl_dcl,_decl_declaredVars,_decl_idC,_decl_idsPres,_decl_layoutMap,_decl_newlines,_decl_pIdC,_decl_pres,_decl_self,_decl_spaces,_decl_typeStr,_decl_varsInScopeAtFocus) =
            (_decl (_lhs_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_idC + 0) (_lhs_ix) (_lhs_layoutMap) (_lhs_level) (_lhs_newlines) (_lhs_pIdC) (_lhs_path++[_lhs_ix]) (_lhs_ranges) (_lhs_spaces) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus))
        ( _decls_col,_decls_dcls,_decls_declaredVars,_decls_idC,_decls_idsPres,_decls_layoutMap,_decls_newlines,_decls_pIdC,_decls_parseErrs,_decls_path,_decls_press,_decls_self,_decls_spaces,_decls_varsInScopeAtFocus) =
            (_decls (_decl_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_decl_idC) (_lhs_ix + 1) (_decl_layoutMap) (_lhs_level) (_decl_newlines) (_decl_pIdC) (_lhs_path) (_lhs_ranges) (_decl_spaces) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_decl_varsInScopeAtFocus))
    in  ( _decls_col,_decl_dcl : _decls_dcls,_decl_declaredVars ++ _decls_declaredVars,_decls_idC,row' [ _decl_idsPres, text " ", _decls_idsPres ],_decls_layoutMap,_decls_newlines,_decls_pIdC,[],_lhs_path,_decl_pres : _decls_press,_self,_decls_spaces,_decls_varsInScopeAtFocus)
sem_Decls_HoleDecls :: (T_Decls)
sem_Decls_HoleDecls (_lhs_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_idC) (_lhs_ix) (_lhs_layoutMap) (_lhs_level) (_lhs_newlines) (_lhs_pIdC) (_lhs_path) (_lhs_ranges) (_lhs_spaces) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            HoleDecls
    in  ( _lhs_col,[],[],_lhs_idC,presHole _lhs_focusD "Decls" (DeclsNode _self _lhs_path) _lhs_path,_lhs_layoutMap,_lhs_newlines,_lhs_pIdC,[],_lhs_path,[presHole _lhs_focusD "Decls" (DeclsNode _self _lhs_path) _lhs_path],_self,_lhs_spaces,_lhs_varsInScopeAtFocus)
sem_Decls_NilDecls :: (IDD) ->
                      (T_Decls)
sem_Decls_NilDecls (_iDD) (_lhs_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_idC) (_lhs_ix) (_lhs_layoutMap) (_lhs_level) (_lhs_newlines) (_lhs_pIdC) (_lhs_path) (_lhs_ranges) (_lhs_spaces) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            NilDecls _iDD
    in  ( _lhs_col,[],[],_lhs_idC,empty,_lhs_layoutMap,_lhs_newlines,_lhs_pIdC,[],_lhs_path,[],_self,_lhs_spaces,_lhs_varsInScopeAtFocus)
sem_Decls_ParseErrDecls :: (Node) ->
                           (Presentation) ->
                           ([String]) ->
                           (T_Decls)
sem_Decls_ParseErrDecls (_node) (_presentation) (_parseErrs) (_lhs_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_idC) (_lhs_ix) (_lhs_layoutMap) (_lhs_level) (_lhs_newlines) (_lhs_pIdC) (_lhs_path) (_lhs_ranges) (_lhs_spaces) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            ParseErrDecls _node _presentation _parseErrs
    in  ( _lhs_col,[],[],_lhs_idC,empty,_lhs_layoutMap,_lhs_newlines,_lhs_pIdC,_parseErrs,_lhs_path,[presParseErr _node _presentation],_self,_lhs_spaces,_lhs_varsInScopeAtFocus)
-- EnrichedDoc -------------------------------------------------
{-
   inherited attributes:
      focusD               : FocusDoc

   chained attributes:
      layoutMap            : LayoutMap
      pIdC                 : IDPCounter

   synthesised attributes:
      pres                 : Presentation
      self                 : EnrichedDoc

-}
{-
   local variables for EnrichedDoc.HoleEnr:
      self

-}
{-
   local variables for EnrichedDoc.ParseErrEnr:
      self

-}
{-
   local variables for EnrichedDoc.RootEnr:
      varsInScope
      topLevelEnv
      typeEnv
      errs
      self

-}
-- semantic domain
type T_EnrichedDoc = (FocusDoc) ->
                     (LayoutMap) ->
                     (IDPCounter) ->
                     ( (LayoutMap),(IDPCounter),(Presentation),(EnrichedDoc))
-- cata
sem_EnrichedDoc :: (EnrichedDoc) ->
                   (T_EnrichedDoc)
sem_EnrichedDoc ((HoleEnr )) =
    (sem_EnrichedDoc_HoleEnr )
sem_EnrichedDoc ((ParseErrEnr (_node) (_presentation))) =
    (sem_EnrichedDoc_ParseErrEnr (_node) (_presentation))
sem_EnrichedDoc ((RootEnr (_id) (_idP) (_idListDecls) (_decls) (_heliumTypeInfo) (_document))) =
    (sem_EnrichedDoc_RootEnr (_id) (_idP) ((sem_Decls (_idListDecls))) ((sem_Decls (_decls))) (_heliumTypeInfo) (_document))
sem_EnrichedDoc_HoleEnr :: (T_EnrichedDoc)
sem_EnrichedDoc_HoleEnr (_lhs_focusD) (_lhs_layoutMap) (_lhs_pIdC) =
    let (_self) =
            HoleEnr
    in  ( _lhs_layoutMap,_lhs_pIdC,presHole _lhs_focusD "EnrichedDoc" (EnrNode _self []) [],_self)
sem_EnrichedDoc_ParseErrEnr :: (Node) ->
                               (Presentation) ->
                               (T_EnrichedDoc)
sem_EnrichedDoc_ParseErrEnr (_node) (_presentation) (_lhs_focusD) (_lhs_layoutMap) (_lhs_pIdC) =
    let (_self) =
            ParseErrEnr _node _presentation
    in  ( _lhs_layoutMap,_lhs_pIdC,presParseErr _node _presentation,_self)
sem_EnrichedDoc_RootEnr :: (IDD) ->
                           (IDP) ->
                           (T_Decls) ->
                           (T_Decls) ->
                           (HeliumTypeInfo) ->
                           (Document) ->
                           (T_EnrichedDoc)
sem_EnrichedDoc_RootEnr (_id) (_idP) (_idListDecls) (_decls) (_heliumTypeInfo) (_document) (_lhs_focusD) (_lhs_layoutMap) (_lhs_pIdC) =
    let (_self) =
            RootEnr _id _idP _idListDecls_self _decls_self _heliumTypeInfo _document
        (_errs) =
            let (errs, typeEnv, topLevelEnv) = _heliumTypeInfo in errs
        (_typeEnv) =
            let (errs, typeEnv, topLevelEnv) = _heliumTypeInfo in topLevelEnv
        (_topLevelEnv) =
            let (errs, typeEnv, topLevelEnv) = _heliumTypeInfo in typeEnv
        (_varsInScope) =
            listToFM _decls_declaredVars
        ( _idListDecls_col,_idListDecls_dcls,_idListDecls_declaredVars,_idListDecls_idC,_idListDecls_idsPres,_idListDecls_layoutMap,_idListDecls_newlines,_idListDecls_pIdC,_idListDecls_parseErrs,_idListDecls_path,_idListDecls_press,_idListDecls_self,_idListDecls_spaces,_idListDecls_varsInScopeAtFocus) =
            (_idListDecls (0) ([]) ([]) (_lhs_focusD) (1000) (0) (_lhs_layoutMap) (0) (0) (_lhs_pIdC) ([]) (([],[],[])) (0) (_topLevelEnv) (_typeEnv) (_varsInScope) (emptyFM))
        ( _decls_col,_decls_dcls,_decls_declaredVars,_decls_idC,_decls_idsPres,_decls_layoutMap,_decls_newlines,_decls_pIdC,_decls_parseErrs,_decls_path,_decls_press,_decls_self,_decls_spaces,_decls_varsInScopeAtFocus) =
            (_decls (0)
                    (_decls_dcls)
                    (_errs)
                    (_lhs_focusD)
                    (_idListDecls_idC)
                    (0)
                    (_idListDecls_layoutMap)
                    (0)
                    (1)
                    (_idListDecls_pIdC)
                    ([])
                    ((\(l1,l2,l3)->(concat l1, concat l2, concat l3)) . unzip3
                     $ map pthFrmMsg _errs)
                    (0)
                    (_topLevelEnv)
                    (_typeEnv)
                    (_varsInScope)
                    (emptyFM))
    in  ( _decls_layoutMap
         ,_decls_pIdC
         ,loc (DocNode _document []) $
          loc (EnrNode _self []) $ structural $
            col [ row' [ text $ "Document focus: "++show _lhs_focusD
                       , typeD NoIDP $ ( case lookup _lhs_focusD _typeEnv of
                                          Nothing -> ""
                                          Just tp -> " :: "++tp)
                                        ++ replicate 80 ' '
                       ]
                , vSpace 4
                , hLine
                , row' [ text "Top level identifiers:"
                       , loc (DeclsNode _idListDecls_self _idListDecls_path) $ parsing $ presentFocus _lhs_focusD _idListDecls_path $ row[ text " ", _idListDecls_idsPres] `withFontSize` 10
                       ]
                , vSpace 4
                , row' [key NoIDP "module ", bold $ text "Main" , key NoIDP " where"]
                , loc (DeclsNode _decls_self _decls_path) $ parsing $ presentFocus _lhs_focusD _decls_path $ row _decls_press
                , vSpace 10
                , hLine
                , vSpace 4
                , let errs = if null _decls_parseErrs then _errs else map toMessage _decls_parseErrs
                  in  col' (map presMessage errs ++ [empty]) `withFontSize` 12
                , vSpace 10
                , hLine
                , vSpace 4
                , text "Variables in scope:"
                , col [ typeD NoIDP (var++" :: "++tpStr) `link` pth
                      | (var,(pth,tpStr)) <- fmToList _decls_varsInScopeAtFocus ]
                ]
              `withFont'` ("Courier New",14)
         ,_self
         )
-- Exp ---------------------------------------------------------
{-
   inherited attributes:
      env                  : Bindings
      errs                 : [HeliumMessage]
      focusD               : FocusDoc
      level                : Int
      path                 : [Int]
      ranges               : ([PathDoc],[PathDoc],[PathDoc])
      topLevelEnv          : [(String, String)]
      typeEnv              : [(PathDoc,String)]
      varsInScope          : FiniteMap String (PathDoc, String)

   chained attributes:
      col                  : Int
      idC                  : Int
      layoutMap            : LayoutMap
      newlines             : Int
      pIdC                 : IDPCounter
      spaces               : Int
      varsInScopeAtFocus   : FiniteMap String (PathDoc, String)

   synthesised attributes:
      lamBody              : ([(String, Exp)] -> Exp)
      pres                 : Presentation
      self                 : Exp
      substitute           : ( [(String, Exp)] -> Exp )
      type                 : String
      val                  : Value

-}
{-
   local variables for Exp.AppExp:
      substitute
      reductionEdit
      type
      self

-}
{-
   local variables for Exp.BoolExp:
      substitute
      reductionEdit
      type
      self

-}
{-
   local variables for Exp.CaseExp:
      substitute
      reductionEdit
      type
      self

-}
{-
   local variables for Exp.DivExp:
      substitute
      reductionEdit
      type
      self

-}
{-
   local variables for Exp.HoleExp:
      substitute
      type
      self

-}
{-
   local variables for Exp.IdentExp:
      substitute
      reductionEdit
      type
      self

-}
{-
   local variables for Exp.IfExp:
      substitute
      reductionEdit
      type
      self

-}
{-
   local variables for Exp.IntExp:
      substitute
      reductionEdit
      type
      self

-}
{-
   local variables for Exp.LamExp:
      substitute
      reductionEdit
      type
      self

-}
{-
   local variables for Exp.LetExp:
      substitute
      reductionEdit
      type
      varsInScope
      self

-}
{-
   local variables for Exp.ListExp:
      substitute
      reductionEdit
      type
      self

-}
{-
   local variables for Exp.ParenExp:
      substitute
      reductionEdit
      type
      self

-}
{-
   local variables for Exp.ParseErrExp:
      substitute
      type
      self

-}
{-
   local variables for Exp.PlusExp:
      substitute
      reductionEdit
      type
      self

-}
{-
   local variables for Exp.PowerExp:
      substitute
      reductionEdit
      type
      self

-}
{-
   local variables for Exp.ProductExp:
      substitute
      reductionEdit
      type
      self

-}
{-
   local variables for Exp.TimesExp:
      substitute
      reductionEdit
      type
      self

-}
-- semantic domain
type T_Exp = (Int) ->
             (Bindings) ->
             ([HeliumMessage]) ->
             (FocusDoc) ->
             (Int) ->
             (LayoutMap) ->
             (Int) ->
             (Int) ->
             (IDPCounter) ->
             ([Int]) ->
             (([PathDoc],[PathDoc],[PathDoc])) ->
             (Int) ->
             ([(String, String)]) ->
             ([(PathDoc,String)]) ->
             (FiniteMap String (PathDoc, String)) ->
             (FiniteMap String (PathDoc, String)) ->
             ( (Int),(Int),(([(String, Exp)] -> Exp)),(LayoutMap),(Int),(IDPCounter),(Presentation),(Exp),(Int),(( [(String, Exp)] -> Exp )),(String),(Value),(FiniteMap String (PathDoc, String)))
-- cata
sem_Exp :: (Exp) ->
           (T_Exp)
sem_Exp ((AppExp (_iDD) (_exp1) (_exp2))) =
    (sem_Exp_AppExp (_iDD) ((sem_Exp (_exp1))) ((sem_Exp (_exp2))))
sem_Exp ((BoolExp (_idD) (_idP0) (_bool))) =
    (sem_Exp_BoolExp (_idD) (_idP0) (_bool))
sem_Exp ((CaseExp (_idD) (_idP0) (_idP1) (_exp) (_alts))) =
    (sem_Exp_CaseExp (_idD) (_idP0) (_idP1) ((sem_Exp (_exp))) ((sem_Alts (_alts))))
sem_Exp ((DivExp (_idD) (_idP0) (_exp1) (_exp2))) =
    (sem_Exp_DivExp (_idD) (_idP0) ((sem_Exp (_exp1))) ((sem_Exp (_exp2))))
sem_Exp ((HoleExp )) =
    (sem_Exp_HoleExp )
sem_Exp ((IdentExp (_iDD) (_ident))) =
    (sem_Exp_IdentExp (_iDD) ((sem_Ident (_ident))))
sem_Exp ((IfExp (_idD) (_idP0) (_idP1) (_idP2) (_exp1) (_exp2) (_exp3))) =
    (sem_Exp_IfExp (_idD) (_idP0) (_idP1) (_idP2) ((sem_Exp (_exp1))) ((sem_Exp (_exp2))) ((sem_Exp (_exp3))))
sem_Exp ((IntExp (_idD) (_idP0) (_int))) =
    (sem_Exp_IntExp (_idD) (_idP0) (_int))
sem_Exp ((LamExp (_idD) (_idP0) (_idP1) (_ident) (_exp))) =
    (sem_Exp_LamExp (_idD) (_idP0) (_idP1) ((sem_Ident (_ident))) ((sem_Exp (_exp))))
sem_Exp ((LetExp (_idD) (_idP0) (_idP1) (_decls) (_exp))) =
    (sem_Exp_LetExp (_idD) (_idP0) (_idP1) ((sem_Decls (_decls))) ((sem_Exp (_exp))))
sem_Exp ((ListExp (_idD) (_idP0) (_idP1) (_ids) (_exps))) =
    (sem_Exp_ListExp (_idD) (_idP0) (_idP1) (_ids) ((sem_Exps (_exps))))
sem_Exp ((ParenExp (_idD) (_idP0) (_idP1) (_exp))) =
    (sem_Exp_ParenExp (_idD) (_idP0) (_idP1) ((sem_Exp (_exp))))
sem_Exp ((ParseErrExp (_node) (_presentation))) =
    (sem_Exp_ParseErrExp (_node) (_presentation))
sem_Exp ((PlusExp (_idD) (_idP0) (_exp1) (_exp2))) =
    (sem_Exp_PlusExp (_idD) (_idP0) ((sem_Exp (_exp1))) ((sem_Exp (_exp2))))
sem_Exp ((PowerExp (_idD) (_idP0) (_exp1) (_exp2))) =
    (sem_Exp_PowerExp (_idD) (_idP0) ((sem_Exp (_exp1))) ((sem_Exp (_exp2))))
sem_Exp ((ProductExp (_idD) (_idP0) (_idP1) (_ids) (_exps))) =
    (sem_Exp_ProductExp (_idD) (_idP0) (_idP1) (_ids) ((sem_Exps (_exps))))
sem_Exp ((TimesExp (_idD) (_idP0) (_exp1) (_exp2))) =
    (sem_Exp_TimesExp (_idD) (_idP0) ((sem_Exp (_exp1))) ((sem_Exp (_exp2))))
sem_Exp_AppExp :: (IDD) ->
                  (T_Exp) ->
                  (T_Exp) ->
                  (T_Exp)
sem_Exp_AppExp (_iDD) (_exp1) (_exp2) (_lhs_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_idC) (_lhs_layoutMap) (_lhs_level) (_lhs_newlines) (_lhs_pIdC) (_lhs_path) (_lhs_ranges) (_lhs_spaces) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            AppExp _iDD _exp1_self _exp2_self
        (_type) =
            lookupType _lhs_typeEnv _lhs_path
        (_reductionEdit) =
            case removeParens _exp1_self of
                    LamExp _ _ _ ident exp -> [ ("Beta reduce",
                                                 pasteExp _lhs_path
                                                          (ensureParens (_exp1_lamBody [(strFromIdent ident, _exp2_self)] ))
                                                )
                                              ]
                    _                      -> []
        (_substitute) =
            \substs -> AppExp _iDD (_exp1_substitute substs) (_exp2_substitute substs)
        ( _exp1_col,_exp1_idC,_exp1_lamBody,_exp1_layoutMap,_exp1_newlines,_exp1_pIdC,_exp1_pres,_exp1_self,_exp1_spaces,_exp1_substitute,_exp1_type,_exp1_val,_exp1_varsInScopeAtFocus) =
            (_exp1 (_lhs_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_idC + 0) (_lhs_layoutMap) (_lhs_level) (_lhs_newlines) (_lhs_pIdC) (_lhs_path++[0]) (_lhs_ranges) (_lhs_spaces) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (if (PathD _lhs_path) == _lhs_focusD then _lhs_varsInScope else _lhs_varsInScopeAtFocus))
        ( _exp2_col,_exp2_idC,_exp2_lamBody,_exp2_layoutMap,_exp2_newlines,_exp2_pIdC,_exp2_pres,_exp2_self,_exp2_spaces,_exp2_substitute,_exp2_type,_exp2_val,_exp2_varsInScopeAtFocus) =
            (_exp2 (_exp1_col+1) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_exp1_idC) (_exp1_layoutMap) (_lhs_level) (0) (_exp1_pIdC) (_lhs_path++[1]) (_lhs_ranges) (1) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_exp1_varsInScopeAtFocus))
    in  ( _lhs_col
         ,_exp2_idC
         ,_substitute
         ,_exp2_layoutMap
         ,_exp2_newlines
         ,_exp2_pIdC
         ,loc (ExpNode _self _lhs_path) $ parsing $ presentFocus _lhs_focusD _lhs_path $
            squiggleRanges _lhs_ranges _lhs_path $ addReductionPopupItems _reductionEdit $
            row' [_exp1_pres, _exp2_pres]
         ,_self
         ,_exp2_spaces
         ,_substitute
         ,_type
         ,case _exp1_val of LamVal f -> f _exp2_val
                            _        -> ErrVal
         ,_exp2_varsInScopeAtFocus
         )
sem_Exp_BoolExp :: (IDD) ->
                   (IDP) ->
                   (Bool) ->
                   (T_Exp)
sem_Exp_BoolExp (_idD) (_idP0) (_bool) (_lhs_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_idC) (_lhs_layoutMap) (_lhs_level) (_lhs_newlines) (_lhs_pIdC) (_lhs_path) (_lhs_ranges) (_lhs_spaces) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            BoolExp _idD _idP0 _bool
        (_type) =
            lookupType _lhs_typeEnv _lhs_path
        (_reductionEdit) =
            []
        (_substitute) =
            \substs -> _self
    in  ( _lhs_col
         ,_lhs_idC
         ,_substitute
         ,addToFM _lhs_layoutMap _idP0 (_lhs_newlines,_lhs_spaces)
         ,_lhs_newlines
         ,_lhs_pIdC
         ,loc (ExpNode _self _lhs_path) $ parsing $ presentFocus _lhs_focusD _lhs_path $
            squiggleRanges _lhs_ranges _lhs_path $ addReductionPopupItems _reductionEdit $
            row' [cons (mkIDP _idP0 _lhs_idC 0) (show _bool), text' NoIDP ""]
         ,_self
         ,_lhs_spaces
         ,_substitute
         ,_type
         ,BoolVal _bool
         ,if (PathD _lhs_path) == _lhs_focusD then _lhs_varsInScope else _lhs_varsInScopeAtFocus
         )
sem_Exp_CaseExp :: (IDD) ->
                   (IDP) ->
                   (IDP) ->
                   (T_Exp) ->
                   (T_Alts) ->
                   (T_Exp)
sem_Exp_CaseExp (_idD) (_idP0) (_idP1) (_exp) (_alts) (_lhs_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_idC) (_lhs_layoutMap) (_lhs_level) (_lhs_newlines) (_lhs_pIdC) (_lhs_path) (_lhs_ranges) (_lhs_spaces) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            CaseExp _idD _idP0 _idP1 _exp_self _alts_self
        (_type) =
            lookupType _lhs_typeEnv _lhs_path
        (_reductionEdit) =
            []
        (_substitute) =
            \substs -> _self
        ( _exp_col,_exp_idC,_exp_lamBody,_exp_layoutMap,_exp_newlines,_exp_pIdC,_exp_pres,_exp_self,_exp_spaces,_exp_substitute,_exp_type,_exp_val,_exp_varsInScopeAtFocus) =
            (_exp (_lhs_col + 5)
                  (_lhs_env)
                  (_lhs_errs)
                  (_lhs_focusD)
                  (_lhs_idC + 2)
                  (addListToFM _lhs_layoutMap
                       [ (_idP0, (_lhs_newlines,_lhs_spaces))
                       , (_idP1, (0,1)) ])
                  (_lhs_level)
                  (0)
                  (_lhs_pIdC)
                  (_lhs_path++[0])
                  (_lhs_ranges)
                  (1)
                  (_lhs_topLevelEnv)
                  (_lhs_typeEnv)
                  (_lhs_varsInScope)
                  (_lhs_varsInScopeAtFocus))
        ( _alts_alts,_alts_col,_alts_idC,_alts_layoutMap,_alts_maxLHSLength,_alts_newlines,_alts_pIdC,_alts_path,_alts_press,_alts_self,_alts_spaces,_alts_varsInScopeAtFocus) =
            (_alts (_lhs_col + 2) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_exp_idC) (0) (_exp_layoutMap) (_lhs_level) (1) (_exp_pIdC) (_lhs_path++[1]) (_lhs_ranges) (_lhs_col + 2) (_lhs_topLevelEnv) (_alts_maxLHSLength) (_lhs_typeEnv) (_lhs_varsInScope) (if (PathD _lhs_path) == _lhs_focusD then _lhs_varsInScope else _lhs_varsInScopeAtFocus))
    in  ( _alts_col
         ,_alts_idC
         ,_substitute
         ,_alts_layoutMap
         ,_alts_newlines
         ,_alts_pIdC
         ,loc (ExpNode _self _lhs_path) $ parsing $ presentFocus _lhs_focusD _lhs_path $
            squiggleRanges _lhs_ranges _lhs_path $ addReductionPopupItems _reductionEdit $
            row' [ key (mkIDP _idP0 _lhs_idC 0) "case"
                 , _exp_pres
                 , key (mkIDP _idP1 _lhs_idC 1) "of"
                 , loc (AltsNode _alts_self _alts_path) $ parsing $ presentFocus _lhs_focusD _alts_path $ row _alts_press
                 ]
         ,_self
         ,_alts_spaces
         ,_substitute
         ,_type
         ,case lookup "a" _alts_alts of {Just v -> v; Nothing -> ErrVal}
         ,_alts_varsInScopeAtFocus
         )
sem_Exp_DivExp :: (IDD) ->
                  (IDP) ->
                  (T_Exp) ->
                  (T_Exp) ->
                  (T_Exp)
sem_Exp_DivExp (_idD) (_idP0) (_exp1) (_exp2) (_lhs_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_idC) (_lhs_layoutMap) (_lhs_level) (_lhs_newlines) (_lhs_pIdC) (_lhs_path) (_lhs_ranges) (_lhs_spaces) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            DivExp _idD _idP0 _exp1_self _exp2_self
        (_type) =
            lookupType _lhs_typeEnv _lhs_path
        (_reductionEdit) =
            case (removeParens _exp1_self, removeParens _exp2_self) of
                   (IntExp idd1 idp1 int1, IntExp _ _ int2 ) -> [ ("Reduce primitive div" ,  pasteExp _lhs_path (IntExp idd1 idp1 (int1 `div` int2)))]
                   _                                         -> []
        (_substitute) =
            \substs -> DivExp _idD _idP0 (_exp1_substitute substs) (_exp2_substitute substs)
        ( _exp1_col,_exp1_idC,_exp1_lamBody,_exp1_layoutMap,_exp1_newlines,_exp1_pIdC,_exp1_pres,_exp1_self,_exp1_spaces,_exp1_substitute,_exp1_type,_exp1_val,_exp1_varsInScopeAtFocus) =
            (_exp1 (0) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_idC + 1) (addToFM _lhs_layoutMap _idP0 (0,0)) (_lhs_level) (0) (_lhs_pIdC) (_lhs_path++[0]) (_lhs_ranges) (0) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (if (PathD _lhs_path) == _lhs_focusD then _lhs_varsInScope else _lhs_varsInScopeAtFocus))
        ( _exp2_col,_exp2_idC,_exp2_lamBody,_exp2_layoutMap,_exp2_newlines,_exp2_pIdC,_exp2_pres,_exp2_self,_exp2_spaces,_exp2_substitute,_exp2_type,_exp2_val,_exp2_varsInScopeAtFocus) =
            (_exp2 (0) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_exp1_idC) (_exp1_layoutMap) (_lhs_level) (0) (_exp1_pIdC) (_lhs_path++[1]) (_lhs_ranges) (0) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_exp1_varsInScopeAtFocus))
    in  ( _exp1_col
         ,_exp2_idC
         ,_substitute
         ,_exp2_layoutMap
         ,_exp2_newlines
         ,_exp2_pIdC
         ,loc (ExpNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
            squiggleRanges _lhs_ranges _lhs_path $ addReductionPopupItems _reductionEdit $
            frac _exp1_pres _exp2_pres
         ,_self
         ,_exp2_spaces
         ,_substitute
         ,_type
         ,evaluateIntOp div _exp1_val _exp2_val
         ,_exp2_varsInScopeAtFocus
         )
sem_Exp_HoleExp :: (T_Exp)
sem_Exp_HoleExp (_lhs_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_idC) (_lhs_layoutMap) (_lhs_level) (_lhs_newlines) (_lhs_pIdC) (_lhs_path) (_lhs_ranges) (_lhs_spaces) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            HoleExp
        (_type) =
            "<Hole>"
        (_substitute) =
            \substs -> _self
    in  ( _lhs_col,_lhs_idC,_substitute,_lhs_layoutMap,_lhs_newlines,_lhs_pIdC,presHole _lhs_focusD "Exp" (ExpNode _self _lhs_path) _lhs_path,_self,_lhs_spaces,_substitute,_type,ErrVal,_lhs_varsInScopeAtFocus)
sem_Exp_IdentExp :: (IDD) ->
                    (T_Ident) ->
                    (T_Exp)
sem_Exp_IdentExp (_iDD) (_ident) (_lhs_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_idC) (_lhs_layoutMap) (_lhs_level) (_lhs_newlines) (_lhs_pIdC) (_lhs_path) (_lhs_ranges) (_lhs_spaces) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            IdentExp _iDD _ident_self
        (_type) =
            lookupType _lhs_typeEnv _lhs_path
        (_reductionEdit) =
            case lookupFM  _lhs_varsInScope (strFromIdent _ident_self) of
              Nothing      -> []
              Just (PathD pth@(_:_),_) ->
                [( "Replace by definition"
                 , \(DocumentLevel d path cl) ->
                   case selectD (init pth) d of
                     (Clip_Decl (Decl idD idP0 idP1 idP2 idP3 _ _ _ exp)) ->
                           let (DocumentLevel d' _ _) =
                                 editPasteD (DocumentLevel d (PathD _lhs_path) (Clip_Exp ( setIDPExp (idP0FromIdent _ident_self) $ ensureParens exp)))
                           in  (DocumentLevel d' path cl)
                     _ -> (DocumentLevel d path cl)
                 )]
        (_substitute) =
            \substs -> case lookup (strFromIdent _ident_self) substs of
                               Just exp -> exp
                               Nothing  -> _self
        ( _ident_col,_ident_firstToken,_ident_idC,_ident_idsPres,_ident_layoutMap,_ident_newlines,_ident_pIdC,_ident_pres,_ident_self,_ident_spaces,_ident_str,_ident_varsInScopeAtFocus) =
            (_ident (_lhs_col) (_lhs_focusD) (_lhs_idC + 2) (_lhs_layoutMap) (_lhs_level) (_lhs_newlines) (_lhs_pIdC) (_lhs_path++[0]) (_lhs_ranges) (_lhs_spaces) (_lhs_varsInScope) (if (PathD _lhs_path) == _lhs_focusD then _lhs_varsInScope else _lhs_varsInScopeAtFocus))
    in  ( _ident_col
         ,_ident_idC
         ,_substitute
         ,_ident_layoutMap
         ,_ident_newlines
         ,_ident_pIdC
         ,loc (ExpNode _self _lhs_path) $ parsing $ presentFocus _lhs_focusD _lhs_path $
            squiggleRanges _lhs_ranges _lhs_path $ addReductionPopupItems _reductionEdit $
              _ident_pres
                `addPopupItems`
                [( "Jump to declaration of "++show (strFromIdent _ident_self),
                      navigateTo $ case lookupFM  _lhs_varsInScope (strFromIdent _ident_self) of
                                     Nothing      -> NoPathD
                                     Just (pth,_) -> pth)]
         ,_self
         ,_ident_spaces
         ,_substitute
         ,_type
         ,case lookup _ident_str _lhs_env of { Just v -> v; Nothing -> ErrVal }
         ,_ident_varsInScopeAtFocus
         )
sem_Exp_IfExp :: (IDD) ->
                 (IDP) ->
                 (IDP) ->
                 (IDP) ->
                 (T_Exp) ->
                 (T_Exp) ->
                 (T_Exp) ->
                 (T_Exp)
sem_Exp_IfExp (_idD) (_idP0) (_idP1) (_idP2) (_exp1) (_exp2) (_exp3) (_lhs_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_idC) (_lhs_layoutMap) (_lhs_level) (_lhs_newlines) (_lhs_pIdC) (_lhs_path) (_lhs_ranges) (_lhs_spaces) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            IfExp _idD _idP0 _idP1 _idP2 _exp1_self _exp2_self _exp3_self
        (_type) =
            lookupType _lhs_typeEnv _lhs_path
        (_reductionEdit) =
            case removeParens _exp1_self of
                   BoolExp _ _ bool -> [ ("Reduce primitive if" , pasteExp _lhs_path (if bool then setIDPExp _idP0 _exp2_self
                                                                             else setIDPExp _idP0 _exp3_self))]
                   _                                         -> []
        (_substitute) =
            \substs -> IfExp _idD _idP0 _idP1 _idP2 (_exp1_substitute substs) (_exp2_substitute substs) (_exp3_substitute substs)
        ( _exp1_col,_exp1_idC,_exp1_lamBody,_exp1_layoutMap,_exp1_newlines,_exp1_pIdC,_exp1_pres,_exp1_self,_exp1_spaces,_exp1_substitute,_exp1_type,_exp1_val,_exp1_varsInScopeAtFocus) =
            (_exp1 (_lhs_col + 2+1)
                   (_lhs_env)
                   (_lhs_errs)
                   (_lhs_focusD)
                   (_lhs_idC + 3)
                   (addListToFM _lhs_layoutMap
                      [ (_idP0, (_lhs_newlines,_lhs_spaces))
                      , (_idP1, (1,_lhs_col))
                      , (_idP2, (1,_lhs_col)) ])
                   (_lhs_level)
                   (0)
                   (_lhs_pIdC)
                   (_lhs_path++[0])
                   (_lhs_ranges)
                   (1)
                   (_lhs_topLevelEnv)
                   (_lhs_typeEnv)
                   (_lhs_varsInScope)
                   (if (PathD _lhs_path) == _lhs_focusD then _lhs_varsInScope else _lhs_varsInScopeAtFocus))
        ( _exp2_col,_exp2_idC,_exp2_lamBody,_exp2_layoutMap,_exp2_newlines,_exp2_pIdC,_exp2_pres,_exp2_self,_exp2_spaces,_exp2_substitute,_exp2_type,_exp2_val,_exp2_varsInScopeAtFocus) =
            (_exp2 (_lhs_col + 4+1) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_exp1_idC) (_exp1_layoutMap) (_lhs_level) (0) (_exp1_pIdC) (_lhs_path++[1]) (_lhs_ranges) (1) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_exp1_varsInScopeAtFocus))
        ( _exp3_col,_exp3_idC,_exp3_lamBody,_exp3_layoutMap,_exp3_newlines,_exp3_pIdC,_exp3_pres,_exp3_self,_exp3_spaces,_exp3_substitute,_exp3_type,_exp3_val,_exp3_varsInScopeAtFocus) =
            (_exp3 (_lhs_col + 4+1) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_exp2_idC) (_exp2_layoutMap) (_lhs_level) (0) (_exp2_pIdC) (_lhs_path++[2]) (_lhs_ranges) (1) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_exp2_varsInScopeAtFocus))
    in  ( _exp3_col
         ,_exp3_idC
         ,_substitute
         ,_exp3_layoutMap
         ,_exp3_newlines
         ,_exp3_pIdC
         ,loc (ExpNode _self _lhs_path) $ parsing $ presentFocus _lhs_focusD _lhs_path $
                squiggleRanges _lhs_ranges _lhs_path $ addReductionPopupItems _reductionEdit $
            row'  $ [ key (mkIDP _idP0 _lhs_idC 0) "if",   _exp1_pres
                        , key (mkIDP _idP1 _lhs_idC 1) "then", _exp2_pres
                        , key (mkIDP _idP2 _lhs_idC 2) "else", _exp3_pres ]
         ,_self
         ,_exp3_spaces
         ,_substitute
         ,_type
         ,case _exp1_val of BoolVal b -> if b then _exp2_val else _exp3_val
                            _         -> ErrVal
         ,_exp3_varsInScopeAtFocus
         )
sem_Exp_IntExp :: (IDD) ->
                  (IDP) ->
                  (Int) ->
                  (T_Exp)
sem_Exp_IntExp (_idD) (_idP0) (_int) (_lhs_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_idC) (_lhs_layoutMap) (_lhs_level) (_lhs_newlines) (_lhs_pIdC) (_lhs_path) (_lhs_ranges) (_lhs_spaces) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            IntExp _idD _idP0 _int
        (_type) =
            lookupType _lhs_typeEnv _lhs_path
        (_reductionEdit) =
            []
        (_substitute) =
            \substs -> _self
    in  ( _lhs_col+length (show _int)
         ,_lhs_idC
         ,_substitute
         ,addToFM _lhs_layoutMap _idP0 (_lhs_newlines,_lhs_spaces)
         ,_lhs_newlines
         ,_lhs_pIdC
         ,loc (ExpNode _self _lhs_path) $ parsing $ presentFocus _lhs_focusD _lhs_path $
            squiggleRanges _lhs_ranges _lhs_path $ addReductionPopupItems _reductionEdit $
            row' [cons (mkIDP _idP0 _lhs_idC 0) (show _int), text' NoIDP ""]
         ,_self
         ,_lhs_spaces
         ,_substitute
         ,_type
         ,IntVal _int
         ,if (PathD _lhs_path) == _lhs_focusD then _lhs_varsInScope else _lhs_varsInScopeAtFocus
         )
sem_Exp_LamExp :: (IDD) ->
                  (IDP) ->
                  (IDP) ->
                  (T_Ident) ->
                  (T_Exp) ->
                  (T_Exp)
sem_Exp_LamExp (_idD) (_idP0) (_idP1) (_ident) (_exp) (_lhs_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_idC) (_lhs_layoutMap) (_lhs_level) (_lhs_newlines) (_lhs_pIdC) (_lhs_path) (_lhs_ranges) (_lhs_spaces) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            LamExp _idD _idP0 _idP1 _ident_self _exp_self
        (_type) =
            lookupType _lhs_typeEnv _lhs_path
        (_reductionEdit) =
            []
        (_substitute) =
            \substs -> LamExp _idD _idP0 _idP1 _ident_self (_exp_substitute
                                                             (filter (\(str,_) -> str /= strFromIdent _ident_self)
                                                                     substs))
        ( _ident_col,_ident_firstToken,_ident_idC,_ident_idsPres,_ident_layoutMap,_ident_newlines,_ident_pIdC,_ident_pres,_ident_self,_ident_spaces,_ident_str,_ident_varsInScopeAtFocus) =
            (_ident (_lhs_col + 1)
                    (_lhs_focusD)
                    (_lhs_idC + 2)
                    (addListToFM _lhs_layoutMap
                       [ (_idP0, (_lhs_newlines,_lhs_spaces))
                       , (_idP1, (0,1)) ])
                    (_lhs_level)
                    (0)
                    (_lhs_pIdC)
                    (_lhs_path++[0])
                    (_lhs_ranges)
                    (0)
                    (_lhs_varsInScope)
                    (if (PathD _lhs_path) == _lhs_focusD then _lhs_varsInScope else _lhs_varsInScopeAtFocus))
        ( _exp_col,_exp_idC,_exp_lamBody,_exp_layoutMap,_exp_newlines,_exp_pIdC,_exp_pres,_exp_self,_exp_spaces,_exp_substitute,_exp_type,_exp_val,_exp_varsInScopeAtFocus) =
            (_exp (_ident_col + 3)
                  (_lhs_env)
                  (_lhs_errs)
                  (_lhs_focusD)
                  (_ident_idC)
                  (_ident_layoutMap)
                  (_lhs_level)
                  (0)
                  (_ident_pIdC)
                  (_lhs_path++[1])
                  (_lhs_ranges)
                  (1)
                  (_lhs_topLevelEnv)
                  (_lhs_typeEnv)
                  (addToFM _lhs_varsInScope (strFromIdent _ident_self)
                                            (PathD $ (_lhs_path++[0]), _exp_type))
                  (_ident_varsInScopeAtFocus))
    in  ( _exp_col
         ,_exp_idC
         ,_exp_substitute
         ,_exp_layoutMap
         ,_exp_newlines
         ,_exp_pIdC
         ,loc (ExpNode _self _lhs_path) $ parsing $ presentFocus _lhs_focusD _lhs_path $
            squiggleRanges _lhs_ranges _lhs_path $ addReductionPopupItems _reductionEdit $
            row' [
                   key (mkIDP _idP0 _lhs_idC 0) "\\"
                 , _ident_pres
                 , text' (mkIDP _idP1 _lhs_idC 1) ""
                   , key NoIDP "®"    `withFontFam` "symbol"
                 , _exp_pres ]
         ,_self
         ,_exp_spaces
         ,_substitute
         ,_type
         ,LamVal (\arg ->
                   let (_,_,_,_,_,_,_,_,_,_,_,v,_) =
                         _exp undefined ((_ident_str, arg): _lhs_env) undefined undefined undefined undefined undefined undefined undefined undefined undefined undefined undefined undefined undefined undefined
                   in  v)
         ,_exp_varsInScopeAtFocus
         )
sem_Exp_LetExp :: (IDD) ->
                  (IDP) ->
                  (IDP) ->
                  (T_Decls) ->
                  (T_Exp) ->
                  (T_Exp)
sem_Exp_LetExp (_idD) (_idP0) (_idP1) (_decls) (_exp) (_lhs_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_idC) (_lhs_layoutMap) (_lhs_level) (_lhs_newlines) (_lhs_pIdC) (_lhs_path) (_lhs_ranges) (_lhs_spaces) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            LetExp _idD _idP0 _idP1 _decls_self _exp_self
        (_varsInScope) =
            addListToFM _lhs_varsInScope _decls_declaredVars
        (_type) =
            lookupType _lhs_typeEnv _lhs_path
        (_reductionEdit) =
            []
        (_substitute) =
            \substs -> _self
        ( _decls_col,_decls_dcls,_decls_declaredVars,_decls_idC,_decls_idsPres,_decls_layoutMap,_decls_newlines,_decls_pIdC,_decls_parseErrs,_decls_path,_decls_press,_decls_self,_decls_spaces,_decls_varsInScopeAtFocus) =
            (_decls (_lhs_col + 3+1)
                    (_lhs_env)
                    (_lhs_errs)
                    (_lhs_focusD)
                    (_lhs_idC + 2)
                    (0)
                    (addListToFM _lhs_layoutMap
                       [ (_idP0, (_lhs_newlines,_lhs_spaces))
                       , (_idP1, (1,_lhs_col))])
                    (_lhs_level + 1)
                    (0)
                    (_lhs_pIdC)
                    (_lhs_path++[0])
                    (_lhs_ranges)
                    (1)
                    (_lhs_topLevelEnv)
                    (_lhs_typeEnv)
                    (_varsInScope)
                    (if (PathD _lhs_path) == _lhs_focusD then _lhs_varsInScope else _lhs_varsInScopeAtFocus))
        ( _exp_col,_exp_idC,_exp_lamBody,_exp_layoutMap,_exp_newlines,_exp_pIdC,_exp_pres,_exp_self,_exp_spaces,_exp_substitute,_exp_type,_exp_val,_exp_varsInScopeAtFocus) =
            (_exp (_lhs_col + 3+1) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_decls_idC) (_decls_layoutMap) (_lhs_level) (0) (_decls_pIdC) (_lhs_path++[1]) (_lhs_ranges) (2) (_lhs_topLevelEnv) (_lhs_typeEnv) (_varsInScope) (_decls_varsInScopeAtFocus))
    in  ( _exp_col
         ,_exp_idC
         ,_substitute
         ,_exp_layoutMap
         ,_exp_newlines
         ,_exp_pIdC
         ,loc (ExpNode _self _lhs_path) $ parsing $ presentFocus _lhs_focusD _lhs_path $
            squiggleRanges _lhs_ranges _lhs_path $ addReductionPopupItems _reductionEdit $
            row' [ key (mkIDP _idP0 _lhs_idC 0) "let"
                 , loc (DeclsNode _decls_self _decls_path) $ parsing $ presentFocus _lhs_focusD _decls_path $ row _decls_press
                 , key (mkIDP _idP1 _lhs_idC 1) "in", _exp_pres ]
         ,_self
         ,_exp_spaces
         ,_substitute
         ,_type
         ,let (_,_,_,_,_,_,_,_,_,_,_,v,_) =
                _exp undefined (_decls_dcls ++ _lhs_env) undefined undefined undefined undefined undefined undefined undefined undefined undefined undefined undefined undefined undefined undefined
          in  v
         ,_exp_varsInScopeAtFocus
         )
sem_Exp_ListExp :: (IDD) ->
                   (IDP) ->
                   (IDP) ->
                   ([IDP]) ->
                   (T_Exps) ->
                   (T_Exp)
sem_Exp_ListExp (_idD) (_idP0) (_idP1) (_ids) (_exps) (_lhs_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_idC) (_lhs_layoutMap) (_lhs_level) (_lhs_newlines) (_lhs_pIdC) (_lhs_path) (_lhs_ranges) (_lhs_spaces) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            ListExp _idD _idP0 _idP1 _ids _exps_self
        (_type) =
            lookupType _lhs_typeEnv _lhs_path
        (_reductionEdit) =
            []
        (_substitute) =
            \substs -> _self
        ( _exps_col,_exps_idC,_exps_layoutMap,_exps_newlines,_exps_pIdC,_exps_path,_exps_press,_exps_self,_exps_spaces,_exps_vals,_exps_varsInScopeAtFocus) =
            (_exps (_lhs_col + 1+1)
                   (_lhs_env)
                   (_lhs_errs)
                   (_lhs_focusD)
                   (_lhs_idC + 2)
                   (0)
                   (addListToFM _lhs_layoutMap
                      [ (_idP0, (_lhs_newlines,_lhs_spaces))
                      , (_idP1, (0,1)) ])
                   (_lhs_level)
                   (0)
                   (_lhs_pIdC)
                   (_lhs_path++[0])
                   (_lhs_ranges)
                   (1)
                   (_lhs_topLevelEnv)
                   (_lhs_typeEnv)
                   (_lhs_varsInScope)
                   (if (PathD _lhs_path) == _lhs_focusD then _lhs_varsInScope else _lhs_varsInScopeAtFocus))
    in  ( _exps_col + 1+1
         ,_exps_idC
         ,_substitute
         ,_exps_layoutMap
         ,0
         ,_exps_pIdC
         ,loc (ExpNode _self _lhs_path) $ parsing $ presentFocus _lhs_focusD _lhs_path $
            squiggleRanges _lhs_ranges _lhs_path $ addReductionPopupItems _reductionEdit $
            row' $    [sep (mkIDP _idP0 _lhs_idC 0) "["]
                   ++ let xps = map (loc (ExpsNode _exps_self _exps_path) . parsing . presentFocus _lhs_focusD _exps_path) _exps_press
                          sps = map (\id -> sep id ",") (_ids++ map IDP [_lhs_idC .. ] )
                      in (if null xps
                          then []
                          else head xps : concat [ [s,e] | (s,e) <- zip sps (tail xps)])
                   ++ [sep (mkIDP _idP1 _lhs_idC 1) "]"]
         ,_self
         ,0
         ,_substitute
         ,_type
         ,ListVal _exps_vals
         ,_exps_varsInScopeAtFocus
         )
sem_Exp_ParenExp :: (IDD) ->
                    (IDP) ->
                    (IDP) ->
                    (T_Exp) ->
                    (T_Exp)
sem_Exp_ParenExp (_idD) (_idP0) (_idP1) (_exp) (_lhs_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_idC) (_lhs_layoutMap) (_lhs_level) (_lhs_newlines) (_lhs_pIdC) (_lhs_path) (_lhs_ranges) (_lhs_spaces) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            ParenExp _idD _idP0 _idP1 _exp_self
        (_type) =
            lookupType _lhs_typeEnv _lhs_path
        (_reductionEdit) =
            []
        (_substitute) =
            \substs -> ParenExp _idD _idP0 _idP1 (_exp_substitute substs)
        ( _exp_col,_exp_idC,_exp_lamBody,_exp_layoutMap,_exp_newlines,_exp_pIdC,_exp_pres,_exp_self,_exp_spaces,_exp_substitute,_exp_type,_exp_val,_exp_varsInScopeAtFocus) =
            (_exp (_lhs_col + 1+1)
                  (_lhs_env)
                  (_lhs_errs)
                  (_lhs_focusD)
                  (_lhs_idC + 2)
                  (addListToFM _lhs_layoutMap
                     [ (_idP0, (_lhs_newlines,_lhs_spaces))
                     , (_idP1, (0,1)) ])
                  (_lhs_level)
                  (0)
                  (_lhs_pIdC)
                  (_lhs_path++[0])
                  (_lhs_ranges)
                  (1)
                  (_lhs_topLevelEnv)
                  (_lhs_typeEnv)
                  (_lhs_varsInScope)
                  (if (PathD _lhs_path) == _lhs_focusD then _lhs_varsInScope else _lhs_varsInScopeAtFocus))
    in  ( _exp_col + 1+1
         ,_exp_idC
         ,_exp_lamBody
         ,_exp_layoutMap
         ,0
         ,_exp_pIdC
         ,loc (ExpNode _self _lhs_path) $ parsing $ presentFocus _lhs_focusD _lhs_path $
            squiggleRanges _lhs_ranges _lhs_path $ addReductionPopupItems _reductionEdit $
            row'  [sep (mkIDP _idP0 _lhs_idC 0) "(", _exp_pres , sep (mkIDP _idP1 _lhs_idC 1) ")"]
         ,_self
         ,0
         ,_substitute
         ,_type
         ,_exp_val
         ,_exp_varsInScopeAtFocus
         )
sem_Exp_ParseErrExp :: (Node) ->
                       (Presentation) ->
                       (T_Exp)
sem_Exp_ParseErrExp (_node) (_presentation) (_lhs_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_idC) (_lhs_layoutMap) (_lhs_level) (_lhs_newlines) (_lhs_pIdC) (_lhs_path) (_lhs_ranges) (_lhs_spaces) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            ParseErrExp _node _presentation
        (_type) =
            "<ParseErr>"
        (_substitute) =
            \substs -> _self
    in  ( _lhs_col,_lhs_idC,_substitute,_lhs_layoutMap,_lhs_newlines,_lhs_pIdC,presParseErr _node _presentation,_self,_lhs_spaces,_substitute,_type,ErrVal,_lhs_varsInScopeAtFocus)
sem_Exp_PlusExp :: (IDD) ->
                   (IDP) ->
                   (T_Exp) ->
                   (T_Exp) ->
                   (T_Exp)
sem_Exp_PlusExp (_idD) (_idP0) (_exp1) (_exp2) (_lhs_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_idC) (_lhs_layoutMap) (_lhs_level) (_lhs_newlines) (_lhs_pIdC) (_lhs_path) (_lhs_ranges) (_lhs_spaces) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            PlusExp _idD _idP0 _exp1_self _exp2_self
        (_type) =
            lookupType _lhs_typeEnv _lhs_path
        (_reductionEdit) =
            case (removeParens _exp1_self, removeParens _exp2_self) of
                   (IntExp idd1 idp1 int1, IntExp _ _ int2 ) -> [ ("Reduce primitive (+)" , pasteExp _lhs_path (IntExp idd1 idp1 (int1+int2)))]
                   _                                         -> []
        (_substitute) =
            \substs -> PlusExp _idD _idP0 (_exp1_substitute substs) (_exp2_substitute substs)
        ( _exp1_col,_exp1_idC,_exp1_lamBody,_exp1_layoutMap,_exp1_newlines,_exp1_pIdC,_exp1_pres,_exp1_self,_exp1_spaces,_exp1_substitute,_exp1_type,_exp1_val,_exp1_varsInScopeAtFocus) =
            (_exp1 (_lhs_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_idC + 1) (addToFM _lhs_layoutMap _idP0 (0,1)) (_lhs_level) (_lhs_newlines) (_lhs_pIdC) (_lhs_path++[0]) (_lhs_ranges) (_lhs_spaces) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (if (PathD _lhs_path) == _lhs_focusD then _lhs_varsInScope else _lhs_varsInScopeAtFocus))
        ( _exp2_col,_exp2_idC,_exp2_lamBody,_exp2_layoutMap,_exp2_newlines,_exp2_pIdC,_exp2_pres,_exp2_self,_exp2_spaces,_exp2_substitute,_exp2_type,_exp2_val,_exp2_varsInScopeAtFocus) =
            (_exp2 (_exp1_col + 3) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_exp1_idC) (_exp1_layoutMap) (_lhs_level) (0) (_exp1_pIdC) (_lhs_path++[1]) (_lhs_ranges) (1) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_exp1_varsInScopeAtFocus))
    in  ( _exp2_col
         ,_exp2_idC
         ,_substitute
         ,_exp2_layoutMap
         ,_exp2_newlines
         ,_exp2_pIdC
         ,loc (ExpNode _self _lhs_path) $ parsing $ presentFocus _lhs_focusD _lhs_path $
            squiggleRanges _lhs_ranges _lhs_path $ addReductionPopupItems _reductionEdit $
            row' [_exp1_pres , op (mkIDP _idP0 _lhs_idC 0) "+", _exp2_pres]
         ,_self
         ,_exp2_spaces
         ,_substitute
         ,_type
         ,evaluateIntOp (+) _exp1_val _exp2_val
         ,_exp2_varsInScopeAtFocus
         )
sem_Exp_PowerExp :: (IDD) ->
                    (IDP) ->
                    (T_Exp) ->
                    (T_Exp) ->
                    (T_Exp)
sem_Exp_PowerExp (_idD) (_idP0) (_exp1) (_exp2) (_lhs_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_idC) (_lhs_layoutMap) (_lhs_level) (_lhs_newlines) (_lhs_pIdC) (_lhs_path) (_lhs_ranges) (_lhs_spaces) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            PowerExp _idD _idP0 _exp1_self _exp2_self
        (_type) =
            lookupType _lhs_typeEnv _lhs_path
        (_reductionEdit) =
            case (removeParens _exp1_self, removeParens _exp2_self) of
                   (IntExp idd1 idp1 int1, IntExp _ _ int2 ) -> [ ("Reduce primitive (^)" , pasteExp _lhs_path (IntExp idd1 idp1 (int1^int2)))]
                   _                                         -> []
        (_substitute) =
            \substs -> PowerExp _idD _idP0 (_exp1_substitute substs) (_exp2_substitute substs)
        ( _exp1_col,_exp1_idC,_exp1_lamBody,_exp1_layoutMap,_exp1_newlines,_exp1_pIdC,_exp1_pres,_exp1_self,_exp1_spaces,_exp1_substitute,_exp1_type,_exp1_val,_exp1_varsInScopeAtFocus) =
            (_exp1 (_lhs_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_idC + 1) (addToFM _lhs_layoutMap _idP0 (0,0)) (_lhs_level) (_lhs_newlines) (_lhs_pIdC) (_lhs_path++[0]) (_lhs_ranges) (_lhs_spaces) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (if (PathD _lhs_path) == _lhs_focusD then _lhs_varsInScope else _lhs_varsInScopeAtFocus))
        ( _exp2_col,_exp2_idC,_exp2_lamBody,_exp2_layoutMap,_exp2_newlines,_exp2_pIdC,_exp2_pres,_exp2_self,_exp2_spaces,_exp2_substitute,_exp2_type,_exp2_val,_exp2_varsInScopeAtFocus) =
            (_exp2 (0) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_exp1_idC) (_exp1_layoutMap) (_lhs_level) (0) (_exp1_pIdC) (_lhs_path++[1]) (_lhs_ranges) (0) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_exp1_varsInScopeAtFocus))
    in  ( _exp2_col
         ,_exp2_idC
         ,_substitute
         ,_exp2_layoutMap
         ,_exp2_newlines
         ,_exp2_pIdC
         ,loc (ExpNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
            squiggleRanges _lhs_ranges _lhs_path $ addReductionPopupItems _reductionEdit $
            power _exp1_pres _exp2_pres
         ,_self
         ,_exp2_spaces
         ,_substitute
         ,_type
         ,evaluateIntOp (^) _exp1_val _exp2_val
         ,_exp2_varsInScopeAtFocus
         )
sem_Exp_ProductExp :: (IDD) ->
                      (IDP) ->
                      (IDP) ->
                      ([IDP]) ->
                      (T_Exps) ->
                      (T_Exp)
sem_Exp_ProductExp (_idD) (_idP0) (_idP1) (_ids) (_exps) (_lhs_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_idC) (_lhs_layoutMap) (_lhs_level) (_lhs_newlines) (_lhs_pIdC) (_lhs_path) (_lhs_ranges) (_lhs_spaces) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            ProductExp _idD _idP0 _idP1 _ids _exps_self
        (_type) =
            lookupType _lhs_typeEnv _lhs_path
        (_reductionEdit) =
            []
        (_substitute) =
            \substs -> _self
        ( _exps_col,_exps_idC,_exps_layoutMap,_exps_newlines,_exps_pIdC,_exps_path,_exps_press,_exps_self,_exps_spaces,_exps_vals,_exps_varsInScopeAtFocus) =
            (_exps (_lhs_col + 1+1)
                   (_lhs_env)
                   (_lhs_errs)
                   (_lhs_focusD)
                   (_lhs_idC + 2)
                   (0)
                   (addListToFM _lhs_layoutMap
                      [ (_idP0, (_lhs_newlines,_lhs_spaces))
                      , (_idP1, (0,1)) ])
                   (_lhs_level)
                   (0)
                   (_lhs_pIdC)
                   (_lhs_path++[0])
                   (_lhs_ranges)
                   (1)
                   (_lhs_topLevelEnv)
                   (_lhs_typeEnv)
                   (_lhs_varsInScope)
                   (if (PathD _lhs_path) == _lhs_focusD then _lhs_varsInScope else _lhs_varsInScopeAtFocus))
    in  ( _exps_col + 1+1
         ,_exps_idC
         ,_substitute
         ,_exps_layoutMap
         ,0
         ,_exps_pIdC
         ,loc (ExpNode _self _lhs_path) $ parsing $ presentFocus _lhs_focusD _lhs_path $
            squiggleRanges _lhs_ranges _lhs_path $ addReductionPopupItems _reductionEdit $
            row' $    [sep (mkIDP _idP0 _lhs_idC 0) "("]
                   ++ let xps = map (loc (ExpsNode _exps_self _exps_path) . parsing . presentFocus _lhs_focusD _exps_path) _exps_press
                          sps = map (\id -> sep id ",") (_ids++ map IDP [_lhs_idC .. ] )
                      in  if null xps
                          then []
                          else head xps : concat [ [s,e] | (s,e) <- zip sps (tail xps)]
                   ++ [sep (mkIDP _idP1 _lhs_idC 1) ")"]
         ,_self
         ,0
         ,_substitute
         ,_type
         ,ProdVal _exps_vals
         ,_exps_varsInScopeAtFocus
         )
sem_Exp_TimesExp :: (IDD) ->
                    (IDP) ->
                    (T_Exp) ->
                    (T_Exp) ->
                    (T_Exp)
sem_Exp_TimesExp (_idD) (_idP0) (_exp1) (_exp2) (_lhs_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_idC) (_lhs_layoutMap) (_lhs_level) (_lhs_newlines) (_lhs_pIdC) (_lhs_path) (_lhs_ranges) (_lhs_spaces) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            TimesExp _idD _idP0 _exp1_self _exp2_self
        (_type) =
            lookupType _lhs_typeEnv _lhs_path
        (_reductionEdit) =
            case (removeParens _exp1_self, removeParens _exp2_self) of
                   (IntExp idd1 idp1 int1, IntExp _ _ int2 ) -> [ ("Reduce primitive (*)" , pasteExp _lhs_path (IntExp idd1 idp1 (int1*int2)))]
                   _                                         -> []
        (_substitute) =
            \substs -> TimesExp _idD _idP0 (_exp1_substitute substs) (_exp2_substitute substs)
        ( _exp1_col,_exp1_idC,_exp1_lamBody,_exp1_layoutMap,_exp1_newlines,_exp1_pIdC,_exp1_pres,_exp1_self,_exp1_spaces,_exp1_substitute,_exp1_type,_exp1_val,_exp1_varsInScopeAtFocus) =
            (_exp1 (_lhs_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_idC + 1) (addToFM _lhs_layoutMap _idP0 (0,1)) (_lhs_level) (_lhs_newlines) (_lhs_pIdC) (_lhs_path++[0]) (_lhs_ranges) (_lhs_spaces) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (if (PathD _lhs_path) == _lhs_focusD then _lhs_varsInScope else _lhs_varsInScopeAtFocus))
        ( _exp2_col,_exp2_idC,_exp2_lamBody,_exp2_layoutMap,_exp2_newlines,_exp2_pIdC,_exp2_pres,_exp2_self,_exp2_spaces,_exp2_substitute,_exp2_type,_exp2_val,_exp2_varsInScopeAtFocus) =
            (_exp2 (_exp1_col + 3) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_exp1_idC) (_exp1_layoutMap) (_lhs_level) (0) (_exp1_pIdC) (_lhs_path++[1]) (_lhs_ranges) (1) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_exp1_varsInScopeAtFocus))
    in  ( _exp2_col
         ,_exp2_idC
         ,_substitute
         ,_exp2_layoutMap
         ,_exp2_newlines
         ,_exp2_pIdC
         ,loc (ExpNode _self _lhs_path) $ parsing $ presentFocus _lhs_focusD _lhs_path $
            squiggleRanges _lhs_ranges _lhs_path $ addReductionPopupItems _reductionEdit $
            row' [_exp1_pres , op (mkIDP _idP0 _lhs_idC 0) "*", _exp2_pres]
         ,_self
         ,_exp2_spaces
         ,_substitute
         ,_type
         ,evaluateIntOp (*) _exp1_val _exp2_val
         ,_exp2_varsInScopeAtFocus
         )
-- Exps --------------------------------------------------------
{-
   inherited attributes:
      env                  : Bindings
      errs                 : [HeliumMessage]
      focusD               : FocusDoc
      ix                   : Int
      level                : Int
      ranges               : ([PathDoc],[PathDoc],[PathDoc])
      topLevelEnv          : [(String, String)]
      typeEnv              : [(PathDoc,String)]
      varsInScope          : FiniteMap String (PathDoc, String)

   chained attributes:
      col                  : Int
      idC                  : Int
      layoutMap            : LayoutMap
      newlines             : Int
      pIdC                 : IDPCounter
      path                 : [Int]
      spaces               : Int
      varsInScopeAtFocus   : FiniteMap String (PathDoc, String)

   synthesised attributes:
      press                : [Presentation]
      self                 : Exps
      vals                 : [Value]

-}
{-
   local variables for Exps.ConsExps:
      self

-}
{-
   local variables for Exps.HoleExps:
      self

-}
{-
   local variables for Exps.NilExps:
      self

-}
{-
   local variables for Exps.ParseErrExps:
      self

-}
-- semantic domain
type T_Exps = (Int) ->
              (Bindings) ->
              ([HeliumMessage]) ->
              (FocusDoc) ->
              (Int) ->
              (Int) ->
              (LayoutMap) ->
              (Int) ->
              (Int) ->
              (IDPCounter) ->
              ([Int]) ->
              (([PathDoc],[PathDoc],[PathDoc])) ->
              (Int) ->
              ([(String, String)]) ->
              ([(PathDoc,String)]) ->
              (FiniteMap String (PathDoc, String)) ->
              (FiniteMap String (PathDoc, String)) ->
              ( (Int),(Int),(LayoutMap),(Int),(IDPCounter),([Int]),([Presentation]),(Exps),(Int),([Value]),(FiniteMap String (PathDoc, String)))
-- cata
sem_Exps :: (Exps) ->
            (T_Exps)
sem_Exps ((ConsExps (_iDD) (_exp) (_exps))) =
    (sem_Exps_ConsExps (_iDD) ((sem_Exp (_exp))) ((sem_Exps (_exps))))
sem_Exps ((HoleExps )) =
    (sem_Exps_HoleExps )
sem_Exps ((NilExps (_iDD))) =
    (sem_Exps_NilExps (_iDD))
sem_Exps ((ParseErrExps (_node) (_presentation))) =
    (sem_Exps_ParseErrExps (_node) (_presentation))
sem_Exps_ConsExps :: (IDD) ->
                     (T_Exp) ->
                     (T_Exps) ->
                     (T_Exps)
sem_Exps_ConsExps (_iDD) (_exp) (_exps) (_lhs_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_idC) (_lhs_ix) (_lhs_layoutMap) (_lhs_level) (_lhs_newlines) (_lhs_pIdC) (_lhs_path) (_lhs_ranges) (_lhs_spaces) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            ConsExps _iDD _exp_self _exps_self
        ( _exp_col,_exp_idC,_exp_lamBody,_exp_layoutMap,_exp_newlines,_exp_pIdC,_exp_pres,_exp_self,_exp_spaces,_exp_substitute,_exp_type,_exp_val,_exp_varsInScopeAtFocus) =
            (_exp (_lhs_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_idC + 100) (_lhs_layoutMap) (_lhs_level) (_lhs_newlines) (_lhs_pIdC) (_lhs_path++[_lhs_ix]) (_lhs_ranges) (_lhs_spaces) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus))
        ( _exps_col,_exps_idC,_exps_layoutMap,_exps_newlines,_exps_pIdC,_exps_path,_exps_press,_exps_self,_exps_spaces,_exps_vals,_exps_varsInScopeAtFocus) =
            (_exps (_exp_col + 2) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_exp_idC) (_lhs_ix + 1) (_exp_layoutMap) (_lhs_level) (_exp_newlines) (_exp_pIdC) (_lhs_path) (_lhs_ranges) (_exp_spaces) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_exp_varsInScopeAtFocus))
    in  ( _exps_col,_exps_idC,_exps_layoutMap,_exps_newlines,_exps_pIdC,_lhs_path,_exp_pres : _exps_press,_self,_exps_spaces,_exp_val : _exps_vals,_exps_varsInScopeAtFocus)
sem_Exps_HoleExps :: (T_Exps)
sem_Exps_HoleExps (_lhs_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_idC) (_lhs_ix) (_lhs_layoutMap) (_lhs_level) (_lhs_newlines) (_lhs_pIdC) (_lhs_path) (_lhs_ranges) (_lhs_spaces) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            HoleExps
    in  ( _lhs_col,_lhs_idC,_lhs_layoutMap,_lhs_newlines,_lhs_pIdC,_lhs_path,[presHole _lhs_focusD "Exps" (ExpsNode _self _lhs_path) _lhs_path],_self,_lhs_spaces,[],_lhs_varsInScopeAtFocus)
sem_Exps_NilExps :: (IDD) ->
                    (T_Exps)
sem_Exps_NilExps (_iDD) (_lhs_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_idC) (_lhs_ix) (_lhs_layoutMap) (_lhs_level) (_lhs_newlines) (_lhs_pIdC) (_lhs_path) (_lhs_ranges) (_lhs_spaces) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            NilExps _iDD
    in  ( _lhs_col,_lhs_idC,_lhs_layoutMap,_lhs_newlines,_lhs_pIdC,_lhs_path,[],_self,_lhs_spaces,[],_lhs_varsInScopeAtFocus)
sem_Exps_ParseErrExps :: (Node) ->
                         (Presentation) ->
                         (T_Exps)
sem_Exps_ParseErrExps (_node) (_presentation) (_lhs_col) (_lhs_env) (_lhs_errs) (_lhs_focusD) (_lhs_idC) (_lhs_ix) (_lhs_layoutMap) (_lhs_level) (_lhs_newlines) (_lhs_pIdC) (_lhs_path) (_lhs_ranges) (_lhs_spaces) (_lhs_topLevelEnv) (_lhs_typeEnv) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            ParseErrExps _node _presentation
    in  ( _lhs_col,_lhs_idC,_lhs_layoutMap,_lhs_newlines,_lhs_pIdC,_lhs_path,[presParseErr _node _presentation],_self,_lhs_spaces,[],_lhs_varsInScopeAtFocus)
-- Ident -------------------------------------------------------
{-
   inherited attributes:
      focusD               : FocusDoc
      level                : Int
      path                 : [Int]
      ranges               : ([PathDoc],[PathDoc],[PathDoc])
      varsInScope          : FiniteMap String (PathDoc, String)

   chained attributes:
      col                  : Int
      idC                  : Int
      layoutMap            : LayoutMap
      newlines             : Int
      pIdC                 : IDPCounter
      spaces               : Int
      varsInScopeAtFocus   : FiniteMap String (PathDoc, String)

   synthesised attributes:
      firstToken           : IDP
      idsPres              : Presentation
      pres                 : Presentation
      self                 : Ident
      str                  : String

-}
{-
   local variables for Ident.HoleIdent:
      self

-}
{-
   local variables for Ident.Ident:
      self

-}
{-
   local variables for Ident.ParseErrIdent:
      self

-}
-- semantic domain
type T_Ident = (Int) ->
               (FocusDoc) ->
               (Int) ->
               (LayoutMap) ->
               (Int) ->
               (Int) ->
               (IDPCounter) ->
               ([Int]) ->
               (([PathDoc],[PathDoc],[PathDoc])) ->
               (Int) ->
               (FiniteMap String (PathDoc, String)) ->
               (FiniteMap String (PathDoc, String)) ->
               ( (Int),(IDP),(Int),(Presentation),(LayoutMap),(Int),(IDPCounter),(Presentation),(Ident),(Int),(String),(FiniteMap String (PathDoc, String)))
-- cata
sem_Ident :: (Ident) ->
             (T_Ident)
sem_Ident ((HoleIdent )) =
    (sem_Ident_HoleIdent )
sem_Ident ((Ident (_idD) (_idP0) (_idP1) (_string))) =
    (sem_Ident_Ident (_idD) (_idP0) (_idP1) (_string))
sem_Ident ((ParseErrIdent (_node) (_presentation))) =
    (sem_Ident_ParseErrIdent (_node) (_presentation))
sem_Ident_HoleIdent :: (T_Ident)
sem_Ident_HoleIdent (_lhs_col) (_lhs_focusD) (_lhs_idC) (_lhs_layoutMap) (_lhs_level) (_lhs_newlines) (_lhs_pIdC) (_lhs_path) (_lhs_ranges) (_lhs_spaces) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            HoleIdent
    in  ( _lhs_col,NoIDP,_lhs_idC,presHole _lhs_focusD "Ident" (IdentNode _self _lhs_path) _lhs_path,_lhs_layoutMap,_lhs_newlines,_lhs_pIdC,presHole _lhs_focusD "Ident" (IdentNode _self _lhs_path) _lhs_path,_self,_lhs_spaces,"",_lhs_varsInScopeAtFocus)
sem_Ident_Ident :: (IDD) ->
                   (IDP) ->
                   (IDP) ->
                   (String) ->
                   (T_Ident)
sem_Ident_Ident (_idD) (_idP0) (_idP1) (_string) (_lhs_col) (_lhs_focusD) (_lhs_idC) (_lhs_layoutMap) (_lhs_level) (_lhs_newlines) (_lhs_pIdC) (_lhs_path) (_lhs_ranges) (_lhs_spaces) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            Ident _idD _idP0 _idP1 _string
    in  ( _lhs_col+length _string
         ,_idP0
         ,_lhs_idC + 1
         ,loc (IdentNode _self _lhs_path) $ parsing $ presentFocus _lhs_focusD _lhs_path $
            row' [ text _string ]
         ,addToFM _lhs_layoutMap _idP0 (_lhs_newlines,_lhs_spaces)
         ,_lhs_newlines
         ,_lhs_pIdC
         ,loc (IdentNode _self _lhs_path) $ parsing $ presentFocus _lhs_focusD _lhs_path $
            squiggleRanges _lhs_ranges _lhs_path $
            row' [text' (mkIDP _idP0 _lhs_idC 0) _string, text' NoIDP ""]
         ,_self
         ,_lhs_spaces
         ,_string
         ,if (PathD _lhs_path) == _lhs_focusD then _lhs_varsInScope else _lhs_varsInScopeAtFocus
         )
sem_Ident_ParseErrIdent :: (Node) ->
                           (Presentation) ->
                           (T_Ident)
sem_Ident_ParseErrIdent (_node) (_presentation) (_lhs_col) (_lhs_focusD) (_lhs_idC) (_lhs_layoutMap) (_lhs_level) (_lhs_newlines) (_lhs_pIdC) (_lhs_path) (_lhs_ranges) (_lhs_spaces) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            ParseErrIdent _node _presentation
    in  ( _lhs_col,NoIDP,_lhs_idC,presParseErr _node _presentation,_lhs_layoutMap,_lhs_newlines,_lhs_pIdC,presParseErr _node _presentation,_self,_lhs_spaces,"",_lhs_varsInScopeAtFocus)
-- Item --------------------------------------------------------
{-
   inherited attributes:
      focusD               : FocusDoc
      ix                   : Int
      listType             : ListType
      path                 : [Int]
      ranges               : ([PathDoc],[PathDoc],[PathDoc])
      varsInScope          : FiniteMap String (PathDoc, String)

   chained attributes:
      idC                  : Int
      varsInScopeAtFocus   : FiniteMap String (PathDoc, String)

   synthesised attributes:
      pres                 : Presentation
      pres2                : Presentation
      self                 : Item

-}
{-
   local variables for Item.HeliumItem:
      self

-}
{-
   local variables for Item.HoleItem:
      self

-}
{-
   local variables for Item.ListItem:
      self

-}
{-
   local variables for Item.ParseErrItem:
      self

-}
{-
   local variables for Item.StringItem:
      self

-}
-- semantic domain
type T_Item = (FocusDoc) ->
              (Int) ->
              (Int) ->
              (ListType) ->
              ([Int]) ->
              (([PathDoc],[PathDoc],[PathDoc])) ->
              (FiniteMap String (PathDoc, String)) ->
              (FiniteMap String (PathDoc, String)) ->
              ( (Int),(Presentation),(Presentation),(Item),(FiniteMap String (PathDoc, String)))
-- cata
sem_Item :: (Item) ->
            (T_Item)
sem_Item ((HeliumItem (_idd) (_exp))) =
    (sem_Item_HeliumItem (_idd) ((sem_Exp (_exp))))
sem_Item ((HoleItem )) =
    (sem_Item_HoleItem )
sem_Item ((ListItem (_idd) (_itemList))) =
    (sem_Item_ListItem (_idd) ((sem_ItemList (_itemList))))
sem_Item ((ParseErrItem (_node) (_presentation))) =
    (sem_Item_ParseErrItem (_node) (_presentation))
sem_Item ((StringItem (_idd) (_string))) =
    (sem_Item_StringItem (_idd) ((sem_String_ (_string))))
sem_Item_HeliumItem :: (IDD) ->
                       (T_Exp) ->
                       (T_Item)
sem_Item_HeliumItem (_idd) (_exp) (_lhs_focusD) (_lhs_idC) (_lhs_ix) (_lhs_listType) (_lhs_path) (_lhs_ranges) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            HeliumItem _idd _exp_self
        ( _exp_col,_exp_idC,_exp_lamBody,_exp_layoutMap,_exp_newlines,_exp_pIdC,_exp_pres,_exp_self,_exp_spaces,_exp_substitute,_exp_type,_exp_val,_exp_varsInScopeAtFocus) =
            (_exp (0) ([]) ([]) (_lhs_focusD) (_lhs_idC) (emptyFM) (0) (0) (0) (_lhs_path++[0]) (_lhs_ranges) (0) ([]) ([]) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus))
    in  ( _lhs_idC + 10
         ,loc (ItemNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
            col' [ text' NoIDP "HeliumItem $"
                 , row [text' NoIDP "  ", _exp_pres]
                 ]
         ,loc (ItemNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
            row' [itemStart _lhs_ix _lhs_listType, _exp_pres
                                                      `withColor` black
                                                      `withbgColor` white
                                                      `withFontFam` "Courier New" ]
         ,_self
         ,_exp_varsInScopeAtFocus
         )
sem_Item_HoleItem :: (T_Item)
sem_Item_HoleItem (_lhs_focusD) (_lhs_idC) (_lhs_ix) (_lhs_listType) (_lhs_path) (_lhs_ranges) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            HoleItem
    in  ( _lhs_idC,presHole _lhs_focusD "Item" (ItemNode _self _lhs_path) _lhs_path,presHole _lhs_focusD "Item" (ItemNode _self _lhs_path) _lhs_path,_self,_lhs_varsInScopeAtFocus)
sem_Item_ListItem :: (IDD) ->
                     (T_ItemList) ->
                     (T_Item)
sem_Item_ListItem (_idd) (_itemList) (_lhs_focusD) (_lhs_idC) (_lhs_ix) (_lhs_listType) (_lhs_path) (_lhs_ranges) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            ListItem _idd _itemList_self
        ( _itemList_idC,_itemList_pres,_itemList_pres2,_itemList_self,_itemList_varsInScopeAtFocus) =
            (_itemList (_lhs_focusD) (_lhs_idC) (_lhs_path++[0]) (_lhs_ranges) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus))
    in  ( _lhs_idC + 10
         ,loc (ItemNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
            col' [ text' NoIDP "ListItem $"
                 , row [text' NoIDP "  ", _itemList_pres]
                 ]
         ,loc (ItemNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
            row' [ text "   ",
                   _itemList_pres2
                               `withFontSize_` (\fs -> if fs > 5 then fs * 80 `div` 100 else fs)
                 ]
         ,_self
         ,_itemList_varsInScopeAtFocus
         )
sem_Item_ParseErrItem :: (Node) ->
                         (Presentation) ->
                         (T_Item)
sem_Item_ParseErrItem (_node) (_presentation) (_lhs_focusD) (_lhs_idC) (_lhs_ix) (_lhs_listType) (_lhs_path) (_lhs_ranges) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            ParseErrItem _node _presentation
    in  ( _lhs_idC,presParseErr _node _presentation,presParseErr _node _presentation,_self,_lhs_varsInScopeAtFocus)
sem_Item_StringItem :: (IDD) ->
                       (T_String_) ->
                       (T_Item)
sem_Item_StringItem (_idd) (_string) (_lhs_focusD) (_lhs_idC) (_lhs_ix) (_lhs_listType) (_lhs_path) (_lhs_ranges) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            StringItem _idd _string_self
        ( _string_pres,_string_pres2,_string_self) =
            (_string (_lhs_focusD) (_lhs_path++[0]))
    in  ( _lhs_idC + 10
         ,loc (ItemNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
             row' [ text' NoIDP "StringItem ", _string_pres ]
         ,loc (ItemNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
            row' [itemStart _lhs_ix _lhs_listType, _string_pres2]
         ,_self
         ,_lhs_varsInScopeAtFocus
         )
-- ItemList ----------------------------------------------------
{-
   inherited attributes:
      focusD               : FocusDoc
      path                 : [Int]
      ranges               : ([PathDoc],[PathDoc],[PathDoc])
      varsInScope          : FiniteMap String (PathDoc, String)

   chained attributes:
      idC                  : Int
      varsInScopeAtFocus   : FiniteMap String (PathDoc, String)

   synthesised attributes:
      pres                 : Presentation
      pres2                : Presentation
      self                 : ItemList

-}
{-
   local variables for ItemList.HoleItemList:
      self

-}
{-
   local variables for ItemList.ItemList:
      self

-}
{-
   local variables for ItemList.ParseErrItemList:
      self

-}
-- semantic domain
type T_ItemList = (FocusDoc) ->
                  (Int) ->
                  ([Int]) ->
                  (([PathDoc],[PathDoc],[PathDoc])) ->
                  (FiniteMap String (PathDoc, String)) ->
                  (FiniteMap String (PathDoc, String)) ->
                  ( (Int),(Presentation),(Presentation),(ItemList),(FiniteMap String (PathDoc, String)))
-- cata
sem_ItemList :: (ItemList) ->
                (T_ItemList)
sem_ItemList ((HoleItemList )) =
    (sem_ItemList_HoleItemList )
sem_ItemList ((ItemList (_idd) (_listType) (_items))) =
    (sem_ItemList_ItemList (_idd) ((sem_ListType (_listType))) ((sem_Items (_items))))
sem_ItemList ((ParseErrItemList (_node) (_presentation))) =
    (sem_ItemList_ParseErrItemList (_node) (_presentation))
sem_ItemList_HoleItemList :: (T_ItemList)
sem_ItemList_HoleItemList (_lhs_focusD) (_lhs_idC) (_lhs_path) (_lhs_ranges) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            HoleItemList
    in  ( _lhs_idC,presHole _lhs_focusD "ItemList" (ItemListNode _self _lhs_path) _lhs_path,presHole _lhs_focusD "ItemList" (ItemListNode _self _lhs_path) _lhs_path,_self,_lhs_varsInScopeAtFocus)
sem_ItemList_ItemList :: (IDD) ->
                         (T_ListType) ->
                         (T_Items) ->
                         (T_ItemList)
sem_ItemList_ItemList (_idd) (_listType) (_items) (_lhs_focusD) (_lhs_idC) (_lhs_path) (_lhs_ranges) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            ItemList _idd _listType_self _items_self
        ( _listType_idC,_listType_pres,_listType_self,_listType_varsInScopeAtFocus) =
            (_listType (_lhs_focusD) (_lhs_idC + 10) (_lhs_path++[0]) (_lhs_ranges) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus))
        ( _items_idC,_items_path,_items_press,_items_press2,_items_self,_items_varsInScopeAtFocus) =
            (_items (_lhs_focusD) (_listType_idC) (0) (_listType_self) (_lhs_path++[1]) (_lhs_ranges) (_lhs_varsInScope) (_listType_varsInScopeAtFocus))
    in  ( _items_idC
         ,loc (ItemListNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
            col' [ row' [ text' NoIDP "ItemList ", _listType_pres, text' NoIDP " $"]
              , loc (ItemsNode _items_self _items_path) $ structural $ presentFocus _lhs_focusD _items_path $
                   presentList _items_press
              ]
         ,loc (ItemListNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
            row' [ loc (ListTypeNode _listType_self (error "no path")) $ structural $
                     empty
                 , loc (ItemsNode _items_self _items_path) $ structural $ presentFocus _lhs_focusD _items_path $
                     col' _items_press2
                 ]
         ,_self
         ,_items_varsInScopeAtFocus
         )
sem_ItemList_ParseErrItemList :: (Node) ->
                                 (Presentation) ->
                                 (T_ItemList)
sem_ItemList_ParseErrItemList (_node) (_presentation) (_lhs_focusD) (_lhs_idC) (_lhs_path) (_lhs_ranges) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            ParseErrItemList _node _presentation
    in  ( _lhs_idC,presParseErr _node _presentation,presParseErr _node _presentation,_self,_lhs_varsInScopeAtFocus)
-- Items -------------------------------------------------------
{-
   inherited attributes:
      focusD               : FocusDoc
      ix                   : Int
      listType             : ListType
      ranges               : ([PathDoc],[PathDoc],[PathDoc])
      varsInScope          : FiniteMap String (PathDoc, String)

   chained attributes:
      idC                  : Int
      path                 : [Int]
      varsInScopeAtFocus   : FiniteMap String (PathDoc, String)

   synthesised attributes:
      press                : [Presentation]
      press2               : [Presentation]
      self                 : Items

-}
{-
   local variables for Items.ConsItems:
      self

-}
{-
   local variables for Items.HoleItems:
      self

-}
{-
   local variables for Items.NilItems:
      self

-}
{-
   local variables for Items.ParseErrItems:
      self

-}
-- semantic domain
type T_Items = (FocusDoc) ->
               (Int) ->
               (Int) ->
               (ListType) ->
               ([Int]) ->
               (([PathDoc],[PathDoc],[PathDoc])) ->
               (FiniteMap String (PathDoc, String)) ->
               (FiniteMap String (PathDoc, String)) ->
               ( (Int),([Int]),([Presentation]),([Presentation]),(Items),(FiniteMap String (PathDoc, String)))
-- cata
sem_Items :: (Items) ->
             (T_Items)
sem_Items ((ConsItems (_idd) (_item) (_items))) =
    (sem_Items_ConsItems (_idd) ((sem_Item (_item))) ((sem_Items (_items))))
sem_Items ((HoleItems )) =
    (sem_Items_HoleItems )
sem_Items ((NilItems (_idd))) =
    (sem_Items_NilItems (_idd))
sem_Items ((ParseErrItems (_node) (_presentation))) =
    (sem_Items_ParseErrItems (_node) (_presentation))
sem_Items_ConsItems :: (IDD) ->
                       (T_Item) ->
                       (T_Items) ->
                       (T_Items)
sem_Items_ConsItems (_idd) (_item) (_items) (_lhs_focusD) (_lhs_idC) (_lhs_ix) (_lhs_listType) (_lhs_path) (_lhs_ranges) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            ConsItems _idd _item_self _items_self
        ( _item_idC,_item_pres,_item_pres2,_item_self,_item_varsInScopeAtFocus) =
            (_item (_lhs_focusD) (_lhs_idC + 100) (_lhs_ix) (_lhs_listType) (_lhs_path++[_lhs_ix]) (_lhs_ranges) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus))
        ( _items_idC,_items_path,_items_press,_items_press2,_items_self,_items_varsInScopeAtFocus) =
            (_items (_lhs_focusD) (_item_idC) (_lhs_ix + 1) (_lhs_listType) (_lhs_path) (_lhs_ranges) (_lhs_varsInScope) (_item_varsInScopeAtFocus))
    in  ( _items_idC,_lhs_path,_item_pres : _items_press,_item_pres2 : _items_press2,_self,_items_varsInScopeAtFocus)
sem_Items_HoleItems :: (T_Items)
sem_Items_HoleItems (_lhs_focusD) (_lhs_idC) (_lhs_ix) (_lhs_listType) (_lhs_path) (_lhs_ranges) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            HoleItems
    in  ( _lhs_idC,_lhs_path,[presHole _lhs_focusD "Items" (ItemsNode _self _lhs_path) _lhs_path],[presHole _lhs_focusD "Items" (ItemsNode _self _lhs_path) _lhs_path],_self,_lhs_varsInScopeAtFocus)
sem_Items_NilItems :: (IDD) ->
                      (T_Items)
sem_Items_NilItems (_idd) (_lhs_focusD) (_lhs_idC) (_lhs_ix) (_lhs_listType) (_lhs_path) (_lhs_ranges) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            NilItems _idd
    in  ( _lhs_idC,_lhs_path,[],[],_self,_lhs_varsInScopeAtFocus)
sem_Items_ParseErrItems :: (Node) ->
                           (Presentation) ->
                           (T_Items)
sem_Items_ParseErrItems (_node) (_presentation) (_lhs_focusD) (_lhs_idC) (_lhs_ix) (_lhs_listType) (_lhs_path) (_lhs_ranges) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            ParseErrItems _node _presentation
    in  ( _lhs_idC,_lhs_path,[presParseErr _node _presentation],[presParseErr _node _presentation],_self,_lhs_varsInScopeAtFocus)
-- ListType ----------------------------------------------------
{-
   inherited attributes:
      focusD               : FocusDoc
      path                 : [Int]
      ranges               : ([PathDoc],[PathDoc],[PathDoc])
      varsInScope          : FiniteMap String (PathDoc, String)

   chained attributes:
      idC                  : Int
      varsInScopeAtFocus   : FiniteMap String (PathDoc, String)

   synthesised attributes:
      pres                 : Presentation
      self                 : ListType

-}
{-
   local variables for ListType.Alpha:
      self

-}
{-
   local variables for ListType.Bullet:
      self

-}
{-
   local variables for ListType.HoleListType:
      self

-}
{-
   local variables for ListType.Number:
      self

-}
{-
   local variables for ListType.ParseErrListType:
      self

-}
-- semantic domain
type T_ListType = (FocusDoc) ->
                  (Int) ->
                  ([Int]) ->
                  (([PathDoc],[PathDoc],[PathDoc])) ->
                  (FiniteMap String (PathDoc, String)) ->
                  (FiniteMap String (PathDoc, String)) ->
                  ( (Int),(Presentation),(ListType),(FiniteMap String (PathDoc, String)))
-- cata
sem_ListType :: (ListType) ->
                (T_ListType)
sem_ListType ((Alpha (_idd))) =
    (sem_ListType_Alpha (_idd))
sem_ListType ((Bullet (_idd))) =
    (sem_ListType_Bullet (_idd))
sem_ListType ((HoleListType )) =
    (sem_ListType_HoleListType )
sem_ListType ((Number (_idd))) =
    (sem_ListType_Number (_idd))
sem_ListType ((ParseErrListType (_node) (_presentation))) =
    (sem_ListType_ParseErrListType (_node) (_presentation))
sem_ListType_Alpha :: (IDD) ->
                      (T_ListType)
sem_ListType_Alpha (_idd) (_lhs_focusD) (_lhs_idC) (_lhs_path) (_lhs_ranges) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            Alpha _idd
    in  ( _lhs_idC + 10
         ,loc (ListTypeNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
            text' NoIDP "Alpha"
         ,_self
         ,_lhs_varsInScopeAtFocus
         )
sem_ListType_Bullet :: (IDD) ->
                       (T_ListType)
sem_ListType_Bullet (_idd) (_lhs_focusD) (_lhs_idC) (_lhs_path) (_lhs_ranges) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            Bullet _idd
    in  ( _lhs_idC + 10
         ,loc (ListTypeNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
            text' NoIDP "Bullet"
         ,_self
         ,_lhs_varsInScopeAtFocus
         )
sem_ListType_HoleListType :: (T_ListType)
sem_ListType_HoleListType (_lhs_focusD) (_lhs_idC) (_lhs_path) (_lhs_ranges) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            HoleListType
    in  ( _lhs_idC,presHole _lhs_focusD "ListType" (ListTypeNode _self _lhs_path) _lhs_path,_self,_lhs_varsInScopeAtFocus)
sem_ListType_Number :: (IDD) ->
                       (T_ListType)
sem_ListType_Number (_idd) (_lhs_focusD) (_lhs_idC) (_lhs_path) (_lhs_ranges) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            Number _idd
    in  ( _lhs_idC + 10
         ,loc (ListTypeNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
            text' NoIDP "Number"
         ,_self
         ,_lhs_varsInScopeAtFocus
         )
sem_ListType_ParseErrListType :: (Node) ->
                                 (Presentation) ->
                                 (T_ListType)
sem_ListType_ParseErrListType (_node) (_presentation) (_lhs_focusD) (_lhs_idC) (_lhs_path) (_lhs_ranges) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            ParseErrListType _node _presentation
    in  ( _lhs_idC,presParseErr _node _presentation,_self,_lhs_varsInScopeAtFocus)
-- PPPresentation ----------------------------------------------
{-
   inherited attributes:
      focusD               : FocusDoc
      path                 : [Int]
      ranges               : ([PathDoc],[PathDoc],[PathDoc])
      varsInScope          : FiniteMap String (PathDoc, String)

   chained attributes:
      idC                  : Int
      varsInScopeAtFocus   : FiniteMap String (PathDoc, String)

   synthesised attributes:
      pres                 : Presentation
      self                 : PPPresentation

-}
{-
   local variables for PPPresentation.HolePPPresentation:
      self

-}
{-
   local variables for PPPresentation.PPPresentation:
      self

-}
{-
   local variables for PPPresentation.ParseErrPPPresentation:
      self

-}
-- semantic domain
type T_PPPresentation = (FocusDoc) ->
                        (Int) ->
                        ([Int]) ->
                        (([PathDoc],[PathDoc],[PathDoc])) ->
                        (FiniteMap String (PathDoc, String)) ->
                        (FiniteMap String (PathDoc, String)) ->
                        ( (Int),(Presentation),(PPPresentation),(FiniteMap String (PathDoc, String)))
-- cata
sem_PPPresentation :: (PPPresentation) ->
                      (T_PPPresentation)
sem_PPPresentation ((HolePPPresentation )) =
    (sem_PPPresentation_HolePPPresentation )
sem_PPPresentation ((PPPresentation (_idd) (_viewType) (_slides))) =
    (sem_PPPresentation_PPPresentation (_idd) (_viewType) ((sem_Slides (_slides))))
sem_PPPresentation ((ParseErrPPPresentation (_node) (_presentation))) =
    (sem_PPPresentation_ParseErrPPPresentation (_node) (_presentation))
sem_PPPresentation_HolePPPresentation :: (T_PPPresentation)
sem_PPPresentation_HolePPPresentation (_lhs_focusD) (_lhs_idC) (_lhs_path) (_lhs_ranges) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            HolePPPresentation
    in  ( _lhs_idC,presHole _lhs_focusD "PPPresentation" (PPPresentationNode _self _lhs_path) _lhs_path,_self,_lhs_varsInScopeAtFocus)
sem_PPPresentation_PPPresentation :: (IDD) ->
                                     (Bool) ->
                                     (T_Slides) ->
                                     (T_PPPresentation)
sem_PPPresentation_PPPresentation (_idd) (_viewType) (_slides) (_lhs_focusD) (_lhs_idC) (_lhs_path) (_lhs_ranges) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            PPPresentation _idd _viewType _slides_self
        ( _slides_idC,_slides_path,_slides_press,_slides_press2,_slides_self,_slides_varsInScopeAtFocus) =
            (_slides (_lhs_focusD) (_lhs_idC + 1) (0) (_lhs_path++[1]) (_lhs_ranges) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus))
    in  ( _slides_idC
         ,loc (PPPresentationNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
             col' $ [ row' [ text' NoIDP "View type: "
                         ,  if _viewType
                            then (box $ text' NoIDP $ "Edit view") `addPopupItems` [("Change to presentation view",toggleViewType _lhs_path _self)]
                            else (box $ text' NoIDP $"Presentation view") `addPopupItems` [("Change to edit view",toggleViewType _lhs_path _self)]
                          ]
                  , vSpace 10
                  ] ++
                    if _viewType
                    then
                      [ row' [ text' NoIDP "pres ",key NoIDP "=",text' NoIDP " Presentation ", text' NoIDP " $"]
                      , row' [ text' NoIDP "         "
                             , loc (SlidesNode _slides_self _slides_path) $ structural $ presentFocus _lhs_focusD _slides_path $
                                 presentList _slides_press ]
                      ]
                    else
                      [ loc (SlidesNode _slides_self _slides_path) $ structural $ presentFocus _lhs_focusD _slides_path $
                                col' $ intersperse (col' [vSpace 4, hLine, vSpace 4]) _slides_press2
                      ]
         ,_self
         ,_slides_varsInScopeAtFocus
         )
sem_PPPresentation_ParseErrPPPresentation :: (Node) ->
                                             (Presentation) ->
                                             (T_PPPresentation)
sem_PPPresentation_ParseErrPPPresentation (_node) (_presentation) (_lhs_focusD) (_lhs_idC) (_lhs_path) (_lhs_ranges) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            ParseErrPPPresentation _node _presentation
    in  ( _lhs_idC,presParseErr _node _presentation,_self,_lhs_varsInScopeAtFocus)
-- Slide -------------------------------------------------------
{-
   inherited attributes:
      focusD               : FocusDoc
      ix                   : Int
      path                 : [Int]
      ranges               : ([PathDoc],[PathDoc],[PathDoc])
      varsInScope          : FiniteMap String (PathDoc, String)

   chained attributes:
      idC                  : Int
      varsInScopeAtFocus   : FiniteMap String (PathDoc, String)

   synthesised attributes:
      pres                 : Presentation
      pres2                : Presentation
      self                 : Slide

-}
{-
   local variables for Slide.HoleSlide:
      self

-}
{-
   local variables for Slide.ParseErrSlide:
      self

-}
{-
   local variables for Slide.Slide:
      self

-}
-- semantic domain
type T_Slide = (FocusDoc) ->
               (Int) ->
               (Int) ->
               ([Int]) ->
               (([PathDoc],[PathDoc],[PathDoc])) ->
               (FiniteMap String (PathDoc, String)) ->
               (FiniteMap String (PathDoc, String)) ->
               ( (Int),(Presentation),(Presentation),(Slide),(FiniteMap String (PathDoc, String)))
-- cata
sem_Slide :: (Slide) ->
             (T_Slide)
sem_Slide ((HoleSlide )) =
    (sem_Slide_HoleSlide )
sem_Slide ((ParseErrSlide (_node) (_presentation))) =
    (sem_Slide_ParseErrSlide (_node) (_presentation))
sem_Slide ((Slide (_idd) (_title) (_itemList))) =
    (sem_Slide_Slide (_idd) ((sem_String_ (_title))) ((sem_ItemList (_itemList))))
sem_Slide_HoleSlide :: (T_Slide)
sem_Slide_HoleSlide (_lhs_focusD) (_lhs_idC) (_lhs_ix) (_lhs_path) (_lhs_ranges) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            HoleSlide
    in  ( _lhs_idC,presHole _lhs_focusD "Slide" (SlideNode _self _lhs_path) _lhs_path,presHole _lhs_focusD "Slide" (SlideNode _self _lhs_path) _lhs_path,_self,_lhs_varsInScopeAtFocus)
sem_Slide_ParseErrSlide :: (Node) ->
                           (Presentation) ->
                           (T_Slide)
sem_Slide_ParseErrSlide (_node) (_presentation) (_lhs_focusD) (_lhs_idC) (_lhs_ix) (_lhs_path) (_lhs_ranges) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            ParseErrSlide _node _presentation
    in  ( _lhs_idC,presParseErr _node _presentation,presParseErr _node _presentation,_self,_lhs_varsInScopeAtFocus)
sem_Slide_Slide :: (IDD) ->
                   (T_String_) ->
                   (T_ItemList) ->
                   (T_Slide)
sem_Slide_Slide (_idd) (_title) (_itemList) (_lhs_focusD) (_lhs_idC) (_lhs_ix) (_lhs_path) (_lhs_ranges) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            Slide _idd _title_self _itemList_self
        ( _title_pres,_title_pres2,_title_self) =
            (_title (_lhs_focusD) (_lhs_path++[0]))
        ( _itemList_idC,_itemList_pres,_itemList_pres2,_itemList_self,_itemList_varsInScopeAtFocus) =
            (_itemList (_lhs_focusD) (_lhs_idC + 1) (_lhs_path++[1]) (_lhs_ranges) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus))
    in  ( _itemList_idC
         ,loc (SlideNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
            col' [ row' [ text' NoIDP "Slide ", _title_pres, text' NoIDP " $"]
                 , row' [ text' NoIDP "  ", _itemList_pres ]
                 ]
         ,loc (SlideNode _self _lhs_path) $ structural $ presentFocus _lhs_focusD _lhs_path $
             slide _title_pres2
                   _itemList_pres2
         ,_self
         ,_itemList_varsInScopeAtFocus
         )
-- Slides ------------------------------------------------------
{-
   inherited attributes:
      focusD               : FocusDoc
      ix                   : Int
      ranges               : ([PathDoc],[PathDoc],[PathDoc])
      varsInScope          : FiniteMap String (PathDoc, String)

   chained attributes:
      idC                  : Int
      path                 : [Int]
      varsInScopeAtFocus   : FiniteMap String (PathDoc, String)

   synthesised attributes:
      press                : [Presentation]
      press2               : [Presentation]
      self                 : Slides

-}
{-
   local variables for Slides.ConsSlides:
      self

-}
{-
   local variables for Slides.HoleSlides:
      self

-}
{-
   local variables for Slides.NilSlides:
      self

-}
{-
   local variables for Slides.ParseErrSlides:
      self

-}
-- semantic domain
type T_Slides = (FocusDoc) ->
                (Int) ->
                (Int) ->
                ([Int]) ->
                (([PathDoc],[PathDoc],[PathDoc])) ->
                (FiniteMap String (PathDoc, String)) ->
                (FiniteMap String (PathDoc, String)) ->
                ( (Int),([Int]),([Presentation]),([Presentation]),(Slides),(FiniteMap String (PathDoc, String)))
-- cata
sem_Slides :: (Slides) ->
              (T_Slides)
sem_Slides ((ConsSlides (_idd) (_slide) (_slides))) =
    (sem_Slides_ConsSlides (_idd) ((sem_Slide (_slide))) ((sem_Slides (_slides))))
sem_Slides ((HoleSlides )) =
    (sem_Slides_HoleSlides )
sem_Slides ((NilSlides (_idd))) =
    (sem_Slides_NilSlides (_idd))
sem_Slides ((ParseErrSlides (_node) (_presentation))) =
    (sem_Slides_ParseErrSlides (_node) (_presentation))
sem_Slides_ConsSlides :: (IDD) ->
                         (T_Slide) ->
                         (T_Slides) ->
                         (T_Slides)
sem_Slides_ConsSlides (_idd) (_slide) (_slides) (_lhs_focusD) (_lhs_idC) (_lhs_ix) (_lhs_path) (_lhs_ranges) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            ConsSlides _idd _slide_self _slides_self
        ( _slide_idC,_slide_pres,_slide_pres2,_slide_self,_slide_varsInScopeAtFocus) =
            (_slide (_lhs_focusD) (_lhs_idC + 1) (_lhs_ix) (_lhs_path++[_lhs_ix]) (_lhs_ranges) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus))
        ( _slides_idC,_slides_path,_slides_press,_slides_press2,_slides_self,_slides_varsInScopeAtFocus) =
            (_slides (_lhs_focusD) (_slide_idC) (_lhs_ix + 1) (_lhs_path) (_lhs_ranges) (_lhs_varsInScope) (_slide_varsInScopeAtFocus))
    in  ( _slides_idC,_lhs_path,_slide_pres : _slides_press,_slide_pres2 : _slides_press2,_self,_slides_varsInScopeAtFocus)
sem_Slides_HoleSlides :: (T_Slides)
sem_Slides_HoleSlides (_lhs_focusD) (_lhs_idC) (_lhs_ix) (_lhs_path) (_lhs_ranges) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            HoleSlides
    in  ( _lhs_idC,_lhs_path,[presHole _lhs_focusD "Slides" (SlidesNode _self _lhs_path) _lhs_path],[presHole _lhs_focusD "Slides" (SlidesNode _self _lhs_path) _lhs_path],_self,_lhs_varsInScopeAtFocus)
sem_Slides_NilSlides :: (IDD) ->
                        (T_Slides)
sem_Slides_NilSlides (_idd) (_lhs_focusD) (_lhs_idC) (_lhs_ix) (_lhs_path) (_lhs_ranges) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            NilSlides _idd
    in  ( _lhs_idC,_lhs_path,[],[],_self,_lhs_varsInScopeAtFocus)
sem_Slides_ParseErrSlides :: (Node) ->
                             (Presentation) ->
                             (T_Slides)
sem_Slides_ParseErrSlides (_node) (_presentation) (_lhs_focusD) (_lhs_idC) (_lhs_ix) (_lhs_path) (_lhs_ranges) (_lhs_varsInScope) (_lhs_varsInScopeAtFocus) =
    let (_self) =
            ParseErrSlides _node _presentation
    in  ( _lhs_idC,_lhs_path,[presParseErr _node _presentation],[presParseErr _node _presentation],_self,_lhs_varsInScopeAtFocus)
-- String_ -----------------------------------------------------
{-
   inherited attributes:
      focusD               : FocusDoc
      path                 : [Int]

   chained attributes:

   synthesised attributes:
      pres                 : Presentation
      pres2                : Presentation
      self                 : String_

-}
{-
   local variables for String_.HoleString_:
      self

-}
{-
   local variables for String_.ParseErrString_:
      self

-}
{-
   local variables for String_.String_:
      self

-}
-- semantic domain
type T_String_ = (FocusDoc) ->
                 ([Int]) ->
                 ( (Presentation),(Presentation),(String_))
-- cata
sem_String_ :: (String_) ->
               (T_String_)
sem_String_ ((HoleString_ )) =
    (sem_String__HoleString_ )
sem_String_ ((ParseErrString_ (_node) (_presentation))) =
    (sem_String__ParseErrString_ (_node) (_presentation))
sem_String_ ((String_ (_idd) (_string))) =
    (sem_String__String_ (_idd) (_string))
sem_String__HoleString_ :: (T_String_)
sem_String__HoleString_ (_lhs_focusD) (_lhs_path) =
    let (_self) =
            HoleString_
    in  ( presHole _lhs_focusD "String_" (String_Node _self _lhs_path) _lhs_path,presHole _lhs_focusD "String_" (String_Node _self _lhs_path) _lhs_path,_self)
sem_String__ParseErrString_ :: (Node) ->
                               (Presentation) ->
                               (T_String_)
sem_String__ParseErrString_ (_node) (_presentation) (_lhs_focusD) (_lhs_path) =
    let (_self) =
            ParseErrString_ _node _presentation
    in  ( presParseErr _node _presentation,presParseErr _node _presentation,_self)
sem_String__String_ :: (IDD) ->
                       (String) ->
                       (T_String_)
sem_String__String_ (_idd) (_string) (_lhs_focusD) (_lhs_path) =
    let (_self) =
            String_ _idd _string
    in  ( row' [ text' NoIDP "\""
               , loc (String_Node _self _lhs_path) $ parsing $ presentFocus _lhs_focusD _lhs_path $
                   row' [text' NoIDP _string, text' NoIDP ""]
               , text' NoIDP "\""
               ] `withColor` darkViolet
         ,loc (String_Node _self _lhs_path) $ parsing $ presentFocus _lhs_focusD _lhs_path $
             row' [text' NoIDP _string, text' NoIDP ""]
         ,_self
         )

