\documentclass[10pt]{article}

\addtolength{\textwidth}{1in}    
\addtolength{\hoffset}{-0.5in}
\addtolength{\textheight}{1in}
\addtolength{\voffset}{-1in}


\usepackage{../Utils}
\usepackage{eurosym}
\bc

Mention open source


Open questions:

Where is the source located? What happens to images? Efficiency of client when many strings are present?

Need to encode rendering? 


\ec


\bc

\ec



\bc

    * Introduction --short description of the project and goals;
    * Description of innovation:
          o the problem solved by this project;
          o the relative advantage of the proposed innovation;
          o usability: for whom and to what purpose;
          o perspectives for further development of this innovation and/or other technologies. 
    * Project setup --organizational, technical, eventual partners, dependencies on other projects, licenses, and such;
    * Project planning --milestones and related results;
    * Project budgeting;
    * Project risks --which risks can be overseen from the start of the project;
    * Project results dissemination --how the project team is going to disseminate results and to whom, publicity, diffusion of the produced innovation;
    * Possibly, follow-ups on the project. 

\ec

\setlength{\parskip}{\baselineskip}
\addtolength{\topsep}{-\baselineskip}
\setlength{\parindent}{0em}
\renewcommand{\familydefault}{\sfdefault}

\title{Proxima 2.0: WYSIWYG generic editing for Web 2.0\\
\bigskip
        \large NLnet Project plan}
\author{dr Martijn M. Schrage\\
        \small Dept. of Computing Sciences, Utrecht University\\
        \small {\tt martijn@cs.uu.nl}
        }
\date{}
\begin{document}

\maketitle

\todo{Mention compact syntax Relax NG and XML Schema}
\todo{mention that server can be anywhere by using iframe}

\head{Abstract}\\
In line with the Web 2.0 trend, an increasing number of web sites offer visitors the possibility to modify and add content. However, the editors provided are either basic text editors that are awkward for editing complex presentations, or custom-made editors for a specific type of content. A generic editor could be used to create powerful editors with little effort, but has the problem that it needs to be installed on each d.

A server-based generic editor can solve this problem. It will allow the easy creation of WYSIWYG editors on web-pages, without requiring the editing user to install any software. Instead, the browser runs a simple script that draws a rendering of the edited content and sends edit events back to the server.

The Proxima generic editor system has a layered architecture that can be modified in a straightforward way to support a client-server model. Because of the powerful presentation language of Proxima, web-based WYSIWYG editors for a wide range of document types can be created with little effort.

\head{What the NLnet contributions will be used for}\\
The NLnet contribution will be used to realize the web-based client-server version of Proxima. Furthermore, a number of interesting editors will be instantiated to showcase the capabilities of the system, thus helping to  attract the attention of possible contributors to the project.


\head{Comparison with other projects}\\
The project can be compared with two kinds of existing projects: web-based editors and generic editors.

A multitude of web-based editors exist. Examples are Wiki's, the Yahoo!\ Pipes editor, and Google Docs suite. However, these editors are either mainly textual or WYSIWYG but targeted at a single type of document. No existing project offers generic web-based editing. \todo{mention Morphle?}

There are not many generic editing projects that are still being maintained. One example is Citrus (http://www.cs.cmu.edu/~NatProg/citrus.html). On the other hand, also XML editors can be regarded as generic editors, but the existing XML editors that are powerful enough to create interesting WYSIWYG editors, such as XMetaL and XMLSpy, have no support for creating web-based versions of these editors, and neither does Citrus.

The Proxima 2.0 project will be unique in the sense that it will combine WYSIWYG generic editing with web-based editing.

\section{Introduction}
%    * Introduction --short description of the project and goals;

\subsection{Project description}

% web 2.0 more editors. Editors are basic. Complex editors tricky. hand-held devices.
With the advance of Web 2.0, an increasing number of web sites offer visitors the possibility to create content by editing the content of the visited page. An example is Wikipedia, which allows anyone visiting the site to edit its content.

Ideally, a visitor should be able to modify and add content in a WYSIWYG fashion, meaning that during editing, the content looks the same way as when simply viewing it. But unfortunately this is often not the case. For example, in Wikipedia, the editor offers a plain text view of the edited content. Hence, text markup such as bold and italic styles are shown as tags in the editor. Moreover, a graphical entity such as a mathematical formula is shown as text as well. For example, the simple formula $b^2 = a^2 + ab$ needs to be edited as:
 
\begin{center}
\verb|''b''<sup>2</sup>&nbsp;=&nbsp;''a''<sup>2</sup>&nbsp;+&nbsp;''ab''|
\end{center}

Buttons are available for inserting the text for certain tags, but these work purely textual. Hence it is possible to insert a new tag in the text of another tag, invalidating the structure. Furthermore, when an invalid structure arises, the editor offers no support to fix it or point out where the problem is. 

Some sites provide more advanced editors. Take for example the editor for Yahoo!\ Pipes\footnote{Yahoo!\ Pipes: \url|http://pipes.yahoo.com|}, which provides a graphical interface for creating web-based applications using web services from various sources (so-called mash-ups). Structures can be created by dragging components onto a canvas, editing their properties, and connecting their input and output points. Though powerful, such custom-made editors require a significant engineering effort, which puts them out of reach for many applications.

Another problem with custom-made editors is that it is difficult to combine them. If a Wiki site makes use of plug-ins which come with their own specific editor, it is not possible in general to combine the plug-in editors into a single editor. Instead, a page will be a collection of editors, each with their own specific edit model, undo buffer, etc.

The problem of building  editors can be tackled by using a generic editor. When provided with the type of the edited content together with a description of its presentation and the edit behavior, a generic editor produces an editor for that specific type of document. However, this solution would require the installation of the generic editor on each device that is used to edit content, which is a serious disadvantage. 


\bc
Furthermore, a complex editor requires a considerable amount of processing power from the device on which the page is edited. This is not an issue for a desktop or laptop computer, but web pages are being viewed increasingly on small handheld devices and mobile phones. 
\todo{noemen?}
\ec

\bc
The goal of this project is to create a web-based cleint-server version for Proxima. This consists of modifying the rendering part of Proxima to act as a server and communicate with an external rendering client. The client itself will be  a light-weight Ajax script that draws the rendering and captures edit events.  
\ec

Because Internet connections are getting faster and more available quickly, a better solution to this problem is to use a web-based generic editor. The editor runs on a server and communicates with a lightweight client-script that draws a rendering of the edited content on the browser page while sending back edit events. 

The Proxima editor\footnote{Proxima homepage: \url|http://www.cs.uu.nl/research/projects/proxima|} is a generic editor with an architecture that is very well suited to support a client-server model of editing. The resulting web-based editor can provide WYSIWYG editing functionality for web pages with only a fraction of the effort required to build a custom-made editor. Moreover, editors for different kinds of content can easily be mixed. Hence, we can provide edit functionality similar to a textual Wiki, but with a much richer underlying document type. Text can have visual markup, such as different fonts and colors, and editable graphical entities such as formulas can be mixed with the textual content. The client only runs a light-weight script, so no plug-in needs to be installed. Lastly, the editors will have little processing impact on the device that is used to edit the page.

%\todo{mention pipes and more editors here? (and mention we can't do pipes yet?)}

The migration from desktop applications to server based applications is already taking place in other areas. E-mail clients are a good example. The first web interfaces were rather static, but more recent Ajax interfaces such as GMail and Yahoo!\ allow access to e-mail and folders comparable to stand-alone mail clients. Although a mail client requires less communication than an editor, applications of Virtual Network Computing show that server based applications that let all processing be done by the server are feasible. Moreover, since a generic editor need not simply send a bitmap but can send a much more efficient incremental update, the speed will be much higher than when the VNC protocol is used for editing. 

\subsection{Project goals}

Our short-term goal is to showcase the potential of the Proxima technology in order to attract the attention of possible contributors. Proxima is an open-ended system: new object types and presentations can be added to enable the creation of increasingly powerful document types. The hope is that eventually a vibrant community will contribute to a shared repository of resources and push the development of Proxima beyond what a small academia-based group can hope to achieve by itself. 
%\todo{mention that implemented web-page editors will provide good showcase?}


\bc

Using Ajax and Flash technology, user-friendly WYSIWYG editors can be created. Take for example the editor for Yahoo!\ Pipes~\cite{yahoo08pipes}, which provides a graphical interface to create web-based applications using web services from various sources. However, such editors are hard to build. Furthermore, a complex editor requires a considerable amount of processing power from the device on which the page is edited. This is not an issue for a desktop or laptop computer, but web pages are being viewed increasingly on small handheld devices and mobile phones. 

% internet getting better. Create server-based editor
At the same time, the availability of (wireless) Internet is on the rise, with connection speeds rising and costs dropping. Hence, it makes sense to take the editor application away from the local device, and create a server-based editor that processes edit events and communicates changes in the presentation to a light-weight client. The fact that this is feasible can be seen from technologies such as Virtual Network Computing (VNC).

% Proxima good for making editors
The Proxima generic editor~\cite{schrage08proximaHome, schrage04proxima} can be used to easily create WYSIWYG editors for a wide range of document types. An editor can be instantiated by specifying a document type, a document presentation and the edit behavior. Presentations can be a mix of text and graphical elements.The resulting editors allow edit operations on the document structure as well as on its screen representation (i.e.\ free-text editing), without the need to switch between the two modes.

% easy to maked server-based
Because of its architecture, it is straightforward to provide Proxima with a web-based interface. Instead of rendering the presentation to a screen, the updates on the rendering are sent over an HTTP connection to a remote client. The client has a light-weight Ajax renderer that draws the rendering on the browser screen and captures mouse and keyboard events, which are sent back. Since the Proxima has support for incrementality, only updates to the rendering are sent to the client.

\ec

% Project goal


\section{Project description}
%    * Description of innovation:
%          o the problem solved by this project;
%          o the relative advantage of the proposed innovation;
%          o usability: for whom and to what purpose;

\subsection{The problem} 

%web 2.0 meer editing, basic
In line with the Web 2.0 trend, more and more web pages allow visitors to add or modify the content on the page. Among the many examples are Wikipedia, social network sites such as Myspace, or auction sites such as eBay. The facilities for editing, however, are often rather basic. 

% beter kan, maar is duur.
Of course, it is possible to provide custom-made editors, for example, by using Javascript or Flash, or through plug-ins. Examples are the advanced graphical editor for Yahoo!\ pipes, and the editors that are part of Google docs suite. Regarding functionality, these systems approach desktop applications. However, the effort required to build such a custom editor is considerable.

Generic editors could help here

\bc
% internet sneller apparaten kleiner.
% take editor application away from the client.
Another trend is that the availability and speed of Internet connections is increasing, while the costs are dropping. A logical step therefore is to state of affairs suggests that the time is ripe for web-based editors. Rather than running a local editor application, the local machine only runs a light-weight client, which is also suitable for devices with little processing power. A server computes a rendering of the document, which is sent to the local client. The client draws the rendering on the screen and catches mouse and keyboard events, which are sent back to the server. Subsequently, the server computes the corresponding update on the rendering and sends it to the client.

% in e-mail we see it already
The migration from desktop applications to server based applications is already taking place in other areas. E-mail clients are a good example. The first web interfaces were rather static, but more recent Ajax interfaces such as GMail and Yahoo!\ allow access to e-mail and folders comparable to stand-alone mail clients. Although a mail client requires less communication than an editor, applications of Virtual Network Computing show that server based applications that let all processing be done by the server are feasible. Moreover, since a generic editor does not simply send a bitmap but a much more efficient incremental update, the speed will be much higher than when a VNC protocol is used for editing. 
\ec

\subsection{Proxima 1.0}
%Proxima. What is proxima and generic editing

Proxima is a generic editor system developed at Utrecht University. A generic editor is a system that can be used to create editors. To create, or {\em instantiate}, an editor, Proxima needs to be provided with a document type and a number of sheets that describe the presentation of the document and the edit behavior. The content of a Proxima document can be mixed text, images and diagrams. A key feature of Proxima is that the instantiated editors are presentation-oriented. This means that the user performs the edit operations on the WYSIWYG screen presentation of the document. At the same time, edit operations on the document structure (such as changing a section to a subsection) are also possible. The system is written in the functional language Haskell and consists of about 15000 lines of code.

An example of an editor for a sophisticated document type created this way is the Dazzle documentation editor, an editor for the documentation of Bayesian networks. This editor combines graph editing with word-processor functionality. A document contains a Bayesian network (which is essentially a graph) and a list of sections, which contain a view on small part of the graph together with the documentation of that part. 

Figure~\ref{fig:bayesDocEditor} shows a screenshot of the editor. The graph in the figure is an editable subgraph of the main network, so any changes to the edges are also applied to the main network, thereby solving the major problem of maintaining consistency. In the text, tags can be added to denote a reference to a network node. The text also contains references to sections and figures, the numbers of which are automatically computed. Missing references are signaled with squiggly lines.

\begin{figure}[t]
\begin{center}
\includegraphics[width=12cm]{images/subgraph}
\end{center}
\caption{The Bayesian network documentation editor.}
\label{fig:bayesDocEditor}
\end{figure}

Another example of an editor that has been obtained from generic Proxima by instantiation is a source code editor for the functional language Helium (see Figure~\ref{fig:heliumEditor}). The editor shows parse and type errors in place, and allows for graphical presentations of language constructs. Structural edit operations can be combined with free-text editing. Hence, we can use structural edit operations to delete and insert list elements, which automatically removes and adds the necessary commas (or other separators). But at the same time, it is possible to delete the substring ``\p{+2, }'' from the expression ``\p{[ 1+2, 3]}'' (which does not correspond to a structural edit operation), resulting in ``\p{[ 13 ]}''.


An important aspect of Proxima is the fact that a presentation may contain computed values and structures. This is apparent in Figure~\ref{fig:heliumEditor} on the line before the declaration of \p{c}. The value \p{16} is computed automatically, and changes when parameter \p{3} is edited or when the function \p{f} is modified.

\begin{figure}
\begin{center}
\includegraphics[width=12cm]{images/heliumMainWindow}
\end{center}
\caption{The Helium editor.}
\label{fig:heliumEditor}
\end{figure}

Besides these two editors a multitude of editors can be implemented with Proxima. One can think of equation editors, spreadsheets, or text editors for an abbreviated syntax for XML standards such as XML Schema and XSLT, but also more exotic applications, such as a chess board, a family-tree editor, or an on-line multiple choice quiz that keeps track of the score.


\subsection{The Proxima architecture}

The core architecture of Proxima consists of a number of layers, each communicating with its direct neighbors. The layered structure is based on the staged nature of the {\em presentation} process and its inverse, the {\em interpretation} process. The positions at which the document, the rendering, and the intermediate data structures reside are called {\em levels}. Between each pair of levels we have a {\em layer} that maintains the mappings between its adjacent levels. Each layer consists of a presentation component and an interpretation component and may be parameterized by a {\em sheet}. Figure~\ref{fig:levelsAndLayers} schematically shows the levels and layers of Proxima. From a document type definition, a code generator generates a number of Haskell modules, which are compiled together with the sheets and the Proxima base modules to yield an editor. 

\begin{figure}
\begin{center}
\includegraphics[width=12cm]{images/LayerOverview}
\end{center}
\caption{The levels and Layers of Proxima.}
\label{fig:levelsAndLayers}
\end{figure}

A data level in Proxima is not simply an intermediate value in the presentation computation. It is an entity in its own right and maintains part of the state of the editor. The six levels of Proxima are:


\bl
\o {\bf Document:} The document structure.

\o {\bf Enriched Document:} The document attributed with derived values and structures, such as the type of a function or a table of contents.

\o{\bf Presentation:} A logical description of the presentation of the document, consisting of rows and columns of presentation elements with attributes. The presentation also supports formatting based on available space (e.g.\ line breaking).

\o{\bf Layout:} A presentation with explicit white space. 
%, which does not contain tokens.

\o{\bf Arrangement:} A formatted layout with absolute size and position information.

\o{\bf Rendering:} A bitmap of the arrangement.
\el


\bc
We briefly discuss each of the five layers.

\head{Evaluation layer}\\
The evaluation layer takes care of computing derived structures and values over the document, and of mapping updates on these derived structures back to document updates. In this layer, for example, type inference may take place. The layer is parameterized by an {\em evaluation sheet} and a {\em reduction sheet}, which specify the mappings. 

\head{Presentation layer}\\
The presentation layer consists of the presenter and the parser. The presenter takes an enriched document tree and computes a presentation for it according to the {\em presentation sheet}. Its counterpart, the parser, maps a presentation tree back to an enriched document and is parameterized by a {\em parsing sheet}.

\head{Layout layer}\\
The layout layer handles automatic white space, which is maintained in the white-space map that is part of the presentation level. For each token, the layout component looks up the corresponding white space and inserts actual line breaks and spaces in the presentation. The scanner recognizes tokens in the layout level, based on regular expressions specified in the {\em scanning sheet}. It also stores white space in the white-space map. Because mapping tokens to strings is straightforward, the layout component does not need a sheet parameter.

\head{Arrangement layer}\\
In the presentation direction, the arrangement layer computes the precise position and size for each element in the layout level. It also handles line breaking. The arrangement level is not directly editable, so it need not be mapped back onto the layout level. Hence, the only thing that needs to be done in the interpretation direction, is to map absolute coordinates in edit commands to paths in the presentation tree. 

\head{Rendering layer}\\
The renderer creates a bitmap for the arrangement. In the other direction is the gesture interpreter, which maps edit gestures onto edit operations designated for the higher layers.

\ec

%\bl
%\o sometimes awkward, because we have to conform to the layers.
%\o but this has advantages: new GUI lib in a matter of days.
%\el



\bc
Presentation-oriented editing actually takes place at the layout level rather than the presentation level, thus allowing free-text editing also on white space (which is absent on the presentation level). Hence the two levels that are directly editable are the document level and the layout level. 
\ec

After an edit operation on the document, all levels from document to rendering are updated to reflect the update. After an edit operation on the layout level, the modified layout is scanned, parsed and reduced, to obtain the corresponding updated document, from which an updated rendering is computed. Scanning and parsing does not occur after every presentation edit operation. Depending on the editor, it may occur either on a navigation operation, after a certain time interval, or at an explicit request by the user.

In order to instantiate an editor, a number of so called {\em sheets} must be provided:

\bl
\o{\bf Document type definition:} 
A EBNF grammar representation of the document type. It is similar to a monomorphic Haskell data type or an XML Schema, with support for lists.

\o{\bf Presentation sheet:} 
An attribute grammar that specifies for each language construct how it is presented. Simple computations, such as section counters, or static checks on the document (e.g.\ whether a reference is defined) can be implemented as well.

\o{\bf Scanning sheet:}
A set of regular expressions for the tokens in the textual parts of the presentation.

\o{\bf Parsing sheet:} 
A module that contains the parsers for each part of the presentation that is presented textually.
\el

For most editors, the computations can be specified in the presentation sheet. However, for more complex editors, two extra sheets can be provided to deal with derived structures and values: the {\em evaluation sheet} and its inverse, the {\em reduction sheet}.  

\bl
\o{\bf Evaluation sheet:}
Can be used to specify derived structures, such as a table of contents, or a table whose structure depends on information in the document. 

\o{\bf Reduction sheet:}

The reduction sheet specifies how updates on derived structures are mapped back onto the document. In many cases, derived values are not editable, in which case the reduction sheet simply ignores the value. However, in some cases, updates on a derived structure correspond to logical updates on the document. One can think of editing the title in a table of contents, or swapping two section titles, which causes the actual sections to swap as well. 
\el


\subsection{Proxima 2.0}

Turning Proxima into a web-based editor will not have a large impact on the overall implementation. Because of the strict separation between layers, which is enforced by the architecture, only four relatively small modules contain GUI-specific code. When the system needed to be ported to a new GUI library, this only took a couple of days. Hence, implementing support for an external renderer will be a relatively straightforward operation. In fact, an early version of Proxima actually used a stand-alone renderer client that it communicated with through a socket connection.

In order to realize the web-based functionality, three components need to be developed:

\bl
\o An HTTP server that sends a rendering to a client and retrieves the edit commands. 

\o A Proxima rendering module that renders the arrangement to an XML string that is handled by the client.

\o An Ajax client that renders a presentation on the screen and captures edit events, which are sent to the server.
\el

\subsubsection{The HTTP server}

A simple HTTP server will handle incoming requests and start a Proxima session for each new request. The Proxima session is quite similar to an ordinary Proxima session, except that instead of catching edit events directly and drawing the rendering updates on the screen, the events are received from a socket connection, and updates are sent over  this socket. This functionality can be added to the current GUI module, which contains the event loop that handles events and draws the rendering onto the screen. 
 
\subsubsection{The web-based renderer}

The current renderer creates drawing commands for the GTK windowing toolkit. It traverses the arrangement data structure, and produces commands for changed parts of the arrangement that are currently in view. The new renderer will be very similar but instead of a list of commands, it will produce an XML string.

\subsubsection{The Ajax client}

The main implementation effort of the project will be the Ajax client. It will capture mouse and keyboard events and send these to the Proxima server. In response, it will receive an XML structure that corresponds to the update on the rendering. Textual parts of the rendering, as well as images, can be mapped onto DHTML elements. Other graphical elements, such as lines, need to be drawn separately.

\bc
\subsection{Usability}

The usability of a web-based editor depends largely on its efficiency. The Proxima renderer only generates a rendering for that part of the presentation that is currently visible on the screen. Furthermore, because Proxima has support for incrementality, only updates to the rendering are sent over the socket, rather than the entire screen. Hence, most edit operations only causes a minimal amount of communication. Only when an update has a more global effect, the amount of data transferred will increase. Nevertheless, a small delay that occurs only once in a while is not a serious hindrance during editing. 

bc
At the moment, moved blocks are not recognized, since the screen renderer performed well enough without this. For web-based editors, however, this is more important, as the creation of a new line would cause half the page to be transmitted. Fortunately, the renderer provides hooks to be extended to recognize moved blocks, and create a move command for these.
ec

Another aspect of the usability is the latency in the server connection. Even if the transfer speed is high enough, there might be a delay in the response from the server. bc 
In order to handle this, the render can create a predictive rendering in response to an edit event, which is updated when the result of the server is received.
ec
A simple solution to this is to insert typed characters at the location of the focus in the current rendering, copying the style from surrounding characters, until the rendering update is received. Latency could also affect drag and drop editing, but a simple solution here is to show an outline of the focused object at the current mouse position. 

However, experiments with a simple web-based text editor have shown response times to be more than adequate over a wireless ADSL connection, even when several kilobytes of date wer transmitted. Hence, efficiency and latency are not expected to pose serious problems. 
\ec

\subsection{Relative advantage of proposed innovation}

Easy to build advanced editors for web pages. Clients have no installation, don't need much power. Servers easily installable.


\subsection{Usability}

One must distinguish between two levels of users of the web-based Proxima technology. One level are the people who generate specific Proxima instantiations by supplying the required sheets (in particular document type definition and presentation sheet). Except for very simple instantiations, creating these wholly anew requires considerable skills. However, as the repository of sheets grows, it will become increasingly possible to cobble new instantiations together by combining pre-existing elements.  Dedicated sheet editors (themselves instantiations of Proxima) can be created to assist in this task.  In any case, even with the very limited current repository, generating an instantiation is definitely much less effort than creating an equivalent editor de novo.

The other level of users consists of the visitors of websites who use a site-specific instantiation of Proxima to edit content on web pages. Here the usability will depend on the specifics of the instantiation and the complexity of the application.  Proxima offers powerful possibilities for support of the edit task, as explained above. (Of course, there is no guarantee that an instantiation will actually make use of these.)






\subsection{Further development}
%          o perspectives for further development of this innovation and/or other technologies. 

Project like proxima, many possibilities for future development.
\bl
\o Database connections
\o Incrementality in parser for larger documents
\o Graphical editing
\el

When the web-based functionality has been added to Proxima, an interesting extension will be the connection of Proxima to a database. Documents are now internal data structures, but it will be interesting to obtain subtrees of the document from a database. Furthermore, More incrementality, so larger documents can be edited. Also focus on parsing. Now only graphs and text which is parsed. To do Yahoo pipes, more general graphical editing. Formula editing.

Also infrastructure, multiple requests, servers? And related to this, how can Proxima be connected to a


Large documents. increases load on server. incremental behavior in parsing and presentation. small change on presentation, small change in doc small change in rendering updat.

More interesting edit model. Now graphs and text. drag and drop, connecting pipes. also incremental


\section{Project setup}
%    * Project setup --organizational, technical, eventual partners, dependencies on other projects, licenses, and such;

Work can be done at the Software technology group of Utrecht University, lead by Prof. Dr. S.D. Swierstra. The software technology has 

Builds upon the Proxima research project at Utrecht University

Group has valueable knowledge of Haskell (lang of Proxima) but also expertise on Javascript and Ajax technology. All libraries used are open source
and used libraries are open source.


\subsection{Planning}

%    * Project planning --milestones and related results;
The available time will be around 25 weeks

\bl
\o Realize Proxima web server and client (8 weeks)
\o Work on underlying Proxima editor (4 weeks)
% rich text editing, drag and drop
\o Implement sample editors (6 weeks)
\o Speed it up. (4 weeks)
\o 3 weeks more
\el
maybe server, handle sessions, show rendering when busy.

% following is probably to detailed
%\bl
%\o investigate Ajax an DHTML technologies
%\o setup Web server on simple web server and implement simple Ajax client
%\o determine format of rendering
%\o implement web server connections, and url that describes document location.
%\o perhaps make more efficient encoding of rendering.
%\o add compression to data using gzip library
%\o implement an editor plugin for wiki
%\o server-side file handling
%\o incrementality for block moves
%\o how to connect with a standard web-server
%\o page blocking
%\o improve Proxima server, drag \& drop, rich text editing.
%\o build sample editors.
%\el

\subsection{Budget}
%    * Project budgeting;

\bc
personeelskosten
1425       70%
3176 bruto 70%  (+werkgeversaandeel)
4537       100%

waarschijnlijk + 500 aan overhead
geen btw

\ec

The requested 30.000 \euro will be used to employ one postDoc for a duration of approximately six months. The position will be filled by the requestor, Martijn Schrage, who has also designed and implemented the Proxima generic editor. He has ... experience in writing large software systems in Haskell and Java. 

Developer of Proxima. Experience in Haskell, Java, C\#, Javascript.

\subsection{Risks}
%    * Project risks --which risks can be overseen from the start of the project;


The usability of a web-based editor can be adversely affected by large delays in updates. Because Proxima has support for incrementality, only rendering updates are sent over the socket, rather than the entire rendering. Moreover, only for those parts of the rendering that are visible on screen, updates are transmitted. Therefore, most edit operations require only a very small amount of communication. Experiments with a simple web-based text editor have shown response times to be more than adequate over a wireless ADSL connection, even when several kilobytes of data were transmitted. Hence, latency is not expected to pose serious problems. 
 

One risk is efficiency. Latency may cause unpleasant editing. But experiments are quite promising, and latency problems can be overcome by predictive rendering. 




The biggest challenge we have to face is to create a community of people working on Proxima. We elaborate on this in the next section.

\subsection{Dissemination of results}
%   * Project results dissemination --how the project team is going to disseminate results and to whom, publicity, diffusion of the produced innovation;


Light weight of editors is an advantage. Anyone visiting a page can test the editors. Furthermore, a server is easy to install, .

In order to help this, we will build severeal example editors, such as a 
Implement several editors: Wiki like editor, on-line quiz


Sample applications. Servers are light weight, and clients are extremely light-weight. Pretty much any Browser on any major platform. Makes it easy to showcase the technology. Attract people


%\subsection{Follow-ups}
%
%%    * Possibly, follow-ups on the project. 
% 
% No follow-ups are planned. Proxima is its own follow-up.


\end{document}



\bc
Links for the implementation:

graphical elements:
http://www.walterzorn.com/jsgraphics/jsgraphics_e.htm

key events:
http://unixpapa.com/js/key.html
http://unixpapa.com/js/testkey.html

mouse events:
http://javascript.internet.com/page-details/mouse-coordinates.html
http://weston.canncentral.org/web_lab/onmousemove/testmousepos.js
http://unixpapa.com/js/testmouse.html

XRay, good for analyzing html pages
\ec


