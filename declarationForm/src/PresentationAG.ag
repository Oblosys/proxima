imports
{
import Common.CommonTypes hiding (Dirty (..))
import Common.CommonUtils
import GHC.Float (formatRealFloat, FFFormat(FFFixed))

import Presentation.PresLayerTypes
import Presentation.PresLayerUtils

import Presentation.XprezLib
import Presentation.XLatex hiding (bold)

import Evaluation.DocumentEdit

import List
import Maybe
import qualified Data.Map as Map
import Data.Map (Map)


import Evaluation.DocTypes (DocumentLevel (..))
import DocTypes_Generated
import DocUtils_Generated
import DocumentEdit_Generated

import ProxParser   
}

INCLUDE "PresentationAG_Generated.ag"


SEM EnrichedDoc
  | RootEnr
      loc.pres = structural $ @choiceDoc.pres
                   
SEM ChoiceDoc
  | FormDoc
      loc.pres = structural $ @form.pres `withbgColor` lightBlue
  | TaskDoc
      loc.pres = structural $ @tasks.pres
                   
SEM Form
  | Form
      loc.pres = structural $ leftTopMargins 30 40 $
                   col [ text "Travel declaration form"
                       , vSpace 5
                       , textField 400 @name.pres
                       , vSpace 5
                       , textField 400 @faculty.pres
                       , vSpace 10
                       , text "Expenses" `addPopupItems` 
                           [ ("Add expense", insertElementAtEnd (toClip newExpense) (@lhs.path++[2]))
                           ]
                       , @expenses.pres
                       , row [ hSpace (400 + 5 + 30 + 5 + 60 + 10 + 6)
                             , textField 120 (text $ showCurrency @expenses.total ++ " Euro")
                             ]
                       , vSpace 30
                       , @currencies.pres `withFontSize_` (\fs -> (fs * 80) `div` 100) 
                       ] 
SEM List_Expense
 | List_Expense
      loc.pres = structural $ 
                   col $ intersperse (vSpace 5) @elts.press

SEM Expense
  | Expense
      loc.pres = structural $ addCurrencyItems @lhs.allCurrencies @lhs.path $
                   row [ textField 400 @description.pres
                       , hSpace 5
                       , textField 30 @amount.pres
                       , hSpace 5
                       , textField 60 $ (text $ fst $ index "Expense.pres" @lhs.allCurrencies @currencyIx)
                       , hSpace 10
                       , textField 120 (text $ showCurrency @total ++ " Euro") 
                                       -- Expense.total is total euro amount for one expense
                       ] `addPopupItems` 
                       [ ("Delete", deleteAt @lhs.path)
		       ]
                         
                       

SEM List_Currency [ | | ]
 | List_Currency
      loc.pres = structural $ 
                   row $ intersperse (hSpace 5) @elts.press ++
                         [ hSpace 5, text "add currency" `withMouseDown` addNewCurrency @lhs.path ]

  
SEM Currency
  | Currency
      loc.pres = structural $ col [ textField 80 @name.pres
                                  , textField 120 @euroRate.pres
                                  ]


-- currency names and rates are put in synthesized attribute that is inherited to Expenses
  
ATTR List_Currency ConsList_Currency Currency
     [ | | allCurrencies USE {++} {[]} : {[(String,Float)]} ]

SEM Currency
  | Currency
      lhs.allCurrencies = [(@name.strVal, @euroRate.floatVal)]

ATTR List_Expense ConsList_Expense Expense
     [ allCurrencies : {[(String,Float)]} | | ]

SEM Form
  | Form
      expenses.allCurrencies = @currencies.allCurrencies


ATTR List_Expense ConsList_Expense Expense 
     [ | | total USE {+} {0} : {Float} ]
                         
SEM Expense
  | Expense
      loc.total = @amount.floatVal * (snd $ index "Expense.total" @lhs.allCurrencies @currencyIx)
        
{

addCurrencyItems currencies path pres = 
  pres `addPopupItems` [ (name, setCurrencyIx path ix) | (ix, (name, _)) <- zip [0..] currencies ]

addNewCurrency :: Path -> UpdateDoc Document ClipDoc
addNewCurrency pth =
  insertElementAtEnd newCurrency pth

newExpense = Expense (Description "") (FloatField 0) 0
  
newCurrency = Clip_Currency $ Currency (Description "new") (FloatField 0.0)

setCurrencyIx :: Path -> Int -> UpdateDoc Document ClipDoc
setCurrencyIx pth newCurrencyIx= 
  \(DocumentLevel doc focus clip) ->
    let doc' = case selectD pth doc of
                 Clip_Expense (Expense desc amount _) -> 
                   pasteD pth (Clip_Expense (Expense desc amount newCurrencyIx)) doc
                 _ -> doc
    in  DocumentLevel doc' focus clip


-- Presentation utils

leftTopMargins left top pres = 
  row [ hSpace left, col [ vSpace top, pres, empty `withStretch` True ], empty `withStretch` True] 
  `withStretch` True
  
textField w pres = boxed $ row [pres, empty `withHStretch` True]  `withbgColor` white `withWidth` w  

-- Utils


showCurrency :: Float -> String
showCurrency f =
    let s = formatRealFloat FFFixed (Just 2) f
        s' = reverse s -- s -- dropWhile (== '0') (reverse s)
        s'' = if head s' == '.' then '0':s' else s'
    in reverse s''
}

-- TODO: why does withStretch not override col and row stretch settings?
-- Stretch does not seem to work for text fields anymore
-- empty has no background








SEM Description [ | | strVal : String ]
  | Description
      loc.pres = parsingWithParser pDescription @self $ text @str
      lhs.strVal = @str
  | HoleDescription
      lhs.strVal = "{Description}"
  | ParseErrDescription
      lhs.strVal = "{parse error}"

SEM FloatField [ | | floatVal : Float ]
  | FloatField
      loc.pres = parsingWithParser pFloatField @self $ text (show @float)
      lhs.floatVal = @float
  | HoleFloatField
      lhs.floatVal = 0
  | ParseErrFloatField
      lhs.floatVal = 0







SEM Tasks
  | Tasks
      loc.pres = structural $ row [ hSpace 4
      	       	 	      	  , col [ text "Tasks:"
      	       	 	      	    	`addPopupItems` 
                                        ([ ("Insert task", insertElementAtEnd (toClip newTask) (@lhs.path++[1]))
                                         ] ++ showHideCompletedItem @lhs.path @self)
					, @tasks.pres `withFontSize` 12
					]
				  ]

SEM List_Task
  | List_Task
      loc.pres = structural $ 
                   col @elts.press

SEM Task
  | BasicTask
      loc.pres = structural $ showHideCompleted @lhs.showCompleted @completed $
                              row [ hSpace $ 9 + 5
                                  , presentCompleted @completed (not @completed)
                                      `withMouseDown` flipCompleted @lhs.path @self

                                  , hSpace 5, vRefHalf $ @description.pres `withColor` if @completed then green else blue]
                              `addPopupItems` 
 			      ([ ("Delete task", fixTask @lhs.path . deleteAt @lhs.path)
			       , ("Insert subtask", changeToComposite @lhs.path)
                               ] ++ mkMoveItems @lhs.path)
  | CompositeTask
      loc.pres = structural $ showHideCompleted @lhs.showCompleted @subtasks.completed $
                              col $ row [ (if @expanded then minusImg else plusImg) `withRef` (0,4)
                                          `withMouseDown` flipExpanded @lhs.path @self
                                        , hSpace 5
                                        , presentCompleted @subtasks.completed @subtasks.notStarted
                                            `withMouseDown` setCompletedRec (not @subtasks.completed) @lhs.path @self
                                        , hSpace 5
                                        , vRefHalf $ @description.pres
                                             `withColor` if @subtasks.completed then green else blue
                                        ] `addPopupItems` 
                                        ([ ("Delete task", deleteAt @lhs.path)
					 , ("Insert subtask", insertElementAtEnd (toClip newTask) (@lhs.path++[2]))
                                         ] ++ mkMoveItems @lhs.path)
 
                                  : if @expanded 
                                    then [row [hSpace $ 9 + 5, @subtasks.pres]] 
                                    else []



-- copy showCompleted field down to tasks
ATTR List_Task ConsList_Task Task
     [ showCompleted : Bool | | ]

SEM Tasks
  | Tasks 
      tasks.showCompleted = @showCompleted

ATTR List_Task ConsList_Task Task 
     [ | | completed USE {&&} {True} : {Bool} ]

ATTR List_Task ConsList_Task Task 
     [ | | notStarted USE {&&} {True} : {Bool} ]

SEM Task
  | BasicTask
      loc.completed = @completed
      loc.notStarted = not @completed

{
showHideCompleted showCompleted completed pres = 
  if showCompleted || not completed then pres else empty

showHideCompletedItem pth (Tasks showCompleted _) = 
  [ ((if showCompleted then "Hide " else "Show ") ++ " completed tasks"
    , updateAt pth $ \clip ->
        case clip of
          Clip_Tasks (Tasks _ tasks) -> toClip $ Tasks (not showCompleted) tasks
          clip -> clip
    )
  ]
showHideCompletedItem _ _ = []

flipCompleted pth (BasicTask descr completed) = pasteAt (Clip_Task (BasicTask descr (not completed))) pth

flipExpanded pth (CompositeTask expanded descr subtasks) = pasteAt (Clip_Task (CompositeTask (not expanded) descr subtasks)) pth

setCompletedRec completed pth task = pasteAt (Clip_Task (setCompletedRec' task)) pth
 where setCompletedRec' (BasicTask descr _) = BasicTask descr completed
       setCompletedRec' (CompositeTask exp descr subtasks) = CompositeTask exp descr $ toList_Task $ map setCompletedRec' (fromList_Task subtasks)

presentCompleted completed notStarted = vRefHalf $ 
  img (if completed then "img/completed.bmp" else if notStarted then "img/notStarted.bmp" else "img/partiallyCompleted.bmp") `withSize` (9,9) `withRef` (4,4)


-- change parent composite to basic if it has no subtasks
fixTask [] = id
fixTask [_] = id
fixTask pth = 
  let parentPath = (init (init pth))
  in  updateAt parentPath $ \clip ->
        case clip of
          Clip_Task (CompositeTask _ descr (List_Task Nil_Task)) -> 
            toClip $ BasicTask descr False
          clip -> clip

changeToComposite pth =
  updateAt pth $ \clip ->
    case clip of
      (Clip_Task (BasicTask descr _)) ->
        Clip_Task $ CompositeTask True descr $
          toList_Task [newTask]
      clip -> clip 

-- TODO: we either need the entire document here, or an isLast attribute to hide move down
--       in case of the last task.
mkMoveItems [] = []
mkMoveItems pth =
 -- if last pth > 0 
 -- then 
 [ ("Move task up", moveTaskUp pth), ("Move task down", moveTaskDown pth) ]

moveTaskUp []  = id
moveTaskUp pth = 
  let parentListPth = init pth
      indexInList = last pth
  in  \(DocumentLevel d f cl) ->
        if indexInList > 0
        then let elt = selectD pth d
                 (d', f') = deleteD pth d
                 d'' = insertListD parentListPth (indexInList - 1) elt d'
             in  DocumentLevel d'' f cl
        else DocumentLevel d f cl

moveTaskDown []  = id
moveTaskDown [_] = id
moveTaskDown pth =
  let parentListPth = init pth
      indexInList = last pth
  in  \(DocumentLevel d f cl) ->
        if indexInList < arityClip (selectD parentListPth d) - 1
        then let elt = selectD pth d
                 (d', f') = deleteD pth d
                 d'' = insertListD parentListPth (indexInList + 1) elt d'
             in  DocumentLevel d'' f cl
        else DocumentLevel d f cl

newTask = BasicTask (Description "") False

-- TODO: move these to library

-- called deleteAtPath in dazzleEditor

deleteAt :: Path -> UpdateDoc Document ClipDoc
deleteAt pth =
   \(DocumentLevel d _ cl) ->
     editCutD (DocumentLevel d (PathD pth) cl)

pasteAt :: ClipDoc -> Path -> UpdateDoc Document ClipDoc
pasteAt clip pth =
  \(DocumentLevel d path cl) ->
    let (DocumentLevel d' _ _) = editPasteD (DocumentLevel d (PathD pth) clip)
    in  (DocumentLevel d' path cl)

updateAt :: Path -> (ClipDoc -> ClipDoc) -> UpdateDoc Document ClipDoc
updateAt pth f =
  \(DocumentLevel d path cl) ->
    let clip = f (selectD pth d)
        (DocumentLevel d' _ _) = editPasteD (DocumentLevel d (PathD pth) clip)
    in  (DocumentLevel d' path cl)


-- PRECONDITION: path points to a list element of the same type as clip
addElementAfter :: ClipDoc -> Path -> UpdateDoc Document ClipDoc
addElementAfter clip path = 
  \(DocumentLevel d pth cl) ->
    (DocumentLevel (insertListD (init path) (last path+1) clip d) pth cl)

-- PRECONDITION: path points to a list of elements of the same type as clip
-- NB path points to the list, rather than to an element.
insertElementAtHead :: ClipDoc -> Path -> UpdateDoc Document ClipDoc
insertElementAtHead  clip listPath = 
  \(DocumentLevel d pth cl) ->
    (DocumentLevel (insertListD listPath 0 clip d) pth cl)

-- PRECONDITION: path points to a list of elements of the same type as clip
-- NB path points to the list, rather than to an element.
insertElementAtEnd :: ClipDoc -> Path -> UpdateDoc Document ClipDoc
insertElementAtEnd  clip listPath = 
  \(DocumentLevel d pth cl) ->
    let list = selectD listPath d
    in  (DocumentLevel (insertListD listPath (arityClip list) clip d) pth cl)
}