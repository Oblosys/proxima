optpragmas
{
{-# LANGUAGE MonoLocalBinds #-}
}
imports
{
import Common.CommonTypes hiding (Dirty (..))
import Common.CommonUtils
import GHC.Float (formatRealFloat, FFFormat(FFFixed))

import Presentation.PresLayerTypes
import Presentation.PresLayerUtils

import Presentation.XprezLib
import Presentation.XLatex hiding (bold)
import Layout.LayTypes
import Proxima.Wrap

import Evaluation.DocumentEdit

import Data.List
import Data.Maybe
import qualified Data.Map as Map
import Data.Map (Map)


import Evaluation.DocTypes (DocumentLevel (..))
import DocTypes_Generated
import DocUtils_Generated
import DocumentEdit_Generated
import ProxParser   

import Sudoku hiding (fst3, snd3, thd3)
}

INCLUDE "PresentationAG_Generated.ag"


SEM EnrichedDoc
  | RootEnr
      loc.pres = structural $ @choiceDoc.pres
                   
SEM ChoiceDoc
  | SudokuDoc
      loc.pres = structural $ @sudoku.pres
SEM Sudoku
  | Sudoku
      loc.pres = structural $ (col [ -- bold $ @f.pres, 
                                           bold $ @i.pres `withColor` black
                                        , text "wtf"]   )


SEM Float_ [ | |  ]
  | Float_
      loc.pres = parsingWithParserLexer pFloat_ (Lexer Lex.float NonStyled) @self $ text (show @value)
  | HoleFloat_
  | ParseErrFloat_


-- todo remame
-- not quite an unboxed int, due to empty presentation for 0
SEM Fload_ [ | | ]
  | Fload_
      loc.pres = parsingWithParserLexer pFload_ (Lexer (Lex.float) NonStyled) @self $ text (show @value)
  | HoleFload_
  | ParseErrFload_


{
}



{
-- TODO: move these to library

-- called deleteAtPath in dazzleEditor

deleteAt :: Path -> UpdateDoc Document ClipDoc
deleteAt path =
   \(DocumentLevel d _ cl) ->
     editCutD (DocumentLevel d (PathD path) cl)

pasteAt :: Path -> ClipDoc -> UpdateDoc Document ClipDoc
pasteAt path clip =
  \(DocumentLevel d pathD cl) ->
    let (DocumentLevel d' _ _) = editPasteD (DocumentLevel d (PathD path) clip)
    in  (DocumentLevel d' pathD cl)

updateAt :: Path -> (ClipDoc -> ClipDoc) -> UpdateDoc Document ClipDoc
updateAt path f =
  \(DocumentLevel d pathD cl) ->
    let clip = f (selectD path d)
        (DocumentLevel d' _ _) = editPasteD (DocumentLevel d (PathD path) clip)
    in  (DocumentLevel d' pathD cl)


-- PRECONDITION: path points to a list element of the same type as clip
addElementAfter :: ClipDoc -> Path -> UpdateDoc Document ClipDoc
addElementAfter clip path = 
  \(DocumentLevel d pathD cl) ->
    (DocumentLevel (insertListD (init path) (last path+1) clip d) pathD cl)

-- PRECONDITION: path points to a list of elements of the same type as clip
-- NB path points to the list, not to an element.
insertElementAtHead :: ClipDoc -> Path -> UpdateDoc Document ClipDoc
insertElementAtHead  clip listPath = 
  \(DocumentLevel d pathD cl) ->
    (DocumentLevel (insertListD listPath 0 clip d) pathD cl)

-- PRECONDITION: path points to a list of elements of the same type as clip
-- NB path points to the list, not to an element.
insertElementAtEnd :: ClipDoc -> Path -> UpdateDoc Document ClipDoc
insertElementAtEnd  clip listPath = 
  \(DocumentLevel d pathD cl) ->
    let list = selectD listPath d
    in  (DocumentLevel (insertListD listPath (arityClip list) clip d) pathD cl)

-- up/down? maybe choose better name
-- PRECONDITION: path points to an element in a list
moveElementUp []  = id
moveElementUp path = 
  let parentListPath = init path
      indexInList = last path
  in  \(DocumentLevel d f cl) ->
        if indexInList > 0
        then let elt = selectD path d
                 (d', f') = deleteD path d
                 d'' = insertListD parentListPath (indexInList - 1) elt d'
             in  DocumentLevel d'' f cl
        else DocumentLevel d f cl

-- PRECONDITION: path points to an element in a list
moveElementDown []  = id
moveElementDown path =
  let parentListPath = init path
      indexInList = last path
  in  \(DocumentLevel d f cl) ->
        if indexInList < arityClip (selectD parentListPath d) - 1
        then let elt = selectD path d
                 (d', f') = deleteD path d
                 d'' = insertListD parentListPath (indexInList + 1) elt d'
             in  DocumentLevel d'' f cl
        else DocumentLevel d f cl
}





