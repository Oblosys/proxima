imports
{
import Common.CommonTypes hiding (Dirty (..))
import Common.CommonUtils
import GHC.Float (formatRealFloat, FFFormat(FFFixed))

import Presentation.PresLayerTypes
import Presentation.PresLayerUtils

import Presentation.XprezLib
import Presentation.XLatex hiding (bold)

import Evaluation.DocumentEdit

import List
import Maybe
import qualified Data.Map as Map
import Data.Map (Map)


import Evaluation.DocTypes (DocumentLevel (..))
import DocTypes_Generated
import DocUtils_Generated
import DocumentEdit_Generated

import ProxParser   

import Sudoku hiding (fst3, snd3, thd3)
}

INCLUDE "PresentationAG_Generated.ag"


SEM EnrichedDoc
  | RootEnr
      loc.pres = structural $ @choiceDoc.pres
                   
SEM ChoiceDoc
  | FormDoc
      loc.pres = structural $ @form.pres `withbgColor` lightBlue
  | TaskDoc
      loc.pres = structural $ @tasks.pres
  | SudokuDoc
      loc.pres = structural $ @sudoku.pres
                   
SEM Form
  | Form
      loc.pres = structural $ leftTopMargins 30 40 $
                   col [ text "Travel declaration form"
                       , vSpace 5
                       , textField 400 @name.pres
                       , vSpace 5
                       , textField 400 @faculty.pres
                       , vSpace 10
                       , text "Expenses" `addPopupItems` 
                           [ ("Add expense", insertElementAtEnd (toClip newExpense) (@lhs.path++[2]))
                           ]
                       , @expenses.pres
                       , vSpace 5
                       , row [ img "img/add.png" `withSize` (23,20) `withVRef` 10
       		               `withMouseDown` insertElementAtEnd (toClip newExpense) (@lhs.path++[2])
			     , hSpace 5
			     , vRefHalf $ text "add expense" 
		             , empty `withHStretch` True
                             , col [ empty `withSize` (120,2) `withbgColor` black
                                   , vSpace 5
                                   , textField 120 (text $ showCurrency @expenses.total ++ " Euro")
                                   ] `withVRef` (10)
			     ]
                       , vSpace 15
                       , @currencies.pres `withFontSize_` (\fs -> (fs * 80) `div` 100) 
                       ] 
SEM List_Expense
 | List_Expense
      loc.pres = structural $ 
                   col $ intersperse (vSpace 5) @elts.press

SEM Expense
  | Expense
      loc.pres = structural $ addCurrencyItems @lhs.allCurrencies @lhs.path $
                   row [ textField 400 @description.pres
                       , hSpace 5
                       , textField 60 @amount.pres
                       , hSpace 5
                       , textField 80 $ (text $ fst $ index "Expense.pres" @lhs.allCurrencies @currencyIx)
                       , hSpace 10
                       , textField 120 (text $ showCurrency @total ++ " Euro") 
                                       -- Expense.total is total euro amount for one expense
                       ] `addPopupItems` 
                       [ ("Delete expense", deleteAt @lhs.path)
		       , ("Move expense up", moveElementUp @lhs.path)
		       , ("Move expense down", moveElementDown @lhs.path)
		       ]
                         
                       

SEM List_Currency [ | | ]
 | List_Currency
      loc.pres = structural $ 
                   col [ row $ intersperse (hSpace 5) @elts.press
                       , vSpace 5
                       , row [ img "img/add.png" `withSize` (23,20) `withVRef` 10
       		       	       `withMouseDown` addNewCurrency @lhs.path
			     , hSpace 5
			     , vRefHalf $ text "add currency" 
			     ]
		       ]

  
SEM Currency
  | Currency
      loc.pres = structural $ col [ textField 120 @name.pres
                                  , vSpace 4
				  , textField 120 @euroRate.pres
                                  ]


-- currency names and rates are put in synthesized attribute that is inherited to Expenses
  
ATTR List_Currency ConsList_Currency Currency
     [ | | allCurrencies USE {++} {[]} : {[(String,Float)]} ]

SEM Currency
  | Currency
      lhs.allCurrencies = [(@name.strVal, @euroRate.floatVal)]

ATTR List_Expense ConsList_Expense Expense
     [ allCurrencies : {[(String,Float)]} | | ]

SEM Form
  | Form
      expenses.allCurrencies = @currencies.allCurrencies


ATTR List_Expense ConsList_Expense Expense 
     [ | | total USE {+} {0} : {Float} ]
                         
SEM Expense
  | Expense
      loc.total = @amount.floatVal * (snd $ index "Expense.total" @lhs.allCurrencies @currencyIx)
        
{

addCurrencyItems currencies path pres = 
  pres `addPopupItems` [ ("Change currency to "++name, setCurrencyIx path ix) | (ix, (name, _)) <- zip [0..] currencies ]

addNewCurrency :: Path -> UpdateDoc Document ClipDoc
addNewCurrency path =
  insertElementAtEnd newCurrency path

newExpense = Expense (Description "") (Float_ 0) 0
  
newCurrency = Clip_Currency $ Currency (Description "new") (Float_ 0.0)

setCurrencyIx :: Path -> Int -> UpdateDoc Document ClipDoc
setCurrencyIx path newCurrencyIx= 
  \(DocumentLevel doc focus clip) ->
    let doc' = case selectD path doc of
                 Clip_Expense (Expense desc amount _) -> 
                   pasteD path (Clip_Expense (Expense desc amount newCurrencyIx)) doc
                 _ -> doc
    in  DocumentLevel doc' focus clip


-- Presentation utils

leftTopMargins left top pres = 
  row [ hSpace left, col [ vSpace top, pres, empty `withStretch` True ], empty `withStretch` True] 
  `withStretch` True
  
textField w pres = boxed $ row [hSpace 2, pres, empty `withHStretch` True]  `withbgColor` white
                           `withWidth` w 
-- setting width for entire pres including box is buggy in Xprez

-- Utils


showCurrency :: Float -> String
showCurrency f =
    let s = formatRealFloat FFFixed (Just 2) f
        s' = reverse s -- s -- dropWhile (== '0') (reverse s)
        s'' = if head s' == '.' then '0':s' else s'
    in reverse s''
}

-- TODO: why does withStretch not override col and row stretch settings?
-- Stretch does not seem to work for text fields anymore
-- empty has no background








SEM Description [ | | strVal : String ]
  | Description
      loc.pres = parsingWithParser pDescription @self $ text @str
      lhs.strVal = @str
  | HoleDescription
      lhs.strVal = "{Description}"
  | ParseErrDescription
      lhs.strVal = "{parse error}"




SEM List_Thing
  | List_Thing
      loc.pres = structural $ dropTarget $ col $
                   map dragSource @elts.press

SEM Thing
  | Thing
      loc.pres = structural $ row [ img "img/add.png" `withSize` (23,20) `withRef` (0,16), text (" "++show @nr) ]

SEM Tasks
  | Tasks
      loc.pres = structural $ row [ hSpace 4
      	       	 	      	  , col [ @things.pres
				        , text "Tasks:"
      	       	 	      	    	`addPopupItems` 
                                        ([ ("Insert task", insertElementAtEnd (toClip newTask) (@lhs.path++[1]))
                                         ] ++ showHideCompletedItem @lhs.path @self)
					, @tasks.pres `withFontSize` 12
					]
				  ]

SEM List_Task
  | List_Task
      loc.pres = structural $ 
                   col @elts.press

SEM Task
  | BasicTask
      loc.pres = structural $ showHideCompleted @lhs.showCompleted @completed $
                              row [ hSpace $ 9 + 5
                                  , presentCompleted @completed (not @completed)
                                      `withMouseDown` flipCompleted @lhs.path @self

                                  , hSpace 5, vRefHalf $ @description.pres `withColor` if @completed then green else blue]
                              `addPopupItems` 
 			      ([ ("Delete task", fixTask @lhs.path . deleteAt @lhs.path)
			       , ("Insert subtask", changeToComposite @lhs.path)
                               ] ++ mkMoveItems @lhs.path)
  | CompositeTask
      loc.pres = structural $ showHideCompleted @lhs.showCompleted @subtasks.completed $
                              col $ row [ (if @expanded then minusImg else plusImg) `withRef` (0,4)
                                          `withMouseDown` flipExpanded @lhs.path @self
                                        , hSpace 5
                                        , presentCompleted @subtasks.completed @subtasks.notStarted
                                            `withMouseDown` setCompletedRec (not @subtasks.completed) @lhs.path @self
                                        , hSpace 5
                                        , vRefHalf $ @description.pres
                                             `withColor` if @subtasks.completed then green else blue
                                        ] `addPopupItems` 
                                        ([ ("Delete task", deleteAt @lhs.path)
					 , ("Insert subtask", insertElementAtEnd (toClip newTask) (@lhs.path++[2]))
                                         ] ++ mkMoveItems @lhs.path)
 
                                  : if @expanded 
                                    then [row [hSpace $ 9 + 5, @subtasks.pres]] 
                                    else []



-- copy showCompleted field down to tasks
ATTR List_Task ConsList_Task Task
     [ showCompleted : Bool | | ]

SEM Tasks
  | Tasks 
      tasks.showCompleted = @showCompleted

ATTR List_Task ConsList_Task Task 
     [ | | completed USE {&&} {True} : {Bool} ]

ATTR List_Task ConsList_Task Task 
     [ | | notStarted USE {&&} {True} : {Bool} ]

SEM Task
  | BasicTask
      loc.completed = @completed
      loc.notStarted = not @completed

{
showHideCompleted showCompleted completed pres = 
  if showCompleted || not completed then pres else empty

showHideCompletedItem path (Tasks _ showCompleted _) = 
  [ ((if showCompleted then "Hide " else "Show ") ++ " completed tasks"
    , updateAt path $ \clip ->
        case clip of
          Clip_Tasks (Tasks things _ tasks) -> toClip $ Tasks things (not showCompleted) tasks
          clip -> clip
    )
  ]
showHideCompletedItem _ _ = []

-- todo toClip in pasteAt
flipCompleted path (BasicTask descr completed) = pasteAt path $ toClip $ BasicTask descr $ not completed

flipExpanded path (CompositeTask expanded descr subtasks) = pasteAt path $ toClip $ CompositeTask (not expanded) descr subtasks

setCompletedRec completed path task = pasteAt path $ toClip $ setCompletedRec' task
 where setCompletedRec' (BasicTask descr _) = BasicTask descr completed
       setCompletedRec' (CompositeTask exp descr subtasks) = CompositeTask exp descr $ toList_Task $ map setCompletedRec' (fromList_Task subtasks)

presentCompleted completed notStarted = vRefHalf $ 
  img (if completed then "img/completed.bmp" else if notStarted then "img/notStarted.bmp" else "img/partiallyCompleted.bmp") `withSize` (9,9) `withRef` (4,4)


-- change parent composite to basic if it has no subtasks
fixTask [] = id
fixTask [_] = id
fixTask path = 
  let parentPath = (init (init path))
  in  updateAt parentPath $ \clip ->
        case clip of
          Clip_Task (CompositeTask _ descr (List_Task Nil_Task)) -> 
            toClip $ BasicTask descr False
          clip -> clip

changeToComposite path =
  updateAt path $ \clip ->
    case clip of
      (Clip_Task (BasicTask descr _)) ->
        Clip_Task $ CompositeTask True descr $
          toList_Task [newTask]
      clip -> clip 

-- TODO: we either need the entire document here, or an isLast attribute to hide move down
--       in case of the last task.
mkMoveItems [] = []
mkMoveItems path =
 -- if last path > 0 
 -- then 
 [ ("Move task up", moveElementUp path), ("Move task down", moveElementDown path) ]


newTask = BasicTask (Description "") False
}







SEM Sudoku
  | Sudoku
      loc.pres = structural $ col [ hLine `withColor` darkGrey
      	       	 	      	  , @r0.pres, @r1.pres, @r2.pres
      	       	 	      	  , hLine `withColor` darkGrey
				  , @r3.pres, @r4.pres, @r5.pres
				  , hLine `withColor` darkGrey
				  , @r6.pres, @r7.pres, @r8.pres
				  , hLine `withColor` darkGrey
				  , vSpace 30
				  ]


SEM Row
  | Row
      loc.pres = structural $ row [ vLine `withColor` darkGrey
      	       	 	      	  , @f0.pres, @f1.pres, @f2.pres
      	       	 	      	  , vLine `withColor` darkGrey
      	       	 	      	  , @f3.pres, @f4.pres, @f5.pres
				  , vLine `withColor` darkGrey
      	       	 	      	  , @f6.pres, @f7.pres, @f8.pres
				  , vLine `withColor` darkGrey
				  ]
SEM Field
  | Field
      loc.pres = structural $ boxed (col [ empty `withVStretch` True
                                         , row [ empty `withHStretch` True
			                       , bold $ squiggleInvalidField @val.value @lhs.rowNrs @lhs.colNrs @lhs.blockNrs $ 
                                                 @val.pres
      	       	 	            	         `withColor` black
					       , empty `withHStretch` True
				               ]
      	       	 	      	         , empty `withVStretch` True
				         ]  `withSize` (35,35)) `withColor` darkGrey
                              `addPopupItems` 
			      fieldPopupItems @lhs.path @lhs.rowNrs @lhs.colNrs @lhs.blockNrs
                                              @lhs.inhBoardStr @lhs.rowNr @lhs.colNr 

SEM Field [ | | val : Int ]
  | Field 
      lhs.val = @val.value

SEM Row [ | | rowNrs : {[Int]} ]
  | Row
      loc.rowNrs = [@f0.val,@f1.val,@f2.val,@f3.val,@f4.val,@f5.val,@f6.val,@f7.val,@f8.val]


ATTR Field [ rowNrs : {[Int]} | |  ]


ATTR Row   [ colsNrs : {([Int],[Int],[Int],[Int],[Int],[Int],[Int],[Int],[Int])} | | ]
ATTR Field [ colNrs : {[Int]} | | ]

SEM Sudoku
  | Sudoku 
      loc.colsNrs = debug Prs (show @blockss)$ listTo9Tuple $ transpose
                         [ @r0.rowNrs, @r1.rowNrs, @r2.rowNrs
      	  	         , @r3.rowNrs, @r4.rowNrs, @r5.rowNrs
      	                 , @r6.rowNrs, @r7.rowNrs, @r8.rowNrs
      	                 ]

SEM Row
  | Row
      (f0.colNrs,f1.colNrs,f2.colNrs,f3.colNrs,f4.colNrs,f5.colNrs,f6.colNrs,f7.colNrs,f8.colNrs) = @lhs.colsNrs

SEM Row [ | | rowGroups : {[[Int]]} ]
  | Row
      lhs.rowGroups = [ [@f0.val, @f1.val, @f2.val]
                      , [@f3.val, @f4.val, @f5.val]
                      , [@f6.val, @f7.val, @f8.val]
                      ]

ATTR Row [ blocks : {([Int],[Int],[Int])} | | ]

SEM Sudoku
  | Sudoku
      loc.rowsGroups = [ [@r0.rowGroups, @r1.rowGroups, @r2.rowGroups ]
      		       , [@r3.rowGroups, @r4.rowGroups, @r5.rowGroups ]
		       , [@r6.rowGroups, @r7.rowGroups, @r8.rowGroups ]
		       ]
      loc.blockss = let [[nw,n,ne],[w,c,e],[sw,s,se]] = 
                          map (map concat . transpose) @rowsGroups
                    in  ((nw,n,ne),(w,c,e),(sw,s,se))

      r0.blocks = fst3 @blockss
      r1.blocks = fst3 @blockss
      r2.blocks = fst3 @blockss
      r3.blocks = snd3 @blockss
      r4.blocks = snd3 @blockss
      r5.blocks = snd3 @blockss
      r6.blocks = thd3 @blockss
      r7.blocks = thd3 @blockss
      r8.blocks = thd3 @blockss
            

ATTR Field [ blockNrs : {[Int]} | | ]

SEM Row
  | Row
      f0.blockNrs = fst3 @lhs.blocks
      f1.blockNrs = fst3 @lhs.blocks
      f2.blockNrs = fst3 @lhs.blocks
      f3.blockNrs = snd3 @lhs.blocks
      f4.blockNrs = snd3 @lhs.blocks
      f5.blockNrs = snd3 @lhs.blocks
      f6.blockNrs = thd3 @lhs.blocks
      f7.blockNrs = thd3 @lhs.blocks
      f8.blockNrs = thd3 @lhs.blocks

-- todo remame
-- not quite an unboxed int, due to empty presentation for 0
SEM Int_ [ | | value : Int ]
  | Int_
      loc.pres = parsingWithParser pInt_ @self $ text $ if @value == 0 then "" else show @value
      lhs.value = @value
  | HoleInt_
      lhs.value = 0
  | ParseErrInt_
      lhs.value = 0


-- get a string representing the board in every field

ATTR Sudoku Row Field
     [ | | synBoardStr USE {++} {[]} : String ]

SEM Field
  | Field
      lhs.synBoardStr = if @val.value == 0 then " " else show @val.value

ATTR Sudoku Row Field [ inhBoardStr : String | | ]

SEM ChoiceDoc
  | SudokuDoc
      sudoku.inhBoardStr = @sudoku.synBoardStr


-- row/column coordinates

-- todo: nr is confusing here

ATTR Row Field [ rowNr : Int | | ]

SEM Sudoku
  | Sudoku
      (r0.rowNr,r1.rowNr,r2.rowNr,r3.rowNr,r4.rowNr,r5.rowNr,r6.rowNr,r7.rowNr,r8.rowNr) =
        (0,1,2,3,4,5,6,7,8)

ATTR Field [ colNr : Int | | ]

SEM Row
  | Row
      (f0.colNr,f1.colNr,f2.colNr,f3.colNr,f4.colNr,f5.colNr,f6.colNr,f7.colNr,f8.colNr) =
        (0,1,2,3,4,5,6,7,8)

      
{

squiggleInvalidField nr rowNrs colNrs blockNrs =
  squiggle green $
    nr /= 0 &&
    (length (filter (==nr) rowNrs) > 1 ||
     length (filter (==nr) colNrs) > 1 ||
     length (filter (==nr) blockNrs) > 1) 
  
listTo9Tuple [x0,x1,x2,x3,x4,x5,x6,x7,x8] = (x0,x1,x2,x3,x4,x5,x6,x7,x8)

fst3 (x,_,_) = x

snd3 (_,x,_) = x

thd3 (_,_,x) = x

fieldPopupItems :: Path -> [Int] -> [Int] -> [Int] -> String -> Int -> Int ->
                   [ PopupMenuItem Document ClipDoc ] 
fieldPopupItems path rowNrs colNrs blockNrs boardStr row col =
  let validNrs = (([1..9] \\ rowNrs) \\ colNrs) \\ blockNrs
  in [ (if i == 0 then show "<clear>" else show i, setFieldValue path i) 
     | i <- 0:validNrs 
     ] ++ case sudokuHint boardStr row col of
            Just nr -> [ ( "Give hint"
                         , pasteAt path $ toClip $ Field $ toInt_ nr) ]
            Nothing -> [ ("No hints, solution is incorrect", id) ]

setFieldValue path n = pasteAt path $ toClip $ Field $ Int_ n

-- http://www.sudokutoday.com/difficult-sudoku-puzzle-i1-answers.html
}



-- TODO: move these to library

SEM Float_ [ | | floatVal : Float ]
  | Float_
      loc.pres = parsingWithParser pFloat_ @self $ text (show @value)
      lhs.floatVal = @value
  | HoleFloat_
      lhs.floatVal = 0
  | ParseErrFloat_
      lhs.floatVal = 0

{
-- TODO: move these to library

-- called deleteAtPath in dazzleEditor

deleteAt :: Path -> UpdateDoc Document ClipDoc
deleteAt path =
   \(DocumentLevel d _ cl) ->
     editCutD (DocumentLevel d (PathD path) cl)

pasteAt :: Path -> ClipDoc -> UpdateDoc Document ClipDoc
pasteAt path clip =
  \(DocumentLevel d pathD cl) ->
    let (DocumentLevel d' _ _) = editPasteD (DocumentLevel d (PathD path) clip)
    in  (DocumentLevel d' pathD cl)

updateAt :: Path -> (ClipDoc -> ClipDoc) -> UpdateDoc Document ClipDoc
updateAt path f =
  \(DocumentLevel d pathD cl) ->
    let clip = f (selectD path d)
        (DocumentLevel d' _ _) = editPasteD (DocumentLevel d (PathD path) clip)
    in  (DocumentLevel d' pathD cl)


-- PRECONDITION: path points to a list element of the same type as clip
addElementAfter :: ClipDoc -> Path -> UpdateDoc Document ClipDoc
addElementAfter clip path = 
  \(DocumentLevel d pathD cl) ->
    (DocumentLevel (insertListD (init path) (last path+1) clip d) pathD cl)

-- PRECONDITION: path points to a list of elements of the same type as clip
-- NB path points to the list, not to an element.
insertElementAtHead :: ClipDoc -> Path -> UpdateDoc Document ClipDoc
insertElementAtHead  clip listPath = 
  \(DocumentLevel d pathD cl) ->
    (DocumentLevel (insertListD listPath 0 clip d) pathD cl)

-- PRECONDITION: path points to a list of elements of the same type as clip
-- NB path points to the list, not to an element.
insertElementAtEnd :: ClipDoc -> Path -> UpdateDoc Document ClipDoc
insertElementAtEnd  clip listPath = 
  \(DocumentLevel d pathD cl) ->
    let list = selectD listPath d
    in  (DocumentLevel (insertListD listPath (arityClip list) clip d) pathD cl)

-- up/down? maybe choose better name
-- PRECONDITION: path points to an element in a list
moveElementUp []  = id
moveElementUp path = 
  let parentListPath = init path
      indexInList = last path
  in  \(DocumentLevel d f cl) ->
        if indexInList > 0
        then let elt = selectD path d
                 (d', f') = deleteD path d
                 d'' = insertListD parentListPath (indexInList - 1) elt d'
             in  DocumentLevel d'' f cl
        else DocumentLevel d f cl

-- PRECONDITION: path points to an element in a list
moveElementDown []  = id
moveElementDown path =
  let parentListPath = init path
      indexInList = last path
  in  \(DocumentLevel d f cl) ->
        if indexInList < arityClip (selectD parentListPath d) - 1
        then let elt = selectD path d
                 (d', f') = deleteD path d
                 d'' = insertListD parentListPath (indexInList + 1) elt d'
             in  DocumentLevel d'' f cl
        else DocumentLevel d f cl
}