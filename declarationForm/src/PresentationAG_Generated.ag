----- GENERATED PART STARTS HERE. DO NOT EDIT ON OR BEYOND THIS LINE -----

--------------------------------------------------------------------------
-- presentationSheet                                                    --
--------------------------------------------------------------------------

imports
{
import ScannerSheetHS as Lex
}

WRAPPER Root

{
-- type PresentationSheet doc enr node clip token = 
--        enr -> doc -> FocusDoc -> WhitespaceMap -> IDPCounter -> 
--        (WhitespaceMap, IDPCounter, Presentation doc node clip token)

presentationSheet :: PresentationSheet Document EnrichedDoc Node ClipDoc UserToken
presentationSheet enrichedDoc document focusD whitespaceMap pIdC = 
  let (Syn_EnrichedDoc pIdC' pres self whitespaceMap') = 
        wrap_EnrichedDoc (sem_EnrichedDoc enrichedDoc) (Inh_EnrichedDoc document focusD pIdC [] whitespaceMap)
  in  (whitespaceMap', pIdC', pres)

{- 
A type error here means that extra attributes were declared on EnrichedDoc
The attribute signature for EnrichedDoc should be:

EnrichedDoc  [ focusD : FocusDoc path : Path
             | pIdC : Int layoutMap : WhitespaceMap
             | pres : Presentation_ EnrichedDoc 
             ]
-}
}



--------------------------------------------------------------------------
-- AG data type                                                         --
--------------------------------------------------------------------------

DATA EnrichedDoc
  | RootEnr choiceDoc:ChoiceDoc
  | HoleEnrichedDoc
  | ParseErrEnrichedDoc error:{(ParseError Document EnrichedDoc Node ClipDoc UserToken)}

DATA ChoiceDoc
  | SudokuDoc sudoku:Sudoku
  | HoleChoiceDoc
  | ParseErrChoiceDoc error:{(ParseError Document EnrichedDoc Node ClipDoc UserToken)}

DATA Sudoku
  | Sudoku f:Float_ i:Fload_
  | HoleSudoku
  | ParseErrSudoku error:{(ParseError Document EnrichedDoc Node ClipDoc UserToken)}

DATA Float_
  | Float_ value:Float
  | HoleFloat_
  | ParseErrFloat_ error:{(ParseError Document EnrichedDoc Node ClipDoc UserToken)}

DATA Fload_
  | Fload_ value:Int
  | HoleFload_
  | ParseErrFload_ error:{(ParseError Document EnrichedDoc Node ClipDoc UserToken)}




--------------------------------------------------------------------------
-- Attr declarations                                                    --
--------------------------------------------------------------------------

ATTR EnrichedDoc ChoiceDoc Sudoku Float_ Fload_
     [ doc : Document focusD : FocusDoc path : Path |  pIdC : Int whitespaceMap : WhitespaceMap | ]

ATTR EnrichedDoc ChoiceDoc Sudoku Float_ Fload_
     [ | | pres : Presentation_ ]

ATTR ChoiceDoc Sudoku Float_ Fload_
     [ ix : Int | | parseErrors USE {++} {[]} : {[ParseErrorMessage]} ]

ATTR ChoiceDoc Sudoku Float_ Fload_
     [ | | ix : Int path : Path presXML : Presentation_ presTree : Presentation_ ]




--------------------------------------------------------------------------
-- General sem functions                                                --
--------------------------------------------------------------------------

SEM EnrichedDoc
  | RootEnr 
      choiceDoc.pIdC = @lhs.pIdC + 0
      lhs.pIdC = @choiceDoc.pIdC
      choiceDoc.path  = @lhs.path++[0]
  | RootEnr
    choiceDoc.ix = 0
  | RootEnr
      lhs.pres = loc (Node_RootEnr @self @lhs.path) $ presentFocus @lhs.focusD @lhs.path @pres
                 `withLocalPopupMenuItems` (mkPopupItemsFromDocUpdates $ menuD (PathD @lhs.path) @lhs.doc)
  | HoleEnrichedDoc
      lhs.pres = presHole @lhs.focusD "EnrichedDoc" (Node_HoleEnrichedDoc @self @lhs.path) @lhs.path
                 `withLocalPopupMenuItems` (mkPopupItemsFromDocUpdates $ menuD (PathD @lhs.path) @lhs.doc)
  | ParseErrEnrichedDoc
      lhs.pres = presParseErr (Node_ParseErrEnrichedDoc @self @lhs.path) @error
                 `withLocalPopupMenuItems` (mkPopupItemsFromDocUpdates $ menuD (PathD @lhs.path) @lhs.doc)

SEM ChoiceDoc
  | SudokuDoc 
      sudoku.pIdC = @lhs.pIdC + 0
      lhs.pIdC = @sudoku.pIdC
      sudoku.path  = @lhs.path++[0]
  | SudokuDoc
    sudoku.ix = 0
  | SudokuDoc
      lhs.pres = loc (Node_SudokuDoc @self @lhs.path) $ presentFocus @lhs.focusD @lhs.path @pres
                 `withLocalPopupMenuItems` (mkPopupItemsFromDocUpdates $ menuD (PathD @lhs.path) @lhs.doc)
  | HoleChoiceDoc
      lhs.pres = presHole @lhs.focusD "ChoiceDoc" (Node_HoleChoiceDoc @self @lhs.path) @lhs.path
                 `withLocalPopupMenuItems` (mkPopupItemsFromDocUpdates $ menuD (PathD @lhs.path) @lhs.doc)
  | ParseErrChoiceDoc
      lhs.pres = presParseErr (Node_ParseErrChoiceDoc @self @lhs.path) @error
                 `withLocalPopupMenuItems` (mkPopupItemsFromDocUpdates $ menuD (PathD @lhs.path) @lhs.doc)
      lhs.parseErrors = getErrorMessages @error

SEM Sudoku
  | Sudoku 
      f.pIdC = @lhs.pIdC + 0
      i.pIdC = @f.pIdC
      lhs.pIdC = @i.pIdC
      f.path  = @lhs.path++[0]
      i.path  = @lhs.path++[1]
  | Sudoku
    f.ix = 0
    i.ix = 1
  | Sudoku
      lhs.pres = loc (Node_Sudoku @self @lhs.path) $ presentFocus @lhs.focusD @lhs.path @pres
                 `withLocalPopupMenuItems` (mkPopupItemsFromDocUpdates $ menuD (PathD @lhs.path) @lhs.doc)
  | HoleSudoku
      lhs.pres = presHole @lhs.focusD "Sudoku" (Node_HoleSudoku @self @lhs.path) @lhs.path
                 `withLocalPopupMenuItems` (mkPopupItemsFromDocUpdates $ menuD (PathD @lhs.path) @lhs.doc)
  | ParseErrSudoku
      lhs.pres = presParseErr (Node_ParseErrSudoku @self @lhs.path) @error
                 `withLocalPopupMenuItems` (mkPopupItemsFromDocUpdates $ menuD (PathD @lhs.path) @lhs.doc)
      lhs.parseErrors = getErrorMessages @error

SEM Float_
  | Float_ 
      lhs.pIdC = @lhs.pIdC + 0
  | Float_
  | Float_
      lhs.pres = loc (Node_Float_ @self @lhs.path) $ presentFocus @lhs.focusD @lhs.path @pres
                 `withLocalPopupMenuItems` (mkPopupItemsFromDocUpdates $ menuD (PathD @lhs.path) @lhs.doc)
  | HoleFloat_
      lhs.pres = presHole @lhs.focusD "Float_" (Node_HoleFloat_ @self @lhs.path) @lhs.path
                 `withLocalPopupMenuItems` (mkPopupItemsFromDocUpdates $ menuD (PathD @lhs.path) @lhs.doc)
  | ParseErrFloat_
      lhs.pres = presParseErr (Node_ParseErrFloat_ @self @lhs.path) @error
                 `withLocalPopupMenuItems` (mkPopupItemsFromDocUpdates $ menuD (PathD @lhs.path) @lhs.doc)
      lhs.parseErrors = getErrorMessages @error

SEM Fload_
  | Fload_ 
      lhs.pIdC = @lhs.pIdC + 0
  | Fload_
  | Fload_
      lhs.pres = loc (Node_Fload_ @self @lhs.path) $ presentFocus @lhs.focusD @lhs.path @pres
                 `withLocalPopupMenuItems` (mkPopupItemsFromDocUpdates $ menuD (PathD @lhs.path) @lhs.doc)
  | HoleFload_
      lhs.pres = presHole @lhs.focusD "Fload_" (Node_HoleFload_ @self @lhs.path) @lhs.path
                 `withLocalPopupMenuItems` (mkPopupItemsFromDocUpdates $ menuD (PathD @lhs.path) @lhs.doc)
  | ParseErrFload_
      lhs.pres = presParseErr (Node_ParseErrFload_ @self @lhs.path) @error
                 `withLocalPopupMenuItems` (mkPopupItemsFromDocUpdates $ menuD (PathD @lhs.path) @lhs.doc)
      lhs.parseErrors = getErrorMessages @error




--------------------------------------------------------------------------
-- Synthesized path rules                                               --
--------------------------------------------------------------------------

SEM ChoiceDoc
  | SudokuDoc lhs.path = @lhs.path

SEM Sudoku
  | Sudoku lhs.path = @lhs.path

SEM Float_
  | Float_ lhs.path = @lhs.path

SEM Fload_
  | Fload_ lhs.path = @lhs.path




--------------------------------------------------------------------------
-- Sem functions for XML presentation                                   --
--------------------------------------------------------------------------

SEM ChoiceDoc
  | SudokuDoc
      lhs.presXML = presentElementXML @lhs.focusD (Node_SudokuDoc @self @lhs.path) @lhs.path "SudokuDoc" [ @sudoku.presXML ] 
  | HoleChoiceDoc     lhs.presXML = presHole @lhs.focusD "ChoiceDoc" (Node_HoleChoiceDoc @self @lhs.path) @lhs.path
  | ParseErrChoiceDoc lhs.presXML = presParseErr (Node_ParseErrChoiceDoc @self @lhs.path) @error

SEM Sudoku
  | Sudoku
      lhs.presXML = presentElementXML @lhs.focusD (Node_Sudoku @self @lhs.path) @lhs.path "Sudoku" [ @f.presXML, @i.presXML ] 
  | HoleSudoku     lhs.presXML = presHole @lhs.focusD "Sudoku" (Node_HoleSudoku @self @lhs.path) @lhs.path
  | ParseErrSudoku lhs.presXML = presParseErr (Node_ParseErrSudoku @self @lhs.path) @error

SEM Float_
  | Float_
      lhs.presXML = presentElementXML @lhs.focusD (Node_Float_ @self @lhs.path) @lhs.path "Float_" [ presentPrimXMLFloat @value ] 
  | HoleFloat_     lhs.presXML = presHole @lhs.focusD "Float_" (Node_HoleFloat_ @self @lhs.path) @lhs.path
  | ParseErrFloat_ lhs.presXML = presParseErr (Node_ParseErrFloat_ @self @lhs.path) @error

SEM Fload_
  | Fload_
      lhs.presXML = presentElementXML @lhs.focusD (Node_Fload_ @self @lhs.path) @lhs.path "Fload_" [ presentPrimXMLInt @value ] 
  | HoleFload_     lhs.presXML = presHole @lhs.focusD "Fload_" (Node_HoleFload_ @self @lhs.path) @lhs.path
  | ParseErrFload_ lhs.presXML = presParseErr (Node_ParseErrFload_ @self @lhs.path) @error




--------------------------------------------------------------------------
-- Sem functions for tree presentation                                  --
--------------------------------------------------------------------------

SEM ChoiceDoc
  | SudokuDoc
      lhs.presTree = presentElementTree @lhs.focusD (Node_SudokuDoc @self @lhs.path) @lhs.path "SudokuDoc" [ @sudoku.presTree ] 
  | HoleChoiceDoc     lhs.presTree = presHole @lhs.focusD "ChoiceDoc" (Node_HoleChoiceDoc @self @lhs.path) @lhs.path
  | ParseErrChoiceDoc lhs.presTree = presParseErr (Node_ParseErrChoiceDoc @self @lhs.path) @error

SEM Sudoku
  | Sudoku
      lhs.presTree = presentElementTree @lhs.focusD (Node_Sudoku @self @lhs.path) @lhs.path "Sudoku" [ @f.presTree, @i.presTree ] 
  | HoleSudoku     lhs.presTree = presHole @lhs.focusD "Sudoku" (Node_HoleSudoku @self @lhs.path) @lhs.path
  | ParseErrSudoku lhs.presTree = presParseErr (Node_ParseErrSudoku @self @lhs.path) @error

SEM Float_
  | Float_
      lhs.presTree = presentElementTree @lhs.focusD (Node_Float_ @self @lhs.path) @lhs.path "Float_" [ presentPrimXMLFloat @value ] 
  | HoleFloat_     lhs.presTree = presHole @lhs.focusD "Float_" (Node_HoleFloat_ @self @lhs.path) @lhs.path
  | ParseErrFloat_ lhs.presTree = presParseErr (Node_ParseErrFloat_ @self @lhs.path) @error

SEM Fload_
  | Fload_
      lhs.presTree = presentElementTree @lhs.focusD (Node_Fload_ @self @lhs.path) @lhs.path "Fload_" [ presentPrimXMLInt @value ] 
  | HoleFload_     lhs.presTree = presHole @lhs.focusD "Fload_" (Node_HoleFload_ @self @lhs.path) @lhs.path
  | ParseErrFload_ lhs.presTree = presParseErr (Node_ParseErrFload_ @self @lhs.path) @error



