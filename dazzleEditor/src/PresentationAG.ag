imports
{
import CommonTypes hiding (Dirty (..))
import PresLayerTypes
import PresLayerUtils

import XprezLib
import XLatex hiding (bold)

import DocumentEdit

import List
import Maybe
import qualified Data.Map as Map
import Data.Map (Map)


import DocTypes (DocumentLevel (..))
import DocTypes_Generated
import DocUtils_Generated
import DocumentEdit_Generated

presHole focus typeStr nd pth = loc nd $
  structural $ row [text $ "{"++typeStr++"}"] `withColor` black `withbgColor` yellow `withFontFam` ("Courier New")

presParseErr pres =
  loc NoNode $ parsing $ pres `withbgColor` whiteSmoke

presentFocus NoPathD     path pres = pres
presentFocus (PathD pth) path pres = if pth==path then pres `withbgColor` focusCol else pres

focusCol = lightBlue

}

INCLUDE "PresentationAG_Generated.ag"

ATTR EnrichedDoc [ | layoutMap : LayoutMap | ]

SEM EnrichedDoc
  | RootEnr
      lhs.pres = loc (RootDocNode @document []) $  --HACK!! top level loc needs to be a ref to the document
                                                        -- it is used by mkPopupMenuXY in Renderer.
                                                        -- A better implementation of popups will create the menu in
                                                        -- the higher layers. Although it is still a bit unclear where
                 loc (RootEnrNode @self []) $ structural $
                   @root.pres

SEM Root
  | Root
      lhs.pres = loc (RootNode @self []) $ structural $ presentFocus @lhs.focusD @lhs.path $
                     col $ [ -- empty `withHeight` 300 
                     --      , mkTreeLeaf False $ text "Bla" 
                     {-      , boxed $ row [ text "blap" `withFontSize` 100, colR 1 [ poly [] `withbgColor` red
                                                                               , text "blap"
                                                                               , poly [] `withbgColor` blue
                                                                               ] `withHRef` (10)
                                         ] -}
                           {-, overlay [ row [rect 100 10] `withbgColor` red `withRef` (45,10) 
                                                   , rect 10 100
                                                   ] -}
                                {- , boxed $ overlay [ rect 100 10  `withRef` (45,10)
                                                   , rect 10 100
                                                   ]  -}  
                         {-  , boxed $ overlay [ col [text "O" ]
                                             , col[ text "+"]
                                                `withRef` (20,40)
                                             ] 
                           -}      
                           -- , col $ replicate 15 $ row $ replicate 20 $ text "bla"
                           --  text "Contents"
                               @graph.pres
                           --, @tree.pres
                           --, parsing $ formatter $ replicate 50 $ text "bla"
                           , col @sections.press `withFontSize` 12  `withWidth` 800 
                           --, parsing $ formatter $ map (text.(++" ").show) [100..149] 
                           --, text "sdakljdksadjasdlkjasdjakdsjalsdjkasdjajsdkajsdkjalskdjasdjlaskdjaksdj"
                           --, col $ replicate 4 $ col $ replicate 20 $ text "84792873498237498274987239487923874928" `withbgColor` green
                          --, col $ map row $ divide 3 @sections.press
                           , row [ (boxed $ text "Add view") `withMouseDown` insertNewSection @lhs.path
                                 , text " "
                                 , (boxed $ text "Remove view") `withMouseDown` removeLastSection @lhs.path 
                                 ]
                          
                           ] 
{
divide n [] = []
divide n xs = let (h,t) = splitAt n xs
              in  h : divide n t
}
                           
SEM List_Paragraph [ || pres:Presentation_Doc_Node_Clip ]
  | List_Paragraph
      lhs.pres = loc (List_ParagraphNode @self @lhs.path) $ parsing $
                     col $ if null (fromList_Paragraph @self) then [formatter [text "  "]] else @elts.press
                     -- formatter [text "  "] prevents the column from getting height 0 when empty
                    
SEM Paragraph
  | Paragraph
      lhs.pres = loc (ParagraphNode @self @lhs.path) $ parsing $ presentFocus @lhs.focusD @lhs.path $
                     col $ [ formatter @words.press ]

SEM Word [ || ]
  | Word
      lhs.pres = loc (WordNode @self @lhs.path) $ parsing $ presentFocus @lhs.focusD @lhs.path $
                     row [ @word.pres, text " " ]
SEM Tree
  | Bin
      lhs.pres = loc (BinNode @self @lhs.path) $ parsing $ presentFocus @lhs.focusD @lhs.path $
                     row [ text $ "(", @left.pres, text " Bin ", @right.pres, text ")" ]
  | Leaf
      lhs.pres = loc (LeafNode @self @lhs.path) $ parsing $ presentFocus @lhs.focusD @lhs.path $
                     row [text $ "Leaf", text ""]

           
ATTR Section [||tocPres : Presentation_Doc_Node_Clip ]          
SEM Section
  | Section
      loc.numberStr = show @sectionNr ++ "."
      lhs.pres = loc (SectionNode @self @lhs.path) $ structural $ presentFocus @lhs.focusD @lhs.path $
                     (col $ [ row [ text @numberStr
                                  , parsing $ formatter [@title.pres], empty `withHStretch` True 
                                  ] `withFontSize_` (percent 150)  
                           , @paragraphs.pres         -- we abuse a formatter for the title to prevent the scanner from touching this whitespace
                           , row [ text "subsections below", empty `withHStretch` True ]
                           , col @subsections.press
                           , row [ @subgraph.pres, empty `withHStretch` True ]
                           ])
                     `addPopupItems` [ ("Delete Section", deleteSection) ]
      lhs.tocPres = loc (SectionNode @self @lhs.path) $ structural $ presentFocus @lhs.focusD @lhs.path $
                      row [text @numberStr, parsing $ formatter [@title.pres]] `withFontSize_` (percent 130)  

ATTR Subsection [||] --tocPres : Presentation_Doc_Node_Clip ]          
SEM Subsection
  | Subsection
      loc.numberStr = show @lhs.sectionNr ++ "." ++ show @subsectionNr ++ ". "
      lhs.pres = loc (SubsectionNode @self @lhs.path) $ structural $ presentFocus @lhs.focusD @lhs.path $
                     (col $ [ row [ text @numberStr
                                  , parsing $ formatter [@title.pres], empty `withHStretch` True
                                  ] `withFontSize_` (percent 130)  
                            , @paragraphs.pres         -- we abuse a formatter for the title to prevent the scanner from touching this whitespace
                            , col @subsubsections.press
                            ])
                     `addPopupItems` [ ("Delete Subsection", deleteSection) ]
      --lhs.tocPres = loc (SubsectionNode @self @lhs.path) $ structural $ presentFocus @lhs.focusD @lhs.path $
      --                row [text @numberStr, parsing $ formatter [@title.pres]] `withFontSize_` (percent 130)  

ATTR Subsubsection [||] --tocPres : Presentation_Doc_Node_Clip ]          
SEM Subsubsection
  | Subsubsection
      loc.numberStr = show @lhs.sectionNr ++ "." ++ show @lhs.subsectionNr ++ "."++ show @subsubsectionNr ++ ". "
      lhs.pres = loc (SubsubsectionNode @self @lhs.path) $ structural $ presentFocus @lhs.focusD @lhs.path $
                     (col $ [ row [ text @numberStr
                                  , parsing $ formatter [@title.pres], empty `withHStretch` True
                                  ] `withFontSize_` (percent 130)  
                            , @paragraphs.pres         -- we abuse a formatter for the title to prevent the scanner from touching this whitespace
                            ])
                     `addPopupItems` [ ("Delete Subsubsection", deleteSection) ]
      --lhs.tocPres = loc (SubsubsectionNode @self @lhs.path) $ structural $ presentFocus @lhs.focusD @lhs.path $
      --                row [text (show $ @subsubsectionNr), text ". ", parsing $ formatter [@title.pres]] `withFontSize_` (percent 130)  


SEM Section [ || ]
  | Section
      loc.sectionNr = @lhs.ix + 1

ATTR List_Subsection ConsList_Subsection Subsection 
             List_Subsubsection ConsList_Subsubsection Subsubsection [ sectionNr : Int || ]

SEM Subsection [ || ]
  | Subsection
      loc.subsectionNr = @lhs.ix + 1

ATTR List_Subsubsection ConsList_Subsubsection Subsubsection [ subsectionNr : Int || ]

SEM Subsubsection [ || ]
  | Subsubsection
      loc.subsubsectionNr = @lhs.ix + 1
  
{
deleteSection :: UpdateDoc Document clip
deleteSection (DocumentLevel d path cl) = debug Prs ("Path is " ++ show path) $
  (DocumentLevel d path cl)

}

SEM Graph
  | Graph
      lhs.pres = loc (GraphNode @self @lhs.path) $ structural $ presentFocus @lhs.focusD @lhs.path $
                     row [ text " "
                         , boxed $ graph 400 340 @edges.edges @vertices.press
                         ]
      
SEM Vertex [ || ] 
  | Vertex
      loc.pres = let (nodePres,nodeOutline) =
                       case @shape.self of
                         (Circle _) -> ( ellipse 18 18 Solid `withRef` (9,9) `withfColor` (200, 255, 255)
                                       , \a -> (round $ 9*cos a , round $ -9*sin a )
                                       )
                         _          -> ( rect 18 18 Solid `withRef` (9,9) `withfColor` (200, 255, 255)
                                       , squareOutline 9
                                       )
                      
                 in  loc (VertexNode @self @lhs.path) $ structural $
                     (vertex @id.int @x.int @y.int nodeOutline $
                       col [ rowR 1 [glue, hRefHalf $ nodePres, glue]
                           , vSpace 4 `withHStretch` True
                           , rowR 1 [glue, hRefHalf $ boxed 
                                              (row [ hSpace 3
                                                   , parsing $ text (@name.str) `withFont'` ("Arial", 6)
                                                   , hSpace 3
                                                   ])
                                                `withbgColor` (236, 236, 169)
                                    , glue]
                           ]) `addPopupItems` [ ("Circle", setShape @lhs.path (Circle NoIDD) @self)
                                              , ("Square", setShape @lhs.path (Square NoIDD) @self)
                                              ]

{
setShape :: [Int] -> Shape -> Vertex -> UpdateDoc Document clip
setShape pth shape (Vertex idD name _ id x y) =
  \(DocumentLevel d path cl) ->
    let (DocumentLevel d' _ _) = editPasteD (DocumentLevel d (PathD pth)
                                              (Clip_Vertex (Vertex idD name shape id x y))
                                            )
    in  (DocumentLevel d' path cl)

squareOutline :: Int -> Double -> (Int, Int)
squareOutline r a | a < pi / 4  || a >= 7 * pi / 4    = (r-1, round $ - tan a * fromIntegral r)  
                  | a >= pi / 4 && a < 3 * pi / 4     = (round $ - tan (a - pi/2) * fromIntegral r, -r+1)
                  | a >= 3 * pi / 4 && a < 5 * pi / 4 = (-r+1, round $ tan a * fromIntegral r)
                  | a >= 5 * pi / 4 && a < 7 * pi / 4 = (round $ tan (a - pi/2) * fromIntegral r, r-1)

}

SEM Subgraph [ vertexIDs : {[Int]} vertexNames : {[String]} edges : {[(Int, Int)]} || ] 
  | Subgraph
      lhs.pres = let subVertices = filter (`elem` @lhs.vertexIDs) (fst . unzip $ @vertices.vertexIDNames)
                     -- only present vertices that are in the supergraph
                     subEdges = [ (fromV,toV) | (fromV, toV) <- @lhs.edges, fromV `elem` subVertices && toV `elem` subVertices]
                 in  loc (SubgraphNode @self @lhs.path) $ structural $ presentFocus @lhs.focusD @lhs.path $
                       (boxed $ graph 100 100 subEdges @vertices.press
                     `addPopupItems` [ ("Add node " ++ show name, pasteInSubgraph @lhs.path id name @self)
                                     | (name,id) <- zip @lhs.vertexNames @lhs.vertexIDs
                                     , id `notElem` (fst . unzip $ @vertices.vertexIDNames)
                                     ])

SEM Root
  | Root
      (sections.vertexIDs, sections.vertexNames) = unzip @graph.vertexIDNames
      sections.edges = @graph.edges
      
ATTR Graph [ || vertexIDNames : {[(Int, String)]} edges : {[(Int, Int)]} ]
-- attributes come from vertices and edges by copy rule

ATTR List_Section [ vertexIDs : {[Int]} vertexNames : {[String]} edges : {[(Int, Int)]} || ] 
ATTR ConsList_Section [ vertexIDs : {[Int]} vertexNames : {[String]} edges : {[(Int, Int)]} || ] 
ATTR Section [ vertexIDs : {[Int]} vertexNames : {[String]} edges : {[(Int, Int)]} || ] 

SEM Edge [ || edge : {Maybe (Int,Int)} ]    
  | Edge
      lhs.edge = Just (@from.int, @to.int)
  | HoleEdge
      lhs.edge = Nothing
  | ParseErrEdge
      lhs.edge = Nothing

SEM List_Edge [ || edges : {[(Int,Int)]} ] 
  | List_Edge
      lhs.edges = catMaybes @elts.edges
  | HoleList_Edge
      lhs.edges = []
  | ParseErrList_Edge
      lhs.edges = []
      
SEM ConsList_Edge [ || edges : {[Maybe (Int,Int)]} ] 
  | Cons_Edge
      lhs.edges = @head.edge : @tail.edges
  | Nil_Edge
      lhs.edges = []

SEM Vertex [ || vertexIDName : {Maybe (Int,String)} ]    
  | Vertex
      lhs.vertexIDName = Just (@id.int, @name.str)
  | HoleVertex
      lhs.vertexIDName = Nothing
  | ParseErrVertex
      lhs.vertexIDName = Nothing

SEM List_Vertex [ || vertexIDNames : {[(Int,String)]} ] 
  | List_Vertex
      lhs.vertexIDNames = catMaybes @elts.vertexIDNames
  | HoleList_Vertex
      lhs.vertexIDNames = []
  | ParseErrList_Vertex
      lhs.vertexIDNames = []
      
SEM ConsList_Vertex [ || vertexIDNames : {[Maybe (Int, String)]} ] 
  | Cons_Vertex
      lhs.vertexIDNames = @head.vertexIDName : @tail.vertexIDNames
  | Nil_Vertex
      lhs.vertexIDNames = []

{
pasteInSubgraph :: [Int] -> Int -> String -> Subgraph -> UpdateDoc Document clip
pasteInSubgraph pth id name subgraph =
  let subgraph' = 
        case subgraph of
        Subgraph idd d vs es -> Subgraph idd d (toList_Vertex $ Vertex NoIDD  (String_ NoIDD name) (Circle NoIDD) (Int_ NoIDD id) (Int_ NoIDD 20) (Int_ NoIDD 20) : fromList_Vertex vs) es
        _                    -> subgraph
  in \(DocumentLevel d path cl) ->
        let (DocumentLevel d' _ _) = editPasteD (DocumentLevel d (PathD pth)
                                                (Clip_Subgraph subgraph')
                                                )
        in  (DocumentLevel d' path cl)

insertNewSection :: [Int] -> UpdateDoc Document clip
insertNewSection pth =
  let section = Section NoIDD
                  (String_ NoIDD "<new>")
                  (List_Paragraph NoIDD Nil_Paragraph) 
                  (List_Subsection NoIDD Nil_Subsection) 
                  (Subgraph NoIDD (Dirty NoIDD) (List_Vertex NoIDD (Nil_Vertex)) (List_Edge NoIDD (Nil_Edge)))
  in  \(DocumentLevel d path cl) ->
        let (Clip_List_Section sectionlist) = select (pth++[2]) d -- nasty: Root tr(0) gr(1) sections(2)
            clipsectionlist' = insertList (length $ fromList_Section sectionlist) (Clip_Section section) sectionlist
            (DocumentLevel d' _ _) = editPasteD (DocumentLevel d (PathD (pth++[2]))
                                                (clipsectionlist')
                                                )
        in  (DocumentLevel d' path cl)

removeLastSection :: [Int] -> UpdateDoc Document clip
removeLastSection pth =
   \(DocumentLevel d path cl) ->
      let (Clip_List_Section sectionlist) = select (pth++[2]) d -- nasty: Root tr(0) gr(1) sections(2)
          clipsectionlist' = removeList (length (fromList_Section sectionlist) - 1) sectionlist
          (DocumentLevel d' _ _) = editPasteD (DocumentLevel d (PathD (pth++[2]))
                                              (clipsectionlist')
                                              )
      in  (DocumentLevel d' path cl)
}


-- annoying bits, since we don't have any default behaviour for pres attributes:

SEM List_Section [||tocPress: {[Presentation_Doc_Node_Clip]}]
  | List_Section
      lhs.tocPress = map ( loc (List_SectionNode @self @lhs.path) 
                      . presentFocus @lhs.focusD @lhs.path ) 
                      @elts.tocPress
                      -- parent is reponsible for setting parsing/structural
  | HoleList_Section     lhs.tocPress = []
  | ParseErrList_Section lhs.tocPress = [ presParseErr @presentation ]

SEM ConsList_Section [|| tocPress:{[Presentation_Doc_Node_Clip]}]
  | Cons_Section lhs.tocPress = @head.tocPres : @tail.tocPress
  | Nil_Section      lhs.tocPress = []
