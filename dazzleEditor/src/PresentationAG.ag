imports
{
import Common.CommonTypes hiding (Dirty (..))
import Presentation.PresLayerTypes
import Presentation.PresLayerUtils

import Presentation.XprezLib
import Presentation.XLatex hiding (bold)

import Evaluation.DocumentEdit

import List
import Maybe
import qualified Data.Map as Map
import Data.Map (Map)


import Evaluation.DocTypes (DocumentLevel (..))
import DocTypes_Generated
import DocUtils_Generated
import DocumentEdit_Generated

presHole focus typeStr nd pth = loc nd $
  structural $ row [text $ "{"++typeStr++"}"] `withColor` black `withbgColor` yellow `withFontFam` ("Courier New")

presParseErr pres =
  loc NoNode $ parsing $ pres `withbgColor` whiteSmoke

presentFocus NoPathD     path pres = pres
presentFocus (PathD pth) path pres = if pth==path then pres `withbgColor` focusCol else pres

focusCol = lightBlue

}

INCLUDE "PresentationAG_Generated.ag"

ATTR EnrichedDoc [ | layoutMap : WhitespaceMap | ]

SEM EnrichedDoc
  | RootEnr
      lhs.pres = loc (Node_RootDoc @document []) $  --HACK!! top level loc needs to be a ref to the document
                                                        -- it is used by mkPopupMenuXY in Renderer.
                                                        -- A better implementation of popups will create the menu in
                                                        -- the higher layers. Although it is still a bit unclear where
                 loc (Node_RootEnr @self []) $ structural $
                   @root.pres


SEM Root
  | Root
      lhs.pres = loc (Node_Root @self []) $ structural $ presentFocus @lhs.focusD @lhs.path $
                     (col $ [ @graph.pres
                            , row [ parsing $ text @title, empty `withHStretch` True ]
                                  `withFontSize_` (percent 160) 
                                  `addPopupItems`
                                [ ("Add Section", insertAtHeadSection @sections.path) ]  
                            , col @sections.press 
                            ]) `withFontSize` 12  `withWidth` 800
{
divide n [] = []
divide n xs = let (h,t) = splitAt n xs
              in  h : divide n t
}
                           
           
SEM Section [||tocPres : Presentation_Doc_Node_Clip_Token ]          
  | Section
      loc.numberStr = show @sectionNr
      lhs.pres = loc (Node_Section @self @lhs.path) $ structural $ presentFocus @lhs.focusD @lhs.path $
                     (col $ [ col [ row [ text (@numberStr++".")
                                        , parsing $ text @title
                                        ] `withFontSize_` (percent 150)
                                          `addPopupItems` [ ("Add Graph", insertAtHeadSubgraphPara @paragraphs.path) ]  
                                          `withHStretch` True 
                                  , @paragraphs.pres
                                  ] `addPopupItems`
                                    [ ("Add Subsection", insertAtHeadSubsection @subsections.path) ]  
                            , col @subsections.press `withHStretch` True -- withStretch is necessary when subsections == []
                            ])
                     `addPopupItems` [ ("Delete Section", deleteAtPath @lhs.path) 
                                     , ("Add Section", addSection @lhs.path) ]
      lhs.tocPres = loc (Node_Section @self @lhs.path) $ structural $ presentFocus @lhs.focusD @lhs.path $
                      row [text (@numberStr++"."), parsing $ formatter [text @title]] `withFontSize_` (percent 130)  
                      -- don't use formatter here


SEM Subsection [||] --tocPres : Presentation_Doc_Node_Clip_Token ]          
  | Subsection
      loc.numberStr = show @lhs.sectionNr ++ "." ++ show @subsectionNr
      lhs.pres = loc (Node_Subsection @self @lhs.path) $ structural $ presentFocus @lhs.focusD @lhs.path $
                     (col $ [ col [ row [ text (@numberStr++".")
                                        , parsing $ text @title, empty `withHStretch` True
                                        ] `withFontSize_` (percent 130)
                                          `addPopupItems` [ ("Add Graph", insertAtHeadSubgraphPara @paragraphs.path) ]  
                                  , @paragraphs.pres
                                  ] `addPopupItems`
                                    [ ("Add Subsubsection", insertAtHeadSubsubsection @subsubsections.path) ]  
                            , col @subsubsections.press `withHStretch` True -- withStretch is necessary when subsubsections == []
                            ])
                     `addPopupItems` [ ("Delete Subsection", deleteAtPath @lhs.path) 
                                     , ("Add Subsection", addSubsection @lhs.path) ]
      --lhs.tocPres = loc (Node_Subsection @self @lhs.path) $ structural $ presentFocus @lhs.focusD @lhs.path $
      --                row [text (@numberStr++"."), parsing $ formatter [@title.pres]] `withFontSize_` (percent 130)  
                      -- don't use formatter here


SEM Subsubsection [||] --tocPres : Presentation_Doc_Node_Clip_Token ]          
  | Subsubsection
      loc.numberStr = show @lhs.sectionNr ++ "." ++ show @lhs.subsectionNr ++ "."++ show @subsubsectionNr ++ ". "
      lhs.pres = loc (Node_Subsubsection @self @lhs.path) $ structural $ presentFocus @lhs.focusD @lhs.path $
                     (col $ [ row [ text (@numberStr++".")
                                  , parsing $ text @title, empty `withHStretch` True
                                  ] `withFontSize_` (percent 130)  
                                    `addPopupItems` [ ("Add Graph", insertAtHeadSubgraphPara @paragraphs.path) ]  
                            , @paragraphs.pres
                            ])
                     `addPopupItems` [ ("Delete Subsubsection", deleteAtPath @lhs.path) 
                                     , ("Add Subsubsection", addSubsubsection @lhs.path)  ]
      --lhs.tocPres = loc (Node_Subsubsection @self @lhs.path) $ structural $ presentFocus @lhs.focusD @lhs.path $
      --                row [text (@numberStr++"."), text ". ", parsing $ formatter [@title.pres]] `withFontSize_` (percent 130)  
                      -- don't use formatter here


SEM Section [ || ]
  | Section
      loc.sectionNr = @lhs.ix + 1

ATTR List_Subsection ConsList_Subsection Subsection 
             List_Subsubsection ConsList_Subsubsection Subsubsection [ sectionNr : Int || ]

SEM Subsection [ || ]
  | Subsection
      loc.subsectionNr = @lhs.ix + 1

ATTR List_Subsubsection ConsList_Subsubsection Subsubsection [ subsectionNr : Int || ]

SEM Subsubsection [ || ]
  | Subsubsection
      loc.subsubsectionNr = @lhs.ix + 1

SEM List_Paragraph [ || pres:Presentation_Doc_Node_Clip_Token ]
  | List_Paragraph
      lhs.pres = loc (Node_List_Paragraph @self @lhs.path) $ parsing' LexFreeText $
                     col $ if null (fromList_Paragraph @self) then [formatter [text ""]] else @elts.press
                     -- if paragraph list is empty, we add a dummy text "" to prevent the presentation from getting height 0
                     -- this dummy is parsed as an empty paragraph
  | HoleList_Paragraph
      lhs.pres = presHole @lhs.focusD "List_Paragraph" (Node_HoleList_Paragraph @self []) []
  | ParseErrList_Paragraph
      lhs.pres = presParseErr @presentation
      
                    
SEM Paragraph
  | Paragraph
      lhs.pres = loc (Node_Paragraph @self @lhs.path) $ parsing $ presentFocus @lhs.focusD @lhs.path $
                     ( formatter ( if null @words.press then [text ""] else @words.press ))
                       `addPopupItems` [ ("Add Graph", addSubgraphPara @lhs.path) ]
       -- for an empty paragraph, we add a dummy word "" so its presentation does not get height 0
       
  | SubgraphPara
      lhs.pres = loc (Node_SubgraphPara @self @lhs.path) $ structural $ presentFocus @lhs.focusD @lhs.path $
                     row [ @subgraph.pres, empty `withHStretch` True ]
                       `addPopupItems` [ ("Delete Graph", deleteAtPath @lhs.path)
                                       , ("Add Graph", addSubgraphPara @lhs.path)
                                       , ("Add Paragraph", addParagraph @lhs.path) ]
                           

SEM Word [ || ]
  | Word
      lhs.pres = loc (Node_Word @self @lhs.path) $ parsing $ presentFocus @lhs.focusD @lhs.path $
                     row [ text @word, text " " ]
  | NodeRef
      lhs.pres = loc (Node_Word @self @lhs.path) $ parsing $ presentFocus @lhs.focusD @lhs.path $
                     row [ text "\\node{" `withColor` blue
                         , if @nodeName `notElem` @lhs.vertexNames
                           then squiggly red $ text @nodeName 
                           else text @nodeName 
                         , text "}" `withColor` blue
                         , text " "
                         ]
  | Label
      lhs.pres = loc (Node_Word @self @lhs.path) $ parsing $ presentFocus @lhs.focusD @lhs.path $
                     row [ text ("\\label{" ++ @label++"}") `withColor` blue
                         , text " "
                         ]
  | LabelRef
      lhs.pres = loc (Node_Word @self @lhs.path) $ parsing $ presentFocus @lhs.focusD @lhs.path $
                   let mLabelNr = lookup @label @lhs.allLabels   
                   in row [ text "\\ref{" `withColor` blue
                          , case mLabelNr of
                              Nothing -> squiggly red $ text  @label
                              Just _  -> text @label
                          , text "}{" `withColor` blue
                          , case mLabelNr of
                              Nothing -> text "undefined" `withColor` red
                              Just nr -> text nr `withColor` green
                          , text "}" `withColor` blue
                          , text " "
                          ]

  
SEM Graph
  | Graph
      lhs.pres = loc (Node_Graph @self @lhs.path) $ structural $ presentFocus @lhs.focusD @lhs.path $
                     row [ text " "
                         , boxed $ graph 400 340 @edges.edges @vertices.press
                         ]
      
SEM Vertex [ || ] 
  | Vertex
      lhs.pres = let (nodePres,nodeOutline) =
                       case @shape.self of
                         Circle -> ( ellipse 18 18 Solid `withRef` (9,9) `withfColor` (200, 255, 255)
                                   , \a -> (round $ 9*cos a , round $ -9*sin a )
                                   )
                         _      -> ( rect 18 18 Solid `withRef` (9,9) `withfColor` (200, 255, 255)
                                   , squareOutline 9
                                   )
                      
                 in  loc (Node_Vertex @self @lhs.path) $ structural $
                     (vertex @id @x @y nodeOutline $
                       col [ rowR 1 [glue, hRefHalf $ nodePres, glue]
                           , vSpace 4 `withHStretch` True
                           , rowR 1 [glue, hRefHalf $ boxed 
                                              (row [ hSpace 3
                                                   , parsing $ text @name `withFont'` ("Arial", 6)
                                                   , hSpace 3
                                                   ])
                                                `withbgColor` (236, 236, 169)
                                    , glue]
                           ]) `addPopupItems` ([ ("Circle", setShape @lhs.path Circle @self)
                                               , ("Square", setShape @lhs.path Square @self)
                                               ])

{
setShape :: [Int] -> Shape -> Vertex -> UpdateDoc Document clip
setShape pth shape (Vertex name _ id x y) =
  \(DocumentLevel d path cl) ->
    let (DocumentLevel d' _ _) = editPasteD (DocumentLevel d (PathD pth)
                                              (Clip_Vertex (Vertex name shape id x y))
                                            )
    in  (DocumentLevel d' path cl)

squareOutline :: Int -> Double -> (Int, Int)
squareOutline r a | a < pi / 4  || a >= 7 * pi / 4    = (r-1, round $ - tan a * fromIntegral r)  
                  | a >= pi / 4 && a < 3 * pi / 4     = (round $ - tan (a - pi/2) * fromIntegral r, -r+1)
                  | a >= 3 * pi / 4 && a < 5 * pi / 4 = (-r+1, round $ tan a * fromIntegral r)
                  | a >= 5 * pi / 4 && a < 7 * pi / 4 = (round $ tan (a - pi/2) * fromIntegral r, r-1)

}

SEM Subgraph [||] 
  | Subgraph
      lhs.pres = let subVertices = filter (`elem` @lhs.vertexIDs) (fst . unzip $ @vertices.vertexIDNames)
                     -- only present vertices that are in the supergraph
                     subEdges = [ (fromV,toV) | (fromV, toV) <- @lhs.edges, fromV `elem` subVertices && toV `elem` subVertices]
                 in  loc (Node_Subgraph @self @lhs.path) $ structural $ presentFocus @lhs.focusD @lhs.path $
                       (boxed $ graph 100 100 subEdges @vertices.press
                     `addPopupItems` [ ("Add node " ++ show name, pasteInSubgraph @lhs.path id name @self)
                                     | (name,id) <- zip @lhs.vertexNames @lhs.vertexIDs
                                     , id `notElem` (fst . unzip $ @vertices.vertexIDNames)
                                     ])


{-
Graph synthesizes vertexIDNames and edges. At Root, vertexIDNames is unzipped, and inherited attributes
vertexIDs, vertexNames, and edges are copied down to the subgraphs.
-}
SEM Root
  | Root
      (sections.vertexIDs, sections.vertexNames) = unzip @graph.vertexIDNames
      sections.edges = @graph.edges
            
-- attributes come from vertices and edges by copy rule

ATTR List_Section ConsList_Section Section 
     List_Subsection ConsList_Subsection Subsection
     List_Subsubsection ConsList_Subsubsection Subsubsection
     List_Paragraph ConsList_Paragraph Paragraph
     List_Word ConsList_Word Word
     [ vertexIDs : {[Int]} vertexNames : {[String]} edges : {[(Int, Int)]} || ] 


ATTR Subgraph [ vertexIDs : {[Int]} vertexNames : {[String]} edges : {[(Int, Int)]} || ]

ATTR Graph
     List_Edge ConsList_Edge Edge
     [ | | edges USE {++} {[]} : {[(Int,Int)]} ]

SEM Edge
  | Edge
      lhs.edges = [(@from, @to)]


ATTR Graph
     List_Vertex ConsList_Vertex Vertex
     [ | | vertexIDNames USE {++} {[]} : {[(Int,String)]} ]

SEM Vertex
  | Vertex
      lhs.vertexIDNames = [(@id, @name)]

{
deleteAtPath :: PathD -> UpdateDoc Document ClipDoc
deleteAtPath pth =
   \(DocumentLevel d _ cl) ->
     editCutD (DocumentLevel d (PathD pth) cl)

newSubgraphPara = Clip_Paragraph $
                    SubgraphPara $
                      Subgraph Dirty
                        (toList_Vertex [])
                        (toList_Edge []) 

newParagraph = Clip_Paragraph $
                 Paragraph $
                   List_Word Nil_Word

newSection = Clip_Section $
               Section
                 "<new section>"
                 (List_Paragraph Nil_Paragraph) 
                 (List_Subsection Nil_Subsection)

newSubsection = Clip_Subsection $
                    Subsection
                      "<new subsection>"
                      (List_Paragraph Nil_Paragraph) 
                      (List_Subsubsection Nil_Subsubsection) 

newSubsubsection = Clip_Subsubsection $
                    Subsubsection
                      "<new subsubsection>"
                      (List_Paragraph Nil_Paragraph) 

addSubgraphPara path = addElementAfter path newSubgraphPara

addParagraph path = addElementAfter path newParagraph

addSection path = addElementAfter path $ newSection 
    
addSubsection path = addElementAfter path $ newSubsection 

addSubsubsection path = addElementAfter path $ newSubsubsection 

insertAtHeadSubgraphPara listPath = insertElementAtHead listPath $ newSubgraphPara

insertAtHeadSection listPath = insertElementAtHead listPath $ newSection

insertAtHeadSubsection listPath = insertElementAtHead listPath $ newSubsection

insertAtHeadSubsubsection listPath = insertElementAtHead listPath $ newSubsubsection

-- PRECONDITION: path points to a list element of the same type as clip
addElementAfter :: PathD -> ClipDoc -> UpdateDoc Document ClipDoc
addElementAfter path clip = 
  \(DocumentLevel d pth cl) ->
    (DocumentLevel (insertListD (init path) (last path+1) clip d) pth cl)

-- PRECONDITION: path points to a list of elements of the same type as clip
-- NB path points to the list, rather than to an element.
insertElementAtHead :: PathD -> ClipDoc -> UpdateDoc Document ClipDoc
insertElementAtHead listPath clip = 
  \(DocumentLevel d pth cl) ->
    (DocumentLevel (insertListD listPath 0 clip d) pth cl)

pasteInSubgraph :: [Int] -> Int -> String -> Subgraph -> UpdateDoc Document clip
pasteInSubgraph pth id name subgraph =
  let subgraph' = 
        case subgraph of
        Subgraph d vs es -> 
          Subgraph d (toList_Vertex $ 
                            Vertex  name 
                              Circle id 20 20
                            : fromList_Vertex vs) es
        _                    -> subgraph
  in \(DocumentLevel d path cl) ->
        let (DocumentLevel d' _ _) = editPasteD (DocumentLevel d (PathD pth)
                                                (Clip_Subgraph subgraph')
                                                )
        in  (DocumentLevel d' path cl)


}

-- labels and refs

-- copy upward, taking the first label that is not Nothing

SEM Word [ | | myLabel USE {use} {Nothing} : {Maybe String} ]
  | Label
      lhs.myLabel = Just @label

SEM ConsList_Word List_Word Paragraph ConsList_Paragraph List_Paragraph
    [ | | myLabel USE {`takeFirst`} {Nothing} : {Maybe String} ]

{
takeFirst :: Maybe x -> Maybe x -> Maybe x
takeFirst left right = case left of
                         Just x  -> Just x
                         Nothing -> right
}

-- collect all labels

SEM List_Section ConsList_Section Section 
    List_Subsection ConsList_Subsection Subsection 
    List_Subsubsection ConsList_Subsubsection Subsubsection 
    [ | | labels USE {++} {[]} : {[(String,String)]} ]

SEM Section
  | Section
      lhs.labels = case @paragraphs.myLabel of
                     Just label -> (label, @numberStr) : @subsections.labels
                     Nothing    -> @subsections.labels

SEM Subsection
  | Subsection
      lhs.labels = case @paragraphs.myLabel of
                     Just label -> (label, @numberStr) : @subsubsections.labels
                     Nothing    -> @subsubsections.labels
                       
SEM Subsubsection
  | Subsubsection
      lhs.labels = case @paragraphs.myLabel of
                     Just label -> [(label, @numberStr)]
                     Nothing    -> []


-- the inherited attribute is allLabels, to prevent the copy rule from threading the attribute.

ATTR List_Section ConsList_Section Section 
     List_Subsection ConsList_Subsection Subsection
     List_Subsubsection ConsList_Subsubsection Subsubsection
     List_Paragraph ConsList_Paragraph Paragraph
     List_Word ConsList_Word Word 
     [ allLabels : {[(String,String)]} | | ]

SEM Root
  | Root
      sections.allLabels = @sections.labels
           
           
           
           
-- annoying bits, since we don't have any default behaviour for pres attributes:

SEM Section
  | HoleSection     lhs.tocPres = presHole @lhs.focusD "Section" (Node_HoleSection @self @lhs.path) @lhs.path
  | ParseErrSection lhs.tocPres = presParseErr @presentation


SEM List_Section [||tocPress: {[Presentation_Doc_Node_Clip_Token]}]
  | List_Section
      lhs.tocPress = map ( loc (Node_List_Section @self @lhs.path) 
                      . presentFocus @lhs.focusD @lhs.path ) 
                      @elts.tocPress
                      -- parent is reponsible for setting parsing/structural
  | HoleList_Section     lhs.tocPress = []
  | ParseErrList_Section lhs.tocPress = [ presParseErr @presentation ]

SEM ConsList_Section [|| tocPress:{[Presentation_Doc_Node_Clip_Token]}]
  | Cons_Section lhs.tocPress = @head.tocPres : @tail.tocPress
  | Nil_Section      lhs.tocPress = []

{- dummy presentations. We don't use the pres attribute for these nonterminals, but it is declared,
   so to prevent warnings, we provide the definitions. 
-}

SEM Edge [ || ] 
  | Edge       
      lhs.pres = empty

SEM Shape [ || ] 
  | Circle       
      lhs.pres = empty
  | Square
      lhs.pres = empty

SEM Dirty [ || ] 
  | Dirty
      lhs.pres = empty
  | Clean       
      lhs.pres = empty

SEM Dummy [ || ] 
  | Dummy       
      lhs.pres = empty
