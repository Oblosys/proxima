imports
{
import Common.CommonTypes hiding (Dirty (..))
import Presentation.PresLayerTypes hiding (Edge)
import Presentation.PresLayerUtils

import Presentation.XprezLib
import Presentation.XLatex hiding (bold)

import Evaluation.DocumentEdit

import List
import Maybe
import qualified Data.Map as Map
import Data.Map (Map)


import Evaluation.DocTypes (DocumentLevel (..))
import DocTypes_Generated
import DocUtils_Generated
import DocumentEdit_Generated

import Reducer

}

INCLUDE "PresentationAG_Generated.ag"


SEM EnrichedDoc
  | RootEnr
      loc.pres = structural $
                   @root.pres

SEM Root
  | Root
      loc.pres = structural $
                     (col $ [ @graph.pres
                            , row [ parsing $ text @title, empty `withHStretch` True ]
                                  `withFontSize_` (percent 160) 
                                  `addPopupItems`
                                [ ("Add Section", insertAtHeadSection @sections.path) ]  
                            , @sections.pres 
                            ]) `withFontSize` 12  `withWidth` 800
{
divide n [] = []
divide n xs = let (h,t) = splitAt n xs
              in  h : divide n t
}
                           
SEM List_Section
  | List_Section
      loc.pres = structural $ col @elts.press
      
SEM Section [||tocPres : Presentation_Doc_Node_Clip_Token ]          
  | Section
      loc.numberStr = show @sectionNr
      loc.pres = structural $
                     (col $ [ col [ row [ text (@numberStr++".")
                                        , parsing $ text @title
                                        ] `withFontSize_` (percent 150)
                                          `addPopupItems` [ ("Add Graph", insertAtHeadSubgraphPara @paragraphs.path) 
                                                          , ("Add Probtable", insertElementAtHead newProbtablePara @paragraphs.path) 
                                                          ]  
                                          `withHStretch` True 
                                  , @paragraphs.pres
                                  ] `addPopupItems`
                                    [ ("Add Subsection", insertAtHeadSubsection @subsections.path) ]  
                            , @subsections.pres `withHStretch` True -- withStretch is necessary when subsections == []
                            ])
                     `addPopupItems` [ ("Delete Section", deleteAtPath @lhs.path) 
                                     , ("Add Section", addSection @lhs.path) ]
      lhs.tocPres = loc (Node_Section @self @lhs.path) $ structural $ presentFocus @lhs.focusD @lhs.path $
                      row [text (@numberStr++"."), parsing $ formatter [text @title]] `withFontSize_` (percent 130)  
                      -- don't use formatter here

SEM List_Subsection
  | List_Subsection
      loc.pres = structural $ col @elts.press

SEM Subsection [||] --tocPres : Presentation_Doc_Node_Clip_Token ]          
  | Subsection
      loc.numberStr = show @lhs.sectionNr ++ "." ++ show @subsectionNr
      loc.pres = structural $
                     (col $ [ col [ row [ text (@numberStr++".")
                                        , parsing $ text @title, empty `withHStretch` True
                                        ] `withFontSize_` (percent 130)
                                          `addPopupItems` [ ("Add Graph", insertAtHeadSubgraphPara @paragraphs.path) ]  
                                  , @paragraphs.pres
                                  ] `addPopupItems`
                                    [ ("Add Subsubsection", insertAtHeadSubsubsection @subsubsections.path) ]  
                            , @subsubsections.pres `withHStretch` True -- withStretch is necessary when subsubsections == []
                            ])
                     `addPopupItems` [ ("Delete Subsection", deleteAtPath @lhs.path) 
                                     , ("Add Subsection", addSubsection @lhs.path) ]
      --lhs.tocPres = loc (Node_Subsection @self @lhs.path) $ structural $ presentFocus @lhs.focusD @lhs.path $
      --                row [text (@numberStr++"."), parsing $ formatter [@title.pres]] `withFontSize_` (percent 130)  
                      -- don't use formatter here

SEM List_Subsubsection
  | List_Subsubsection
      loc.pres = structural $ col @elts.press


SEM Subsubsection [||] --tocPres : Presentation_Doc_Node_Clip_Token ]          
  | Subsubsection
      loc.numberStr = show @lhs.sectionNr ++ "." ++ show @lhs.subsectionNr ++ "."++ show @subsubsectionNr ++ ". "
      loc.pres = structural $
                     (col $ [ row [ text (@numberStr++".")
                                  , parsing $ text @title, empty `withHStretch` True
                                  ] `withFontSize_` (percent 130)  
                                    `addPopupItems` [ ("Add Graph", insertAtHeadSubgraphPara @paragraphs.path) ]  
                            , @paragraphs.pres
                            ])
                     `addPopupItems` [ ("Delete Subsubsection", deleteAtPath @lhs.path) 
                                     , ("Add Subsubsection", addSubsubsection @lhs.path)  ]
      --lhs.tocPres = loc (Node_Subsubsection @self @lhs.path) $ structural $ presentFocus @lhs.focusD @lhs.path $
      --                row [text (@numberStr++"."), text ". ", parsing $ formatter [@title.pres]] `withFontSize_` (percent 130)  
                      -- don't use formatter here


SEM Section [ || ]
  | Section
      loc.sectionNr = @lhs.ix + 1

ATTR List_Subsection ConsList_Subsection Subsection 
             List_Subsubsection ConsList_Subsubsection Subsubsection [ sectionNr : Int || ]

SEM Subsection [ || ]
  | Subsection
      loc.subsectionNr = @lhs.ix + 1

ATTR List_Subsubsection ConsList_Subsubsection Subsubsection [ subsectionNr : Int || ]

SEM Subsubsection [ || ]
  | Subsubsection
      loc.subsubsectionNr = @lhs.ix + 1

SEM List_Paragraph
  | List_Paragraph
      loc.pres = parsing' LexFreeText $
                   col $ if null (fromList_Paragraph @self) then [formatter [text ""]] else @elts.press
                   -- if paragraph list is empty, we add a dummy text "" to prevent the presentation from getting height 0
                   -- this dummy is parsed as an empty paragraph
                          
SEM Paragraph
  | Paragraph
      loc.pres = parsing $
                   @words.pres
                       `addPopupItems` [ ("Add Graph", addSubgraphPara @lhs.path) ]
       -- for an empty paragraph, we add a dummy word "" so its presentation does not get height 0
       
  | SubgraphPara
      loc.pres = structural $
                     row [ @subgraph.pres, empty `withHStretch` True ]
                       `addPopupItems` [ ("Delete Graph", deleteAtPath @lhs.path)
                                       , ("Add Graph", addSubgraphPara @lhs.path)
                                       , ("Add Paragraph", addParagraph @lhs.path) ]
  | ProbtablePara
      loc.pres = structural $
                     row [ @probtable.pres, empty `withHStretch` True ]
                       `addPopupItems` [ ("tralala", id)
                                       ]
                    
SEM List_Word
  | List_Word
     loc.pres = parsing $
                  formatter (if null @elts.press then [text ""] else @elts.press )

SEM Word [ || ]
  | Word
      loc.pres = parsing $
                     row [ text @word, text " " ]
  | NodeRef
      loc.pres = parsing $
                     row [ text "\\node{" `withColor` blue
                         , if @nodeName `notElem` @lhs.vertexNames
                           then squiggly red $ text @nodeName 
                           else text @nodeName 
                         , text "}" `withColor` blue
                         , text " "
                         ]
  | Label
      loc.pres = parsing $
                     row [ text ("\\label{" ++ @label++"}") `withColor` blue
                         , text " "
                         ]
  | LabelRef
      loc.pres = parsing $
                   let mLabelNr = lookup @label @lhs.allLabels   
                   in row [ text "\\ref{" `withColor` blue
                          , case mLabelNr of
                              Nothing -> squiggly red $ text  @label
                              Just _  -> text @label
                          , text "}{" `withColor` blue
                          , case mLabelNr of
                              Nothing -> text "undefined" `withColor` red
                              Just nr -> text nr `withColor` green
                          , text "}" `withColor` blue
                          , text " "
                          ]

  
SEM Graph
  | Graph
      loc.pres = structural $
                     row [ text " "
                         , boxed $ graph 400 340 @edges.edges @vertices.press
                         ]
      
SEM Vertex [ || ] 
  | Vertex
      loc.pres = let (nodePres,nodeOutline) =
                       case @shape.self of
                         Circle -> ( ellipse 18 18 Solid `withRef` (9,9) `withfColor` (200, 255, 255)
                                   , \a -> (round $ 9*cos a , round $ -9*sin a )
                                   )
                         _      -> ( rect 18 18 Solid `withRef` (9,9) `withfColor` (200, 255, 255)
                                   , squareOutline 9
                                   )
                      
                 in  structural $
                       (vertex @id @x @y nodeOutline $
                       col [ rowR 1 [glue, hRefHalf $ nodePres, glue]
                           , vSpace 4 `withHStretch` True
                           , rowR 1 [glue, hRefHalf $ boxed 
                                              (row [ hSpace 3
                                                   , parsing $ text @name `withFont'` ("Arial", 6)
                                                   , hSpace 3
                                                   ])
                                                `withbgColor` (236, 236, 169)
                                    , glue]
                           ]) `addPopupItems` ([ ("Circle", setShape @lhs.path Circle @self)
                                               , ("Square", setShape @lhs.path Square @self)
                                               ])

{
-- probably can do without self by using select
setShape :: Path -> Shape -> Vertex -> UpdateDoc Document clip
setShape pth shape (Vertex name _ id x y) =
  \(DocumentLevel d path cl) ->
    let (DocumentLevel d' _ _) = editPasteD (DocumentLevel d (PathD pth)
                                              (Clip_Vertex (Vertex name shape id x y))
                                            )
    in  (DocumentLevel d' path cl)

squareOutline :: Int -> Double -> (Int, Int)
squareOutline r a | a < pi / 4  || a >= 7 * pi / 4    = (r-1, round $ - tan a * fromIntegral r)  
                  | a >= pi / 4 && a < 3 * pi / 4     = (round $ - tan (a - pi/2) * fromIntegral r, -r+1)
                  | a >= 3 * pi / 4 && a < 5 * pi / 4 = (-r+1, round $ tan a * fromIntegral r)
                  | a >= 5 * pi / 4 && a < 7 * pi / 4 = (round $ tan (a - pi/2) * fromIntegral r, r-1)

}

SEM Subgraph [||] 
  | Subgraph
      loc.pres = let subVertices = filter (`elem` @lhs.vertexIDs) (fst . unzip $ @vertices.vertexIDNames)
                     -- only present vertices that are in the supergraph
                     subEdges = [ (fromV,toV) | (fromV, toV) <- @lhs.edges, fromV `elem` subVertices && toV `elem` subVertices]
                 in  structural $
                       (boxed $ graph 100 100 subEdges @vertices.press
                     `addPopupItems` [ ("Add node " ++ show name, pasteInSubgraph @lhs.path id name @self)
                                     | (name,id) <- zip @lhs.vertexNames @lhs.vertexIDs
                                     , id `notElem` (fst . unzip $ @vertices.vertexIDNames)
                                     ])


SEM Probtable
  | Probtable
      loc.pres = structural $ col [ row [ text $ "Probtable for " ++
                                           (case lookup @id (zip @lhs.vertexIDs @lhs.vertexNames) of
                                             Nothing -> "nothing"
                                             Just name -> name
                                            ) ++" with values "
                                        , @values.pres
                                        ]
                                  , @table.pres
                                  ] `addPopupItems`
                                  [ ( "Show probtable for "++show name
                                    , setProbtableID @lhs.path id @self)
                                  | (name,id) <- zip @lhs.vertexNames @lhs.vertexIDs
                                  ]

{
setProbtableID :: Path -> Int -> Probtable -> UpdateDoc Document clip
setProbtableID pth id (Probtable _ vals probs) =
  \(DocumentLevel d path cl) ->
    let (DocumentLevel d' _ _) = editPasteD (DocumentLevel d (PathD pth)
                                              (Clip_Probtable (Probtable id vals probs))
                                            )
    in  (DocumentLevel d' path cl)
}

SEM List_Value
  | List_Value
     loc.pres = structural $ row $ [text "[" `addPopupItems` [ ("Insert value"
                                                            , reduceDoc .
                                                              insertElementAtHead newValue (@lhs.path)
                                                            ) ]] ++
                                intersperse (text ",") @elts.press ++
                                [text "]"]
                             
SEM Value
  | Value
      loc.pres = parsing $ text @val
                   `addPopupItems` [ ("Delete value", reduceDoc . deleteAtPath @lhs.path)
                                   , ("Insert value after", reduceDoc . addElementAfter newValue @lhs.path) 
                                   ]

SEM Table
  | Table
      loc.pres = let axesStrings = [ [ str | Value str <- fromList_Value list_Val ]
                                   | Axis list_Val <- fromList_Axis @axes.self
                                   ]
                     rows = products axesStrings
                 in  structural $ boxed $ row $ ( intersperse vSep $ 
                                        [ (col $ intersperse hSep $ map (hPad . text) cl)
                                          `withVRef` 0
                                        | cl <- transpose rows ] ) ++
                                        [ endVSep
                                        , (col $ intersperse hSep @probs.press) `withVRef` 0 ]
                                        
{
-- withVRef is due to arranger bug
hPad pres = row [ hSpace 4, pres, hSpace 4 ]
hSep = colR 1 [ vSpace 2, hLine, vSpace 2]

vSep = rowR 0 [ vLine ]

endVSep = row [ vLine, vLine ]

-- | return a list of all cartesian products for a list of lists
--   e.g. products [[1,2],[3,4]] = [[1,3],[1,4],[2,3],[2,4]]
products :: [[a]] -> [[a]]
products [] = [[]]
products (xs:xss) = [ x:prod | x <- xs, prod <- products xss]
}                             
SEM Probability
  | Probability 
      loc.pres = parsing $ hPad $ text @prob

-- not used
SEM List_Axis
  | List_Axis
      loc.pres = structural $ row $ [ text "[" ] ++
                                    intersperse (text ",") @elts.press ++
                                    [ text "]" ]

-- not used                             
SEM Axis
  | Axis
      loc.pres = structural $ @values.pres

-- not used                             
SEM List_Probability
  | List_Probability
     loc.pres = structural $ col [ hLine
                                 , row $ [vLine] ++ intersperse vLine @elts.press ++ [vLine]
                                 , hLine
                                 ]
      
{-
Graph synthesizes vertexIDNames and edges. At Root, vertexIDNames is unzipped, and inherited attributes
vertexIDs, vertexNames, and edges are copied down to the subgraphs.
-}
SEM Root
  | Root
      (sections.vertexIDs, sections.vertexNames) = unzip @graph.vertexIDNames
      (probtables.vertexIDs, probtables.vertexNames) = unzip @graph.vertexIDNames
      sections.edges = @graph.edges
            
-- attributes come from vertices and edges by copy rule

ATTR List_Section ConsList_Section Section 
     List_Subsection ConsList_Subsection Subsection
     List_Subsubsection ConsList_Subsubsection Subsubsection
     List_Paragraph ConsList_Paragraph Paragraph
     List_Word ConsList_Word Word
     List_Probtable ConsList_Probtable Probtable
     [ vertexIDs : {[Int]} vertexNames : {[String]} edges : {[(Int, Int)]} || ] 


ATTR Subgraph [ vertexIDs : {[Int]} vertexNames : {[String]} edges : {[(Int, Int)]} || ]

ATTR Graph
     List_Edge ConsList_Edge Edge
     [ | | edges USE {++} {[]} : {[(Int,Int)]} ]

SEM Edge
  | Edge
      lhs.edges = [(@from, @to)]


ATTR Graph
     List_Vertex ConsList_Vertex Vertex
     [ | | vertexIDNames USE {++} {[]} : {[(Int,String)]} ]

SEM Vertex
  | Vertex
      lhs.vertexIDNames = [(@id, @name)]

{
deleteAtPath :: Path -> UpdateDoc Document ClipDoc
deleteAtPath pth =
   \(DocumentLevel d _ cl) ->
     editCutD (DocumentLevel d (PathD pth) cl)

newParagraph = Clip_Paragraph $
                 Paragraph $
                   List_Word Nil_Word

newSubgraphPara = Clip_Paragraph $
                    SubgraphPara $
                      Subgraph Dirty
                        (toList_Vertex [])
                        (toList_Edge []) 

newProbtablePara = Clip_Paragraph $
                     ProbtablePara $
                       Probtable (-1) (toList_Value []) $
                         Table (toList_Axis []) (toList_Probability [])
                       
newSection = Clip_Section $
               Section
                 "<new section>"
                 (List_Paragraph Nil_Paragraph) 
                 (List_Subsection Nil_Subsection)

newSubsection = Clip_Subsection $
                    Subsection
                      "<new subsection>"
                      (List_Paragraph Nil_Paragraph) 
                      (List_Subsubsection Nil_Subsubsection) 

newSubsubsection = Clip_Subsubsection $
                    Subsubsection
                      "<new subsubsection>"
                      (List_Paragraph Nil_Paragraph) 

newValue = Clip_Value $ Value "new"

addSubgraphPara path = addElementAfter newSubgraphPara path

addParagraph path = addElementAfter newParagraph path

addSection path = addElementAfter newSection path
    
addSubsection path = addElementAfter newSubsection path

addSubsubsection path = addElementAfter newSubsubsection path

insertAtHeadSubgraphPara listPath = insertElementAtHead newSubgraphPara listPath

insertAtHeadSection listPath = insertElementAtHead newSection listPath

insertAtHeadSubsection listPath = insertElementAtHead newSubsection listPath

insertAtHeadSubsubsection listPath = insertElementAtHead newSubsubsection listPath

-- PRECONDITION: path points to a list element of the same type as clip
addElementAfter :: ClipDoc -> Path -> UpdateDoc Document ClipDoc
addElementAfter clip path = 
  \(DocumentLevel d pth cl) ->
    (DocumentLevel (insertListD (init path) (last path+1) clip d) pth cl)

-- PRECONDITION: path points to a list of elements of the same type as clip
-- NB path points to the list, rather than to an element.
insertElementAtHead :: ClipDoc -> Path -> UpdateDoc Document ClipDoc
insertElementAtHead  clip listPath = 
  \(DocumentLevel d pth cl) ->
    (DocumentLevel (insertListD listPath 0 clip d) pth cl)

pasteInSubgraph :: Path -> Int -> String -> Subgraph -> UpdateDoc Document clip
pasteInSubgraph pth id name subgraph =
  let subgraph' = 
        case subgraph of
        Subgraph d vs es -> 
          Subgraph d (toList_Vertex $ 
                            Vertex  name 
                              Circle id 20 20
                            : fromList_Vertex vs) es
        _                    -> subgraph
  in \(DocumentLevel d path cl) ->
        let (DocumentLevel d' _ _) = editPasteD (DocumentLevel d (PathD pth)
                                                (Clip_Subgraph subgraph')
                                                )
        in  (DocumentLevel d' path cl)


}

-- labels and refs

-- copy upward, taking the first label that is not Nothing

SEM Word [ | | myLabel USE {use} {Nothing} : {Maybe String} ]
  | Label
      lhs.myLabel = Just @label

SEM ConsList_Word List_Word Paragraph ConsList_Paragraph List_Paragraph
    [ | | myLabel USE {`takeFirst`} {Nothing} : {Maybe String} ]

{
takeFirst :: Maybe x -> Maybe x -> Maybe x
takeFirst left right = case left of
                         Just x  -> Just x
                         Nothing -> right
}

-- collect all labels

SEM List_Section ConsList_Section Section 
    List_Subsection ConsList_Subsection Subsection 
    List_Subsubsection ConsList_Subsubsection Subsubsection 
    [ | | labels USE {++} {[]} : {[(String,String)]} ]

SEM Section
  | Section
      lhs.labels = case @paragraphs.myLabel of
                     Just label -> (label, @numberStr) : @subsections.labels
                     Nothing    -> @subsections.labels

SEM Subsection
  | Subsection
      lhs.labels = case @paragraphs.myLabel of
                     Just label -> (label, @numberStr) : @subsubsections.labels
                     Nothing    -> @subsubsections.labels
                       
SEM Subsubsection
  | Subsubsection
      lhs.labels = case @paragraphs.myLabel of
                     Just label -> [(label, @numberStr)]
                     Nothing    -> []


-- the inherited attribute is allLabels, to prevent the copy rule from threading the attribute.

ATTR List_Section ConsList_Section Section 
     List_Subsection ConsList_Subsection Subsection
     List_Subsubsection ConsList_Subsubsection Subsubsection
     List_Paragraph ConsList_Paragraph Paragraph
     List_Word ConsList_Word Word 
     [ allLabels : {[(String,String)]} | | ]

SEM Root
  | Root
      sections.allLabels = @sections.labels
           
           
           
           
-- annoying bits, since we don't have any default behaviour for pres attributes:

SEM Section
  | HoleSection     lhs.tocPres = presHole @lhs.focusD "Section" (Node_HoleSection @self @lhs.path) @lhs.path
  | ParseErrSection lhs.tocPres = presParseErr (Node_Section @self @lhs.path) @error


SEM List_Section [||tocPress: {[Presentation_Doc_Node_Clip_Token]}]
  | List_Section
      lhs.tocPress = map ( loc (Node_List_Section @self @lhs.path) 
                      . presentFocus @lhs.focusD @lhs.path ) 
                      @elts.tocPress
                      -- parent is reponsible for setting parsing/structural
  | HoleList_Section     lhs.tocPress = []
  | ParseErrList_Section lhs.tocPress = [ presParseErr (Node_List_Section @self @lhs.path) @error ]

SEM ConsList_Section [|| tocPress:{[Presentation_Doc_Node_Clip_Token]}]
  | Cons_Section lhs.tocPress = @head.tocPres : @tail.tocPress
  | Nil_Section      lhs.tocPress = []


SEM Edge
  | Edge       
      loc.pres = empty

SEM Shape
  | Circle       
      loc.pres = empty
  | Square
      loc.pres = empty

SEM Dirty
  | Dirty
      loc.pres = empty
  | Clean       
      loc.pres = empty
      
SEM List_Edge
  | List_Edge
      loc.pres = empty

SEM List_Vertex
  | List_Vertex
      loc.pres = empty

SEM List_Probtable
  | List_Probtable
      loc.pres = empty